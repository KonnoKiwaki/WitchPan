var ze = Object.defineProperty, Me = Object.defineProperties;
var Re = Object.getOwnPropertyDescriptors;
var re = Object.getOwnPropertySymbols;
var Te = Object.prototype.hasOwnProperty, Oe = Object.prototype.propertyIsEnumerable;
var ne = (i, e, t) => e in i ? ze(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, vt = (i, e) => {
  for (var t in e || (e = {}))
    Te.call(e, t) && ne(i, t, e[t]);
  if (re)
    for (var t of re(e))
      Oe.call(e, t) && ne(i, t, e[t]);
  return i;
}, Mt = (i, e) => Me(i, Re(e));
var yt = (i, e, t) => new Promise((r, a) => {
  var n = (u) => {
    try {
      l(t.next(u));
    } catch (g) {
      a(g);
    }
  }, o = (u) => {
    try {
      l(t.throw(u));
    } catch (g) {
      a(g);
    }
  }, l = (u) => u.done ? r(u.value) : Promise.resolve(u.value).then(n, o);
  l((t = t.apply(i, e)).next());
});
import { defineComponent as Fe, ref as Ie, onMounted as De, watch as Le } from "vue-demi";
import { openBlock as je, createElementBlock as Ue, createElementVNode as We } from "vue";
typeof window.setImmediate == "undefined" && (window.setImmediate = function(i, ...e) {
  setTimeout(() => i(e));
});
var Dt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function He(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Lt(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pe = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(i, e) {
  (function(t) {
    i.exports = t();
  })(function() {
    return function t(r, a, n) {
      function o(g, _) {
        if (!a[g]) {
          if (!r[g]) {
            var k = typeof Lt == "function" && Lt;
            if (!_ && k)
              return k(g, !0);
            if (l)
              return l(g, !0);
            var w = new Error("Cannot find module '" + g + "'");
            throw w.code = "MODULE_NOT_FOUND", w;
          }
          var d = a[g] = { exports: {} };
          r[g][0].call(d.exports, function(y) {
            var h = r[g][1][y];
            return o(h || y);
          }, d, d.exports, t, r, a, n);
        }
        return a[g].exports;
      }
      for (var l = typeof Lt == "function" && Lt, u = 0; u < n.length; u++)
        o(n[u]);
      return o;
    }({ 1: [function(t, r, a) {
      var n = t("./utils"), o = t("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      a.encode = function(u) {
        for (var g, _, k, w, d, y, h, m = [], f = 0, v = u.length, x = v, A = n.getTypeOf(u) !== "string"; f < u.length; )
          x = v - f, k = A ? (g = u[f++], _ = f < v ? u[f++] : 0, f < v ? u[f++] : 0) : (g = u.charCodeAt(f++), _ = f < v ? u.charCodeAt(f++) : 0, f < v ? u.charCodeAt(f++) : 0), w = g >> 2, d = (3 & g) << 4 | _ >> 4, y = 1 < x ? (15 & _) << 2 | k >> 6 : 64, h = 2 < x ? 63 & k : 64, m.push(l.charAt(w) + l.charAt(d) + l.charAt(y) + l.charAt(h));
        return m.join("");
      }, a.decode = function(u) {
        var g, _, k, w, d, y, h = 0, m = 0, f = "data:";
        if (u.substr(0, f.length) === f)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var v, x = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === l.charAt(64) && x--, u.charAt(u.length - 2) === l.charAt(64) && x--, x % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); h < u.length; )
          g = l.indexOf(u.charAt(h++)) << 2 | (w = l.indexOf(u.charAt(h++))) >> 4, _ = (15 & w) << 4 | (d = l.indexOf(u.charAt(h++))) >> 2, k = (3 & d) << 6 | (y = l.indexOf(u.charAt(h++))), v[m++] = g, d !== 64 && (v[m++] = _), y !== 64 && (v[m++] = k);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, r, a) {
      var n = t("./external"), o = t("./stream/DataWorker"), l = t("./stream/Crc32Probe"), u = t("./stream/DataLengthProbe");
      function g(_, k, w, d, y) {
        this.compressedSize = _, this.uncompressedSize = k, this.crc32 = w, this.compression = d, this.compressedContent = y;
      }
      g.prototype = { getContentWorker: function() {
        var _ = new o(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), k = this;
        return _.on("end", function() {
          if (this.streamInfo.data_length !== k.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), _;
      }, getCompressedWorker: function() {
        return new o(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, g.createWorkerFrom = function(_, k, w) {
        return _.pipe(new l()).pipe(new u("uncompressedSize")).pipe(k.compressWorker(w)).pipe(new u("compressedSize")).withStreamInfo("compression", k);
      }, r.exports = g;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, r, a) {
      var n = t("./stream/GenericWorker");
      a.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, a.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, r, a) {
      var n = t("./utils"), o = function() {
        for (var l, u = [], g = 0; g < 256; g++) {
          l = g;
          for (var _ = 0; _ < 8; _++)
            l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[g] = l;
        }
        return u;
      }();
      r.exports = function(l, u) {
        return l !== void 0 && l.length ? n.getTypeOf(l) !== "string" ? function(g, _, k, w) {
          var d = o, y = w + k;
          g ^= -1;
          for (var h = w; h < y; h++)
            g = g >>> 8 ^ d[255 & (g ^ _[h])];
          return -1 ^ g;
        }(0 | u, l, l.length, 0) : function(g, _, k, w) {
          var d = o, y = w + k;
          g ^= -1;
          for (var h = w; h < y; h++)
            g = g >>> 8 ^ d[255 & (g ^ _.charCodeAt(h))];
          return -1 ^ g;
        }(0 | u, l, l.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, r, a) {
      a.base64 = !1, a.binary = !1, a.dir = !1, a.createFolders = !0, a.date = null, a.compression = null, a.compressionOptions = null, a.comment = null, a.unixPermissions = null, a.dosPermissions = null;
    }, {}], 6: [function(t, r, a) {
      var n = null;
      n = typeof Promise != "undefined" ? Promise : t("lie"), r.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(t, r, a) {
      var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", o = t("pako"), l = t("./utils"), u = t("./stream/GenericWorker"), g = n ? "uint8array" : "array";
      function _(k, w) {
        u.call(this, "FlateWorker/" + k), this._pako = null, this._pakoAction = k, this._pakoOptions = w, this.meta = {};
      }
      a.magic = "\b\0", l.inherits(_, u), _.prototype.processChunk = function(k) {
        this.meta = k.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(g, k.data), !1);
      }, _.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, _.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, _.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var k = this;
        this._pako.onData = function(w) {
          k.push({ data: w, meta: k.meta });
        };
      }, a.compressWorker = function(k) {
        return new _("Deflate", k);
      }, a.uncompressWorker = function() {
        return new _("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, r, a) {
      function n(d, y) {
        var h, m = "";
        for (h = 0; h < y; h++)
          m += String.fromCharCode(255 & d), d >>>= 8;
        return m;
      }
      function o(d, y, h, m, f, v) {
        var x, A, P = d.file, D = d.compression, O = v !== g.utf8encode, H = l.transformTo("string", v(P.name)), T = l.transformTo("string", g.utf8encode(P.name)), X = P.comment, Q = l.transformTo("string", v(X)), S = l.transformTo("string", g.utf8encode(X)), F = T.length !== P.name.length, c = S.length !== X.length, L = "", et = "", W = "", rt = P.dir, $ = P.date, tt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        y && !h || (tt.crc32 = d.crc32, tt.compressedSize = d.compressedSize, tt.uncompressedSize = d.uncompressedSize);
        var z = 0;
        y && (z |= 8), O || !F && !c || (z |= 2048);
        var B = 0, J = 0;
        rt && (B |= 16), f === "UNIX" ? (J = 798, B |= function(G, ht) {
          var bt = G;
          return G || (bt = ht ? 16893 : 33204), (65535 & bt) << 16;
        }(P.unixPermissions, rt)) : (J = 20, B |= function(G) {
          return 63 & (G || 0);
        }(P.dosPermissions)), x = $.getUTCHours(), x <<= 6, x |= $.getUTCMinutes(), x <<= 5, x |= $.getUTCSeconds() / 2, A = $.getUTCFullYear() - 1980, A <<= 4, A |= $.getUTCMonth() + 1, A <<= 5, A |= $.getUTCDate(), F && (et = n(1, 1) + n(_(H), 4) + T, L += "up" + n(et.length, 2) + et), c && (W = n(1, 1) + n(_(Q), 4) + S, L += "uc" + n(W.length, 2) + W);
        var q = "";
        return q += `
\0`, q += n(z, 2), q += D.magic, q += n(x, 2), q += n(A, 2), q += n(tt.crc32, 4), q += n(tt.compressedSize, 4), q += n(tt.uncompressedSize, 4), q += n(H.length, 2), q += n(L.length, 2), { fileRecord: k.LOCAL_FILE_HEADER + q + H + L, dirRecord: k.CENTRAL_FILE_HEADER + n(J, 2) + q + n(Q.length, 2) + "\0\0\0\0" + n(B, 4) + n(m, 4) + H + L + Q };
      }
      var l = t("../utils"), u = t("../stream/GenericWorker"), g = t("../utf8"), _ = t("../crc32"), k = t("../signature");
      function w(d, y, h, m) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = y, this.zipPlatform = h, this.encodeFileName = m, this.streamFiles = d, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      l.inherits(w, u), w.prototype.push = function(d) {
        var y = d.meta.percent || 0, h = this.entriesCount, m = this._sources.length;
        this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, u.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: h ? (y + 100 * (h - m - 1)) / h : 100 } }));
      }, w.prototype.openedSource = function(d) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
        var y = this.streamFiles && !d.file.dir;
        if (y) {
          var h = o(d, y, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: h.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, w.prototype.closedSource = function(d) {
        this.accumulate = !1;
        var y = this.streamFiles && !d.file.dir, h = o(d, y, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(h.dirRecord), y)
          this.push({ data: function(m) {
            return k.DATA_DESCRIPTOR + n(m.crc32, 4) + n(m.compressedSize, 4) + n(m.uncompressedSize, 4);
          }(d), meta: { percent: 100 } });
        else
          for (this.push({ data: h.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, w.prototype.flush = function() {
        for (var d = this.bytesWritten, y = 0; y < this.dirRecords.length; y++)
          this.push({ data: this.dirRecords[y], meta: { percent: 100 } });
        var h = this.bytesWritten - d, m = function(f, v, x, A, P) {
          var D = l.transformTo("string", P(A));
          return k.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(f, 2) + n(f, 2) + n(v, 4) + n(x, 4) + n(D.length, 2) + D;
        }(this.dirRecords.length, h, d, this.zipComment, this.encodeFileName);
        this.push({ data: m, meta: { percent: 100 } });
      }, w.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, w.prototype.registerPrevious = function(d) {
        this._sources.push(d);
        var y = this;
        return d.on("data", function(h) {
          y.processChunk(h);
        }), d.on("end", function() {
          y.closedSource(y.previous.streamInfo), y._sources.length ? y.prepareNextSource() : y.end();
        }), d.on("error", function(h) {
          y.error(h);
        }), this;
      }, w.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, w.prototype.error = function(d) {
        var y = this._sources;
        if (!u.prototype.error.call(this, d))
          return !1;
        for (var h = 0; h < y.length; h++)
          try {
            y[h].error(d);
          } catch (m) {
          }
        return !0;
      }, w.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var d = this._sources, y = 0; y < d.length; y++)
          d[y].lock();
      }, r.exports = w;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, r, a) {
      var n = t("../compressions"), o = t("./ZipFileWorker");
      a.generateWorker = function(l, u, g) {
        var _ = new o(u.streamFiles, g, u.platform, u.encodeFileName), k = 0;
        try {
          l.forEach(function(w, d) {
            k++;
            var y = function(v, x) {
              var A = v || x, P = n[A];
              if (!P)
                throw new Error(A + " is not a valid compression method !");
              return P;
            }(d.options.compression, u.compression), h = d.options.compressionOptions || u.compressionOptions || {}, m = d.dir, f = d.date;
            d._compressWorker(y, h).withStreamInfo("file", { name: w, dir: m, date: f, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(_);
          }), _.entriesCount = k;
        } catch (w) {
          _.error(w);
        }
        return _;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, r, a) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new n();
          for (var l in this)
            typeof this[l] != "function" && (o[l] = this[l]);
          return o;
        };
      }
      (n.prototype = t("./object")).loadAsync = t("./load"), n.support = t("./support"), n.defaults = t("./defaults"), n.version = "3.10.1", n.loadAsync = function(o, l) {
        return new n().loadAsync(o, l);
      }, n.external = t("./external"), r.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, r, a) {
      var n = t("./utils"), o = t("./external"), l = t("./utf8"), u = t("./zipEntries"), g = t("./stream/Crc32Probe"), _ = t("./nodejsUtils");
      function k(w) {
        return new o.Promise(function(d, y) {
          var h = w.decompressed.getContentWorker().pipe(new g());
          h.on("error", function(m) {
            y(m);
          }).on("end", function() {
            h.streamInfo.crc32 !== w.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : d();
          }).resume();
        });
      }
      r.exports = function(w, d) {
        var y = this;
        return d = n.extend(d || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), _.isNode && _.isStream(w) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", w, !0, d.optimizedBinaryString, d.base64).then(function(h) {
          var m = new u(d);
          return m.load(h), m;
        }).then(function(h) {
          var m = [o.Promise.resolve(h)], f = h.files;
          if (d.checkCRC32)
            for (var v = 0; v < f.length; v++)
              m.push(k(f[v]));
          return o.Promise.all(m);
        }).then(function(h) {
          for (var m = h.shift(), f = m.files, v = 0; v < f.length; v++) {
            var x = f[v], A = x.fileNameStr, P = n.resolve(x.fileNameStr);
            y.file(P, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: d.createFolders }), x.dir || (y.file(P).unsafeOriginalName = A);
          }
          return m.zipComment.length && (y.comment = m.zipComment), y;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, r, a) {
      var n = t("../utils"), o = t("../stream/GenericWorker");
      function l(u, g) {
        o.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(g);
      }
      n.inherits(l, o), l.prototype._bindStream = function(u) {
        var g = this;
        (this._stream = u).pause(), u.on("data", function(_) {
          g.push({ data: _, meta: { percent: 0 } });
        }).on("error", function(_) {
          g.isPaused ? this.generatedError = _ : g.error(_);
        }).on("end", function() {
          g.isPaused ? g._upstreamEnded = !0 : g.end();
        });
      }, l.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = l;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, r, a) {
      var n = t("readable-stream").Readable;
      function o(l, u, g) {
        n.call(this, u), this._helper = l;
        var _ = this;
        l.on("data", function(k, w) {
          _.push(k) || _._helper.pause(), g && g(w);
        }).on("error", function(k) {
          _.emit("error", k);
        }).on("end", function() {
          _.push(null);
        });
      }
      t("../utils").inherits(o, n), o.prototype._read = function() {
        this._helper.resume();
      }, r.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, r, a) {
      r.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(n, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(n, o);
        if (typeof n == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(n, o);
      }, allocBuffer: function(n) {
        if (Buffer.alloc)
          return Buffer.alloc(n);
        var o = new Buffer(n);
        return o.fill(0), o;
      }, isBuffer: function(n) {
        return Buffer.isBuffer(n);
      }, isStream: function(n) {
        return n && typeof n.on == "function" && typeof n.pause == "function" && typeof n.resume == "function";
      } };
    }, {}], 15: [function(t, r, a) {
      function n(P, D, O) {
        var H, T = l.getTypeOf(D), X = l.extend(O || {}, _);
        X.date = X.date || /* @__PURE__ */ new Date(), X.compression !== null && (X.compression = X.compression.toUpperCase()), typeof X.unixPermissions == "string" && (X.unixPermissions = parseInt(X.unixPermissions, 8)), X.unixPermissions && 16384 & X.unixPermissions && (X.dir = !0), X.dosPermissions && 16 & X.dosPermissions && (X.dir = !0), X.dir && (P = f(P)), X.createFolders && (H = m(P)) && v.call(this, H, !0);
        var Q = T === "string" && X.binary === !1 && X.base64 === !1;
        O && O.binary !== void 0 || (X.binary = !Q), (D instanceof k && D.uncompressedSize === 0 || X.dir || !D || D.length === 0) && (X.base64 = !1, X.binary = !0, D = "", X.compression = "STORE", T = "string");
        var S = null;
        S = D instanceof k || D instanceof u ? D : y.isNode && y.isStream(D) ? new h(P, D) : l.prepareContent(P, D, X.binary, X.optimizedBinaryString, X.base64);
        var F = new w(P, S, X);
        this.files[P] = F;
      }
      var o = t("./utf8"), l = t("./utils"), u = t("./stream/GenericWorker"), g = t("./stream/StreamHelper"), _ = t("./defaults"), k = t("./compressedObject"), w = t("./zipObject"), d = t("./generate"), y = t("./nodejsUtils"), h = t("./nodejs/NodejsStreamInputAdapter"), m = function(P) {
        P.slice(-1) === "/" && (P = P.substring(0, P.length - 1));
        var D = P.lastIndexOf("/");
        return 0 < D ? P.substring(0, D) : "";
      }, f = function(P) {
        return P.slice(-1) !== "/" && (P += "/"), P;
      }, v = function(P, D) {
        return D = D !== void 0 ? D : _.createFolders, P = f(P), this.files[P] || n.call(this, P, null, { dir: !0, createFolders: D }), this.files[P];
      };
      function x(P) {
        return Object.prototype.toString.call(P) === "[object RegExp]";
      }
      var A = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(P) {
        var D, O, H;
        for (D in this.files)
          H = this.files[D], (O = D.slice(this.root.length, D.length)) && D.slice(0, this.root.length) === this.root && P(O, H);
      }, filter: function(P) {
        var D = [];
        return this.forEach(function(O, H) {
          P(O, H) && D.push(H);
        }), D;
      }, file: function(P, D, O) {
        if (arguments.length !== 1)
          return P = this.root + P, n.call(this, P, D, O), this;
        if (x(P)) {
          var H = P;
          return this.filter(function(X, Q) {
            return !Q.dir && H.test(X);
          });
        }
        var T = this.files[this.root + P];
        return T && !T.dir ? T : null;
      }, folder: function(P) {
        if (!P)
          return this;
        if (x(P))
          return this.filter(function(T, X) {
            return X.dir && P.test(T);
          });
        var D = this.root + P, O = v.call(this, D), H = this.clone();
        return H.root = O.name, H;
      }, remove: function(P) {
        P = this.root + P;
        var D = this.files[P];
        if (D || (P.slice(-1) !== "/" && (P += "/"), D = this.files[P]), D && !D.dir)
          delete this.files[P];
        else
          for (var O = this.filter(function(T, X) {
            return X.name.slice(0, P.length) === P;
          }), H = 0; H < O.length; H++)
            delete this.files[O[H].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(P) {
        var D, O = {};
        try {
          if ((O = l.extend(P || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = O.type.toLowerCase(), O.compression = O.compression.toUpperCase(), O.type === "binarystring" && (O.type = "string"), !O.type)
            throw new Error("No output type specified.");
          l.checkSupport(O.type), O.platform !== "darwin" && O.platform !== "freebsd" && O.platform !== "linux" && O.platform !== "sunos" || (O.platform = "UNIX"), O.platform === "win32" && (O.platform = "DOS");
          var H = O.comment || this.comment || "";
          D = d.generateWorker(this, O, H);
        } catch (T) {
          (D = new u("error")).error(T);
        }
        return new g(D, O.type || "string", O.mimeType);
      }, generateAsync: function(P, D) {
        return this.generateInternalStream(P).accumulate(D);
      }, generateNodeStream: function(P, D) {
        return (P = P || {}).type || (P.type = "nodebuffer"), this.generateInternalStream(P).toNodejsStream(D);
      } };
      r.exports = A;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, r, a) {
      r.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, r, a) {
      var n = t("./DataReader");
      function o(l) {
        n.call(this, l);
        for (var u = 0; u < this.data.length; u++)
          l[u] = 255 & l[u];
      }
      t("../utils").inherits(o, n), o.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, o.prototype.lastIndexOfSignature = function(l) {
        for (var u = l.charCodeAt(0), g = l.charCodeAt(1), _ = l.charCodeAt(2), k = l.charCodeAt(3), w = this.length - 4; 0 <= w; --w)
          if (this.data[w] === u && this.data[w + 1] === g && this.data[w + 2] === _ && this.data[w + 3] === k)
            return w - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(l) {
        var u = l.charCodeAt(0), g = l.charCodeAt(1), _ = l.charCodeAt(2), k = l.charCodeAt(3), w = this.readData(4);
        return u === w[0] && g === w[1] && _ === w[2] && k === w[3];
      }, o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, r, a) {
      var n = t("../utils");
      function o(l) {
        this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(l) {
        this.checkIndex(this.index + l);
      }, checkIndex: function(l) {
        if (this.length < this.zero + l || l < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
      }, setIndex: function(l) {
        this.checkIndex(l), this.index = l;
      }, skip: function(l) {
        this.setIndex(this.index + l);
      }, byteAt: function() {
      }, readInt: function(l) {
        var u, g = 0;
        for (this.checkOffset(l), u = this.index + l - 1; u >= this.index; u--)
          g = (g << 8) + this.byteAt(u);
        return this.index += l, g;
      }, readString: function(l) {
        return n.transformTo("string", this.readData(l));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var l = this.readInt(4);
        return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
      } }, r.exports = o;
    }, { "../utils": 32 }], 19: [function(t, r, a) {
      var n = t("./Uint8ArrayReader");
      function o(l) {
        n.call(this, l);
      }
      t("../utils").inherits(o, n), o.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, r, a) {
      var n = t("./DataReader");
      function o(l) {
        n.call(this, l);
      }
      t("../utils").inherits(o, n), o.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, o.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, o.prototype.readAndCheckSignature = function(l) {
        return l === this.readData(4);
      }, o.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, r, a) {
      var n = t("./ArrayReader");
      function o(l) {
        n.call(this, l);
      }
      t("../utils").inherits(o, n), o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, r.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, r, a) {
      var n = t("../utils"), o = t("../support"), l = t("./ArrayReader"), u = t("./StringReader"), g = t("./NodeBufferReader"), _ = t("./Uint8ArrayReader");
      r.exports = function(k) {
        var w = n.getTypeOf(k);
        return n.checkSupport(w), w !== "string" || o.uint8array ? w === "nodebuffer" ? new g(k) : o.uint8array ? new _(n.transformTo("uint8array", k)) : new l(n.transformTo("array", k)) : new u(k);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, r, a) {
      a.LOCAL_FILE_HEADER = "PK", a.CENTRAL_FILE_HEADER = "PK", a.CENTRAL_DIRECTORY_END = "PK", a.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", a.ZIP64_CENTRAL_DIRECTORY_END = "PK", a.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, r, a) {
      var n = t("./GenericWorker"), o = t("../utils");
      function l(u) {
        n.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      o.inherits(l, n), l.prototype.processChunk = function(u) {
        this.push({ data: o.transformTo(this.destType, u.data), meta: u.meta });
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, r, a) {
      var n = t("./GenericWorker"), o = t("../crc32");
      function l() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(l, n), l.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, r, a) {
      var n = t("../utils"), o = t("./GenericWorker");
      function l(u) {
        o.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      n.inherits(l, o), l.prototype.processChunk = function(u) {
        if (u) {
          var g = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = g + u.data.length;
        }
        o.prototype.processChunk.call(this, u);
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, r, a) {
      var n = t("../utils"), o = t("./GenericWorker");
      function l(u) {
        o.call(this, "DataWorker");
        var g = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(_) {
          g.dataIsReady = !0, g.data = _, g.max = _ && _.length || 0, g.type = n.getTypeOf(_), g.isPaused || g._tickAndRepeat();
        }, function(_) {
          g.error(_);
        });
      }
      n.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var u = null, g = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, g);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, g);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, g);
        }
        return this.index = g, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, r, a) {
      function n(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, l) {
        return this._listeners[o].push(l), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, l) {
        if (this._listeners[o])
          for (var u = 0; u < this._listeners[o].length; u++)
            this._listeners[o][u].call(this, l);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var l = this;
        return o.on("data", function(u) {
          l.processChunk(u);
        }), o.on("end", function() {
          l.end();
        }), o.on("error", function(u) {
          l.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, l) {
        return this.extraStreamInfo[o] = l, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, r.exports = n;
    }, {}], 29: [function(t, r, a) {
      var n = t("../utils"), o = t("./ConvertWorker"), l = t("./GenericWorker"), u = t("../base64"), g = t("../support"), _ = t("../external"), k = null;
      if (g.nodestream)
        try {
          k = t("../nodejs/NodejsStreamOutputAdapter");
        } catch (y) {
        }
      function w(y, h) {
        return new _.Promise(function(m, f) {
          var v = [], x = y._internalType, A = y._outputType, P = y._mimeType;
          y.on("data", function(D, O) {
            v.push(D), h && h(O);
          }).on("error", function(D) {
            v = [], f(D);
          }).on("end", function() {
            try {
              var D = function(O, H, T) {
                switch (O) {
                  case "blob":
                    return n.newBlob(n.transformTo("arraybuffer", H), T);
                  case "base64":
                    return u.encode(H);
                  default:
                    return n.transformTo(O, H);
                }
              }(A, function(O, H) {
                var T, X = 0, Q = null, S = 0;
                for (T = 0; T < H.length; T++)
                  S += H[T].length;
                switch (O) {
                  case "string":
                    return H.join("");
                  case "array":
                    return Array.prototype.concat.apply([], H);
                  case "uint8array":
                    for (Q = new Uint8Array(S), T = 0; T < H.length; T++)
                      Q.set(H[T], X), X += H[T].length;
                    return Q;
                  case "nodebuffer":
                    return Buffer.concat(H);
                  default:
                    throw new Error("concat : unsupported type '" + O + "'");
                }
              }(x, v), P);
              m(D);
            } catch (O) {
              f(O);
            }
            v = [];
          }).resume();
        });
      }
      function d(y, h, m) {
        var f = h;
        switch (h) {
          case "blob":
          case "arraybuffer":
            f = "uint8array";
            break;
          case "base64":
            f = "string";
        }
        try {
          this._internalType = f, this._outputType = h, this._mimeType = m, n.checkSupport(f), this._worker = y.pipe(new o(f)), y.lock();
        } catch (v) {
          this._worker = new l("error"), this._worker.error(v);
        }
      }
      d.prototype = { accumulate: function(y) {
        return w(this, y);
      }, on: function(y, h) {
        var m = this;
        return y === "data" ? this._worker.on(y, function(f) {
          h.call(m, f.data, f.meta);
        }) : this._worker.on(y, function() {
          n.delay(h, arguments, m);
        }), this;
      }, resume: function() {
        return n.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(y) {
        if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new k(this, { objectMode: this._outputType !== "nodebuffer" }, y);
      } }, r.exports = d;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, r, a) {
      if (a.base64 = !0, a.array = !0, a.string = !0, a.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", a.nodebuffer = typeof Buffer != "undefined", a.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
        a.blob = !1;
      else {
        var n = new ArrayBuffer(0);
        try {
          a.blob = new Blob([n], { type: "application/zip" }).size === 0;
        } catch (l) {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(n), a.blob = o.getBlob("application/zip").size === 0;
          } catch (u) {
            a.blob = !1;
          }
        }
      }
      try {
        a.nodestream = !!t("readable-stream").Readable;
      } catch (l) {
        a.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, r, a) {
      for (var n = t("./utils"), o = t("./support"), l = t("./nodejsUtils"), u = t("./stream/GenericWorker"), g = new Array(256), _ = 0; _ < 256; _++)
        g[_] = 252 <= _ ? 6 : 248 <= _ ? 5 : 240 <= _ ? 4 : 224 <= _ ? 3 : 192 <= _ ? 2 : 1;
      g[254] = g[254] = 1;
      function k() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function w() {
        u.call(this, "utf-8 encode");
      }
      a.utf8encode = function(d) {
        return o.nodebuffer ? l.newBufferFrom(d, "utf-8") : function(y) {
          var h, m, f, v, x, A = y.length, P = 0;
          for (v = 0; v < A; v++)
            (64512 & (m = y.charCodeAt(v))) == 55296 && v + 1 < A && (64512 & (f = y.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (f - 56320), v++), P += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
          for (h = o.uint8array ? new Uint8Array(P) : new Array(P), v = x = 0; x < P; v++)
            (64512 & (m = y.charCodeAt(v))) == 55296 && v + 1 < A && (64512 & (f = y.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (f - 56320), v++), m < 128 ? h[x++] = m : (m < 2048 ? h[x++] = 192 | m >>> 6 : (m < 65536 ? h[x++] = 224 | m >>> 12 : (h[x++] = 240 | m >>> 18, h[x++] = 128 | m >>> 12 & 63), h[x++] = 128 | m >>> 6 & 63), h[x++] = 128 | 63 & m);
          return h;
        }(d);
      }, a.utf8decode = function(d) {
        return o.nodebuffer ? n.transformTo("nodebuffer", d).toString("utf-8") : function(y) {
          var h, m, f, v, x = y.length, A = new Array(2 * x);
          for (h = m = 0; h < x; )
            if ((f = y[h++]) < 128)
              A[m++] = f;
            else if (4 < (v = g[f]))
              A[m++] = 65533, h += v - 1;
            else {
              for (f &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && h < x; )
                f = f << 6 | 63 & y[h++], v--;
              1 < v ? A[m++] = 65533 : f < 65536 ? A[m++] = f : (f -= 65536, A[m++] = 55296 | f >> 10 & 1023, A[m++] = 56320 | 1023 & f);
            }
          return A.length !== m && (A.subarray ? A = A.subarray(0, m) : A.length = m), n.applyFromCharCode(A);
        }(d = n.transformTo(o.uint8array ? "uint8array" : "array", d));
      }, n.inherits(k, u), k.prototype.processChunk = function(d) {
        var y = n.transformTo(o.uint8array ? "uint8array" : "array", d.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var h = y;
            (y = new Uint8Array(h.length + this.leftOver.length)).set(this.leftOver, 0), y.set(h, this.leftOver.length);
          } else
            y = this.leftOver.concat(y);
          this.leftOver = null;
        }
        var m = function(v, x) {
          var A;
          for ((x = x || v.length) > v.length && (x = v.length), A = x - 1; 0 <= A && (192 & v[A]) == 128; )
            A--;
          return A < 0 || A === 0 ? x : A + g[v[A]] > x ? A : x;
        }(y), f = y;
        m !== y.length && (o.uint8array ? (f = y.subarray(0, m), this.leftOver = y.subarray(m, y.length)) : (f = y.slice(0, m), this.leftOver = y.slice(m, y.length))), this.push({ data: a.utf8decode(f), meta: d.meta });
      }, k.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: a.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, a.Utf8DecodeWorker = k, n.inherits(w, u), w.prototype.processChunk = function(d) {
        this.push({ data: a.utf8encode(d.data), meta: d.meta });
      }, a.Utf8EncodeWorker = w;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, r, a) {
      var n = t("./support"), o = t("./base64"), l = t("./nodejsUtils"), u = t("./external");
      function g(h) {
        return h;
      }
      function _(h, m) {
        for (var f = 0; f < h.length; ++f)
          m[f] = 255 & h.charCodeAt(f);
        return m;
      }
      t("setimmediate"), a.newBlob = function(h, m) {
        a.checkSupport("blob");
        try {
          return new Blob([h], { type: m });
        } catch (v) {
          try {
            var f = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return f.append(h), f.getBlob(m);
          } catch (x) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var k = { stringifyByChunk: function(h, m, f) {
        var v = [], x = 0, A = h.length;
        if (A <= f)
          return String.fromCharCode.apply(null, h);
        for (; x < A; )
          m === "array" || m === "nodebuffer" ? v.push(String.fromCharCode.apply(null, h.slice(x, Math.min(x + f, A)))) : v.push(String.fromCharCode.apply(null, h.subarray(x, Math.min(x + f, A)))), x += f;
        return v.join("");
      }, stringifyByChar: function(h) {
        for (var m = "", f = 0; f < h.length; f++)
          m += String.fromCharCode(h[f]);
        return m;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (h) {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return n.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
        } catch (h) {
          return !1;
        }
      }() } };
      function w(h) {
        var m = 65536, f = a.getTypeOf(h), v = !0;
        if (f === "uint8array" ? v = k.applyCanBeUsed.uint8array : f === "nodebuffer" && (v = k.applyCanBeUsed.nodebuffer), v)
          for (; 1 < m; )
            try {
              return k.stringifyByChunk(h, f, m);
            } catch (x) {
              m = Math.floor(m / 2);
            }
        return k.stringifyByChar(h);
      }
      function d(h, m) {
        for (var f = 0; f < h.length; f++)
          m[f] = h[f];
        return m;
      }
      a.applyFromCharCode = w;
      var y = {};
      y.string = { string: g, array: function(h) {
        return _(h, new Array(h.length));
      }, arraybuffer: function(h) {
        return y.string.uint8array(h).buffer;
      }, uint8array: function(h) {
        return _(h, new Uint8Array(h.length));
      }, nodebuffer: function(h) {
        return _(h, l.allocBuffer(h.length));
      } }, y.array = { string: w, array: g, arraybuffer: function(h) {
        return new Uint8Array(h).buffer;
      }, uint8array: function(h) {
        return new Uint8Array(h);
      }, nodebuffer: function(h) {
        return l.newBufferFrom(h);
      } }, y.arraybuffer = { string: function(h) {
        return w(new Uint8Array(h));
      }, array: function(h) {
        return d(new Uint8Array(h), new Array(h.byteLength));
      }, arraybuffer: g, uint8array: function(h) {
        return new Uint8Array(h);
      }, nodebuffer: function(h) {
        return l.newBufferFrom(new Uint8Array(h));
      } }, y.uint8array = { string: w, array: function(h) {
        return d(h, new Array(h.length));
      }, arraybuffer: function(h) {
        return h.buffer;
      }, uint8array: g, nodebuffer: function(h) {
        return l.newBufferFrom(h);
      } }, y.nodebuffer = { string: w, array: function(h) {
        return d(h, new Array(h.length));
      }, arraybuffer: function(h) {
        return y.nodebuffer.uint8array(h).buffer;
      }, uint8array: function(h) {
        return d(h, new Uint8Array(h.length));
      }, nodebuffer: g }, a.transformTo = function(h, m) {
        if (m = m || "", !h)
          return m;
        a.checkSupport(h);
        var f = a.getTypeOf(m);
        return y[f][h](m);
      }, a.resolve = function(h) {
        for (var m = h.split("/"), f = [], v = 0; v < m.length; v++) {
          var x = m[v];
          x === "." || x === "" && v !== 0 && v !== m.length - 1 || (x === ".." ? f.pop() : f.push(x));
        }
        return f.join("/");
      }, a.getTypeOf = function(h) {
        return typeof h == "string" ? "string" : Object.prototype.toString.call(h) === "[object Array]" ? "array" : n.nodebuffer && l.isBuffer(h) ? "nodebuffer" : n.uint8array && h instanceof Uint8Array ? "uint8array" : n.arraybuffer && h instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(h) {
        if (!n[h.toLowerCase()])
          throw new Error(h + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(h) {
        var m, f, v = "";
        for (f = 0; f < (h || "").length; f++)
          v += "\\x" + ((m = h.charCodeAt(f)) < 16 ? "0" : "") + m.toString(16).toUpperCase();
        return v;
      }, a.delay = function(h, m, f) {
        setImmediate(function() {
          h.apply(f || null, m || []);
        });
      }, a.inherits = function(h, m) {
        function f() {
        }
        f.prototype = m.prototype, h.prototype = new f();
      }, a.extend = function() {
        var h, m, f = {};
        for (h = 0; h < arguments.length; h++)
          for (m in arguments[h])
            Object.prototype.hasOwnProperty.call(arguments[h], m) && f[m] === void 0 && (f[m] = arguments[h][m]);
        return f;
      }, a.prepareContent = function(h, m, f, v, x) {
        return u.Promise.resolve(m).then(function(A) {
          return n.blob && (A instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(A)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(P, D) {
            var O = new FileReader();
            O.onload = function(H) {
              P(H.target.result);
            }, O.onerror = function(H) {
              D(H.target.error);
            }, O.readAsArrayBuffer(A);
          }) : A;
        }).then(function(A) {
          var P = a.getTypeOf(A);
          return P ? (P === "arraybuffer" ? A = a.transformTo("uint8array", A) : P === "string" && (x ? A = o.decode(A) : f && v !== !0 && (A = function(D) {
            return _(D, n.uint8array ? new Uint8Array(D.length) : new Array(D.length));
          }(A))), A) : u.Promise.reject(new Error("Can't read the data of '" + h + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, r, a) {
      var n = t("./reader/readerFor"), o = t("./utils"), l = t("./signature"), u = t("./zipEntry"), g = t("./support");
      function _(k) {
        this.files = [], this.loadOptions = k;
      }
      _.prototype = { checkSignature: function(k) {
        if (!this.reader.readAndCheckSignature(k)) {
          this.reader.index -= 4;
          var w = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(w) + ", expected " + o.pretty(k) + ")");
        }
      }, isSignature: function(k, w) {
        var d = this.reader.index;
        this.reader.setIndex(k);
        var y = this.reader.readString(4) === w;
        return this.reader.setIndex(d), y;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var k = this.reader.readData(this.zipCommentLength), w = g.uint8array ? "uint8array" : "array", d = o.transformTo(w, k);
        this.zipComment = this.loadOptions.decodeFileName(d);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var k, w, d, y = this.zip64EndOfCentralSize - 44; 0 < y; )
          k = this.reader.readInt(2), w = this.reader.readInt(4), d = this.reader.readData(w), this.zip64ExtensibleData[k] = { id: k, length: w, value: d };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var k, w;
        for (k = 0; k < this.files.length; k++)
          w = this.files[k], this.reader.setIndex(w.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), w.readLocalPart(this.reader), w.handleUTF8(), w.processAttributes();
      }, readCentralDir: function() {
        var k;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); )
          (k = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(k);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var k = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
        if (k < 0)
          throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(k);
        var w = k;
        if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (k = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(k), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var d = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
        var y = w - d;
        if (0 < y)
          this.isSignature(w, l.CENTRAL_FILE_HEADER) || (this.reader.zero = y);
        else if (y < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(y) + " bytes.");
      }, prepareReader: function(k) {
        this.reader = n(k);
      }, load: function(k) {
        this.prepareReader(k), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = _;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, r, a) {
      var n = t("./reader/readerFor"), o = t("./utils"), l = t("./compressedObject"), u = t("./crc32"), g = t("./utf8"), _ = t("./compressions"), k = t("./support");
      function w(d, y) {
        this.options = d, this.loadOptions = y;
      }
      w.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(d) {
        var y, h;
        if (d.skip(22), this.fileNameLength = d.readInt(2), h = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(h), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((y = function(m) {
          for (var f in _)
            if (Object.prototype.hasOwnProperty.call(_, f) && _[f].magic === m)
              return _[f];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, y, d.readData(this.compressedSize));
      }, readCentralPart: function(d) {
        this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
        var y = d.readInt(2);
        if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        d.skip(y), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var d = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var d = n(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
        }
      }, readExtraFields: function(d) {
        var y, h, m, f = d.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); d.index + 4 < f; )
          y = d.readInt(2), h = d.readInt(2), m = d.readData(h), this.extraFields[y] = { id: y, length: h, value: m };
        d.setIndex(f);
      }, handleUTF8: function() {
        var d = k.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = g.utf8decode(this.fileName), this.fileCommentStr = g.utf8decode(this.fileComment);
        else {
          var y = this.findExtraFieldUnicodePath();
          if (y !== null)
            this.fileNameStr = y;
          else {
            var h = o.transformTo(d, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(h);
          }
          var m = this.findExtraFieldUnicodeComment();
          if (m !== null)
            this.fileCommentStr = m;
          else {
            var f = o.transformTo(d, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(f);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var d = this.extraFields[28789];
        if (d) {
          var y = n(d.value);
          return y.readInt(1) !== 1 || u(this.fileName) !== y.readInt(4) ? null : g.utf8decode(y.readData(d.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var d = this.extraFields[25461];
        if (d) {
          var y = n(d.value);
          return y.readInt(1) !== 1 || u(this.fileComment) !== y.readInt(4) ? null : g.utf8decode(y.readData(d.length - 5));
        }
        return null;
      } }, r.exports = w;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, r, a) {
      function n(y, h, m) {
        this.name = y, this.dir = m.dir, this.date = m.date, this.comment = m.comment, this.unixPermissions = m.unixPermissions, this.dosPermissions = m.dosPermissions, this._data = h, this._dataBinary = m.binary, this.options = { compression: m.compression, compressionOptions: m.compressionOptions };
      }
      var o = t("./stream/StreamHelper"), l = t("./stream/DataWorker"), u = t("./utf8"), g = t("./compressedObject"), _ = t("./stream/GenericWorker");
      n.prototype = { internalStream: function(y) {
        var h = null, m = "string";
        try {
          if (!y)
            throw new Error("No output type specified.");
          var f = (m = y.toLowerCase()) === "string" || m === "text";
          m !== "binarystring" && m !== "text" || (m = "string"), h = this._decompressWorker();
          var v = !this._dataBinary;
          v && !f && (h = h.pipe(new u.Utf8EncodeWorker())), !v && f && (h = h.pipe(new u.Utf8DecodeWorker()));
        } catch (x) {
          (h = new _("error")).error(x);
        }
        return new o(h, m, "");
      }, async: function(y, h) {
        return this.internalStream(y).accumulate(h);
      }, nodeStream: function(y, h) {
        return this.internalStream(y || "nodebuffer").toNodejsStream(h);
      }, _compressWorker: function(y, h) {
        if (this._data instanceof g && this._data.compression.magic === y.magic)
          return this._data.getCompressedWorker();
        var m = this._decompressWorker();
        return this._dataBinary || (m = m.pipe(new u.Utf8EncodeWorker())), g.createWorkerFrom(m, y, h);
      }, _decompressWorker: function() {
        return this._data instanceof g ? this._data.getContentWorker() : this._data instanceof _ ? this._data : new l(this._data);
      } };
      for (var k = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], w = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, d = 0; d < k.length; d++)
        n.prototype[k[d]] = w;
      r.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, r, a) {
      (function(n) {
        var o, l, u = n.MutationObserver || n.WebKitMutationObserver;
        if (u) {
          var g = 0, _ = new u(y), k = n.document.createTextNode("");
          _.observe(k, { characterData: !0 }), o = function() {
            k.data = g = ++g % 2;
          };
        } else if (n.setImmediate || n.MessageChannel === void 0)
          o = "document" in n && "onreadystatechange" in n.document.createElement("script") ? function() {
            var h = n.document.createElement("script");
            h.onreadystatechange = function() {
              y(), h.onreadystatechange = null, h.parentNode.removeChild(h), h = null;
            }, n.document.documentElement.appendChild(h);
          } : function() {
            setTimeout(y, 0);
          };
        else {
          var w = new n.MessageChannel();
          w.port1.onmessage = y, o = function() {
            w.port2.postMessage(0);
          };
        }
        var d = [];
        function y() {
          var h, m;
          l = !0;
          for (var f = d.length; f; ) {
            for (m = d, d = [], h = -1; ++h < f; )
              m[h]();
            f = d.length;
          }
          l = !1;
        }
        r.exports = function(h) {
          d.push(h) !== 1 || l || o();
        };
      }).call(this, typeof Dt != "undefined" ? Dt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 37: [function(t, r, a) {
      var n = t("immediate");
      function o() {
      }
      var l = {}, u = ["REJECTED"], g = ["FULFILLED"], _ = ["PENDING"];
      function k(f) {
        if (typeof f != "function")
          throw new TypeError("resolver must be a function");
        this.state = _, this.queue = [], this.outcome = void 0, f !== o && h(this, f);
      }
      function w(f, v, x) {
        this.promise = f, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function d(f, v, x) {
        n(function() {
          var A;
          try {
            A = v(x);
          } catch (P) {
            return l.reject(f, P);
          }
          A === f ? l.reject(f, new TypeError("Cannot resolve promise with itself")) : l.resolve(f, A);
        });
      }
      function y(f) {
        var v = f && f.then;
        if (f && (typeof f == "object" || typeof f == "function") && typeof v == "function")
          return function() {
            v.apply(f, arguments);
          };
      }
      function h(f, v) {
        var x = !1;
        function A(O) {
          x || (x = !0, l.reject(f, O));
        }
        function P(O) {
          x || (x = !0, l.resolve(f, O));
        }
        var D = m(function() {
          v(P, A);
        });
        D.status === "error" && A(D.value);
      }
      function m(f, v) {
        var x = {};
        try {
          x.value = f(v), x.status = "success";
        } catch (A) {
          x.status = "error", x.value = A;
        }
        return x;
      }
      (r.exports = k).prototype.finally = function(f) {
        if (typeof f != "function")
          return this;
        var v = this.constructor;
        return this.then(function(x) {
          return v.resolve(f()).then(function() {
            return x;
          });
        }, function(x) {
          return v.resolve(f()).then(function() {
            throw x;
          });
        });
      }, k.prototype.catch = function(f) {
        return this.then(null, f);
      }, k.prototype.then = function(f, v) {
        if (typeof f != "function" && this.state === g || typeof v != "function" && this.state === u)
          return this;
        var x = new this.constructor(o);
        return this.state !== _ ? d(x, this.state === g ? f : v, this.outcome) : this.queue.push(new w(x, f, v)), x;
      }, w.prototype.callFulfilled = function(f) {
        l.resolve(this.promise, f);
      }, w.prototype.otherCallFulfilled = function(f) {
        d(this.promise, this.onFulfilled, f);
      }, w.prototype.callRejected = function(f) {
        l.reject(this.promise, f);
      }, w.prototype.otherCallRejected = function(f) {
        d(this.promise, this.onRejected, f);
      }, l.resolve = function(f, v) {
        var x = m(y, v);
        if (x.status === "error")
          return l.reject(f, x.value);
        var A = x.value;
        if (A)
          h(f, A);
        else {
          f.state = g, f.outcome = v;
          for (var P = -1, D = f.queue.length; ++P < D; )
            f.queue[P].callFulfilled(v);
        }
        return f;
      }, l.reject = function(f, v) {
        f.state = u, f.outcome = v;
        for (var x = -1, A = f.queue.length; ++x < A; )
          f.queue[x].callRejected(v);
        return f;
      }, k.resolve = function(f) {
        return f instanceof this ? f : l.resolve(new this(o), f);
      }, k.reject = function(f) {
        var v = new this(o);
        return l.reject(v, f);
      }, k.all = function(f) {
        var v = this;
        if (Object.prototype.toString.call(f) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = f.length, A = !1;
        if (!x)
          return this.resolve([]);
        for (var P = new Array(x), D = 0, O = -1, H = new this(o); ++O < x; )
          T(f[O], O);
        return H;
        function T(X, Q) {
          v.resolve(X).then(function(S) {
            P[Q] = S, ++D !== x || A || (A = !0, l.resolve(H, P));
          }, function(S) {
            A || (A = !0, l.reject(H, S));
          });
        }
      }, k.race = function(f) {
        var v = this;
        if (Object.prototype.toString.call(f) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = f.length, A = !1;
        if (!x)
          return this.resolve([]);
        for (var P = -1, D = new this(o); ++P < x; )
          O = f[P], v.resolve(O).then(function(H) {
            A || (A = !0, l.resolve(D, H));
          }, function(H) {
            A || (A = !0, l.reject(D, H));
          });
        var O;
        return D;
      };
    }, { immediate: 36 }], 38: [function(t, r, a) {
      var n = {};
      (0, t("./lib/utils/common").assign)(n, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), r.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, r, a) {
      var n = t("./zlib/deflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/messages"), g = t("./zlib/zstream"), _ = Object.prototype.toString, k = 0, w = -1, d = 0, y = 8;
      function h(f) {
        if (!(this instanceof h))
          return new h(f);
        this.options = o.assign({ level: w, method: y, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, f || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new g(), this.strm.avail_out = 0;
        var x = n.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (x !== k)
          throw new Error(u[x]);
        if (v.header && n.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var A;
          if (A = typeof v.dictionary == "string" ? l.string2buf(v.dictionary) : _.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (x = n.deflateSetDictionary(this.strm, A)) !== k)
            throw new Error(u[x]);
          this._dict_set = !0;
        }
      }
      function m(f, v) {
        var x = new h(v);
        if (x.push(f, !0), x.err)
          throw x.msg || u[x.err];
        return x.result;
      }
      h.prototype.push = function(f, v) {
        var x, A, P = this.strm, D = this.options.chunkSize;
        if (this.ended)
          return !1;
        A = v === ~~v ? v : v === !0 ? 4 : 0, typeof f == "string" ? P.input = l.string2buf(f) : _.call(f) === "[object ArrayBuffer]" ? P.input = new Uint8Array(f) : P.input = f, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new o.Buf8(D), P.next_out = 0, P.avail_out = D), (x = n.deflate(P, A)) !== 1 && x !== k)
            return this.onEnd(x), !(this.ended = !0);
          P.avail_out !== 0 && (P.avail_in !== 0 || A !== 4 && A !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(o.shrinkBuf(P.output, P.next_out))) : this.onData(o.shrinkBuf(P.output, P.next_out)));
        } while ((0 < P.avail_in || P.avail_out === 0) && x !== 1);
        return A === 4 ? (x = n.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === k) : A !== 2 || (this.onEnd(k), !(P.avail_out = 0));
      }, h.prototype.onData = function(f) {
        this.chunks.push(f);
      }, h.prototype.onEnd = function(f) {
        f === k && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = f, this.msg = this.strm.msg;
      }, a.Deflate = h, a.deflate = m, a.deflateRaw = function(f, v) {
        return (v = v || {}).raw = !0, m(f, v);
      }, a.gzip = function(f, v) {
        return (v = v || {}).gzip = !0, m(f, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, r, a) {
      var n = t("./zlib/inflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/constants"), g = t("./zlib/messages"), _ = t("./zlib/zstream"), k = t("./zlib/gzheader"), w = Object.prototype.toString;
      function d(h) {
        if (!(this instanceof d))
          return new d(h);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, h || {});
        var m = this.options;
        m.raw && 0 <= m.windowBits && m.windowBits < 16 && (m.windowBits = -m.windowBits, m.windowBits === 0 && (m.windowBits = -15)), !(0 <= m.windowBits && m.windowBits < 16) || h && h.windowBits || (m.windowBits += 32), 15 < m.windowBits && m.windowBits < 48 && !(15 & m.windowBits) && (m.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _(), this.strm.avail_out = 0;
        var f = n.inflateInit2(this.strm, m.windowBits);
        if (f !== u.Z_OK)
          throw new Error(g[f]);
        this.header = new k(), n.inflateGetHeader(this.strm, this.header);
      }
      function y(h, m) {
        var f = new d(m);
        if (f.push(h, !0), f.err)
          throw f.msg || g[f.err];
        return f.result;
      }
      d.prototype.push = function(h, m) {
        var f, v, x, A, P, D, O = this.strm, H = this.options.chunkSize, T = this.options.dictionary, X = !1;
        if (this.ended)
          return !1;
        v = m === ~~m ? m : m === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof h == "string" ? O.input = l.binstring2buf(h) : w.call(h) === "[object ArrayBuffer]" ? O.input = new Uint8Array(h) : O.input = h, O.next_in = 0, O.avail_in = O.input.length;
        do {
          if (O.avail_out === 0 && (O.output = new o.Buf8(H), O.next_out = 0, O.avail_out = H), (f = n.inflate(O, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && T && (D = typeof T == "string" ? l.string2buf(T) : w.call(T) === "[object ArrayBuffer]" ? new Uint8Array(T) : T, f = n.inflateSetDictionary(this.strm, D)), f === u.Z_BUF_ERROR && X === !0 && (f = u.Z_OK, X = !1), f !== u.Z_STREAM_END && f !== u.Z_OK)
            return this.onEnd(f), !(this.ended = !0);
          O.next_out && (O.avail_out !== 0 && f !== u.Z_STREAM_END && (O.avail_in !== 0 || v !== u.Z_FINISH && v !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = l.utf8border(O.output, O.next_out), A = O.next_out - x, P = l.buf2string(O.output, x), O.next_out = A, O.avail_out = H - A, A && o.arraySet(O.output, O.output, x, A, 0), this.onData(P)) : this.onData(o.shrinkBuf(O.output, O.next_out)))), O.avail_in === 0 && O.avail_out === 0 && (X = !0);
        } while ((0 < O.avail_in || O.avail_out === 0) && f !== u.Z_STREAM_END);
        return f === u.Z_STREAM_END && (v = u.Z_FINISH), v === u.Z_FINISH ? (f = n.inflateEnd(this.strm), this.onEnd(f), this.ended = !0, f === u.Z_OK) : v !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(O.avail_out = 0));
      }, d.prototype.onData = function(h) {
        this.chunks.push(h);
      }, d.prototype.onEnd = function(h) {
        h === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = h, this.msg = this.strm.msg;
      }, a.Inflate = d, a.inflate = y, a.inflateRaw = function(h, m) {
        return (m = m || {}).raw = !0, y(h, m);
      }, a.ungzip = y;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, r, a) {
      var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      a.assign = function(u) {
        for (var g = Array.prototype.slice.call(arguments, 1); g.length; ) {
          var _ = g.shift();
          if (_) {
            if (typeof _ != "object")
              throw new TypeError(_ + "must be non-object");
            for (var k in _)
              _.hasOwnProperty(k) && (u[k] = _[k]);
          }
        }
        return u;
      }, a.shrinkBuf = function(u, g) {
        return u.length === g ? u : u.subarray ? u.subarray(0, g) : (u.length = g, u);
      };
      var o = { arraySet: function(u, g, _, k, w) {
        if (g.subarray && u.subarray)
          u.set(g.subarray(_, _ + k), w);
        else
          for (var d = 0; d < k; d++)
            u[w + d] = g[_ + d];
      }, flattenChunks: function(u) {
        var g, _, k, w, d, y;
        for (g = k = 0, _ = u.length; g < _; g++)
          k += u[g].length;
        for (y = new Uint8Array(k), g = w = 0, _ = u.length; g < _; g++)
          d = u[g], y.set(d, w), w += d.length;
        return y;
      } }, l = { arraySet: function(u, g, _, k, w) {
        for (var d = 0; d < k; d++)
          u[w + d] = g[_ + d];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      a.setTyped = function(u) {
        u ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, o)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, l));
      }, a.setTyped(n);
    }, {}], 42: [function(t, r, a) {
      var n = t("./common"), o = !0, l = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (k) {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (k) {
        l = !1;
      }
      for (var u = new n.Buf8(256), g = 0; g < 256; g++)
        u[g] = 252 <= g ? 6 : 248 <= g ? 5 : 240 <= g ? 4 : 224 <= g ? 3 : 192 <= g ? 2 : 1;
      function _(k, w) {
        if (w < 65537 && (k.subarray && l || !k.subarray && o))
          return String.fromCharCode.apply(null, n.shrinkBuf(k, w));
        for (var d = "", y = 0; y < w; y++)
          d += String.fromCharCode(k[y]);
        return d;
      }
      u[254] = u[254] = 1, a.string2buf = function(k) {
        var w, d, y, h, m, f = k.length, v = 0;
        for (h = 0; h < f; h++)
          (64512 & (d = k.charCodeAt(h))) == 55296 && h + 1 < f && (64512 & (y = k.charCodeAt(h + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (y - 56320), h++), v += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
        for (w = new n.Buf8(v), h = m = 0; m < v; h++)
          (64512 & (d = k.charCodeAt(h))) == 55296 && h + 1 < f && (64512 & (y = k.charCodeAt(h + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (y - 56320), h++), d < 128 ? w[m++] = d : (d < 2048 ? w[m++] = 192 | d >>> 6 : (d < 65536 ? w[m++] = 224 | d >>> 12 : (w[m++] = 240 | d >>> 18, w[m++] = 128 | d >>> 12 & 63), w[m++] = 128 | d >>> 6 & 63), w[m++] = 128 | 63 & d);
        return w;
      }, a.buf2binstring = function(k) {
        return _(k, k.length);
      }, a.binstring2buf = function(k) {
        for (var w = new n.Buf8(k.length), d = 0, y = w.length; d < y; d++)
          w[d] = k.charCodeAt(d);
        return w;
      }, a.buf2string = function(k, w) {
        var d, y, h, m, f = w || k.length, v = new Array(2 * f);
        for (d = y = 0; d < f; )
          if ((h = k[d++]) < 128)
            v[y++] = h;
          else if (4 < (m = u[h]))
            v[y++] = 65533, d += m - 1;
          else {
            for (h &= m === 2 ? 31 : m === 3 ? 15 : 7; 1 < m && d < f; )
              h = h << 6 | 63 & k[d++], m--;
            1 < m ? v[y++] = 65533 : h < 65536 ? v[y++] = h : (h -= 65536, v[y++] = 55296 | h >> 10 & 1023, v[y++] = 56320 | 1023 & h);
          }
        return _(v, y);
      }, a.utf8border = function(k, w) {
        var d;
        for ((w = w || k.length) > k.length && (w = k.length), d = w - 1; 0 <= d && (192 & k[d]) == 128; )
          d--;
        return d < 0 || d === 0 ? w : d + u[k[d]] > w ? d : w;
      };
    }, { "./common": 41 }], 43: [function(t, r, a) {
      r.exports = function(n, o, l, u) {
        for (var g = 65535 & n | 0, _ = n >>> 16 & 65535 | 0, k = 0; l !== 0; ) {
          for (l -= k = 2e3 < l ? 2e3 : l; _ = _ + (g = g + o[u++] | 0) | 0, --k; )
            ;
          g %= 65521, _ %= 65521;
        }
        return g | _ << 16 | 0;
      };
    }, {}], 44: [function(t, r, a) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, r, a) {
      var n = function() {
        for (var o, l = [], u = 0; u < 256; u++) {
          o = u;
          for (var g = 0; g < 8; g++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          l[u] = o;
        }
        return l;
      }();
      r.exports = function(o, l, u, g) {
        var _ = n, k = g + u;
        o ^= -1;
        for (var w = g; w < k; w++)
          o = o >>> 8 ^ _[255 & (o ^ l[w])];
        return -1 ^ o;
      };
    }, {}], 46: [function(t, r, a) {
      var n, o = t("../utils/common"), l = t("./trees"), u = t("./adler32"), g = t("./crc32"), _ = t("./messages"), k = 0, w = 4, d = 0, y = -2, h = -1, m = 4, f = 2, v = 8, x = 9, A = 286, P = 30, D = 19, O = 2 * A + 1, H = 15, T = 3, X = 258, Q = X + T + 1, S = 42, F = 113, c = 1, L = 2, et = 3, W = 4;
      function rt(s, I) {
        return s.msg = _[I], I;
      }
      function $(s) {
        return (s << 1) - (4 < s ? 9 : 0);
      }
      function tt(s) {
        for (var I = s.length; 0 <= --I; )
          s[I] = 0;
      }
      function z(s) {
        var I = s.state, M = I.pending;
        M > s.avail_out && (M = s.avail_out), M !== 0 && (o.arraySet(s.output, I.pending_buf, I.pending_out, M, s.next_out), s.next_out += M, I.pending_out += M, s.total_out += M, s.avail_out -= M, I.pending -= M, I.pending === 0 && (I.pending_out = 0));
      }
      function B(s, I) {
        l._tr_flush_block(s, 0 <= s.block_start ? s.block_start : -1, s.strstart - s.block_start, I), s.block_start = s.strstart, z(s.strm);
      }
      function J(s, I) {
        s.pending_buf[s.pending++] = I;
      }
      function q(s, I) {
        s.pending_buf[s.pending++] = I >>> 8 & 255, s.pending_buf[s.pending++] = 255 & I;
      }
      function G(s, I) {
        var M, b, p = s.max_chain_length, C = s.strstart, j = s.prev_length, U = s.nice_match, N = s.strstart > s.w_size - Q ? s.strstart - (s.w_size - Q) : 0, Z = s.window, K = s.w_mask, V = s.prev, Y = s.strstart + X, ot = Z[C + j - 1], st = Z[C + j];
        s.prev_length >= s.good_match && (p >>= 2), U > s.lookahead && (U = s.lookahead);
        do
          if (Z[(M = I) + j] === st && Z[M + j - 1] === ot && Z[M] === Z[C] && Z[++M] === Z[C + 1]) {
            C += 2, M++;
            do
              ;
            while (Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && Z[++C] === Z[++M] && C < Y);
            if (b = X - (Y - C), C = Y - X, j < b) {
              if (s.match_start = I, U <= (j = b))
                break;
              ot = Z[C + j - 1], st = Z[C + j];
            }
          }
        while ((I = V[I & K]) > N && --p != 0);
        return j <= s.lookahead ? j : s.lookahead;
      }
      function ht(s) {
        var I, M, b, p, C, j, U, N, Z, K, V = s.w_size;
        do {
          if (p = s.window_size - s.lookahead - s.strstart, s.strstart >= V + (V - Q)) {
            for (o.arraySet(s.window, s.window, V, V, 0), s.match_start -= V, s.strstart -= V, s.block_start -= V, I = M = s.hash_size; b = s.head[--I], s.head[I] = V <= b ? b - V : 0, --M; )
              ;
            for (I = M = V; b = s.prev[--I], s.prev[I] = V <= b ? b - V : 0, --M; )
              ;
            p += V;
          }
          if (s.strm.avail_in === 0)
            break;
          if (j = s.strm, U = s.window, N = s.strstart + s.lookahead, Z = p, K = void 0, K = j.avail_in, Z < K && (K = Z), M = K === 0 ? 0 : (j.avail_in -= K, o.arraySet(U, j.input, j.next_in, K, N), j.state.wrap === 1 ? j.adler = u(j.adler, U, K, N) : j.state.wrap === 2 && (j.adler = g(j.adler, U, K, N)), j.next_in += K, j.total_in += K, K), s.lookahead += M, s.lookahead + s.insert >= T)
            for (C = s.strstart - s.insert, s.ins_h = s.window[C], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[C + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[C + T - 1]) & s.hash_mask, s.prev[C & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = C, C++, s.insert--, !(s.lookahead + s.insert < T)); )
              ;
        } while (s.lookahead < Q && s.strm.avail_in !== 0);
      }
      function bt(s, I) {
        for (var M, b; ; ) {
          if (s.lookahead < Q) {
            if (ht(s), s.lookahead < Q && I === k)
              return c;
            if (s.lookahead === 0)
              break;
          }
          if (M = 0, s.lookahead >= T && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), M !== 0 && s.strstart - M <= s.w_size - Q && (s.match_length = G(s, M)), s.match_length >= T)
            if (b = l._tr_tally(s, s.strstart - s.match_start, s.match_length - T), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= T) {
              for (s.match_length--; s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart, --s.match_length != 0; )
                ;
              s.strstart++;
            } else
              s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          else
            b = l._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;
          if (b && (B(s, !1), s.strm.avail_out === 0))
            return c;
        }
        return s.insert = s.strstart < T - 1 ? s.strstart : T - 1, I === w ? (B(s, !0), s.strm.avail_out === 0 ? et : W) : s.last_lit && (B(s, !1), s.strm.avail_out === 0) ? c : L;
      }
      function at(s, I) {
        for (var M, b, p; ; ) {
          if (s.lookahead < Q) {
            if (ht(s), s.lookahead < Q && I === k)
              return c;
            if (s.lookahead === 0)
              break;
          }
          if (M = 0, s.lookahead >= T && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = T - 1, M !== 0 && s.prev_length < s.max_lazy_match && s.strstart - M <= s.w_size - Q && (s.match_length = G(s, M), s.match_length <= 5 && (s.strategy === 1 || s.match_length === T && 4096 < s.strstart - s.match_start) && (s.match_length = T - 1)), s.prev_length >= T && s.match_length <= s.prev_length) {
            for (p = s.strstart + s.lookahead - T, b = l._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - T), s.lookahead -= s.prev_length - 1, s.prev_length -= 2; ++s.strstart <= p && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + T - 1]) & s.hash_mask, M = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), --s.prev_length != 0; )
              ;
            if (s.match_available = 0, s.match_length = T - 1, s.strstart++, b && (B(s, !1), s.strm.avail_out === 0))
              return c;
          } else if (s.match_available) {
            if ((b = l._tr_tally(s, 0, s.window[s.strstart - 1])) && B(s, !1), s.strstart++, s.lookahead--, s.strm.avail_out === 0)
              return c;
          } else
            s.match_available = 1, s.strstart++, s.lookahead--;
        }
        return s.match_available && (b = l._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0), s.insert = s.strstart < T - 1 ? s.strstart : T - 1, I === w ? (B(s, !0), s.strm.avail_out === 0 ? et : W) : s.last_lit && (B(s, !1), s.strm.avail_out === 0) ? c : L;
      }
      function it(s, I, M, b, p) {
        this.good_length = s, this.max_lazy = I, this.nice_length = M, this.max_chain = b, this.func = p;
      }
      function gt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * O), this.dyn_dtree = new o.Buf16(2 * (2 * P + 1)), this.bl_tree = new o.Buf16(2 * (2 * D + 1)), tt(this.dyn_ltree), tt(this.dyn_dtree), tt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(H + 1), this.heap = new o.Buf16(2 * A + 1), tt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * A + 1), tt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function dt(s) {
        var I;
        return s && s.state ? (s.total_in = s.total_out = 0, s.data_type = f, (I = s.state).pending = 0, I.pending_out = 0, I.wrap < 0 && (I.wrap = -I.wrap), I.status = I.wrap ? S : F, s.adler = I.wrap === 2 ? 0 : 1, I.last_flush = k, l._tr_init(I), d) : rt(s, y);
      }
      function St(s) {
        var I = dt(s);
        return I === d && function(M) {
          M.window_size = 2 * M.w_size, tt(M.head), M.max_lazy_match = n[M.level].max_lazy, M.good_match = n[M.level].good_length, M.nice_match = n[M.level].nice_length, M.max_chain_length = n[M.level].max_chain, M.strstart = 0, M.block_start = 0, M.lookahead = 0, M.insert = 0, M.match_length = M.prev_length = T - 1, M.match_available = 0, M.ins_h = 0;
        }(s.state), I;
      }
      function _t(s, I, M, b, p, C) {
        if (!s)
          return y;
        var j = 1;
        if (I === h && (I = 6), b < 0 ? (j = 0, b = -b) : 15 < b && (j = 2, b -= 16), p < 1 || x < p || M !== v || b < 8 || 15 < b || I < 0 || 9 < I || C < 0 || m < C)
          return rt(s, y);
        b === 8 && (b = 9);
        var U = new gt();
        return (s.state = U).strm = s, U.wrap = j, U.gzhead = null, U.w_bits = b, U.w_size = 1 << U.w_bits, U.w_mask = U.w_size - 1, U.hash_bits = p + 7, U.hash_size = 1 << U.hash_bits, U.hash_mask = U.hash_size - 1, U.hash_shift = ~~((U.hash_bits + T - 1) / T), U.window = new o.Buf8(2 * U.w_size), U.head = new o.Buf16(U.hash_size), U.prev = new o.Buf16(U.w_size), U.lit_bufsize = 1 << p + 6, U.pending_buf_size = 4 * U.lit_bufsize, U.pending_buf = new o.Buf8(U.pending_buf_size), U.d_buf = 1 * U.lit_bufsize, U.l_buf = 3 * U.lit_bufsize, U.level = I, U.strategy = C, U.method = M, St(s);
      }
      n = [new it(0, 0, 0, 0, function(s, I) {
        var M = 65535;
        for (M > s.pending_buf_size - 5 && (M = s.pending_buf_size - 5); ; ) {
          if (s.lookahead <= 1) {
            if (ht(s), s.lookahead === 0 && I === k)
              return c;
            if (s.lookahead === 0)
              break;
          }
          s.strstart += s.lookahead, s.lookahead = 0;
          var b = s.block_start + M;
          if ((s.strstart === 0 || s.strstart >= b) && (s.lookahead = s.strstart - b, s.strstart = b, B(s, !1), s.strm.avail_out === 0) || s.strstart - s.block_start >= s.w_size - Q && (B(s, !1), s.strm.avail_out === 0))
            return c;
        }
        return s.insert = 0, I === w ? (B(s, !0), s.strm.avail_out === 0 ? et : W) : (s.strstart > s.block_start && (B(s, !1), s.strm.avail_out), c);
      }), new it(4, 4, 8, 4, bt), new it(4, 5, 16, 8, bt), new it(4, 6, 32, 32, bt), new it(4, 4, 16, 16, at), new it(8, 16, 32, 32, at), new it(8, 16, 128, 128, at), new it(8, 32, 128, 256, at), new it(32, 128, 258, 1024, at), new it(32, 258, 258, 4096, at)], a.deflateInit = function(s, I) {
        return _t(s, I, v, 15, 8, 0);
      }, a.deflateInit2 = _t, a.deflateReset = St, a.deflateResetKeep = dt, a.deflateSetHeader = function(s, I) {
        return s && s.state ? s.state.wrap !== 2 ? y : (s.state.gzhead = I, d) : y;
      }, a.deflate = function(s, I) {
        var M, b, p, C;
        if (!s || !s.state || 5 < I || I < 0)
          return s ? rt(s, y) : y;
        if (b = s.state, !s.output || !s.input && s.avail_in !== 0 || b.status === 666 && I !== w)
          return rt(s, s.avail_out === 0 ? -5 : y);
        if (b.strm = s, M = b.last_flush, b.last_flush = I, b.status === S)
          if (b.wrap === 2)
            s.adler = 0, J(b, 31), J(b, 139), J(b, 8), b.gzhead ? (J(b, (b.gzhead.text ? 1 : 0) + (b.gzhead.hcrc ? 2 : 0) + (b.gzhead.extra ? 4 : 0) + (b.gzhead.name ? 8 : 0) + (b.gzhead.comment ? 16 : 0)), J(b, 255 & b.gzhead.time), J(b, b.gzhead.time >> 8 & 255), J(b, b.gzhead.time >> 16 & 255), J(b, b.gzhead.time >> 24 & 255), J(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), J(b, 255 & b.gzhead.os), b.gzhead.extra && b.gzhead.extra.length && (J(b, 255 & b.gzhead.extra.length), J(b, b.gzhead.extra.length >> 8 & 255)), b.gzhead.hcrc && (s.adler = g(s.adler, b.pending_buf, b.pending, 0)), b.gzindex = 0, b.status = 69) : (J(b, 0), J(b, 0), J(b, 0), J(b, 0), J(b, 0), J(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), J(b, 3), b.status = F);
          else {
            var j = v + (b.w_bits - 8 << 4) << 8;
            j |= (2 <= b.strategy || b.level < 2 ? 0 : b.level < 6 ? 1 : b.level === 6 ? 2 : 3) << 6, b.strstart !== 0 && (j |= 32), j += 31 - j % 31, b.status = F, q(b, j), b.strstart !== 0 && (q(b, s.adler >>> 16), q(b, 65535 & s.adler)), s.adler = 1;
          }
        if (b.status === 69)
          if (b.gzhead.extra) {
            for (p = b.pending; b.gzindex < (65535 & b.gzhead.extra.length) && (b.pending !== b.pending_buf_size || (b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), z(s), p = b.pending, b.pending !== b.pending_buf_size)); )
              J(b, 255 & b.gzhead.extra[b.gzindex]), b.gzindex++;
            b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), b.gzindex === b.gzhead.extra.length && (b.gzindex = 0, b.status = 73);
          } else
            b.status = 73;
        if (b.status === 73)
          if (b.gzhead.name) {
            p = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), z(s), p = b.pending, b.pending === b.pending_buf_size)) {
                C = 1;
                break;
              }
              C = b.gzindex < b.gzhead.name.length ? 255 & b.gzhead.name.charCodeAt(b.gzindex++) : 0, J(b, C);
            } while (C !== 0);
            b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), C === 0 && (b.gzindex = 0, b.status = 91);
          } else
            b.status = 91;
        if (b.status === 91)
          if (b.gzhead.comment) {
            p = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), z(s), p = b.pending, b.pending === b.pending_buf_size)) {
                C = 1;
                break;
              }
              C = b.gzindex < b.gzhead.comment.length ? 255 & b.gzhead.comment.charCodeAt(b.gzindex++) : 0, J(b, C);
            } while (C !== 0);
            b.gzhead.hcrc && b.pending > p && (s.adler = g(s.adler, b.pending_buf, b.pending - p, p)), C === 0 && (b.status = 103);
          } else
            b.status = 103;
        if (b.status === 103 && (b.gzhead.hcrc ? (b.pending + 2 > b.pending_buf_size && z(s), b.pending + 2 <= b.pending_buf_size && (J(b, 255 & s.adler), J(b, s.adler >> 8 & 255), s.adler = 0, b.status = F)) : b.status = F), b.pending !== 0) {
          if (z(s), s.avail_out === 0)
            return b.last_flush = -1, d;
        } else if (s.avail_in === 0 && $(I) <= $(M) && I !== w)
          return rt(s, -5);
        if (b.status === 666 && s.avail_in !== 0)
          return rt(s, -5);
        if (s.avail_in !== 0 || b.lookahead !== 0 || I !== k && b.status !== 666) {
          var U = b.strategy === 2 ? function(N, Z) {
            for (var K; ; ) {
              if (N.lookahead === 0 && (ht(N), N.lookahead === 0)) {
                if (Z === k)
                  return c;
                break;
              }
              if (N.match_length = 0, K = l._tr_tally(N, 0, N.window[N.strstart]), N.lookahead--, N.strstart++, K && (B(N, !1), N.strm.avail_out === 0))
                return c;
            }
            return N.insert = 0, Z === w ? (B(N, !0), N.strm.avail_out === 0 ? et : W) : N.last_lit && (B(N, !1), N.strm.avail_out === 0) ? c : L;
          }(b, I) : b.strategy === 3 ? function(N, Z) {
            for (var K, V, Y, ot, st = N.window; ; ) {
              if (N.lookahead <= X) {
                if (ht(N), N.lookahead <= X && Z === k)
                  return c;
                if (N.lookahead === 0)
                  break;
              }
              if (N.match_length = 0, N.lookahead >= T && 0 < N.strstart && (V = st[Y = N.strstart - 1]) === st[++Y] && V === st[++Y] && V === st[++Y]) {
                ot = N.strstart + X;
                do
                  ;
                while (V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && V === st[++Y] && Y < ot);
                N.match_length = X - (ot - Y), N.match_length > N.lookahead && (N.match_length = N.lookahead);
              }
              if (N.match_length >= T ? (K = l._tr_tally(N, 1, N.match_length - T), N.lookahead -= N.match_length, N.strstart += N.match_length, N.match_length = 0) : (K = l._tr_tally(N, 0, N.window[N.strstart]), N.lookahead--, N.strstart++), K && (B(N, !1), N.strm.avail_out === 0))
                return c;
            }
            return N.insert = 0, Z === w ? (B(N, !0), N.strm.avail_out === 0 ? et : W) : N.last_lit && (B(N, !1), N.strm.avail_out === 0) ? c : L;
          }(b, I) : n[b.level].func(b, I);
          if (U !== et && U !== W || (b.status = 666), U === c || U === et)
            return s.avail_out === 0 && (b.last_flush = -1), d;
          if (U === L && (I === 1 ? l._tr_align(b) : I !== 5 && (l._tr_stored_block(b, 0, 0, !1), I === 3 && (tt(b.head), b.lookahead === 0 && (b.strstart = 0, b.block_start = 0, b.insert = 0))), z(s), s.avail_out === 0))
            return b.last_flush = -1, d;
        }
        return I !== w ? d : b.wrap <= 0 ? 1 : (b.wrap === 2 ? (J(b, 255 & s.adler), J(b, s.adler >> 8 & 255), J(b, s.adler >> 16 & 255), J(b, s.adler >> 24 & 255), J(b, 255 & s.total_in), J(b, s.total_in >> 8 & 255), J(b, s.total_in >> 16 & 255), J(b, s.total_in >> 24 & 255)) : (q(b, s.adler >>> 16), q(b, 65535 & s.adler)), z(s), 0 < b.wrap && (b.wrap = -b.wrap), b.pending !== 0 ? d : 1);
      }, a.deflateEnd = function(s) {
        var I;
        return s && s.state ? (I = s.state.status) !== S && I !== 69 && I !== 73 && I !== 91 && I !== 103 && I !== F && I !== 666 ? rt(s, y) : (s.state = null, I === F ? rt(s, -3) : d) : y;
      }, a.deflateSetDictionary = function(s, I) {
        var M, b, p, C, j, U, N, Z, K = I.length;
        if (!s || !s.state || (C = (M = s.state).wrap) === 2 || C === 1 && M.status !== S || M.lookahead)
          return y;
        for (C === 1 && (s.adler = u(s.adler, I, K, 0)), M.wrap = 0, K >= M.w_size && (C === 0 && (tt(M.head), M.strstart = 0, M.block_start = 0, M.insert = 0), Z = new o.Buf8(M.w_size), o.arraySet(Z, I, K - M.w_size, M.w_size, 0), I = Z, K = M.w_size), j = s.avail_in, U = s.next_in, N = s.input, s.avail_in = K, s.next_in = 0, s.input = I, ht(M); M.lookahead >= T; ) {
          for (b = M.strstart, p = M.lookahead - (T - 1); M.ins_h = (M.ins_h << M.hash_shift ^ M.window[b + T - 1]) & M.hash_mask, M.prev[b & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = b, b++, --p; )
            ;
          M.strstart = b, M.lookahead = T - 1, ht(M);
        }
        return M.strstart += M.lookahead, M.block_start = M.strstart, M.insert = M.lookahead, M.lookahead = 0, M.match_length = M.prev_length = T - 1, M.match_available = 0, s.next_in = U, s.input = N, s.avail_in = j, M.wrap = C, d;
      }, a.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, r, a) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, r, a) {
      r.exports = function(n, o) {
        var l, u, g, _, k, w, d, y, h, m, f, v, x, A, P, D, O, H, T, X, Q, S, F, c, L;
        l = n.state, u = n.next_in, c = n.input, g = u + (n.avail_in - 5), _ = n.next_out, L = n.output, k = _ - (o - n.avail_out), w = _ + (n.avail_out - 257), d = l.dmax, y = l.wsize, h = l.whave, m = l.wnext, f = l.window, v = l.hold, x = l.bits, A = l.lencode, P = l.distcode, D = (1 << l.lenbits) - 1, O = (1 << l.distbits) - 1;
        t:
          do {
            x < 15 && (v += c[u++] << x, x += 8, v += c[u++] << x, x += 8), H = A[v & D];
            e:
              for (; ; ) {
                if (v >>>= T = H >>> 24, x -= T, (T = H >>> 16 & 255) === 0)
                  L[_++] = 65535 & H;
                else {
                  if (!(16 & T)) {
                    if (!(64 & T)) {
                      H = A[(65535 & H) + (v & (1 << T) - 1)];
                      continue e;
                    }
                    if (32 & T) {
                      l.mode = 12;
                      break t;
                    }
                    n.msg = "invalid literal/length code", l.mode = 30;
                    break t;
                  }
                  X = 65535 & H, (T &= 15) && (x < T && (v += c[u++] << x, x += 8), X += v & (1 << T) - 1, v >>>= T, x -= T), x < 15 && (v += c[u++] << x, x += 8, v += c[u++] << x, x += 8), H = P[v & O];
                  r:
                    for (; ; ) {
                      if (v >>>= T = H >>> 24, x -= T, !(16 & (T = H >>> 16 & 255))) {
                        if (!(64 & T)) {
                          H = P[(65535 & H) + (v & (1 << T) - 1)];
                          continue r;
                        }
                        n.msg = "invalid distance code", l.mode = 30;
                        break t;
                      }
                      if (Q = 65535 & H, x < (T &= 15) && (v += c[u++] << x, (x += 8) < T && (v += c[u++] << x, x += 8)), d < (Q += v & (1 << T) - 1)) {
                        n.msg = "invalid distance too far back", l.mode = 30;
                        break t;
                      }
                      if (v >>>= T, x -= T, (T = _ - k) < Q) {
                        if (h < (T = Q - T) && l.sane) {
                          n.msg = "invalid distance too far back", l.mode = 30;
                          break t;
                        }
                        if (F = f, (S = 0) === m) {
                          if (S += y - T, T < X) {
                            for (X -= T; L[_++] = f[S++], --T; )
                              ;
                            S = _ - Q, F = L;
                          }
                        } else if (m < T) {
                          if (S += y + m - T, (T -= m) < X) {
                            for (X -= T; L[_++] = f[S++], --T; )
                              ;
                            if (S = 0, m < X) {
                              for (X -= T = m; L[_++] = f[S++], --T; )
                                ;
                              S = _ - Q, F = L;
                            }
                          }
                        } else if (S += m - T, T < X) {
                          for (X -= T; L[_++] = f[S++], --T; )
                            ;
                          S = _ - Q, F = L;
                        }
                        for (; 2 < X; )
                          L[_++] = F[S++], L[_++] = F[S++], L[_++] = F[S++], X -= 3;
                        X && (L[_++] = F[S++], 1 < X && (L[_++] = F[S++]));
                      } else {
                        for (S = _ - Q; L[_++] = L[S++], L[_++] = L[S++], L[_++] = L[S++], 2 < (X -= 3); )
                          ;
                        X && (L[_++] = L[S++], 1 < X && (L[_++] = L[S++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (u < g && _ < w);
        u -= X = x >> 3, v &= (1 << (x -= X << 3)) - 1, n.next_in = u, n.next_out = _, n.avail_in = u < g ? g - u + 5 : 5 - (u - g), n.avail_out = _ < w ? w - _ + 257 : 257 - (_ - w), l.hold = v, l.bits = x;
      };
    }, {}], 49: [function(t, r, a) {
      var n = t("../utils/common"), o = t("./adler32"), l = t("./crc32"), u = t("./inffast"), g = t("./inftrees"), _ = 1, k = 2, w = 0, d = -2, y = 1, h = 852, m = 592;
      function f(S) {
        return (S >>> 24 & 255) + (S >>> 8 & 65280) + ((65280 & S) << 8) + ((255 & S) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(S) {
        var F;
        return S && S.state ? (F = S.state, S.total_in = S.total_out = F.total = 0, S.msg = "", F.wrap && (S.adler = 1 & F.wrap), F.mode = y, F.last = 0, F.havedict = 0, F.dmax = 32768, F.head = null, F.hold = 0, F.bits = 0, F.lencode = F.lendyn = new n.Buf32(h), F.distcode = F.distdyn = new n.Buf32(m), F.sane = 1, F.back = -1, w) : d;
      }
      function A(S) {
        var F;
        return S && S.state ? ((F = S.state).wsize = 0, F.whave = 0, F.wnext = 0, x(S)) : d;
      }
      function P(S, F) {
        var c, L;
        return S && S.state ? (L = S.state, F < 0 ? (c = 0, F = -F) : (c = 1 + (F >> 4), F < 48 && (F &= 15)), F && (F < 8 || 15 < F) ? d : (L.window !== null && L.wbits !== F && (L.window = null), L.wrap = c, L.wbits = F, A(S))) : d;
      }
      function D(S, F) {
        var c, L;
        return S ? (L = new v(), (S.state = L).window = null, (c = P(S, F)) !== w && (S.state = null), c) : d;
      }
      var O, H, T = !0;
      function X(S) {
        if (T) {
          var F;
          for (O = new n.Buf32(512), H = new n.Buf32(32), F = 0; F < 144; )
            S.lens[F++] = 8;
          for (; F < 256; )
            S.lens[F++] = 9;
          for (; F < 280; )
            S.lens[F++] = 7;
          for (; F < 288; )
            S.lens[F++] = 8;
          for (g(_, S.lens, 0, 288, O, 0, S.work, { bits: 9 }), F = 0; F < 32; )
            S.lens[F++] = 5;
          g(k, S.lens, 0, 32, H, 0, S.work, { bits: 5 }), T = !1;
        }
        S.lencode = O, S.lenbits = 9, S.distcode = H, S.distbits = 5;
      }
      function Q(S, F, c, L) {
        var et, W = S.state;
        return W.window === null && (W.wsize = 1 << W.wbits, W.wnext = 0, W.whave = 0, W.window = new n.Buf8(W.wsize)), L >= W.wsize ? (n.arraySet(W.window, F, c - W.wsize, W.wsize, 0), W.wnext = 0, W.whave = W.wsize) : (L < (et = W.wsize - W.wnext) && (et = L), n.arraySet(W.window, F, c - L, et, W.wnext), (L -= et) ? (n.arraySet(W.window, F, c - L, L, 0), W.wnext = L, W.whave = W.wsize) : (W.wnext += et, W.wnext === W.wsize && (W.wnext = 0), W.whave < W.wsize && (W.whave += et))), 0;
      }
      a.inflateReset = A, a.inflateReset2 = P, a.inflateResetKeep = x, a.inflateInit = function(S) {
        return D(S, 15);
      }, a.inflateInit2 = D, a.inflate = function(S, F) {
        var c, L, et, W, rt, $, tt, z, B, J, q, G, ht, bt, at, it, gt, dt, St, _t, s, I, M, b, p = 0, C = new n.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!S || !S.state || !S.output || !S.input && S.avail_in !== 0)
          return d;
        (c = S.state).mode === 12 && (c.mode = 13), rt = S.next_out, et = S.output, tt = S.avail_out, W = S.next_in, L = S.input, $ = S.avail_in, z = c.hold, B = c.bits, J = $, q = tt, I = w;
        t:
          for (; ; )
            switch (c.mode) {
              case y:
                if (c.wrap === 0) {
                  c.mode = 13;
                  break;
                }
                for (; B < 16; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if (2 & c.wrap && z === 35615) {
                  C[c.check = 0] = 255 & z, C[1] = z >>> 8 & 255, c.check = l(c.check, C, 2, 0), B = z = 0, c.mode = 2;
                  break;
                }
                if (c.flags = 0, c.head && (c.head.done = !1), !(1 & c.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                  S.msg = "incorrect header check", c.mode = 30;
                  break;
                }
                if ((15 & z) != 8) {
                  S.msg = "unknown compression method", c.mode = 30;
                  break;
                }
                if (B -= 4, s = 8 + (15 & (z >>>= 4)), c.wbits === 0)
                  c.wbits = s;
                else if (s > c.wbits) {
                  S.msg = "invalid window size", c.mode = 30;
                  break;
                }
                c.dmax = 1 << s, S.adler = c.check = 1, c.mode = 512 & z ? 10 : 12, B = z = 0;
                break;
              case 2:
                for (; B < 16; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if (c.flags = z, (255 & c.flags) != 8) {
                  S.msg = "unknown compression method", c.mode = 30;
                  break;
                }
                if (57344 & c.flags) {
                  S.msg = "unknown header flags set", c.mode = 30;
                  break;
                }
                c.head && (c.head.text = z >> 8 & 1), 512 & c.flags && (C[0] = 255 & z, C[1] = z >>> 8 & 255, c.check = l(c.check, C, 2, 0)), B = z = 0, c.mode = 3;
              case 3:
                for (; B < 32; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                c.head && (c.head.time = z), 512 & c.flags && (C[0] = 255 & z, C[1] = z >>> 8 & 255, C[2] = z >>> 16 & 255, C[3] = z >>> 24 & 255, c.check = l(c.check, C, 4, 0)), B = z = 0, c.mode = 4;
              case 4:
                for (; B < 16; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                c.head && (c.head.xflags = 255 & z, c.head.os = z >> 8), 512 & c.flags && (C[0] = 255 & z, C[1] = z >>> 8 & 255, c.check = l(c.check, C, 2, 0)), B = z = 0, c.mode = 5;
              case 5:
                if (1024 & c.flags) {
                  for (; B < 16; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  c.length = z, c.head && (c.head.extra_len = z), 512 & c.flags && (C[0] = 255 & z, C[1] = z >>> 8 & 255, c.check = l(c.check, C, 2, 0)), B = z = 0;
                } else
                  c.head && (c.head.extra = null);
                c.mode = 6;
              case 6:
                if (1024 & c.flags && ($ < (G = c.length) && (G = $), G && (c.head && (s = c.head.extra_len - c.length, c.head.extra || (c.head.extra = new Array(c.head.extra_len)), n.arraySet(c.head.extra, L, W, G, s)), 512 & c.flags && (c.check = l(c.check, L, G, W)), $ -= G, W += G, c.length -= G), c.length))
                  break t;
                c.length = 0, c.mode = 7;
              case 7:
                if (2048 & c.flags) {
                  if ($ === 0)
                    break t;
                  for (G = 0; s = L[W + G++], c.head && s && c.length < 65536 && (c.head.name += String.fromCharCode(s)), s && G < $; )
                    ;
                  if (512 & c.flags && (c.check = l(c.check, L, G, W)), $ -= G, W += G, s)
                    break t;
                } else
                  c.head && (c.head.name = null);
                c.length = 0, c.mode = 8;
              case 8:
                if (4096 & c.flags) {
                  if ($ === 0)
                    break t;
                  for (G = 0; s = L[W + G++], c.head && s && c.length < 65536 && (c.head.comment += String.fromCharCode(s)), s && G < $; )
                    ;
                  if (512 & c.flags && (c.check = l(c.check, L, G, W)), $ -= G, W += G, s)
                    break t;
                } else
                  c.head && (c.head.comment = null);
                c.mode = 9;
              case 9:
                if (512 & c.flags) {
                  for (; B < 16; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  if (z !== (65535 & c.check)) {
                    S.msg = "header crc mismatch", c.mode = 30;
                    break;
                  }
                  B = z = 0;
                }
                c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done = !0), S.adler = c.check = 0, c.mode = 12;
                break;
              case 10:
                for (; B < 32; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                S.adler = c.check = f(z), B = z = 0, c.mode = 11;
              case 11:
                if (c.havedict === 0)
                  return S.next_out = rt, S.avail_out = tt, S.next_in = W, S.avail_in = $, c.hold = z, c.bits = B, 2;
                S.adler = c.check = 1, c.mode = 12;
              case 12:
                if (F === 5 || F === 6)
                  break t;
              case 13:
                if (c.last) {
                  z >>>= 7 & B, B -= 7 & B, c.mode = 27;
                  break;
                }
                for (; B < 3; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                switch (c.last = 1 & z, B -= 1, 3 & (z >>>= 1)) {
                  case 0:
                    c.mode = 14;
                    break;
                  case 1:
                    if (X(c), c.mode = 20, F !== 6)
                      break;
                    z >>>= 2, B -= 2;
                    break t;
                  case 2:
                    c.mode = 17;
                    break;
                  case 3:
                    S.msg = "invalid block type", c.mode = 30;
                }
                z >>>= 2, B -= 2;
                break;
              case 14:
                for (z >>>= 7 & B, B -= 7 & B; B < 32; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if ((65535 & z) != (z >>> 16 ^ 65535)) {
                  S.msg = "invalid stored block lengths", c.mode = 30;
                  break;
                }
                if (c.length = 65535 & z, B = z = 0, c.mode = 15, F === 6)
                  break t;
              case 15:
                c.mode = 16;
              case 16:
                if (G = c.length) {
                  if ($ < G && (G = $), tt < G && (G = tt), G === 0)
                    break t;
                  n.arraySet(et, L, W, G, rt), $ -= G, W += G, tt -= G, rt += G, c.length -= G;
                  break;
                }
                c.mode = 12;
                break;
              case 17:
                for (; B < 14; ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if (c.nlen = 257 + (31 & z), z >>>= 5, B -= 5, c.ndist = 1 + (31 & z), z >>>= 5, B -= 5, c.ncode = 4 + (15 & z), z >>>= 4, B -= 4, 286 < c.nlen || 30 < c.ndist) {
                  S.msg = "too many length or distance symbols", c.mode = 30;
                  break;
                }
                c.have = 0, c.mode = 18;
              case 18:
                for (; c.have < c.ncode; ) {
                  for (; B < 3; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  c.lens[j[c.have++]] = 7 & z, z >>>= 3, B -= 3;
                }
                for (; c.have < 19; )
                  c.lens[j[c.have++]] = 0;
                if (c.lencode = c.lendyn, c.lenbits = 7, M = { bits: c.lenbits }, I = g(0, c.lens, 0, 19, c.lencode, 0, c.work, M), c.lenbits = M.bits, I) {
                  S.msg = "invalid code lengths set", c.mode = 30;
                  break;
                }
                c.have = 0, c.mode = 19;
              case 19:
                for (; c.have < c.nlen + c.ndist; ) {
                  for (; it = (p = c.lencode[z & (1 << c.lenbits) - 1]) >>> 16 & 255, gt = 65535 & p, !((at = p >>> 24) <= B); ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  if (gt < 16)
                    z >>>= at, B -= at, c.lens[c.have++] = gt;
                  else {
                    if (gt === 16) {
                      for (b = at + 2; B < b; ) {
                        if ($ === 0)
                          break t;
                        $--, z += L[W++] << B, B += 8;
                      }
                      if (z >>>= at, B -= at, c.have === 0) {
                        S.msg = "invalid bit length repeat", c.mode = 30;
                        break;
                      }
                      s = c.lens[c.have - 1], G = 3 + (3 & z), z >>>= 2, B -= 2;
                    } else if (gt === 17) {
                      for (b = at + 3; B < b; ) {
                        if ($ === 0)
                          break t;
                        $--, z += L[W++] << B, B += 8;
                      }
                      B -= at, s = 0, G = 3 + (7 & (z >>>= at)), z >>>= 3, B -= 3;
                    } else {
                      for (b = at + 7; B < b; ) {
                        if ($ === 0)
                          break t;
                        $--, z += L[W++] << B, B += 8;
                      }
                      B -= at, s = 0, G = 11 + (127 & (z >>>= at)), z >>>= 7, B -= 7;
                    }
                    if (c.have + G > c.nlen + c.ndist) {
                      S.msg = "invalid bit length repeat", c.mode = 30;
                      break;
                    }
                    for (; G--; )
                      c.lens[c.have++] = s;
                  }
                }
                if (c.mode === 30)
                  break;
                if (c.lens[256] === 0) {
                  S.msg = "invalid code -- missing end-of-block", c.mode = 30;
                  break;
                }
                if (c.lenbits = 9, M = { bits: c.lenbits }, I = g(_, c.lens, 0, c.nlen, c.lencode, 0, c.work, M), c.lenbits = M.bits, I) {
                  S.msg = "invalid literal/lengths set", c.mode = 30;
                  break;
                }
                if (c.distbits = 6, c.distcode = c.distdyn, M = { bits: c.distbits }, I = g(k, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, M), c.distbits = M.bits, I) {
                  S.msg = "invalid distances set", c.mode = 30;
                  break;
                }
                if (c.mode = 20, F === 6)
                  break t;
              case 20:
                c.mode = 21;
              case 21:
                if (6 <= $ && 258 <= tt) {
                  S.next_out = rt, S.avail_out = tt, S.next_in = W, S.avail_in = $, c.hold = z, c.bits = B, u(S, q), rt = S.next_out, et = S.output, tt = S.avail_out, W = S.next_in, L = S.input, $ = S.avail_in, z = c.hold, B = c.bits, c.mode === 12 && (c.back = -1);
                  break;
                }
                for (c.back = 0; it = (p = c.lencode[z & (1 << c.lenbits) - 1]) >>> 16 & 255, gt = 65535 & p, !((at = p >>> 24) <= B); ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if (it && !(240 & it)) {
                  for (dt = at, St = it, _t = gt; it = (p = c.lencode[_t + ((z & (1 << dt + St) - 1) >> dt)]) >>> 16 & 255, gt = 65535 & p, !(dt + (at = p >>> 24) <= B); ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  z >>>= dt, B -= dt, c.back += dt;
                }
                if (z >>>= at, B -= at, c.back += at, c.length = gt, it === 0) {
                  c.mode = 26;
                  break;
                }
                if (32 & it) {
                  c.back = -1, c.mode = 12;
                  break;
                }
                if (64 & it) {
                  S.msg = "invalid literal/length code", c.mode = 30;
                  break;
                }
                c.extra = 15 & it, c.mode = 22;
              case 22:
                if (c.extra) {
                  for (b = c.extra; B < b; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  c.length += z & (1 << c.extra) - 1, z >>>= c.extra, B -= c.extra, c.back += c.extra;
                }
                c.was = c.length, c.mode = 23;
              case 23:
                for (; it = (p = c.distcode[z & (1 << c.distbits) - 1]) >>> 16 & 255, gt = 65535 & p, !((at = p >>> 24) <= B); ) {
                  if ($ === 0)
                    break t;
                  $--, z += L[W++] << B, B += 8;
                }
                if (!(240 & it)) {
                  for (dt = at, St = it, _t = gt; it = (p = c.distcode[_t + ((z & (1 << dt + St) - 1) >> dt)]) >>> 16 & 255, gt = 65535 & p, !(dt + (at = p >>> 24) <= B); ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  z >>>= dt, B -= dt, c.back += dt;
                }
                if (z >>>= at, B -= at, c.back += at, 64 & it) {
                  S.msg = "invalid distance code", c.mode = 30;
                  break;
                }
                c.offset = gt, c.extra = 15 & it, c.mode = 24;
              case 24:
                if (c.extra) {
                  for (b = c.extra; B < b; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  c.offset += z & (1 << c.extra) - 1, z >>>= c.extra, B -= c.extra, c.back += c.extra;
                }
                if (c.offset > c.dmax) {
                  S.msg = "invalid distance too far back", c.mode = 30;
                  break;
                }
                c.mode = 25;
              case 25:
                if (tt === 0)
                  break t;
                if (G = q - tt, c.offset > G) {
                  if ((G = c.offset - G) > c.whave && c.sane) {
                    S.msg = "invalid distance too far back", c.mode = 30;
                    break;
                  }
                  ht = G > c.wnext ? (G -= c.wnext, c.wsize - G) : c.wnext - G, G > c.length && (G = c.length), bt = c.window;
                } else
                  bt = et, ht = rt - c.offset, G = c.length;
                for (tt < G && (G = tt), tt -= G, c.length -= G; et[rt++] = bt[ht++], --G; )
                  ;
                c.length === 0 && (c.mode = 21);
                break;
              case 26:
                if (tt === 0)
                  break t;
                et[rt++] = c.length, tt--, c.mode = 21;
                break;
              case 27:
                if (c.wrap) {
                  for (; B < 32; ) {
                    if ($ === 0)
                      break t;
                    $--, z |= L[W++] << B, B += 8;
                  }
                  if (q -= tt, S.total_out += q, c.total += q, q && (S.adler = c.check = c.flags ? l(c.check, et, q, rt - q) : o(c.check, et, q, rt - q)), q = tt, (c.flags ? z : f(z)) !== c.check) {
                    S.msg = "incorrect data check", c.mode = 30;
                    break;
                  }
                  B = z = 0;
                }
                c.mode = 28;
              case 28:
                if (c.wrap && c.flags) {
                  for (; B < 32; ) {
                    if ($ === 0)
                      break t;
                    $--, z += L[W++] << B, B += 8;
                  }
                  if (z !== (4294967295 & c.total)) {
                    S.msg = "incorrect length check", c.mode = 30;
                    break;
                  }
                  B = z = 0;
                }
                c.mode = 29;
              case 29:
                I = 1;
                break t;
              case 30:
                I = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return d;
            }
        return S.next_out = rt, S.avail_out = tt, S.next_in = W, S.avail_in = $, c.hold = z, c.bits = B, (c.wsize || q !== S.avail_out && c.mode < 30 && (c.mode < 27 || F !== 4)) && Q(S, S.output, S.next_out, q - S.avail_out) ? (c.mode = 31, -4) : (J -= S.avail_in, q -= S.avail_out, S.total_in += J, S.total_out += q, c.total += q, c.wrap && q && (S.adler = c.check = c.flags ? l(c.check, et, q, S.next_out - q) : o(c.check, et, q, S.next_out - q)), S.data_type = c.bits + (c.last ? 64 : 0) + (c.mode === 12 ? 128 : 0) + (c.mode === 20 || c.mode === 15 ? 256 : 0), (J == 0 && q === 0 || F === 4) && I === w && (I = -5), I);
      }, a.inflateEnd = function(S) {
        if (!S || !S.state)
          return d;
        var F = S.state;
        return F.window && (F.window = null), S.state = null, w;
      }, a.inflateGetHeader = function(S, F) {
        var c;
        return S && S.state && 2 & (c = S.state).wrap ? ((c.head = F).done = !1, w) : d;
      }, a.inflateSetDictionary = function(S, F) {
        var c, L = F.length;
        return S && S.state ? (c = S.state).wrap !== 0 && c.mode !== 11 ? d : c.mode === 11 && o(1, F, L, 0) !== c.check ? -3 : Q(S, F, L, L) ? (c.mode = 31, -4) : (c.havedict = 1, w) : d;
      }, a.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, r, a) {
      var n = t("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], g = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(_, k, w, d, y, h, m, f) {
        var v, x, A, P, D, O, H, T, X, Q = f.bits, S = 0, F = 0, c = 0, L = 0, et = 0, W = 0, rt = 0, $ = 0, tt = 0, z = 0, B = null, J = 0, q = new n.Buf16(16), G = new n.Buf16(16), ht = null, bt = 0;
        for (S = 0; S <= 15; S++)
          q[S] = 0;
        for (F = 0; F < d; F++)
          q[k[w + F]]++;
        for (et = Q, L = 15; 1 <= L && q[L] === 0; L--)
          ;
        if (L < et && (et = L), L === 0)
          return y[h++] = 20971520, y[h++] = 20971520, f.bits = 1, 0;
        for (c = 1; c < L && q[c] === 0; c++)
          ;
        for (et < c && (et = c), S = $ = 1; S <= 15; S++)
          if ($ <<= 1, ($ -= q[S]) < 0)
            return -1;
        if (0 < $ && (_ === 0 || L !== 1))
          return -1;
        for (G[1] = 0, S = 1; S < 15; S++)
          G[S + 1] = G[S] + q[S];
        for (F = 0; F < d; F++)
          k[w + F] !== 0 && (m[G[k[w + F]]++] = F);
        if (O = _ === 0 ? (B = ht = m, 19) : _ === 1 ? (B = o, J -= 257, ht = l, bt -= 257, 256) : (B = u, ht = g, -1), S = c, D = h, rt = F = z = 0, A = -1, P = (tt = 1 << (W = et)) - 1, _ === 1 && 852 < tt || _ === 2 && 592 < tt)
          return 1;
        for (; ; ) {
          for (H = S - rt, X = m[F] < O ? (T = 0, m[F]) : m[F] > O ? (T = ht[bt + m[F]], B[J + m[F]]) : (T = 96, 0), v = 1 << S - rt, c = x = 1 << W; y[D + (z >> rt) + (x -= v)] = H << 24 | T << 16 | X | 0, x !== 0; )
            ;
          for (v = 1 << S - 1; z & v; )
            v >>= 1;
          if (v !== 0 ? (z &= v - 1, z += v) : z = 0, F++, --q[S] == 0) {
            if (S === L)
              break;
            S = k[w + m[F]];
          }
          if (et < S && (z & P) !== A) {
            for (rt === 0 && (rt = et), D += c, $ = 1 << (W = S - rt); W + rt < L && !(($ -= q[W + rt]) <= 0); )
              W++, $ <<= 1;
            if (tt += 1 << W, _ === 1 && 852 < tt || _ === 2 && 592 < tt)
              return 1;
            y[A = z & P] = et << 24 | W << 16 | D - h | 0;
          }
        }
        return z !== 0 && (y[D + z] = S - rt << 24 | 64 << 16 | 0), f.bits = et, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, r, a) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, r, a) {
      var n = t("../utils/common"), o = 0, l = 1;
      function u(p) {
        for (var C = p.length; 0 <= --C; )
          p[C] = 0;
      }
      var g = 0, _ = 29, k = 256, w = k + 1 + _, d = 30, y = 19, h = 2 * w + 1, m = 15, f = 16, v = 7, x = 256, A = 16, P = 17, D = 18, O = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], H = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Q = new Array(2 * (w + 2));
      u(Q);
      var S = new Array(2 * d);
      u(S);
      var F = new Array(512);
      u(F);
      var c = new Array(256);
      u(c);
      var L = new Array(_);
      u(L);
      var et, W, rt, $ = new Array(d);
      function tt(p, C, j, U, N) {
        this.static_tree = p, this.extra_bits = C, this.extra_base = j, this.elems = U, this.max_length = N, this.has_stree = p && p.length;
      }
      function z(p, C) {
        this.dyn_tree = p, this.max_code = 0, this.stat_desc = C;
      }
      function B(p) {
        return p < 256 ? F[p] : F[256 + (p >>> 7)];
      }
      function J(p, C) {
        p.pending_buf[p.pending++] = 255 & C, p.pending_buf[p.pending++] = C >>> 8 & 255;
      }
      function q(p, C, j) {
        p.bi_valid > f - j ? (p.bi_buf |= C << p.bi_valid & 65535, J(p, p.bi_buf), p.bi_buf = C >> f - p.bi_valid, p.bi_valid += j - f) : (p.bi_buf |= C << p.bi_valid & 65535, p.bi_valid += j);
      }
      function G(p, C, j) {
        q(p, j[2 * C], j[2 * C + 1]);
      }
      function ht(p, C) {
        for (var j = 0; j |= 1 & p, p >>>= 1, j <<= 1, 0 < --C; )
          ;
        return j >>> 1;
      }
      function bt(p, C, j) {
        var U, N, Z = new Array(m + 1), K = 0;
        for (U = 1; U <= m; U++)
          Z[U] = K = K + j[U - 1] << 1;
        for (N = 0; N <= C; N++) {
          var V = p[2 * N + 1];
          V !== 0 && (p[2 * N] = ht(Z[V]++, V));
        }
      }
      function at(p) {
        var C;
        for (C = 0; C < w; C++)
          p.dyn_ltree[2 * C] = 0;
        for (C = 0; C < d; C++)
          p.dyn_dtree[2 * C] = 0;
        for (C = 0; C < y; C++)
          p.bl_tree[2 * C] = 0;
        p.dyn_ltree[2 * x] = 1, p.opt_len = p.static_len = 0, p.last_lit = p.matches = 0;
      }
      function it(p) {
        8 < p.bi_valid ? J(p, p.bi_buf) : 0 < p.bi_valid && (p.pending_buf[p.pending++] = p.bi_buf), p.bi_buf = 0, p.bi_valid = 0;
      }
      function gt(p, C, j, U) {
        var N = 2 * C, Z = 2 * j;
        return p[N] < p[Z] || p[N] === p[Z] && U[C] <= U[j];
      }
      function dt(p, C, j) {
        for (var U = p.heap[j], N = j << 1; N <= p.heap_len && (N < p.heap_len && gt(C, p.heap[N + 1], p.heap[N], p.depth) && N++, !gt(C, U, p.heap[N], p.depth)); )
          p.heap[j] = p.heap[N], j = N, N <<= 1;
        p.heap[j] = U;
      }
      function St(p, C, j) {
        var U, N, Z, K, V = 0;
        if (p.last_lit !== 0)
          for (; U = p.pending_buf[p.d_buf + 2 * V] << 8 | p.pending_buf[p.d_buf + 2 * V + 1], N = p.pending_buf[p.l_buf + V], V++, U === 0 ? G(p, N, C) : (G(p, (Z = c[N]) + k + 1, C), (K = O[Z]) !== 0 && q(p, N -= L[Z], K), G(p, Z = B(--U), j), (K = H[Z]) !== 0 && q(p, U -= $[Z], K)), V < p.last_lit; )
            ;
        G(p, x, C);
      }
      function _t(p, C) {
        var j, U, N, Z = C.dyn_tree, K = C.stat_desc.static_tree, V = C.stat_desc.has_stree, Y = C.stat_desc.elems, ot = -1;
        for (p.heap_len = 0, p.heap_max = h, j = 0; j < Y; j++)
          Z[2 * j] !== 0 ? (p.heap[++p.heap_len] = ot = j, p.depth[j] = 0) : Z[2 * j + 1] = 0;
        for (; p.heap_len < 2; )
          Z[2 * (N = p.heap[++p.heap_len] = ot < 2 ? ++ot : 0)] = 1, p.depth[N] = 0, p.opt_len--, V && (p.static_len -= K[2 * N + 1]);
        for (C.max_code = ot, j = p.heap_len >> 1; 1 <= j; j--)
          dt(p, Z, j);
        for (N = Y; j = p.heap[1], p.heap[1] = p.heap[p.heap_len--], dt(p, Z, 1), U = p.heap[1], p.heap[--p.heap_max] = j, p.heap[--p.heap_max] = U, Z[2 * N] = Z[2 * j] + Z[2 * U], p.depth[N] = (p.depth[j] >= p.depth[U] ? p.depth[j] : p.depth[U]) + 1, Z[2 * j + 1] = Z[2 * U + 1] = N, p.heap[1] = N++, dt(p, Z, 1), 2 <= p.heap_len; )
          ;
        p.heap[--p.heap_max] = p.heap[1], function(st, kt) {
          var Nt, xt, Bt, ft, Ft, $t, Ct = kt.dyn_tree, te = kt.max_code, Ee = kt.stat_desc.static_tree, Ne = kt.stat_desc.has_stree, Be = kt.stat_desc.extra_bits, ee = kt.stat_desc.extra_base, zt = kt.stat_desc.max_length, It = 0;
          for (ft = 0; ft <= m; ft++)
            st.bl_count[ft] = 0;
          for (Ct[2 * st.heap[st.heap_max] + 1] = 0, Nt = st.heap_max + 1; Nt < h; Nt++)
            zt < (ft = Ct[2 * Ct[2 * (xt = st.heap[Nt]) + 1] + 1] + 1) && (ft = zt, It++), Ct[2 * xt + 1] = ft, te < xt || (st.bl_count[ft]++, Ft = 0, ee <= xt && (Ft = Be[xt - ee]), $t = Ct[2 * xt], st.opt_len += $t * (ft + Ft), Ne && (st.static_len += $t * (Ee[2 * xt + 1] + Ft)));
          if (It !== 0) {
            do {
              for (ft = zt - 1; st.bl_count[ft] === 0; )
                ft--;
              st.bl_count[ft]--, st.bl_count[ft + 1] += 2, st.bl_count[zt]--, It -= 2;
            } while (0 < It);
            for (ft = zt; ft !== 0; ft--)
              for (xt = st.bl_count[ft]; xt !== 0; )
                te < (Bt = st.heap[--Nt]) || (Ct[2 * Bt + 1] !== ft && (st.opt_len += (ft - Ct[2 * Bt + 1]) * Ct[2 * Bt], Ct[2 * Bt + 1] = ft), xt--);
          }
        }(p, C), bt(Z, ot, p.bl_count);
      }
      function s(p, C, j) {
        var U, N, Z = -1, K = C[1], V = 0, Y = 7, ot = 4;
        for (K === 0 && (Y = 138, ot = 3), C[2 * (j + 1) + 1] = 65535, U = 0; U <= j; U++)
          N = K, K = C[2 * (U + 1) + 1], ++V < Y && N === K || (V < ot ? p.bl_tree[2 * N] += V : N !== 0 ? (N !== Z && p.bl_tree[2 * N]++, p.bl_tree[2 * A]++) : V <= 10 ? p.bl_tree[2 * P]++ : p.bl_tree[2 * D]++, Z = N, ot = (V = 0) === K ? (Y = 138, 3) : N === K ? (Y = 6, 3) : (Y = 7, 4));
      }
      function I(p, C, j) {
        var U, N, Z = -1, K = C[1], V = 0, Y = 7, ot = 4;
        for (K === 0 && (Y = 138, ot = 3), U = 0; U <= j; U++)
          if (N = K, K = C[2 * (U + 1) + 1], !(++V < Y && N === K)) {
            if (V < ot)
              for (; G(p, N, p.bl_tree), --V != 0; )
                ;
            else
              N !== 0 ? (N !== Z && (G(p, N, p.bl_tree), V--), G(p, A, p.bl_tree), q(p, V - 3, 2)) : V <= 10 ? (G(p, P, p.bl_tree), q(p, V - 3, 3)) : (G(p, D, p.bl_tree), q(p, V - 11, 7));
            Z = N, ot = (V = 0) === K ? (Y = 138, 3) : N === K ? (Y = 6, 3) : (Y = 7, 4);
          }
      }
      u($);
      var M = !1;
      function b(p, C, j, U) {
        q(p, (g << 1) + (U ? 1 : 0), 3), function(N, Z, K, V) {
          it(N), V && (J(N, K), J(N, ~K)), n.arraySet(N.pending_buf, N.window, Z, K, N.pending), N.pending += K;
        }(p, C, j, !0);
      }
      a._tr_init = function(p) {
        M || (function() {
          var C, j, U, N, Z, K = new Array(m + 1);
          for (N = U = 0; N < _ - 1; N++)
            for (L[N] = U, C = 0; C < 1 << O[N]; C++)
              c[U++] = N;
          for (c[U - 1] = N, N = Z = 0; N < 16; N++)
            for ($[N] = Z, C = 0; C < 1 << H[N]; C++)
              F[Z++] = N;
          for (Z >>= 7; N < d; N++)
            for ($[N] = Z << 7, C = 0; C < 1 << H[N] - 7; C++)
              F[256 + Z++] = N;
          for (j = 0; j <= m; j++)
            K[j] = 0;
          for (C = 0; C <= 143; )
            Q[2 * C + 1] = 8, C++, K[8]++;
          for (; C <= 255; )
            Q[2 * C + 1] = 9, C++, K[9]++;
          for (; C <= 279; )
            Q[2 * C + 1] = 7, C++, K[7]++;
          for (; C <= 287; )
            Q[2 * C + 1] = 8, C++, K[8]++;
          for (bt(Q, w + 1, K), C = 0; C < d; C++)
            S[2 * C + 1] = 5, S[2 * C] = ht(C, 5);
          et = new tt(Q, O, k + 1, w, m), W = new tt(S, H, 0, d, m), rt = new tt(new Array(0), T, 0, y, v);
        }(), M = !0), p.l_desc = new z(p.dyn_ltree, et), p.d_desc = new z(p.dyn_dtree, W), p.bl_desc = new z(p.bl_tree, rt), p.bi_buf = 0, p.bi_valid = 0, at(p);
      }, a._tr_stored_block = b, a._tr_flush_block = function(p, C, j, U) {
        var N, Z, K = 0;
        0 < p.level ? (p.strm.data_type === 2 && (p.strm.data_type = function(V) {
          var Y, ot = 4093624447;
          for (Y = 0; Y <= 31; Y++, ot >>>= 1)
            if (1 & ot && V.dyn_ltree[2 * Y] !== 0)
              return o;
          if (V.dyn_ltree[18] !== 0 || V.dyn_ltree[20] !== 0 || V.dyn_ltree[26] !== 0)
            return l;
          for (Y = 32; Y < k; Y++)
            if (V.dyn_ltree[2 * Y] !== 0)
              return l;
          return o;
        }(p)), _t(p, p.l_desc), _t(p, p.d_desc), K = function(V) {
          var Y;
          for (s(V, V.dyn_ltree, V.l_desc.max_code), s(V, V.dyn_dtree, V.d_desc.max_code), _t(V, V.bl_desc), Y = y - 1; 3 <= Y && V.bl_tree[2 * X[Y] + 1] === 0; Y--)
            ;
          return V.opt_len += 3 * (Y + 1) + 5 + 5 + 4, Y;
        }(p), N = p.opt_len + 3 + 7 >>> 3, (Z = p.static_len + 3 + 7 >>> 3) <= N && (N = Z)) : N = Z = j + 5, j + 4 <= N && C !== -1 ? b(p, C, j, U) : p.strategy === 4 || Z === N ? (q(p, 2 + (U ? 1 : 0), 3), St(p, Q, S)) : (q(p, 4 + (U ? 1 : 0), 3), function(V, Y, ot, st) {
          var kt;
          for (q(V, Y - 257, 5), q(V, ot - 1, 5), q(V, st - 4, 4), kt = 0; kt < st; kt++)
            q(V, V.bl_tree[2 * X[kt] + 1], 3);
          I(V, V.dyn_ltree, Y - 1), I(V, V.dyn_dtree, ot - 1);
        }(p, p.l_desc.max_code + 1, p.d_desc.max_code + 1, K + 1), St(p, p.dyn_ltree, p.dyn_dtree)), at(p), U && it(p);
      }, a._tr_tally = function(p, C, j) {
        return p.pending_buf[p.d_buf + 2 * p.last_lit] = C >>> 8 & 255, p.pending_buf[p.d_buf + 2 * p.last_lit + 1] = 255 & C, p.pending_buf[p.l_buf + p.last_lit] = 255 & j, p.last_lit++, C === 0 ? p.dyn_ltree[2 * j]++ : (p.matches++, C--, p.dyn_ltree[2 * (c[j] + k + 1)]++, p.dyn_dtree[2 * B(C)]++), p.last_lit === p.lit_bufsize - 1;
      }, a._tr_align = function(p) {
        q(p, 2, 3), G(p, x, Q), function(C) {
          C.bi_valid === 16 ? (J(C, C.bi_buf), C.bi_buf = 0, C.bi_valid = 0) : 8 <= C.bi_valid && (C.pending_buf[C.pending++] = 255 & C.bi_buf, C.bi_buf >>= 8, C.bi_valid -= 8);
        }(p);
      };
    }, { "../utils/common": 41 }], 53: [function(t, r, a) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, r, a) {
      (function(n) {
        (function(o, l) {
          if (!o.setImmediate) {
            var u, g, _, k, w = 1, d = {}, y = !1, h = o.document, m = Object.getPrototypeOf && Object.getPrototypeOf(o);
            m = m && m.setTimeout ? m : o, u = {}.toString.call(o.process) === "[object process]" ? function(A) {
              process.nextTick(function() {
                v(A);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var A = !0, P = o.onmessage;
                return o.onmessage = function() {
                  A = !1;
                }, o.postMessage("", "*"), o.onmessage = P, A;
              }
            }() ? (k = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", x, !1) : o.attachEvent("onmessage", x), function(A) {
              o.postMessage(k + A, "*");
            }) : o.MessageChannel ? ((_ = new MessageChannel()).port1.onmessage = function(A) {
              v(A.data);
            }, function(A) {
              _.port2.postMessage(A);
            }) : h && "onreadystatechange" in h.createElement("script") ? (g = h.documentElement, function(A) {
              var P = h.createElement("script");
              P.onreadystatechange = function() {
                v(A), P.onreadystatechange = null, g.removeChild(P), P = null;
              }, g.appendChild(P);
            }) : function(A) {
              setTimeout(v, 0, A);
            }, m.setImmediate = function(A) {
              typeof A != "function" && (A = new Function("" + A));
              for (var P = new Array(arguments.length - 1), D = 0; D < P.length; D++)
                P[D] = arguments[D + 1];
              var O = { callback: A, args: P };
              return d[w] = O, u(w), w++;
            }, m.clearImmediate = f;
          }
          function f(A) {
            delete d[A];
          }
          function v(A) {
            if (y)
              setTimeout(v, 0, A);
            else {
              var P = d[A];
              if (P) {
                y = !0;
                try {
                  (function(D) {
                    var O = D.callback, H = D.args;
                    switch (H.length) {
                      case 0:
                        O();
                        break;
                      case 1:
                        O(H[0]);
                        break;
                      case 2:
                        O(H[0], H[1]);
                        break;
                      case 3:
                        O(H[0], H[1], H[2]);
                        break;
                      default:
                        O.apply(l, H);
                    }
                  })(P);
                } finally {
                  f(A), y = !1;
                }
              }
            }
          }
          function x(A) {
            A.source === o && typeof A.data == "string" && A.data.indexOf(k) === 0 && v(+A.data.slice(k.length));
          }
        })(typeof self == "undefined" ? n === void 0 ? this : n : self);
      }).call(this, typeof Dt != "undefined" ? Dt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(pe);
var $e = pe.exports;
const Ze = /* @__PURE__ */ He($e);
var mt;
(function(i) {
  i.OfficeDocument = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", i.FontTable = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable", i.Image = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", i.Numbering = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering", i.Styles = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", i.StylesWithEffects = "http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects", i.Theme = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", i.Settings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings", i.WebSettings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings", i.Hyperlink = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", i.Footnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes", i.Endnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes", i.Footer = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", i.Header = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", i.ExtendedProperties = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", i.CoreProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", i.CustomProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/custom-properties";
})(mt || (mt = {}));
function Ve(i, e) {
  return e.elements(i).map((t) => ({
    id: e.attr(t, "Id"),
    type: e.attr(t, "Type"),
    target: e.attr(t, "Target"),
    targetMode: e.attr(t, "TargetMode")
  }));
}
const me = {
  wordml: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  drawingml: "http://schemas.openxmlformats.org/drawingml/2006/main",
  picture: "http://schemas.openxmlformats.org/drawingml/2006/picture",
  compatibility: "http://schemas.openxmlformats.org/markup-compatibility/2006",
  math: "http://schemas.openxmlformats.org/officeDocument/2006/math"
}, pt = {
  Dxa: { mul: 0.05, unit: "pt" },
  Emu: { mul: 1 / 12700, unit: "pt" },
  FontSize: { mul: 0.5, unit: "pt" },
  Border: { mul: 0.125, unit: "pt" },
  Point: { mul: 1, unit: "pt" },
  Percent: { mul: 0.02, unit: "%" },
  LineHeight: { mul: 1 / 240, unit: "" },
  VmlEmu: { mul: 1 / 12700, unit: "" }
};
function ge(i, e = pt.Dxa) {
  return i == null || /.+(p[xt]|[%])$/.test(i) ? i : `${(parseInt(i) * e.mul).toFixed(2)}${e.unit}`;
}
function Xe(i, e = !1) {
  switch (i) {
    case "1":
      return !0;
    case "0":
      return !1;
    case "on":
      return !0;
    case "off":
      return !1;
    case "true":
      return !0;
    case "false":
      return !1;
    default:
      return e;
  }
}
function be(i, e, t) {
  if (i.namespaceURI != me.wordml)
    return !1;
  switch (i.localName) {
    case "color":
      e.color = t.attr(i, "val");
      break;
    case "sz":
      e.fontSize = t.lengthAttr(i, "val", pt.FontSize);
      break;
    default:
      return !1;
  }
  return !0;
}
function Ge(i, e = !1) {
  e && (i = i.replace(/<[?].*[?]>/, "")), i = Ke(i);
  const t = new DOMParser().parseFromString(i, "application/xml"), r = qe(t);
  if (r)
    throw new Error(r);
  return t;
}
function qe(i) {
  var e;
  return (e = i.getElementsByTagName("parsererror")[0]) == null ? void 0 : e.textContent;
}
function Ke(i) {
  return i.charCodeAt(0) === 65279 ? i.substring(1) : i;
}
function Ye(i) {
  return new XMLSerializer().serializeToString(i);
}
class ve {
  elements(e, t = null) {
    const r = [];
    for (let a = 0, n = e.childNodes.length; a < n; a++) {
      let o = e.childNodes.item(a);
      o.nodeType == 1 && (t == null || o.localName == t) && r.push(o);
    }
    return r;
  }
  element(e, t) {
    for (let r = 0, a = e.childNodes.length; r < a; r++) {
      let n = e.childNodes.item(r);
      if (n.nodeType == 1 && n.localName == t)
        return n;
    }
    return null;
  }
  elementAttr(e, t, r) {
    var a = this.element(e, t);
    return a ? this.attr(a, r) : void 0;
  }
  attrs(e) {
    return Array.from(e.attributes);
  }
  attr(e, t) {
    for (let r = 0, a = e.attributes.length; r < a; r++) {
      let n = e.attributes.item(r);
      if (n.localName == t)
        return n.value;
    }
    return null;
  }
  intAttr(e, t, r = null) {
    var a = this.attr(e, t);
    return a ? parseInt(a) : r;
  }
  hexAttr(e, t, r = null) {
    var a = this.attr(e, t);
    return a ? parseInt(a, 16) : r;
  }
  floatAttr(e, t, r = null) {
    var a = this.attr(e, t);
    return a ? parseFloat(a) : r;
  }
  boolAttr(e, t, r = null) {
    return Xe(this.attr(e, t), r);
  }
  lengthAttr(e, t, r = pt.Dxa) {
    return ge(this.attr(e, t), r);
  }
}
const E = new ve();
class wt {
  constructor(e, t) {
    this._package = e, this.path = t;
  }
  load() {
    return yt(this, null, function* () {
      this.rels = yield this._package.loadRelationships(this.path);
      const e = yield this._package.load(this.path), t = this._package.parseXmlDocument(e);
      this._package.options.keepOrigin && (this._xmlDocument = t), this.parseXml(t.firstElementChild);
    });
  }
  save() {
    this._package.update(this.path, Ye(this._xmlDocument));
  }
  parseXml(e) {
  }
}
const Je = {
  embedRegular: "regular",
  embedBold: "bold",
  embedItalic: "italic",
  embedBoldItalic: "boldItalic"
};
function Qe(i, e) {
  return e.elements(i).map((t) => tr(t, e));
}
function tr(i, e) {
  let t = {
    name: e.attr(i, "name"),
    embedFontRefs: []
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "family":
        t.family = e.attr(r, "val");
        break;
      case "altName":
        t.altName = e.attr(r, "val");
        break;
      case "embedRegular":
      case "embedBold":
      case "embedItalic":
      case "embedBoldItalic":
        t.embedFontRefs.push(er(r, e));
        break;
    }
  return t;
}
function er(i, e) {
  return {
    id: e.attr(i, "id"),
    key: e.attr(i, "fontKey"),
    type: Je[i.localName]
  };
}
class rr extends wt {
  parseXml(e) {
    this.fonts = Qe(e, this._package.xmlParser);
  }
}
function nr(i) {
  return i == null ? void 0 : i.replace(/[ .]+/g, "-").replace(/[&]+/g, "and").toLowerCase();
}
function Ut(i) {
  let e = i.lastIndexOf("/") + 1, t = e == 0 ? "" : i.substring(0, e), r = e == 0 ? i : i.substring(e);
  return [t, r];
}
function Zt(i, e) {
  try {
    const t = "http://docx/";
    return new URL(i, t + e).toString().substring(t.length);
  } catch (t) {
    return `${e}${i}`;
  }
}
function Pt(i, e) {
  return i.reduce((t, r) => (t[e(r)] = r, t), {});
}
function ar(i) {
  return new Promise((e, t) => {
    const r = new FileReader();
    r.onloadend = () => e(r.result), r.onerror = () => t(), r.readAsDataURL(i);
  });
}
function Vt(i) {
  return i && typeof i == "object" && !Array.isArray(i);
}
function sr(i) {
  return typeof i == "string" || i instanceof String;
}
function Ht(i, ...e) {
  var r;
  if (!e.length)
    return i;
  const t = e.shift();
  if (Vt(i) && Vt(t))
    for (const a in t)
      if (Vt(t[a])) {
        const n = (r = i[a]) != null ? r : i[a] = {};
        Ht(n, t[a]);
      } else
        i[a] = t[a];
  return Ht(i, ...e);
}
function Rt(i) {
  return Array.isArray(i) ? i : [i];
}
class Kt {
  constructor(e, t) {
    this._zip = e, this.options = t, this.xmlParser = new ve();
  }
  get(e) {
    return this._zip.files[ir(e)];
  }
  update(e, t) {
    this._zip.file(e, t);
  }
  static load(e, t) {
    return yt(this, null, function* () {
      const r = yield Ze.loadAsync(e);
      return new Kt(r, t);
    });
  }
  save(e = "blob") {
    return this._zip.generateAsync({ type: e });
  }
  load(e, t = "string") {
    var r, a;
    return (a = (r = this.get(e)) == null ? void 0 : r.async(t)) != null ? a : Promise.resolve(null);
  }
  loadRelationships(e = null) {
    return yt(this, null, function* () {
      let t = "_rels/.rels";
      if (e != null) {
        const [a, n] = Ut(e);
        t = `${a}_rels/${n}.rels`;
      }
      const r = yield this.load(t);
      return r ? Ve(this.parseXmlDocument(r).firstElementChild, this.xmlParser) : null;
    });
  }
  parseXmlDocument(e) {
    return Ge(e, this.options.trimXmlDeclaration);
  }
}
function ir(i) {
  return i.startsWith("/") ? i.substr(1) : i;
}
class or extends wt {
  constructor(e, t, r) {
    super(e, t), this._documentParser = r;
  }
  parseXml(e) {
    this.body = this._documentParser.parseDocumentFile(e);
  }
}
function jt(i, e) {
  return {
    type: e.attr(i, "val"),
    color: e.attr(i, "color"),
    size: e.lengthAttr(i, "sz", pt.Border),
    offset: e.lengthAttr(i, "space", pt.Point),
    frame: e.boolAttr(i, "frame"),
    shadow: e.boolAttr(i, "shadow")
  };
}
function lr(i, e) {
  var t = {};
  for (let r of e.elements(i))
    switch (r.localName) {
      case "left":
        t.left = jt(r, e);
        break;
      case "top":
        t.top = jt(r, e);
        break;
      case "right":
        t.right = jt(r, e);
        break;
      case "bottom":
        t.bottom = jt(r, e);
        break;
    }
  return t;
}
var ae;
(function(i) {
  i.Continuous = "continuous", i.NextPage = "nextPage", i.NextColumn = "nextColumn", i.EvenPage = "evenPage", i.OddPage = "oddPage";
})(ae || (ae = {}));
function ye(i, e = E) {
  var r, a;
  var t = {};
  for (let n of e.elements(i))
    switch (n.localName) {
      case "pgSz":
        t.pageSize = {
          width: e.lengthAttr(n, "w"),
          height: e.lengthAttr(n, "h"),
          orientation: e.attr(n, "orient")
        };
        break;
      case "type":
        t.type = e.attr(n, "val");
        break;
      case "pgMar":
        t.pageMargins = {
          left: e.lengthAttr(n, "left"),
          right: e.lengthAttr(n, "right"),
          top: e.lengthAttr(n, "top"),
          bottom: e.lengthAttr(n, "bottom"),
          header: e.lengthAttr(n, "header"),
          footer: e.lengthAttr(n, "footer"),
          gutter: e.lengthAttr(n, "gutter")
        };
        break;
      case "cols":
        t.columns = cr(n, e);
        break;
      case "headerReference":
        ((r = t.headerRefs) != null ? r : t.headerRefs = []).push(se(n, e));
        break;
      case "footerReference":
        ((a = t.footerRefs) != null ? a : t.footerRefs = []).push(se(n, e));
        break;
      case "titlePg":
        t.titlePage = e.boolAttr(n, "val", !0);
        break;
      case "pgBorders":
        t.pageBorders = lr(n, e);
        break;
      case "pgNumType":
        t.pageNumber = ur(n, e);
        break;
    }
  return t;
}
function cr(i, e) {
  return {
    numberOfColumns: e.intAttr(i, "num"),
    space: e.lengthAttr(i, "space"),
    separator: e.boolAttr(i, "sep"),
    equalWidth: e.boolAttr(i, "equalWidth", !0),
    columns: e.elements(i, "col").map((t) => ({
      width: e.lengthAttr(t, "w"),
      space: e.lengthAttr(t, "space")
    }))
  };
}
function ur(i, e) {
  return {
    chapSep: e.attr(i, "chapSep"),
    chapStyle: e.attr(i, "chapStyle"),
    format: e.attr(i, "fmt"),
    start: e.intAttr(i, "start")
  };
}
function se(i, e) {
  return {
    id: e.attr(i, "id"),
    type: e.attr(i, "type")
  };
}
function hr(i, e) {
  return {
    before: e.lengthAttr(i, "before"),
    after: e.lengthAttr(i, "after"),
    line: e.intAttr(i, "line"),
    lineRule: e.attr(i, "lineRule")
  };
}
function Yt(i, e) {
  let t = {};
  for (let r of e.elements(i))
    dr(r, t, e);
  return t;
}
function dr(i, e, t) {
  return !!be(i, e, t);
}
function ke(i, e) {
  let t = {};
  for (let r of e.elements(i))
    _e(r, t, e);
  return t;
}
function _e(i, e, t) {
  if (i.namespaceURI != me.wordml)
    return !1;
  if (be(i, e, t))
    return !0;
  switch (i.localName) {
    case "tabs":
      e.tabs = fr(i, t);
      break;
    case "sectPr":
      e.sectionProps = ye(i, t);
      break;
    case "numPr":
      e.numbering = pr(i, t);
      break;
    case "spacing":
      return e.lineSpacing = hr(i, t), !1;
    case "textAlignment":
      return e.textAlignment = t.attr(i, "val"), !1;
    case "keepLines":
      e.keepLines = t.boolAttr(i, "val", !0);
      break;
    case "keepNext":
      e.keepNext = t.boolAttr(i, "val", !0);
      break;
    case "pageBreakBefore":
      e.pageBreakBefore = t.boolAttr(i, "val", !0);
      break;
    case "outlineLvl":
      e.outlineLevel = t.intAttr(i, "val");
      break;
    case "pStyle":
      e.styleName = t.attr(i, "val");
      break;
    case "rPr":
      e.runProps = Yt(i, t);
      break;
    default:
      return !1;
  }
  return !0;
}
function fr(i, e) {
  return e.elements(i, "tab").map((t) => ({
    position: e.lengthAttr(t, "pos"),
    leader: e.attr(t, "leader"),
    style: e.attr(t, "val")
  }));
}
function pr(i, e) {
  var t = {};
  for (let r of e.elements(i))
    switch (r.localName) {
      case "numId":
        t.id = e.attr(r, "val");
        break;
      case "ilvl":
        t.level = e.intAttr(r, "val");
        break;
    }
  return t;
}
function mr(i, e) {
  let t = {
    numberings: [],
    abstractNumberings: [],
    bulletPictures: []
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "num":
        t.numberings.push(gr(r, e));
        break;
      case "abstractNum":
        t.abstractNumberings.push(br(r, e));
        break;
      case "numPicBullet":
        t.bulletPictures.push(yr(r, e));
        break;
    }
  return t;
}
function gr(i, e) {
  let t = {
    id: e.attr(i, "numId"),
    overrides: []
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "abstractNumId":
        t.abstractId = e.attr(r, "val");
        break;
      case "lvlOverride":
        t.overrides.push(vr(r, e));
        break;
    }
  return t;
}
function br(i, e) {
  let t = {
    id: e.attr(i, "abstractNumId"),
    levels: []
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "name":
        t.name = e.attr(r, "val");
        break;
      case "multiLevelType":
        t.multiLevelType = e.attr(r, "val");
        break;
      case "numStyleLink":
        t.numberingStyleLink = e.attr(r, "val");
        break;
      case "styleLink":
        t.styleLink = e.attr(r, "val");
        break;
      case "lvl":
        t.levels.push(we(r, e));
        break;
    }
  return t;
}
function we(i, e) {
  let t = {
    level: e.intAttr(i, "ilvl")
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "start":
        t.start = e.attr(r, "val");
        break;
      case "lvlRestart":
        t.restart = e.intAttr(r, "val");
        break;
      case "numFmt":
        t.format = e.attr(r, "val");
        break;
      case "lvlText":
        t.text = e.attr(r, "val");
        break;
      case "lvlJc":
        t.justification = e.attr(r, "val");
        break;
      case "lvlPicBulletId":
        t.bulletPictureId = e.attr(r, "val");
        break;
      case "pStyle":
        t.paragraphStyle = e.attr(r, "val");
        break;
      case "pPr":
        t.paragraphProps = ke(r, e);
        break;
      case "rPr":
        t.runProps = Yt(r, e);
        break;
    }
  return t;
}
function vr(i, e) {
  let t = {
    level: e.intAttr(i, "ilvl")
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "startOverride":
        t.start = e.intAttr(r, "val");
        break;
      case "lvl":
        t.numberingLevel = we(r, e);
        break;
    }
  return t;
}
function yr(i, e) {
  var t = e.element(i, "pict"), r = t && e.element(t, "shape"), a = r && e.element(r, "imagedata");
  return a ? {
    id: e.attr(i, "numPicBulletId"),
    referenceId: e.attr(a, "id"),
    style: e.attr(r, "style")
  } : null;
}
class kr extends wt {
  constructor(e, t, r) {
    super(e, t), this._documentParser = r;
  }
  parseXml(e) {
    Object.assign(this, mr(e, this._package.xmlParser)), this.domNumberings = this._documentParser.parseNumberingFile(e);
  }
}
class _r extends wt {
  constructor(e, t, r) {
    super(e, t), this._documentParser = r;
  }
  parseXml(e) {
    this.styles = this._documentParser.parseStylesFile(e);
  }
}
var R;
(function(i) {
  i.Document = "document", i.Paragraph = "paragraph", i.Run = "run", i.Break = "break", i.NoBreakHyphen = "noBreakHyphen", i.Table = "table", i.Row = "row", i.Cell = "cell", i.Hyperlink = "hyperlink", i.Drawing = "drawing", i.Image = "image", i.Text = "text", i.Tab = "tab", i.Symbol = "symbol", i.BookmarkStart = "bookmarkStart", i.BookmarkEnd = "bookmarkEnd", i.Footer = "footer", i.Header = "header", i.FootnoteReference = "footnoteReference", i.EndnoteReference = "endnoteReference", i.Footnote = "footnote", i.Endnote = "endnote", i.SimpleField = "simpleField", i.ComplexField = "complexField", i.Instruction = "instruction", i.VmlPicture = "vmlPicture", i.MmlMath = "mmlMath", i.MmlMathParagraph = "mmlMathParagraph", i.MmlFraction = "mmlFraction", i.MmlFunction = "mmlFunction", i.MmlFunctionName = "mmlFunctionName", i.MmlNumerator = "mmlNumerator", i.MmlDenominator = "mmlDenominator", i.MmlRadical = "mmlRadical", i.MmlBase = "mmlBase", i.MmlDegree = "mmlDegree", i.MmlSuperscript = "mmlSuperscript", i.MmlSubscript = "mmlSubscript", i.MmlPreSubSuper = "mmlPreSubSuper", i.MmlSubArgument = "mmlSubArgument", i.MmlSuperArgument = "mmlSuperArgument", i.MmlNary = "mmlNary", i.MmlDelimiter = "mmlDelimiter", i.MmlRun = "mmlRun", i.MmlEquationArray = "mmlEquationArray", i.MmlLimit = "mmlLimit", i.MmlLimitLower = "mmlLimitLower", i.MmlMatrix = "mmlMatrix", i.MmlMatrixRow = "mmlMatrixRow", i.MmlBox = "mmlBox", i.MmlBar = "mmlBar", i.MmlGroupChar = "mmlGroupChar", i.VmlElement = "vmlElement", i.Inserted = "inserted", i.Deleted = "deleted", i.DeletedText = "deletedText";
})(R || (R = {}));
class Jt {
  constructor() {
    this.children = [], this.cssStyle = {};
  }
}
class wr extends Jt {
  constructor() {
    super(...arguments), this.type = R.Header;
  }
}
class Sr extends Jt {
  constructor() {
    super(...arguments), this.type = R.Footer;
  }
}
class Se extends wt {
  constructor(e, t, r) {
    super(e, t), this._documentParser = r;
  }
  parseXml(e) {
    this.rootElement = this.createRootElement(), this.rootElement.children = this._documentParser.parseBodyElements(e);
  }
}
class xr extends Se {
  createRootElement() {
    return new wr();
  }
}
class Cr extends Se {
  createRootElement() {
    return new Sr();
  }
}
function Pr(i, e) {
  const t = {};
  for (let r of e.elements(i))
    switch (r.localName) {
      case "Template":
        t.template = r.textContent;
        break;
      case "Pages":
        t.pages = Tt(r.textContent);
        break;
      case "Words":
        t.words = Tt(r.textContent);
        break;
      case "Characters":
        t.characters = Tt(r.textContent);
        break;
      case "Application":
        t.application = r.textContent;
        break;
      case "Lines":
        t.lines = Tt(r.textContent);
        break;
      case "Paragraphs":
        t.paragraphs = Tt(r.textContent);
        break;
      case "Company":
        t.company = r.textContent;
        break;
      case "AppVersion":
        t.appVersion = r.textContent;
        break;
    }
  return t;
}
function Tt(i) {
  if (typeof i != "undefined")
    return parseInt(i);
}
class Ar extends wt {
  parseXml(e) {
    this.props = Pr(e, this._package.xmlParser);
  }
}
function Er(i, e) {
  const t = {};
  for (let r of e.elements(i))
    switch (r.localName) {
      case "title":
        t.title = r.textContent;
        break;
      case "description":
        t.description = r.textContent;
        break;
      case "subject":
        t.subject = r.textContent;
        break;
      case "creator":
        t.creator = r.textContent;
        break;
      case "keywords":
        t.keywords = r.textContent;
        break;
      case "language":
        t.language = r.textContent;
        break;
      case "lastModifiedBy":
        t.lastModifiedBy = r.textContent;
        break;
      case "revision":
        r.textContent && (t.revision = parseInt(r.textContent));
        break;
    }
  return t;
}
class Nr extends wt {
  parseXml(e) {
    this.props = Er(e, this._package.xmlParser);
  }
}
class Br {
}
function zr(i, e) {
  var t = new Br(), r = e.element(i, "themeElements");
  for (let a of e.elements(r))
    switch (a.localName) {
      case "clrScheme":
        t.colorScheme = Mr(a, e);
        break;
      case "fontScheme":
        t.fontScheme = Rr(a, e);
        break;
    }
  return t;
}
function Mr(i, e) {
  var t = {
    name: e.attr(i, "name"),
    colors: {}
  };
  for (let n of e.elements(i)) {
    var r = e.element(n, "srgbClr"), a = e.element(n, "sysClr");
    r ? t.colors[n.localName] = e.attr(r, "val") : a && (t.colors[n.localName] = e.attr(a, "lastClr"));
  }
  return t;
}
function Rr(i, e) {
  var t = {
    name: e.attr(i, "name")
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "majorFont":
        t.majorFont = ie(r, e);
        break;
      case "minorFont":
        t.minorFont = ie(r, e);
        break;
    }
  return t;
}
function ie(i, e) {
  return {
    latinTypeface: e.elementAttr(i, "latin", "typeface"),
    eaTypeface: e.elementAttr(i, "ea", "typeface"),
    csTypeface: e.elementAttr(i, "cs", "typeface")
  };
}
class Tr extends wt {
  constructor(e, t) {
    super(e, t);
  }
  parseXml(e) {
    this.theme = zr(e, this._package.xmlParser);
  }
}
class xe {
}
class Or extends xe {
  constructor() {
    super(...arguments), this.type = R.Footnote;
  }
}
class Fr extends xe {
  constructor() {
    super(...arguments), this.type = R.Endnote;
  }
}
class Ce extends wt {
  constructor(e, t, r) {
    super(e, t), this._documentParser = r;
  }
}
class Ir extends Ce {
  constructor(e, t, r) {
    super(e, t, r);
  }
  parseXml(e) {
    this.notes = this._documentParser.parseNotes(e, "footnote", Or);
  }
}
class Dr extends Ce {
  constructor(e, t, r) {
    super(e, t, r);
  }
  parseXml(e) {
    this.notes = this._documentParser.parseNotes(e, "endnote", Fr);
  }
}
function Lr(i, e) {
  var t = {};
  for (let r of e.elements(i))
    switch (r.localName) {
      case "defaultTabStop":
        t.defaultTabStop = e.lengthAttr(r, "val");
        break;
      case "footnotePr":
        t.footnoteProps = oe(r, e);
        break;
      case "endnotePr":
        t.endnoteProps = oe(r, e);
        break;
      case "autoHyphenation":
        t.autoHyphenation = e.boolAttr(r, "val");
        break;
    }
  return t;
}
function oe(i, e) {
  var t = {
    defaultNoteIds: []
  };
  for (let r of e.elements(i))
    switch (r.localName) {
      case "numFmt":
        t.nummeringFormat = e.attr(r, "val");
        break;
      case "footnote":
      case "endnote":
        t.defaultNoteIds.push(e.attr(r, "id"));
        break;
    }
  return t;
}
class jr extends wt {
  constructor(e, t) {
    super(e, t);
  }
  parseXml(e) {
    this.settings = Lr(e, this._package.xmlParser);
  }
}
function Ur(i, e) {
  return e.elements(i, "property").map((t) => {
    const r = t.firstChild;
    return {
      formatId: e.attr(t, "fmtid"),
      name: e.attr(t, "name"),
      type: r.nodeName,
      value: r.textContent
    };
  });
}
class Wr extends wt {
  parseXml(e) {
    this.props = Ur(e, this._package.xmlParser);
  }
}
const Hr = [
  { type: mt.OfficeDocument, target: "word/document.xml" },
  { type: mt.ExtendedProperties, target: "docProps/app.xml" },
  { type: mt.CoreProperties, target: "docProps/core.xml" },
  { type: mt.CustomProperties, target: "docProps/custom.xml" }
];
class Qt {
  constructor() {
    this.parts = [], this.partsMap = {};
  }
  static load(e, t, r) {
    return yt(this, null, function* () {
      var a = new Qt();
      return a._options = r, a._parser = t, a._package = yield Kt.load(e, r), a.rels = yield a._package.loadRelationships(), yield Promise.all(Hr.map((n) => {
        var l;
        const o = (l = a.rels.find((u) => u.type === n.type)) != null ? l : n;
        return a.loadRelationshipPart(o.target, o.type);
      })), a;
    });
  }
  save(e = "blob") {
    return this._package.save(e);
  }
  loadRelationshipPart(e, t) {
    return yt(this, null, function* () {
      var a;
      if (this.partsMap[e])
        return this.partsMap[e];
      if (!this._package.get(e))
        return null;
      let r = null;
      switch (t) {
        case mt.OfficeDocument:
          this.documentPart = r = new or(this._package, e, this._parser);
          break;
        case mt.FontTable:
          this.fontTablePart = r = new rr(this._package, e);
          break;
        case mt.Numbering:
          this.numberingPart = r = new kr(this._package, e, this._parser);
          break;
        case mt.Styles:
          this.stylesPart = r = new _r(this._package, e, this._parser);
          break;
        case mt.Theme:
          this.themePart = r = new Tr(this._package, e);
          break;
        case mt.Footnotes:
          this.footnotesPart = r = new Ir(this._package, e, this._parser);
          break;
        case mt.Endnotes:
          this.endnotesPart = r = new Dr(this._package, e, this._parser);
          break;
        case mt.Footer:
          r = new Cr(this._package, e, this._parser);
          break;
        case mt.Header:
          r = new xr(this._package, e, this._parser);
          break;
        case mt.CoreProperties:
          this.corePropsPart = r = new Nr(this._package, e);
          break;
        case mt.ExtendedProperties:
          this.extendedPropsPart = r = new Ar(this._package, e);
          break;
        case mt.CustomProperties:
          r = new Wr(this._package, e);
          break;
        case mt.Settings:
          this.settingsPart = r = new jr(this._package, e);
          break;
      }
      if (r == null)
        return Promise.resolve(null);
      if (this.partsMap[e] = r, this.parts.push(r), yield r.load(), ((a = r.rels) == null ? void 0 : a.length) > 0) {
        const [n] = Ut(r.path);
        yield Promise.all(r.rels.map((o) => this.loadRelationshipPart(Zt(o.target, n), o.type)));
      }
      return r;
    });
  }
  loadDocumentImage(e, t) {
    return yt(this, null, function* () {
      const r = yield this.loadResource(t != null ? t : this.documentPart, e, "blob");
      return this.blobToURL(r);
    });
  }
  loadNumberingImage(e) {
    return yt(this, null, function* () {
      const t = yield this.loadResource(this.numberingPart, e, "blob");
      return this.blobToURL(t);
    });
  }
  loadFont(e, t) {
    return yt(this, null, function* () {
      const r = yield this.loadResource(this.fontTablePart, e, "uint8array");
      return r && this.blobToURL(new Blob([$r(r, t)]));
    });
  }
  blobToURL(e) {
    return e ? this._options.useBase64URL ? ar(e) : URL.createObjectURL(e) : null;
  }
  findPartByRelId(e, t = null) {
    var n;
    var r = ((n = t.rels) != null ? n : this.rels).find((o) => o.id == e);
    const a = t ? Ut(t.path)[0] : "";
    return r ? this.partsMap[Zt(r.target, a)] : null;
  }
  getPathById(e, t) {
    const r = e.rels.find((n) => n.id == t), [a] = Ut(e.path);
    return r ? Zt(r.target, a) : null;
  }
  loadResource(e, t, r) {
    const a = this.getPathById(e, t);
    return a ? this._package.load(a, r) : Promise.resolve(null);
  }
}
function $r(i, e) {
  const r = e.replace(/{|}|-/g, ""), a = new Array(16);
  for (let n = 0; n < 16; n++)
    a[16 - n - 1] = parseInt(r.substr(n * 2, 2), 16);
  for (let n = 0; n < 32; n++)
    i[n] = i[n] ^ a[n % 16];
  return i;
}
function Zr(i, e) {
  return {
    type: R.BookmarkStart,
    id: e.attr(i, "id"),
    name: e.attr(i, "name"),
    colFirst: e.intAttr(i, "colFirst"),
    colLast: e.intAttr(i, "colLast")
  };
}
function Vr(i, e) {
  return {
    type: R.BookmarkEnd,
    id: e.attr(i, "id")
  };
}
class Xr extends Jt {
  constructor() {
    super(...arguments), this.type = R.VmlElement, this.attrs = {};
  }
}
function Pe(i, e) {
  var t = new Xr();
  switch (i.localName) {
    case "rect":
      t.tagName = "rect", Object.assign(t.attrs, { width: "100%", height: "100%" });
      break;
    case "oval":
      t.tagName = "ellipse", Object.assign(t.attrs, { cx: "50%", cy: "50%", rx: "50%", ry: "50%" });
      break;
    case "line":
      t.tagName = "line";
      break;
    case "shape":
      t.tagName = "g";
      break;
    case "textbox":
      t.tagName = "foreignObject", Object.assign(t.attrs, { width: "100%", height: "100%" });
      break;
    default:
      return null;
  }
  for (const r of E.attrs(i))
    switch (r.localName) {
      case "style":
        t.cssStyleText = r.value;
        break;
      case "fillcolor":
        t.attrs.fill = r.value;
        break;
      case "from":
        const [a, n] = le(r.value);
        Object.assign(t.attrs, { x1: a, y1: n });
        break;
      case "to":
        const [o, l] = le(r.value);
        Object.assign(t.attrs, { x2: o, y2: l });
        break;
    }
  for (const r of E.elements(i))
    switch (r.localName) {
      case "stroke":
        Object.assign(t.attrs, Gr(r));
        break;
      case "fill":
        Object.assign(t.attrs, qr());
        break;
      case "imagedata":
        t.tagName = "image", Object.assign(t.attrs, { width: "100%", height: "100%" }), t.imageHref = {
          id: E.attr(r, "id"),
          title: E.attr(r, "title")
        };
        break;
      case "txbxContent":
        t.children.push(...e.parseBodyElements(r));
        break;
      default:
        const a = Pe(r, e);
        a && t.children.push(a);
        break;
    }
  return t;
}
function Gr(i) {
  var e;
  return {
    stroke: E.attr(i, "color"),
    "stroke-width": (e = E.lengthAttr(i, "weight", pt.Emu)) != null ? e : "1px"
  };
}
function qr(i) {
  return {};
}
function le(i) {
  return i.split(",");
}
var Wt = {
  shd: "inherit",
  color: "black",
  borderColor: "black",
  highlight: "transparent"
};
const Kr = [], ce = {
  oMath: R.MmlMath,
  oMathPara: R.MmlMathParagraph,
  f: R.MmlFraction,
  func: R.MmlFunction,
  fName: R.MmlFunctionName,
  num: R.MmlNumerator,
  den: R.MmlDenominator,
  rad: R.MmlRadical,
  deg: R.MmlDegree,
  e: R.MmlBase,
  sSup: R.MmlSuperscript,
  sSub: R.MmlSubscript,
  sPre: R.MmlPreSubSuper,
  sup: R.MmlSuperArgument,
  sub: R.MmlSubArgument,
  d: R.MmlDelimiter,
  nary: R.MmlNary,
  eqArr: R.MmlEquationArray,
  lim: R.MmlLimit,
  limLow: R.MmlLimitLower,
  m: R.MmlMatrix,
  mr: R.MmlMatrixRow,
  box: R.MmlBox,
  bar: R.MmlBar,
  groupChr: R.MmlGroupChar
};
class Yr {
  constructor(e) {
    this.options = vt({
      ignoreWidth: !1,
      debug: !1
    }, e);
  }
  parseNotes(e, t, r) {
    var a = [];
    for (let n of E.elements(e, t)) {
      const o = new r();
      o.id = E.attr(n, "id"), o.noteType = E.attr(n, "type"), o.children = this.parseBodyElements(n), a.push(o);
    }
    return a;
  }
  parseDocumentFile(e) {
    var t = E.element(e, "body"), r = E.element(e, "background"), a = E.element(t, "sectPr");
    return {
      type: R.Document,
      children: this.parseBodyElements(t),
      props: a ? ye(a, E) : {},
      cssStyle: r ? this.parseBackground(r) : {}
    };
  }
  parseBackground(e) {
    var t = {}, r = ut.colorAttr(e, "color");
    return r && (t["background-color"] = r), t;
  }
  parseBodyElements(e) {
    var t = [];
    for (let r of E.elements(e))
      switch (r.localName) {
        case "p":
          t.push(this.parseParagraph(r));
          break;
        case "tbl":
          t.push(this.parseTable(r));
          break;
        case "sdt":
          t.push(...this.parseSdt(r, (a) => this.parseBodyElements(a)));
          break;
      }
    return t;
  }
  parseStylesFile(e) {
    var t = [];
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "style":
          t.push(this.parseStyle(r));
          break;
        case "docDefaults":
          t.push(this.parseDefaultStyles(r));
          break;
      }
    }), t;
  }
  parseDefaultStyles(e) {
    var t = {
      id: null,
      name: null,
      target: null,
      basedOn: null,
      styles: []
    };
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "rPrDefault":
          var a = E.element(r, "rPr");
          a && t.styles.push({
            target: "span",
            values: this.parseDefaultProperties(a, {})
          });
          break;
        case "pPrDefault":
          var n = E.element(r, "pPr");
          n && t.styles.push({
            target: "p",
            values: this.parseDefaultProperties(n, {})
          });
          break;
      }
    }), t;
  }
  parseStyle(e) {
    var t = {
      id: E.attr(e, "styleId"),
      isDefault: E.boolAttr(e, "default"),
      name: null,
      target: null,
      basedOn: null,
      styles: [],
      linked: null
    };
    switch (E.attr(e, "type")) {
      case "paragraph":
        t.target = "p";
        break;
      case "table":
        t.target = "table";
        break;
      case "character":
        t.target = "span";
        break;
    }
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "basedOn":
          t.basedOn = E.attr(r, "val");
          break;
        case "name":
          t.name = E.attr(r, "val");
          break;
        case "link":
          t.linked = E.attr(r, "val");
          break;
        case "next":
          t.next = E.attr(r, "val");
          break;
        case "aliases":
          t.aliases = E.attr(r, "val").split(",");
          break;
        case "pPr":
          t.styles.push({
            target: "p",
            values: this.parseDefaultProperties(r, {})
          }), t.paragraphProps = ke(r, E);
          break;
        case "rPr":
          t.styles.push({
            target: "span",
            values: this.parseDefaultProperties(r, {})
          }), t.runProps = Yt(r, E);
          break;
        case "tblPr":
        case "tcPr":
          t.styles.push({
            target: "td",
            values: this.parseDefaultProperties(r, {})
          });
          break;
        case "tblStylePr":
          for (let a of this.parseTableStyle(r))
            t.styles.push(a);
          break;
        case "rsid":
        case "qFormat":
        case "hidden":
        case "semiHidden":
        case "unhideWhenUsed":
        case "autoRedefine":
        case "uiPriority":
          break;
        default:
          this.options.debug && console.warn(`DOCX: Unknown style element: ${r.localName}`);
      }
    }), t;
  }
  parseTableStyle(e) {
    var t = [], r = E.attr(e, "type"), a = "", n = "";
    switch (r) {
      case "firstRow":
        n = ".first-row", a = "tr.first-row td";
        break;
      case "lastRow":
        n = ".last-row", a = "tr.last-row td";
        break;
      case "firstCol":
        n = ".first-col", a = "td.first-col";
        break;
      case "lastCol":
        n = ".last-col", a = "td.last-col";
        break;
      case "band1Vert":
        n = ":not(.no-vband)", a = "td.odd-col";
        break;
      case "band2Vert":
        n = ":not(.no-vband)", a = "td.even-col";
        break;
      case "band1Horz":
        n = ":not(.no-hband)", a = "tr.odd-row";
        break;
      case "band2Horz":
        n = ":not(.no-hband)", a = "tr.even-row";
        break;
      default:
        return [];
    }
    return ut.foreach(e, (o) => {
      switch (o.localName) {
        case "pPr":
          t.push({
            target: `${a} p`,
            mod: n,
            values: this.parseDefaultProperties(o, {})
          });
          break;
        case "rPr":
          t.push({
            target: `${a} span`,
            mod: n,
            values: this.parseDefaultProperties(o, {})
          });
          break;
        case "tblPr":
        case "tcPr":
          t.push({
            target: a,
            mod: n,
            values: this.parseDefaultProperties(o, {})
          });
          break;
      }
    }), t;
  }
  parseNumberingFile(e) {
    var t = [], r = {}, a = [];
    return ut.foreach(e, (n) => {
      switch (n.localName) {
        case "abstractNum":
          this.parseAbstractNumbering(n, a).forEach((u) => t.push(u));
          break;
        case "numPicBullet":
          a.push(this.parseNumberingPicBullet(n));
          break;
        case "num":
          var o = E.attr(n, "numId"), l = E.elementAttr(n, "abstractNumId", "val");
          r[l] = o;
          break;
      }
    }), t.forEach((n) => n.id = r[n.id]), t;
  }
  parseNumberingPicBullet(e) {
    var t = E.element(e, "pict"), r = t && E.element(t, "shape"), a = r && E.element(r, "imagedata");
    return a ? {
      id: E.intAttr(e, "numPicBulletId"),
      src: E.attr(a, "id"),
      style: E.attr(r, "style")
    } : null;
  }
  parseAbstractNumbering(e, t) {
    var r = [], a = E.attr(e, "abstractNumId");
    return ut.foreach(e, (n) => {
      switch (n.localName) {
        case "lvl":
          r.push(this.parseNumberingLevel(a, n, t));
          break;
      }
    }), r;
  }
  parseNumberingLevel(e, t, r) {
    var a = {
      id: e,
      level: E.intAttr(t, "ilvl"),
      start: 1,
      pStyleName: void 0,
      pStyle: {},
      rStyle: {},
      suff: "tab"
    };
    return ut.foreach(t, (n) => {
      switch (n.localName) {
        case "start":
          a.start = E.intAttr(n, "val");
          break;
        case "pPr":
          this.parseDefaultProperties(n, a.pStyle);
          break;
        case "rPr":
          this.parseDefaultProperties(n, a.rStyle);
          break;
        case "lvlPicBulletId":
          var o = E.intAttr(n, "val");
          a.bullet = r.find((l) => l.id == o);
          break;
        case "lvlText":
          a.levelText = E.attr(n, "val");
          break;
        case "pStyle":
          a.pStyleName = E.attr(n, "val");
          break;
        case "numFmt":
          a.format = E.attr(n, "val");
          break;
        case "suff":
          a.suff = E.attr(n, "val");
          break;
      }
    }), a;
  }
  parseSdt(e, t) {
    const r = E.element(e, "sdtContent");
    return r ? t(r) : [];
  }
  parseInserted(e, t) {
    var r, a;
    return {
      type: R.Inserted,
      children: (a = (r = t(e)) == null ? void 0 : r.children) != null ? a : []
    };
  }
  parseDeleted(e, t) {
    var r, a;
    return {
      type: R.Deleted,
      children: (a = (r = t(e)) == null ? void 0 : r.children) != null ? a : []
    };
  }
  parseParagraph(e) {
    var t = { type: R.Paragraph, children: [] };
    for (let r of E.elements(e))
      switch (r.localName) {
        case "pPr":
          this.parseParagraphProperties(r, t);
          break;
        case "r":
          t.children.push(this.parseRun(r, t));
          break;
        case "hyperlink":
          t.children.push(this.parseHyperlink(r, t));
          break;
        case "bookmarkStart":
          t.children.push(Zr(r, E));
          break;
        case "bookmarkEnd":
          t.children.push(Vr(r, E));
          break;
        case "oMath":
        case "oMathPara":
          t.children.push(this.parseMathElement(r));
          break;
        case "sdt":
          t.children.push(...this.parseSdt(r, (a) => this.parseParagraph(a).children));
          break;
        case "ins":
          t.children.push(this.parseInserted(r, (a) => this.parseParagraph(a)));
          break;
        case "del":
          t.children.push(this.parseDeleted(r, (a) => this.parseParagraph(a)));
          break;
      }
    return t;
  }
  parseParagraphProperties(e, t) {
    this.parseDefaultProperties(e, t.cssStyle = {}, null, (r) => {
      if (_e(r, t, E))
        return !0;
      switch (r.localName) {
        case "pStyle":
          t.styleName = E.attr(r, "val");
          break;
        case "cnfStyle":
          t.className = lt.classNameOfCnfStyle(r);
          break;
        case "framePr":
          this.parseFrame(r, t);
          break;
        case "rPr":
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseFrame(e, t) {
    var r = E.attr(e, "dropCap");
    r == "drop" && (t.cssStyle.float = "left");
  }
  parseHyperlink(e, t) {
    var r = { type: R.Hyperlink, parent: t, children: [] }, a = E.attr(e, "anchor"), n = E.attr(e, "id");
    return a && (r.href = "#" + a), n && (r.id = n), ut.foreach(e, (o) => {
      switch (o.localName) {
        case "r":
          r.children.push(this.parseRun(o, r));
          break;
      }
    }), r;
  }
  parseRun(e, t) {
    var r = { type: R.Run, parent: t, children: [] };
    return ut.foreach(e, (a) => {
      switch (a = this.checkAlternateContent(a), a.localName) {
        case "t":
          r.children.push({
            type: R.Text,
            text: a.textContent
          });
          break;
        case "delText":
          r.children.push({
            type: R.DeletedText,
            text: a.textContent
          });
          break;
        case "fldSimple":
          r.children.push({
            type: R.SimpleField,
            instruction: E.attr(a, "instr"),
            lock: E.boolAttr(a, "lock", !1),
            dirty: E.boolAttr(a, "dirty", !1)
          });
          break;
        case "instrText":
          r.fieldRun = !0, r.children.push({
            type: R.Instruction,
            text: a.textContent
          });
          break;
        case "fldChar":
          r.fieldRun = !0, r.children.push({
            type: R.ComplexField,
            charType: E.attr(a, "fldCharType"),
            lock: E.boolAttr(a, "lock", !1),
            dirty: E.boolAttr(a, "dirty", !1)
          });
          break;
        case "noBreakHyphen":
          r.children.push({ type: R.NoBreakHyphen });
          break;
        case "br":
          r.children.push({
            type: R.Break,
            break: E.attr(a, "type") || "textWrapping"
          });
          break;
        case "lastRenderedPageBreak":
          r.children.push({
            type: R.Break,
            break: "lastRenderedPageBreak"
          });
          break;
        case "sym":
          r.children.push({
            type: R.Symbol,
            font: E.attr(a, "font"),
            char: E.attr(a, "char")
          });
          break;
        case "tab":
          r.children.push({ type: R.Tab });
          break;
        case "footnoteReference":
          r.children.push({
            type: R.FootnoteReference,
            id: E.attr(a, "id")
          });
          break;
        case "endnoteReference":
          r.children.push({
            type: R.EndnoteReference,
            id: E.attr(a, "id")
          });
          break;
        case "drawing":
          let n = this.parseDrawing(a);
          n && (r.children = [n]);
          break;
        case "pict":
          r.children.push(this.parseVmlPicture(a));
          break;
        case "rPr":
          this.parseRunProperties(a, r);
          break;
      }
    }), r;
  }
  parseMathElement(e) {
    const t = `${e.localName}Pr`, r = { type: ce[e.localName], children: [] };
    for (const n of E.elements(e))
      if (ce[n.localName])
        r.children.push(this.parseMathElement(n));
      else if (n.localName == "r") {
        var a = this.parseRun(n);
        a.type = R.MmlRun, r.children.push(a);
      } else
        n.localName == t && (r.props = this.parseMathProperies(n));
    return r;
  }
  parseMathProperies(e) {
    const t = {};
    for (const r of E.elements(e))
      switch (r.localName) {
        case "chr":
          t.char = E.attr(r, "val");
          break;
        case "vertJc":
          t.verticalJustification = E.attr(r, "val");
          break;
        case "pos":
          t.position = E.attr(r, "val");
          break;
        case "degHide":
          t.hideDegree = E.boolAttr(r, "val");
          break;
        case "begChr":
          t.beginChar = E.attr(r, "val");
          break;
        case "endChr":
          t.endChar = E.attr(r, "val");
          break;
      }
    return t;
  }
  parseRunProperties(e, t) {
    this.parseDefaultProperties(e, t.cssStyle = {}, null, (r) => {
      switch (r.localName) {
        case "rStyle":
          t.styleName = E.attr(r, "val");
          break;
        case "vertAlign":
          t.verticalAlign = lt.valueOfVertAlign(r, !0);
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseVmlPicture(e) {
    const t = { type: R.VmlPicture, children: [] };
    for (const r of E.elements(e)) {
      const a = Pe(r, this);
      a && t.children.push(a);
    }
    return t;
  }
  checkAlternateContent(e) {
    var n;
    if (e.localName != "AlternateContent")
      return e;
    var t = E.element(e, "Choice");
    if (t) {
      var r = E.attr(t, "Requires"), a = e.lookupNamespaceURI(r);
      if (Kr.includes(a))
        return t.firstElementChild;
    }
    return (n = E.element(e, "Fallback")) == null ? void 0 : n.firstElementChild;
  }
  parseDrawing(e) {
    for (var t of E.elements(e))
      switch (t.localName) {
        case "inline":
        case "anchor":
          return this.parseDrawingWrapper(t);
      }
  }
  parseDrawingWrapper(e) {
    var w;
    var t = { type: R.Drawing, children: [], cssStyle: {} }, r = e.localName == "anchor";
    let a = null, n = E.boolAttr(e, "simplePos"), o = { relative: "page", align: "left", offset: "0" }, l = { relative: "page", align: "top", offset: "0" };
    for (var u of E.elements(e))
      switch (u.localName) {
        case "simplePos":
          n && (o.offset = E.lengthAttr(u, "x", pt.Emu), l.offset = E.lengthAttr(u, "y", pt.Emu));
          break;
        case "extent":
          t.cssStyle.width = E.lengthAttr(u, "cx", pt.Emu), t.cssStyle.height = E.lengthAttr(u, "cy", pt.Emu);
          break;
        case "positionH":
        case "positionV":
          if (!n) {
            let d = u.localName == "positionH" ? o : l;
            var g = E.element(u, "align"), _ = E.element(u, "posOffset");
            d.relative = (w = E.attr(u, "relativeFrom")) != null ? w : d.relative, g && (d.align = g.textContent), _ && (d.offset = ut.sizeValue(_, pt.Emu));
          }
          break;
        case "wrapTopAndBottom":
          a = "wrapTopAndBottom";
          break;
        case "wrapNone":
          a = "wrapNone";
          break;
        case "graphic":
          var k = this.parseGraphic(u);
          k && t.children.push(k);
          break;
      }
    return a == "wrapTopAndBottom" ? (t.cssStyle.display = "block", o.align && (t.cssStyle["text-align"] = o.align, t.cssStyle.width = "100%")) : a == "wrapNone" ? (t.cssStyle.display = "block", t.cssStyle.position = "relative", t.cssStyle.width = "0px", t.cssStyle.height = "0px", o.offset && (t.cssStyle.left = o.offset), l.offset && (t.cssStyle.top = l.offset)) : r && (o.align == "left" || o.align == "right") && (t.cssStyle.float = o.align), t;
  }
  parseGraphic(e) {
    var t = E.element(e, "graphicData");
    for (let r of E.elements(t))
      switch (r.localName) {
        case "pic":
          return this.parsePicture(r);
      }
    return null;
  }
  parsePicture(e) {
    var t = { type: R.Image, src: "", cssStyle: {} }, r = E.element(e, "blipFill"), a = E.element(r, "blip");
    t.src = E.attr(a, "embed");
    var n = E.element(e, "spPr"), o = E.element(n, "xfrm");
    t.cssStyle.position = "relative";
    for (var l of E.elements(o))
      switch (l.localName) {
        case "ext":
          t.cssStyle.width = E.lengthAttr(l, "cx", pt.Emu), t.cssStyle.height = E.lengthAttr(l, "cy", pt.Emu);
          break;
        case "off":
          t.cssStyle.left = E.lengthAttr(l, "x", pt.Emu), t.cssStyle.top = E.lengthAttr(l, "y", pt.Emu);
          break;
      }
    return t;
  }
  parseTable(e) {
    var t = { type: R.Table, children: [] };
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "tr":
          t.children.push(this.parseTableRow(r));
          break;
        case "tblGrid":
          t.columns = this.parseTableColumns(r);
          break;
        case "tblPr":
          this.parseTableProperties(r, t);
          break;
      }
    }), t;
  }
  parseTableColumns(e) {
    var t = [];
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "gridCol":
          t.push({ width: E.lengthAttr(r, "w") });
          break;
      }
    }), t;
  }
  parseTableProperties(e, t) {
    switch (t.cssStyle = {}, t.cellStyle = {}, this.parseDefaultProperties(e, t.cssStyle, t.cellStyle, (r) => {
      switch (r.localName) {
        case "tblStyle":
          t.styleName = E.attr(r, "val");
          break;
        case "tblLook":
          t.className = lt.classNameOftblLook(r);
          break;
        case "tblpPr":
          this.parseTablePosition(r, t);
          break;
        case "tblStyleColBandSize":
          t.colBandSize = E.intAttr(r, "val");
          break;
        case "tblStyleRowBandSize":
          t.rowBandSize = E.intAttr(r, "val");
          break;
        default:
          return !1;
      }
      return !0;
    }), t.cssStyle["text-align"]) {
      case "center":
        delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto", t.cssStyle["margin-right"] = "auto";
        break;
      case "right":
        delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto";
        break;
    }
  }
  parseTablePosition(e, t) {
    var r = E.lengthAttr(e, "topFromText"), a = E.lengthAttr(e, "bottomFromText"), n = E.lengthAttr(e, "rightFromText"), o = E.lengthAttr(e, "leftFromText");
    t.cssStyle.float = "left", t.cssStyle["margin-bottom"] = lt.addSize(t.cssStyle["margin-bottom"], a), t.cssStyle["margin-left"] = lt.addSize(t.cssStyle["margin-left"], o), t.cssStyle["margin-right"] = lt.addSize(t.cssStyle["margin-right"], n), t.cssStyle["margin-top"] = lt.addSize(t.cssStyle["margin-top"], r);
  }
  parseTableRow(e) {
    var t = { type: R.Row, children: [] };
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "tc":
          t.children.push(this.parseTableCell(r));
          break;
        case "trPr":
          this.parseTableRowProperties(r, t);
          break;
      }
    }), t;
  }
  parseTableRowProperties(e, t) {
    t.cssStyle = this.parseDefaultProperties(e, {}, null, (r) => {
      switch (r.localName) {
        case "cnfStyle":
          t.className = lt.classNameOfCnfStyle(r);
          break;
        case "tblHeader":
          t.isHeader = E.boolAttr(r, "val");
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseTableCell(e) {
    var t = { type: R.Cell, children: [] };
    return ut.foreach(e, (r) => {
      switch (r.localName) {
        case "tbl":
          t.children.push(this.parseTable(r));
          break;
        case "p":
          t.children.push(this.parseParagraph(r));
          break;
        case "tcPr":
          this.parseTableCellProperties(r, t);
          break;
      }
    }), t;
  }
  parseTableCellProperties(e, t) {
    t.cssStyle = this.parseDefaultProperties(e, {}, null, (r) => {
      var a;
      switch (r.localName) {
        case "gridSpan":
          t.span = E.intAttr(r, "val", null);
          break;
        case "vMerge":
          t.verticalMerge = (a = E.attr(r, "val")) != null ? a : "continue";
          break;
        case "cnfStyle":
          t.className = lt.classNameOfCnfStyle(r);
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseDefaultProperties(e, t = null, r = null, a = null) {
    return t = t || {}, ut.foreach(e, (n) => {
      if (!(a != null && a(n)))
        switch (n.localName) {
          case "jc":
            t["text-align"] = lt.valueOfJc(n);
            break;
          case "textAlignment":
            t["vertical-align"] = lt.valueOfTextAlignment(n);
            break;
          case "color":
            t.color = ut.colorAttr(n, "val", null, Wt.color);
            break;
          case "sz":
            t["font-size"] = t["min-height"] = E.lengthAttr(n, "val", pt.FontSize);
            break;
          case "shd":
            t["background-color"] = ut.colorAttr(n, "fill", null, Wt.shd);
            break;
          case "highlight":
            t["background-color"] = ut.colorAttr(n, "val", null, Wt.highlight);
            break;
          case "vertAlign":
            break;
          case "position":
            t.verticalAlign = E.lengthAttr(n, "val", pt.FontSize);
            break;
          case "tcW":
            if (this.options.ignoreWidth)
              break;
          case "tblW":
            t.width = lt.valueOfSize(n, "w");
            break;
          case "trHeight":
            this.parseTrHeight(n, t);
            break;
          case "strike":
            t["text-decoration"] = E.boolAttr(n, "val", !0) ? "line-through" : "none";
            break;
          case "b":
            t["font-weight"] = E.boolAttr(n, "val", !0) ? "bold" : "normal";
            break;
          case "i":
            t["font-style"] = E.boolAttr(n, "val", !0) ? "italic" : "normal";
            break;
          case "caps":
            t["text-transform"] = E.boolAttr(n, "val", !0) ? "uppercase" : "none";
            break;
          case "smallCaps":
            t["font-variant"] = E.boolAttr(n, "val", !0) ? "small-caps" : "none";
            break;
          case "u":
            this.parseUnderline(n, t);
            break;
          case "ind":
          case "tblInd":
            this.parseIndentation(n, t);
            break;
          case "rFonts":
            this.parseFont(n, t);
            break;
          case "tblBorders":
            this.parseBorderProperties(n, r || t);
            break;
          case "tblCellSpacing":
            t["border-spacing"] = lt.valueOfMargin(n), t["border-collapse"] = "separate";
            break;
          case "pBdr":
            this.parseBorderProperties(n, t);
            break;
          case "bdr":
            t.border = lt.valueOfBorder(n);
            break;
          case "tcBorders":
            this.parseBorderProperties(n, t);
            break;
          case "vanish":
            E.boolAttr(n, "val", !0) && (t.display = "none");
            break;
          case "kern":
            break;
          case "noWrap":
            break;
          case "tblCellMar":
          case "tcMar":
            this.parseMarginProperties(n, r || t);
            break;
          case "tblLayout":
            t["table-layout"] = lt.valueOfTblLayout(n);
            break;
          case "vAlign":
            t["vertical-align"] = lt.valueOfTextAlignment(n);
            break;
          case "spacing":
            e.localName == "pPr" && this.parseSpacing(n, t);
            break;
          case "wordWrap":
            E.boolAttr(n, "val") && (t["overflow-wrap"] = "break-word");
            break;
          case "suppressAutoHyphens":
            t.hyphens = E.boolAttr(n, "val", !0) ? "none" : "auto";
            break;
          case "lang":
            t.$lang = E.attr(n, "val");
            break;
          case "bCs":
          case "iCs":
          case "szCs":
          case "tabs":
          case "outlineLvl":
          case "contextualSpacing":
          case "tblStyleColBandSize":
          case "tblStyleRowBandSize":
          case "webHidden":
          case "pageBreakBefore":
          case "suppressLineNumbers":
          case "keepLines":
          case "keepNext":
          case "widowControl":
          case "bidi":
          case "rtl":
          case "noProof":
            break;
          default:
            this.options.debug && console.warn(`DOCX: Unknown document element: ${e.localName}.${n.localName}`);
            break;
        }
    }), t;
  }
  parseUnderline(e, t) {
    var r = E.attr(e, "val");
    if (r != null) {
      switch (r) {
        case "dash":
        case "dashDotDotHeavy":
        case "dashDotHeavy":
        case "dashedHeavy":
        case "dashLong":
        case "dashLongHeavy":
        case "dotDash":
        case "dotDotDash":
          t["text-decoration"] = "underline dashed";
          break;
        case "dotted":
        case "dottedHeavy":
          t["text-decoration"] = "underline dotted";
          break;
        case "double":
          t["text-decoration"] = "underline double";
          break;
        case "single":
        case "thick":
          t["text-decoration"] = "underline";
          break;
        case "wave":
        case "wavyDouble":
        case "wavyHeavy":
          t["text-decoration"] = "underline wavy";
          break;
        case "words":
          t["text-decoration"] = "underline";
          break;
        case "none":
          t["text-decoration"] = "none";
          break;
      }
      var a = ut.colorAttr(e, "color");
      a && (t["text-decoration-color"] = a);
    }
  }
  parseFont(e, t) {
    var r = E.attr(e, "ascii"), a = lt.themeValue(e, "asciiTheme"), n = [r, a].filter((o) => o).join(", ");
    n.length > 0 && (t["font-family"] = n);
  }
  parseIndentation(e, t) {
    var r = E.lengthAttr(e, "firstLine"), a = E.lengthAttr(e, "hanging"), n = E.lengthAttr(e, "left"), o = E.lengthAttr(e, "start"), l = E.lengthAttr(e, "right"), u = E.lengthAttr(e, "end");
    r && (t["text-indent"] = r), a && (t["text-indent"] = `-${a}`), (n || o) && (t["margin-left"] = n || o), (l || u) && (t["margin-right"] = l || u);
  }
  parseSpacing(e, t) {
    var r = E.lengthAttr(e, "before"), a = E.lengthAttr(e, "after"), n = E.intAttr(e, "line", null), o = E.attr(e, "lineRule");
    if (r && (t["margin-top"] = r), a && (t["margin-bottom"] = a), n !== null)
      switch (o) {
        case "auto":
          t["line-height"] = `${(n / 240).toFixed(2)}`;
          break;
        case "atLeast":
          t["line-height"] = `calc(100% + ${n / 20}pt)`;
          break;
        default:
          t["line-height"] = t["min-height"] = `${n / 20}pt`;
          break;
      }
  }
  parseMarginProperties(e, t) {
    ut.foreach(e, (r) => {
      switch (r.localName) {
        case "left":
          t["padding-left"] = lt.valueOfMargin(r);
          break;
        case "right":
          t["padding-right"] = lt.valueOfMargin(r);
          break;
        case "top":
          t["padding-top"] = lt.valueOfMargin(r);
          break;
        case "bottom":
          t["padding-bottom"] = lt.valueOfMargin(r);
          break;
      }
    });
  }
  parseTrHeight(e, t) {
    switch (E.attr(e, "hRule")) {
      case "exact":
        t.height = E.lengthAttr(e, "val");
        break;
      case "atLeast":
      default:
        t.height = E.lengthAttr(e, "val");
        break;
    }
  }
  parseBorderProperties(e, t) {
    ut.foreach(e, (r) => {
      switch (r.localName) {
        case "start":
        case "left":
          t["border-left"] = lt.valueOfBorder(r);
          break;
        case "end":
        case "right":
          t["border-right"] = lt.valueOfBorder(r);
          break;
        case "top":
          t["border-top"] = lt.valueOfBorder(r);
          break;
        case "bottom":
          t["border-bottom"] = lt.valueOfBorder(r);
          break;
      }
    });
  }
}
const Jr = ["black", "blue", "cyan", "darkBlue", "darkCyan", "darkGray", "darkGreen", "darkMagenta", "darkRed", "darkYellow", "green", "lightGray", "magenta", "none", "red", "white", "yellow"];
class ut {
  static foreach(e, t) {
    for (var r = 0; r < e.childNodes.length; r++) {
      let a = e.childNodes[r];
      a.nodeType == Node.ELEMENT_NODE && t(a);
    }
  }
  static colorAttr(e, t, r = null, a = "black") {
    var n = E.attr(e, t);
    if (n)
      return n == "auto" ? a : Jr.includes(n) ? n : `#${n}`;
    var o = E.attr(e, "themeColor");
    return o ? `var(--docx-${o}-color)` : r;
  }
  static sizeValue(e, t = pt.Dxa) {
    return ge(e.textContent, t);
  }
}
class lt {
  static themeValue(e, t) {
    var r = E.attr(e, t);
    return r ? `var(--docx-${r}-font)` : null;
  }
  static valueOfSize(e, t) {
    var r = pt.Dxa;
    switch (E.attr(e, "type")) {
      case "dxa":
        break;
      case "pct":
        r = pt.Percent;
        break;
      case "auto":
        return "auto";
    }
    return E.lengthAttr(e, t, r);
  }
  static valueOfMargin(e) {
    return E.lengthAttr(e, "w");
  }
  static valueOfBorder(e) {
    var t = E.attr(e, "val");
    if (t == "nil")
      return "none";
    var r = ut.colorAttr(e, "color"), a = E.lengthAttr(e, "sz", pt.Border);
    return `${a} solid ${r == "auto" ? Wt.borderColor : r}`;
  }
  static valueOfTblLayout(e) {
    var t = E.attr(e, "val");
    return t == "fixed" ? "fixed" : "auto";
  }
  static classNameOfCnfStyle(e) {
    const t = E.attr(e, "val");
    return [
      "first-row",
      "last-row",
      "first-col",
      "last-col",
      "odd-col",
      "even-col",
      "odd-row",
      "even-row",
      "ne-cell",
      "nw-cell",
      "se-cell",
      "sw-cell"
    ].filter((a, n) => t[n] == "1").join(" ");
  }
  static valueOfJc(e) {
    var t = E.attr(e, "val");
    switch (t) {
      case "start":
      case "left":
        return "left";
      case "center":
        return "center";
      case "end":
      case "right":
        return "right";
      case "both":
        return "justify";
    }
    return t;
  }
  static valueOfVertAlign(e, t = !1) {
    var r = E.attr(e, "val");
    switch (r) {
      case "subscript":
        return "sub";
      case "superscript":
        return t ? "sup" : "super";
    }
    return t ? null : r;
  }
  static valueOfTextAlignment(e) {
    var t = E.attr(e, "val");
    switch (t) {
      case "auto":
      case "baseline":
        return "baseline";
      case "top":
        return "top";
      case "center":
        return "middle";
      case "bottom":
        return "bottom";
    }
    return t;
  }
  static addSize(e, t) {
    return e == null ? t : t == null ? e : `calc(${e} + ${t})`;
  }
  static classNameOftblLook(e) {
    const t = E.hexAttr(e, "val", 0);
    let r = "";
    return (E.boolAttr(e, "firstRow") || t & 32) && (r += " first-row"), (E.boolAttr(e, "lastRow") || t & 64) && (r += " last-row"), (E.boolAttr(e, "firstColumn") || t & 128) && (r += " first-col"), (E.boolAttr(e, "lastColumn") || t & 256) && (r += " last-col"), (E.boolAttr(e, "noHBand") || t & 512) && (r += " no-hband"), (E.boolAttr(e, "noVBand") || t & 1024) && (r += " no-vband"), r.trim();
  }
}
const ue = { pos: 0, leader: "none", style: "left" }, Qr = 50;
function tn(i = document.body) {
  const e = document.createElement("div");
  e.style.width = "100pt", i.appendChild(e);
  const t = 100 / e.offsetWidth;
  return i.removeChild(e), t;
}
function en(i, e, t, r = 72 / 96) {
  const a = i.closest("p"), n = i.getBoundingClientRect(), o = a.getBoundingClientRect(), l = getComputedStyle(a), u = (e == null ? void 0 : e.length) > 0 ? e.map((v) => ({
    pos: he(v.position),
    leader: v.leader,
    style: v.style
  })).sort((v, x) => v.pos - x.pos) : [ue], g = u[u.length - 1], _ = o.width * r, k = he(t);
  let w = g.pos + k;
  if (w < _)
    for (; w < _ && u.length < Qr; w += k)
      u.push(Mt(vt({}, ue), { pos: w }));
  const d = parseFloat(l.marginLeft), y = o.left + d, h = (n.left - y) * r, m = u.find((v) => v.style != "clear" && v.pos > h);
  if (m == null)
    return;
  let f = 1;
  if (m.style == "right" || m.style == "center") {
    const v = Array.from(a.querySelectorAll(`.${i.className}`)), x = v.indexOf(i) + 1, A = document.createRange();
    A.setStart(i, 1), x < v.length ? A.setEndBefore(v[x]) : A.setEndAfter(a);
    const P = m.style == "center" ? 0.5 : 1, D = A.getBoundingClientRect(), O = D.left + P * D.width - (o.left - d);
    f = m.pos - O * r;
  } else
    f = m.pos - h;
  switch (i.innerHTML = "&nbsp;", i.style.textDecoration = "inherit", i.style.wordSpacing = `${f.toFixed(0)}pt`, m.leader) {
    case "dot":
    case "middleDot":
      i.style.textDecoration = "underline", i.style.textDecorationStyle = "dotted";
      break;
    case "hyphen":
    case "heavy":
    case "underscore":
      i.style.textDecoration = "underline";
      break;
  }
}
function he(i) {
  return parseFloat(i);
}
const nt = {
  svg: "http://www.w3.org/2000/svg",
  mathML: "http://www.w3.org/1998/Math/MathML"
};
class rn {
  constructor(e) {
    this.htmlDocument = e, this.className = "docx", this.styleMap = {}, this.currentPart = null, this.tableVerticalMerges = [], this.currentVerticalMerge = null, this.tableCellPositions = [], this.currentCellPosition = null, this.footnoteMap = {}, this.endnoteMap = {}, this.currentEndnoteIds = [], this.usedHederFooterParts = [], this.currentTabs = [], this.tabsTimeout = 0, this.tasks = [], this.createElement = Gt;
  }
  render(e, t, r = null, a) {
    var o;
    this.document = e, this.options = a, this.className = a.className, this.rootSelector = a.inWrapper ? `.${this.className}-wrapper` : ":root", this.styleMap = null, this.tasks = [], r = r || t, fe(r), fe(t), Ot(r, "docxjs library predefined styles"), r.appendChild(this.renderDefaultStyle()), e.themePart && (Ot(r, "docxjs document theme values"), this.renderTheme(e.themePart, r)), e.stylesPart != null && (this.styleMap = this.processStyles(e.stylesPart.styles), Ot(r, "docxjs document styles"), r.appendChild(this.renderStyles(e.stylesPart.styles))), e.numberingPart && (this.prodessNumberings(e.numberingPart.domNumberings), Ot(r, "docxjs document numbering styles"), r.appendChild(this.renderNumbering(e.numberingPart.domNumberings, r))), e.footnotesPart && (this.footnoteMap = Pt(e.footnotesPart.notes, (l) => l.id)), e.endnotesPart && (this.endnoteMap = Pt(e.endnotesPart.notes, (l) => l.id)), e.settingsPart && (this.defaultTabSize = (o = e.settingsPart.settings) == null ? void 0 : o.defaultTabStop), !a.ignoreFonts && e.fontTablePart && this.renderFontTable(e.fontTablePart, r);
    var n = this.renderSections(e.documentPart.body);
    this.options.inWrapper ? t.appendChild(this.renderWrapper(n)) : qt(t, n), this.refreshTabStops();
  }
  renderTheme(e, t) {
    var l, u;
    const r = {}, a = (l = e.theme) == null ? void 0 : l.fontScheme;
    a && (a.majorFont && (r["--docx-majorHAnsi-font"] = a.majorFont.latinTypeface), a.minorFont && (r["--docx-minorHAnsi-font"] = a.minorFont.latinTypeface));
    const n = (u = e.theme) == null ? void 0 : u.colorScheme;
    if (n)
      for (let [g, _] of Object.entries(n.colors))
        r[`--docx-${g}-color`] = `#${_}`;
    const o = this.styleToString(`.${this.className}`, r);
    t.appendChild(At(o));
  }
  renderFontTable(e, t) {
    for (let r of e.fonts)
      for (let a of r.embedFontRefs)
        this.tasks.push(this.document.loadFont(a.id, a.key).then((n) => {
          const o = {
            "font-family": r.name,
            src: `url(${n})`
          };
          (a.type == "bold" || a.type == "boldItalic") && (o["font-weight"] = "bold"), (a.type == "italic" || a.type == "boldItalic") && (o["font-style"] = "italic"), Ot(t, `docxjs ${r.name} font`);
          const l = this.styleToString("@font-face", o);
          t.appendChild(At(l)), this.refreshTabStops();
        }));
  }
  processStyleName(e) {
    return e ? `${this.className}_${nr(e)}` : this.className;
  }
  processStyles(e) {
    const t = Pt(e.filter((a) => a.id != null), (a) => a.id);
    for (const a of e.filter((n) => n.basedOn)) {
      var r = t[a.basedOn];
      if (r) {
        a.paragraphProps = Ht(a.paragraphProps, r.paragraphProps), a.runProps = Ht(a.runProps, r.runProps);
        for (const n of r.styles) {
          const o = a.styles.find((l) => l.target == n.target);
          o ? this.copyStyleProperties(n.values, o.values) : a.styles.push(Mt(vt({}, n), { values: vt({}, n.values) }));
        }
      } else
        this.options.debug && console.warn(`Can't find base style ${a.basedOn}`);
    }
    for (let a of e)
      a.cssName = this.processStyleName(a.id);
    return t;
  }
  prodessNumberings(e) {
    var t;
    for (let r of e.filter((a) => a.pStyleName)) {
      const a = this.findStyle(r.pStyleName);
      (t = a == null ? void 0 : a.paragraphProps) != null && t.numbering && (a.paragraphProps.numbering.level = r.level);
    }
  }
  processElement(e) {
    if (e.children)
      for (var t of e.children)
        t.parent = e, t.type == R.Table ? this.processTable(t) : this.processElement(t);
  }
  processTable(e) {
    for (var t of e.children)
      for (var r of t.children)
        r.cssStyle = this.copyStyleProperties(e.cellStyle, r.cssStyle, [
          "border-left",
          "border-right",
          "border-top",
          "border-bottom",
          "padding-left",
          "padding-right",
          "padding-top",
          "padding-bottom"
        ]), this.processElement(r);
  }
  copyStyleProperties(e, t, r = null) {
    if (!e)
      return t;
    t == null && (t = {}), r == null && (r = Object.getOwnPropertyNames(e));
    for (var a of r)
      e.hasOwnProperty(a) && !t.hasOwnProperty(a) && (t[a] = e[a]);
    return t;
  }
  createSection(e, t) {
    var r = this.createElement("section", { className: e });
    return t && (t.pageMargins && (r.style.paddingLeft = t.pageMargins.left, r.style.paddingRight = t.pageMargins.right, r.style.paddingTop = t.pageMargins.top, r.style.paddingBottom = t.pageMargins.bottom), t.pageSize && (this.options.ignoreWidth || (r.style.width = t.pageSize.width), this.options.ignoreHeight || (r.style.minHeight = t.pageSize.height)), t.columns && t.columns.numberOfColumns && (r.style.columnCount = `${t.columns.numberOfColumns}`, r.style.columnGap = t.columns.space, t.columns.separator && (r.style.columnRule = "1px solid black"))), r;
  }
  renderSections(e) {
    const t = [];
    this.processElement(e);
    const r = this.splitBySection(e.children);
    let a = null;
    for (let o = 0, l = r.length; o < l; o++) {
      this.currentFootnoteIds = [];
      const u = r[o], g = u.sectProps || e.props, _ = this.createSection(this.className, g);
      this.renderStyleValues(e.cssStyle, _), this.options.renderHeaders && this.renderHeaderFooter(g.headerRefs, g, t.length, a != g, _);
      var n = this.createElement("article");
      this.renderElements(u.elements, n), _.appendChild(n), this.options.renderFootnotes && this.renderNotes(this.currentFootnoteIds, this.footnoteMap, _), this.options.renderEndnotes && o == l - 1 && this.renderNotes(this.currentEndnoteIds, this.endnoteMap, _), this.options.renderFooters && this.renderHeaderFooter(g.footerRefs, g, t.length, a != g, _), t.push(_), a = g;
    }
    return t;
  }
  renderHeaderFooter(e, t, r, a, n) {
    var u, g;
    if (e) {
      var o = (g = (u = t.titlePage && a ? e.find((_) => _.type == "first") : null) != null ? u : r % 2 == 1 ? e.find((_) => _.type == "even") : null) != null ? g : e.find((_) => _.type == "default"), l = o && this.document.findPartByRelId(o.id, this.document.documentPart);
      if (l) {
        this.currentPart = l, this.usedHederFooterParts.includes(l.path) || (this.processElement(l.rootElement), this.usedHederFooterParts.push(l.path));
        const [_] = this.renderElements([l.rootElement], n);
        t != null && t.pageMargins && (l.rootElement.type === R.Header ? (_.style.marginTop = `calc(${t.pageMargins.header} - ${t.pageMargins.top})`, _.style.minHeight = `calc(${t.pageMargins.top} - ${t.pageMargins.header})`) : l.rootElement.type === R.Footer && (_.style.marginBottom = `calc(${t.pageMargins.footer} - ${t.pageMargins.bottom})`, _.style.minHeight = `calc(${t.pageMargins.bottom} - ${t.pageMargins.footer})`)), this.currentPart = null;
      }
    }
  }
  isPageBreakElement(e) {
    return e.type != R.Break ? !1 : e.break == "lastRenderedPageBreak" ? !this.options.ignoreLastRenderedPageBreak : e.break == "page";
  }
  splitBySection(e) {
    var _;
    var t = { sectProps: null, elements: [] }, r = [t];
    for (let k of e) {
      if (k.type == R.Paragraph) {
        const w = this.findStyle(k.styleName);
        (_ = w == null ? void 0 : w.paragraphProps) != null && _.pageBreakBefore && (t.sectProps = a, t = { sectProps: null, elements: [] }, r.push(t));
      }
      if (t.elements.push(k), k.type == R.Paragraph) {
        const w = k;
        var a = w.sectionProps, n = -1, o = -1;
        if (this.options.breakPages && w.children && (n = w.children.findIndex((d) => {
          var y, h;
          return o = (h = (y = d.children) == null ? void 0 : y.findIndex(this.isPageBreakElement.bind(this))) != null ? h : -1, o != -1;
        })), (a || n != -1) && (t.sectProps = a, t = { sectProps: null, elements: [] }, r.push(t)), n != -1) {
          let d = w.children[n], y = o < d.children.length - 1;
          if (n < w.children.length - 1 || y) {
            var l = k.children, u = Mt(vt({}, k), { children: l.slice(n) });
            if (k.children = l.slice(0, n), t.elements.push(u), y) {
              let h = d.children, m = Mt(vt({}, d), { children: h.slice(0, o) });
              k.children.push(m), d.children = h.slice(o);
            }
          }
        }
      }
    }
    let g = null;
    for (let k = r.length - 1; k >= 0; k--)
      r[k].sectProps == null ? r[k].sectProps = g : g = r[k].sectProps;
    return r;
  }
  renderWrapper(e) {
    return this.createElement("div", { className: `${this.className}-wrapper` }, e);
  }
  renderDefaultStyle() {
    var e = this.className, t = `
.${e}-wrapper { background: gray; padding: 30px; padding-bottom: 0px; display: flex; flex-flow: column; align-items: center; } 
.${e}-wrapper>section.${e} { background: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); margin-bottom: 30px; }
.${e} { color: black; hyphens: auto; text-underline-position: from-font; }
section.${e} { box-sizing: border-box; display: flex; flex-flow: column nowrap; position: relative; overflow: hidden; }
section.${e}>article { margin-bottom: auto; z-index: 1; }
section.${e}>footer { z-index: 1; }
.${e} table { border-collapse: collapse; }
.${e} table td, .${e} table th { vertical-align: top; }
.${e} p { margin: 0pt; min-height: 1em; }
.${e} span { white-space: pre-wrap; overflow-wrap: break-word; }
.${e} a { color: inherit; text-decoration: inherit; }
`;
    return At(t);
  }
  renderNumbering(e, t) {
    var r = "", a = [];
    for (var n of e) {
      var o = `p.${this.numberingClass(n.id, n.level)}`, l = "none";
      if (n.bullet) {
        let u = `--${this.className}-${n.bullet.src}`.toLowerCase();
        r += this.styleToString(`${o}:before`, {
          content: "' '",
          display: "inline-block",
          background: `var(${u})`
        }, n.bullet.style), this.tasks.push(this.document.loadNumberingImage(n.bullet.src).then((g) => {
          var _ = `${this.rootSelector} { ${u}: url(${g}) }`;
          t.appendChild(At(_));
        }));
      } else if (n.levelText) {
        let u = this.numberingCounter(n.id, n.level);
        const g = u + " " + (n.start - 1);
        n.level > 0 && (r += this.styleToString(`p.${this.numberingClass(n.id, n.level - 1)}`, {
          "counter-reset": g
        })), a.push(g), r += this.styleToString(`${o}:before`, vt({
          content: this.levelTextToContent(n.levelText, n.suff, n.id, this.numFormatToCssValue(n.format)),
          "counter-increment": u
        }, n.rStyle));
      } else
        l = this.numFormatToCssValue(n.format);
      r += this.styleToString(o, vt({
        display: "list-item",
        "list-style-position": "inside",
        "list-style-type": l
      }, n.pStyle));
    }
    return a.length > 0 && (r += this.styleToString(this.rootSelector, {
      "counter-reset": a.join(" ")
    })), At(r);
  }
  renderStyles(e) {
    var u;
    var t = "";
    const r = this.styleMap, a = Pt(e.filter((g) => g.isDefault), (g) => g.target);
    for (const g of e) {
      var n = g.styles;
      if (g.linked) {
        var o = g.linked && r[g.linked];
        o ? n = n.concat(o.styles) : this.options.debug && console.warn(`Can't find linked style ${g.linked}`);
      }
      for (const _ of n) {
        var l = `${(u = g.target) != null ? u : ""}.${g.cssName}`;
        g.target != _.target && (l += ` ${_.target}`), a[g.target] == g && (l = `.${this.className} ${g.target}, ` + l), t += this.styleToString(l, _.values);
      }
    }
    return At(t);
  }
  renderNotes(e, t, r) {
    var a = e.map((o) => t[o]).filter((o) => o);
    if (a.length > 0) {
      var n = this.createElement("ol", null, this.renderElements(a));
      r.appendChild(n);
    }
  }
  renderElement(e) {
    switch (e.type) {
      case R.Paragraph:
        return this.renderParagraph(e);
      case R.BookmarkStart:
        return this.renderBookmarkStart(e);
      case R.BookmarkEnd:
        return null;
      case R.Run:
        return this.renderRun(e);
      case R.Table:
        return this.renderTable(e);
      case R.Row:
        return this.renderTableRow(e);
      case R.Cell:
        return this.renderTableCell(e);
      case R.Hyperlink:
        return this.renderHyperlink(e);
      case R.Drawing:
        return this.renderDrawing(e);
      case R.Image:
        return this.renderImage(e);
      case R.Text:
        return this.renderText(e);
      case R.Text:
        return this.renderText(e);
      case R.DeletedText:
        return this.renderDeletedText(e);
      case R.Tab:
        return this.renderTab(e);
      case R.Symbol:
        return this.renderSymbol(e);
      case R.Break:
        return this.renderBreak(e);
      case R.Footer:
        return this.renderContainer(e, "footer");
      case R.Header:
        return this.renderContainer(e, "header");
      case R.Footnote:
      case R.Endnote:
        return this.renderContainer(e, "li");
      case R.FootnoteReference:
        return this.renderFootnoteReference(e);
      case R.EndnoteReference:
        return this.renderEndnoteReference(e);
      case R.NoBreakHyphen:
        return this.createElement("wbr");
      case R.VmlPicture:
        return this.renderVmlPicture(e);
      case R.VmlElement:
        return this.renderVmlElement(e);
      case R.MmlMath:
        return this.renderContainerNS(e, nt.mathML, "math", { xmlns: nt.mathML });
      case R.MmlMathParagraph:
        return this.renderContainer(e, "span");
      case R.MmlFraction:
        return this.renderContainerNS(e, nt.mathML, "mfrac");
      case R.MmlBase:
        return this.renderContainerNS(e, nt.mathML, e.parent.type == R.MmlMatrixRow ? "mtd" : "mrow");
      case R.MmlNumerator:
      case R.MmlDenominator:
      case R.MmlFunction:
      case R.MmlLimit:
      case R.MmlBox:
        return this.renderContainerNS(e, nt.mathML, "mrow");
      case R.MmlGroupChar:
        return this.renderMmlGroupChar(e);
      case R.MmlLimitLower:
        return this.renderContainerNS(e, nt.mathML, "munder");
      case R.MmlMatrix:
        return this.renderContainerNS(e, nt.mathML, "mtable");
      case R.MmlMatrixRow:
        return this.renderContainerNS(e, nt.mathML, "mtr");
      case R.MmlRadical:
        return this.renderMmlRadical(e);
      case R.MmlSuperscript:
        return this.renderContainerNS(e, nt.mathML, "msup");
      case R.MmlSubscript:
        return this.renderContainerNS(e, nt.mathML, "msub");
      case R.MmlDegree:
      case R.MmlSuperArgument:
      case R.MmlSubArgument:
        return this.renderContainerNS(e, nt.mathML, "mn");
      case R.MmlFunctionName:
        return this.renderContainerNS(e, nt.mathML, "ms");
      case R.MmlDelimiter:
        return this.renderMmlDelimiter(e);
      case R.MmlRun:
        return this.renderMmlRun(e);
      case R.MmlNary:
        return this.renderMmlNary(e);
      case R.MmlPreSubSuper:
        return this.renderMmlPreSubSuper(e);
      case R.MmlBar:
        return this.renderMmlBar(e);
      case R.MmlEquationArray:
        return this.renderMllList(e);
      case R.Inserted:
        return this.renderInserted(e);
      case R.Deleted:
        return this.renderDeleted(e);
    }
    return null;
  }
  renderChildren(e, t) {
    return this.renderElements(e.children, t);
  }
  renderElements(e, t) {
    if (e == null)
      return null;
    var r = e.flatMap((a) => this.renderElement(a)).filter((a) => a != null);
    return t && qt(t, r), r;
  }
  renderContainer(e, t, r) {
    return this.createElement(t, r, this.renderChildren(e));
  }
  renderContainerNS(e, t, r, a) {
    return ct(t, r, a, this.renderChildren(e));
  }
  renderParagraph(e) {
    var n, o, l, u;
    var t = this.createElement("p");
    const r = this.findStyle(e.styleName);
    (o = e.tabs) != null || (e.tabs = (n = r == null ? void 0 : r.paragraphProps) == null ? void 0 : n.tabs), this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.renderCommonProperties(t.style, e);
    const a = (u = e.numbering) != null ? u : (l = r == null ? void 0 : r.paragraphProps) == null ? void 0 : l.numbering;
    return a && t.classList.add(this.numberingClass(a.id, a.level)), t;
  }
  renderRunProperties(e, t) {
    this.renderCommonProperties(e, t);
  }
  renderCommonProperties(e, t) {
    t != null && (t.color && (e.color = t.color), t.fontSize && (e["font-size"] = t.fontSize));
  }
  renderHyperlink(e) {
    var t = this.createElement("a");
    if (this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), e.href)
      t.href = e.href;
    else if (e.id) {
      const r = this.document.documentPart.rels.find((a) => a.id == e.id && a.targetMode === "External");
      t.href = r == null ? void 0 : r.target;
    }
    return t;
  }
  renderDrawing(e) {
    var t = this.createElement("div");
    return t.style.display = "inline-block", t.style.position = "relative", t.style.textIndent = "0px", this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), t;
  }
  renderImage(e) {
    let t = this.createElement("img");
    return this.renderStyleValues(e.cssStyle, t), this.document && this.tasks.push(this.document.loadDocumentImage(e.src, this.currentPart).then((r) => {
      t.src = r;
    })), t;
  }
  renderText(e) {
    return this.htmlDocument.createTextNode(e.text);
  }
  renderDeletedText(e) {
    return this.options.renderEndnotes ? this.htmlDocument.createTextNode(e.text) : null;
  }
  renderBreak(e) {
    return e.break == "textWrapping" ? this.createElement("br") : null;
  }
  renderInserted(e) {
    return this.options.renderChanges ? this.renderContainer(e, "ins") : this.renderChildren(e);
  }
  renderDeleted(e) {
    return this.options.renderChanges ? this.renderContainer(e, "del") : null;
  }
  renderSymbol(e) {
    var t = this.createElement("span");
    return t.style.fontFamily = e.font, t.innerHTML = `&#x${e.char};`, t;
  }
  renderFootnoteReference(e) {
    var t = this.createElement("sup");
    return this.currentFootnoteIds.push(e.id), t.textContent = `${this.currentFootnoteIds.length}`, t;
  }
  renderEndnoteReference(e) {
    var t = this.createElement("sup");
    return this.currentEndnoteIds.push(e.id), t.textContent = `${this.currentEndnoteIds.length}`, t;
  }
  renderTab(e) {
    var a;
    var t = this.createElement("span");
    if (t.innerHTML = "&emsp;", this.options.experimental) {
      t.className = this.tabStopClass();
      var r = (a = nn(e, R.Paragraph)) == null ? void 0 : a.tabs;
      this.currentTabs.push({ stops: r, span: t });
    }
    return t;
  }
  renderBookmarkStart(e) {
    var t = this.createElement("span");
    return t.id = e.name, t;
  }
  renderRun(e) {
    if (e.fieldRun)
      return null;
    const t = this.createElement("span");
    if (e.id && (t.id = e.id), this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), e.verticalAlign) {
      const r = this.createElement(e.verticalAlign);
      this.renderChildren(e, r), t.appendChild(r);
    } else
      this.renderChildren(e, t);
    return t;
  }
  renderTable(e) {
    let t = this.createElement("table");
    return this.tableCellPositions.push(this.currentCellPosition), this.tableVerticalMerges.push(this.currentVerticalMerge), this.currentVerticalMerge = {}, this.currentCellPosition = { col: 0, row: 0 }, e.columns && t.appendChild(this.renderTableColumns(e.columns)), this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.currentVerticalMerge = this.tableVerticalMerges.pop(), this.currentCellPosition = this.tableCellPositions.pop(), t;
  }
  renderTableColumns(e) {
    let t = this.createElement("colgroup");
    for (let r of e) {
      let a = this.createElement("col");
      r.width && (a.style.width = r.width), t.appendChild(a);
    }
    return t;
  }
  renderTableRow(e) {
    let t = this.createElement("tr");
    return this.currentCellPosition.col = 0, this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), this.currentCellPosition.row++, t;
  }
  renderTableCell(e) {
    let t = this.createElement("td");
    const r = this.currentCellPosition.col;
    return e.verticalMerge ? e.verticalMerge == "restart" ? (this.currentVerticalMerge[r] = t, t.rowSpan = 1) : this.currentVerticalMerge[r] && (this.currentVerticalMerge[r].rowSpan += 1, t.style.display = "none") : this.currentVerticalMerge[r] = null, this.renderClass(e, t), this.renderChildren(e, t), this.renderStyleValues(e.cssStyle, t), e.span && (t.colSpan = e.span), this.currentCellPosition.col += t.colSpan, t;
  }
  renderVmlPicture(e) {
    var t = Gt("div");
    return this.renderChildren(e, t), t;
  }
  renderVmlElement(e) {
    var a, n;
    var t = de("svg");
    t.setAttribute("style", e.cssStyleText);
    const r = this.renderVmlChildElement(e);
    return (a = e.imageHref) != null && a.id && this.tasks.push((n = this.document) == null ? void 0 : n.loadDocumentImage(e.imageHref.id, this.currentPart).then((o) => r.setAttribute("href", o))), t.appendChild(r), requestAnimationFrame(() => {
      const o = t.firstElementChild.getBBox();
      t.setAttribute("width", `${Math.ceil(o.x + o.width)}`), t.setAttribute("height", `${Math.ceil(o.y + o.height)}`);
    }), t;
  }
  renderVmlChildElement(e) {
    const t = de(e.tagName);
    Object.entries(e.attrs).forEach(([r, a]) => t.setAttribute(r, a));
    for (let r of e.children)
      r.type == R.VmlElement ? t.appendChild(this.renderVmlChildElement(r)) : t.appendChild(...Rt(this.renderElement(r)));
    return t;
  }
  renderMmlRadical(e) {
    var a;
    const t = e.children.find((n) => n.type == R.MmlBase);
    if ((a = e.props) != null && a.hideDegree)
      return ct(nt.mathML, "msqrt", null, this.renderElements([t]));
    const r = e.children.find((n) => n.type == R.MmlDegree);
    return ct(nt.mathML, "mroot", null, this.renderElements([t, r]));
  }
  renderMmlDelimiter(e) {
    var r, a;
    const t = [];
    return t.push(ct(nt.mathML, "mo", null, [(r = e.props.beginChar) != null ? r : "("])), t.push(...this.renderElements(e.children)), t.push(ct(nt.mathML, "mo", null, [(a = e.props.endChar) != null ? a : ")"])), ct(nt.mathML, "mrow", null, t);
  }
  renderMmlNary(e) {
    var g, _;
    const t = [], r = Pt(e.children, (k) => k.type), a = r[R.MmlSuperArgument], n = r[R.MmlSubArgument], o = a ? ct(nt.mathML, "mo", null, Rt(this.renderElement(a))) : null, l = n ? ct(nt.mathML, "mo", null, Rt(this.renderElement(n))) : null, u = ct(nt.mathML, "mo", null, [(_ = (g = e.props) == null ? void 0 : g.char) != null ? _ : "∫"]);
    return o || l ? t.push(ct(nt.mathML, "munderover", null, [u, l, o])) : o ? t.push(ct(nt.mathML, "mover", null, [u, o])) : l ? t.push(ct(nt.mathML, "munder", null, [u, l])) : t.push(u), t.push(...this.renderElements(r[R.MmlBase].children)), ct(nt.mathML, "mrow", null, t);
  }
  renderMmlPreSubSuper(e) {
    const t = [], r = Pt(e.children, (g) => g.type), a = r[R.MmlSuperArgument], n = r[R.MmlSubArgument], o = a ? ct(nt.mathML, "mo", null, Rt(this.renderElement(a))) : null, l = n ? ct(nt.mathML, "mo", null, Rt(this.renderElement(n))) : null, u = ct(nt.mathML, "mo", null);
    return t.push(ct(nt.mathML, "msubsup", null, [u, l, o])), t.push(...this.renderElements(r[R.MmlBase].children)), ct(nt.mathML, "mrow", null, t);
  }
  renderMmlGroupChar(e) {
    const t = e.props.verticalJustification === "bot" ? "mover" : "munder", r = this.renderContainerNS(e, nt.mathML, t);
    return e.props.char && r.appendChild(ct(nt.mathML, "mo", null, [e.props.char])), r;
  }
  renderMmlBar(e) {
    const t = this.renderContainerNS(e, nt.mathML, "mrow");
    switch (e.props.position) {
      case "top":
        t.style.textDecoration = "overline";
        break;
      case "bottom":
        t.style.textDecoration = "underline";
        break;
    }
    return t;
  }
  renderMmlRun(e) {
    const t = ct(nt.mathML, "ms");
    return this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.renderChildren(e, t), t;
  }
  renderMllList(e) {
    const t = ct(nt.mathML, "mtable");
    this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.renderChildren(e);
    for (let r of this.renderChildren(e))
      t.appendChild(ct(nt.mathML, "mtr", null, [
        ct(nt.mathML, "mtd", null, [r])
      ]));
    return t;
  }
  renderStyleValues(e, t) {
    for (let r in e)
      r.startsWith("$") ? t.setAttribute(r.slice(1), e[r]) : t.style[r] = e[r];
  }
  renderClass(e, t) {
    e.className && (t.className = e.className), e.styleName && t.classList.add(this.processStyleName(e.styleName));
  }
  findStyle(e) {
    var t;
    return e && ((t = this.styleMap) == null ? void 0 : t[e]);
  }
  numberingClass(e, t) {
    return `${this.className}-num-${e}-${t}`;
  }
  tabStopClass() {
    return `${this.className}-tab-stop`;
  }
  styleToString(e, t, r = null) {
    let a = `${e} {\r
`;
    for (const n in t)
      n.startsWith("$") || (a += `  ${n}: ${t[n]};\r
`);
    return r && (a += r), a + `}\r
`;
  }
  numberingCounter(e, t) {
    return `${this.className}-num-${e}-${t}`;
  }
  levelTextToContent(e, t, r, a) {
    var l;
    const n = {
      tab: "\\9",
      space: "\\a0"
    };
    var o = e.replace(/%\d*/g, (u) => {
      let g = parseInt(u.substring(1), 10) - 1;
      return `"counter(${this.numberingCounter(r, g)}, ${a})"`;
    });
    return `"${o}${(l = n[t]) != null ? l : ""}"`;
  }
  numFormatToCssValue(e) {
    var r;
    var t = {
      none: "none",
      bullet: "disc",
      decimal: "decimal",
      lowerLetter: "lower-alpha",
      upperLetter: "upper-alpha",
      lowerRoman: "lower-roman",
      upperRoman: "upper-roman",
      decimalZero: "decimal-leading-zero",
      aiueo: "katakana",
      aiueoFullWidth: "katakana",
      chineseCounting: "simp-chinese-informal",
      chineseCountingThousand: "simp-chinese-informal",
      chineseLegalSimplified: "simp-chinese-formal",
      chosung: "hangul-consonant",
      ideographDigital: "cjk-ideographic",
      ideographTraditional: "cjk-heavenly-stem",
      ideographLegalTraditional: "trad-chinese-formal",
      ideographZodiac: "cjk-earthly-branch",
      iroha: "katakana-iroha",
      irohaFullWidth: "katakana-iroha",
      japaneseCounting: "japanese-informal",
      japaneseDigitalTenThousand: "cjk-decimal",
      japaneseLegal: "japanese-formal",
      thaiNumbers: "thai",
      koreanCounting: "korean-hangul-formal",
      koreanDigital: "korean-hangul-formal",
      koreanDigital2: "korean-hanja-informal",
      hebrew1: "hebrew",
      hebrew2: "hebrew",
      hindiNumbers: "devanagari",
      ganada: "hangul",
      taiwaneseCounting: "cjk-ideographic",
      taiwaneseCountingThousand: "cjk-ideographic",
      taiwaneseDigital: "cjk-decimal"
    };
    return (r = t[e]) != null ? r : e;
  }
  refreshTabStops() {
    this.options.experimental && (clearTimeout(this.tabsTimeout), this.tabsTimeout = setTimeout(() => {
      const e = tn();
      for (let t of this.currentTabs)
        en(t.span, t.stops, this.defaultTabSize, e);
    }, 500));
  }
}
function Gt(i, e, t) {
  return ct(void 0, i, e, t);
}
function de(i, e, t) {
  return ct(nt.svg, i, e, t);
}
function ct(i, e, t, r) {
  var a = i ? document.createElementNS(i, e) : document.createElement(e);
  return Object.assign(a, t), r && qt(a, r), a;
}
function fe(i) {
  i.innerHTML = "";
}
function qt(i, e) {
  e.forEach((t) => i.appendChild(sr(t) ? document.createTextNode(t) : t));
}
function At(i) {
  return Gt("style", { innerHTML: i });
}
function Ot(i, e) {
  i.appendChild(document.createComment(e));
}
function nn(i, e) {
  for (var t = i.parent; t != null && t.type != e; )
    t = t.parent;
  return t;
}
const Ae = {
  ignoreHeight: !1,
  ignoreWidth: !1,
  ignoreFonts: !1,
  breakPages: !0,
  debug: !1,
  experimental: !1,
  className: "docx",
  inWrapper: !0,
  trimXmlDeclaration: !0,
  ignoreLastRenderedPageBreak: !0,
  renderHeaders: !0,
  renderFooters: !0,
  renderFootnotes: !0,
  renderEndnotes: !0,
  useBase64URL: !1,
  renderChanges: !1
};
function an(i, e) {
  const t = vt(vt({}, Ae), e);
  return Qt.load(i, new Yr(t), t);
}
function sn(i, e, t, r) {
  return yt(this, null, function* () {
    const a = vt(vt({}, Ae), r), n = new rn(window.document);
    return n.render(i, e, t, a), Promise.allSettled(n.tasks.filter((o) => o));
  });
}
function on(i, e, t, r) {
  return yt(this, null, function* () {
    const a = yield an(i, r);
    return yield sn(a, e, t, r), a;
  });
}
const ln = {
  ignoreLastRenderedPageBreak: !1
};
function cn(i, e = {}) {
  return typeof i == "string" ? un(i, e) : Promise.resolve(i);
}
function un(i, e) {
  return fetch(i, e).then((t) => t.status !== 200 ? Promise.reject(t) : t);
}
function hn(i) {
  return yt(this, null, function* () {
    let e;
    return i instanceof Blob ? e = i : i instanceof Response ? e = yield i.blob() : i instanceof ArrayBuffer && (e = new Blob([i])), e;
  });
}
function dn(i, e, t = {}) {
  if (!i)
    return e.innerHTML = "", Promise.resolve();
  let r;
  return i instanceof Blob ? r = i : i instanceof Response ? r = i.blob() : i instanceof ArrayBuffer && (r = new Blob([i])), on(r, e, e, vt(vt({}, ln), t));
}
const Et = {
  getData: cn,
  render: dn,
  getBlob: hn
};
function fn(i, e) {
  return yt(this, null, function* () {
    e && (e instanceof ArrayBuffer && (e = new Blob([e])), pn(i, URL.createObjectURL(e)));
  });
}
function pn(i, e) {
  let t = document.createElement("a");
  t.download = i, t.style.display = "none", t.href = e, document.body.appendChild(t), t.click(), document.body.removeChild(t);
}
const mn = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, a] of e)
    t[r] = a;
  return t;
}, gn = Fe({
  name: "VueOfficeDocx",
  props: {
    src: [String, ArrayBuffer, Blob],
    requestOptions: {
      type: Object,
      default: () => ({})
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["rendered", "error"],
  setup(i, { emit: e }) {
    const t = Ie(null);
    let r = null;
    function a() {
      let o = t.value;
      Et.getData(i.src, i.requestOptions).then((l) => yt(this, null, function* () {
        r = yield Et.getBlob(l), Et.render(r, o, i.options).then(() => {
          e("rendered");
        }).catch((u) => {
          Et.render("", o, i.options), e("error", u);
        });
      })).catch((l) => {
        Et.render("", o, i.options), e("error", l);
      });
    }
    De(() => {
      i.src && a();
    }), Le(() => i.src, () => {
      i.src ? a() : Et.render("", t.value, i.options).then(() => {
        e("rendered");
      });
    });
    function n(o) {
      fn(o || `vue-office-docx-${(/* @__PURE__ */ new Date()).getTime()}.docx`, r);
    }
    return {
      rootRef: t,
      save: n
    };
  }
}), bn = { class: "vue-office-docx" }, vn = {
  class: "vue-office-docx-main",
  ref: "rootRef"
};
function yn(i, e, t, r, a, n) {
  return je(), Ue("div", bn, [
    We("div", vn, null, 512)
  ]);
}
const Xt = /* @__PURE__ */ mn(gn, [["render", yn]]);
Xt.install = function(i) {
  i.component(Xt.name, Xt);
};
export {
  Xt as default
};
