import { defineComponent, ref, onMounted, nextTick, onBeforeUnmount, watch } from "vue-demi";
import { openBlock, createElementBlock, createElementVNode } from "vue";
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function toPrimitive(t2, r) {
  if ("object" != _typeof$2(t2) || !t2)
    return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r || "default");
    if ("object" != _typeof$2(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof$2(i) ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r, l) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t2 = t2.call(r)).next, 0 === l) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t2)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$4(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest();
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableRest();
}
var Element = /* @__PURE__ */ function() {
  function Element2(tag) {
    var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    _classCallCheck(this, Element2);
    if (typeof tag === "string") {
      this.el = document.createElement(tag);
      this.el.className = className;
    } else {
      this.el = tag;
    }
    this.data = {};
  }
  _createClass(Element2, [{
    key: "data",
    value: function data(key, value) {
      if (value !== void 0) {
        this.data[key] = value;
        return this;
      }
      return this.data[key];
    }
  }, {
    key: "on",
    value: function on(eventNames, handler) {
      var _eventNames$split = eventNames.split("."), _eventNames$split2 = _toArray(_eventNames$split), fen = _eventNames$split2[0], oen = _eventNames$split2.slice(1);
      var eventName = fen;
      if (eventName === "mousewheel" && /Firefox/i.test(window.navigator.userAgent)) {
        eventName = "DOMMouseScroll";
      }
      this.el.addEventListener(eventName, function(evt) {
        handler(evt);
        for (var i = 0; i < oen.length; i += 1) {
          var k = oen[i];
          if (k === "left" && evt.button !== 0) {
            return;
          }
          if (k === "right" && evt.button !== 2) {
            return;
          }
          if (k === "stop") {
            evt.stopPropagation();
          }
        }
      });
      return this;
    }
  }, {
    key: "offset",
    value: function offset(value) {
      var _this = this;
      if (value !== void 0) {
        Object.keys(value).forEach(function(k) {
          _this.css(k, "".concat(value[k], "px"));
        });
        return this;
      }
      var _this$el = this.el, offsetTop = _this$el.offsetTop, offsetLeft = _this$el.offsetLeft, offsetHeight = _this$el.offsetHeight, offsetWidth = _this$el.offsetWidth;
      return {
        top: offsetTop,
        left: offsetLeft,
        height: offsetHeight,
        width: offsetWidth
      };
    }
  }, {
    key: "scroll",
    value: function scroll(v) {
      var el = this.el;
      if (v !== void 0) {
        if (v.left !== void 0) {
          el.scrollLeft = v.left;
        }
        if (v.top !== void 0) {
          el.scrollTop = v.top;
        }
      }
      return {
        left: el.scrollLeft,
        top: el.scrollTop
      };
    }
  }, {
    key: "box",
    value: function box() {
      return this.el.getBoundingClientRect();
    }
  }, {
    key: "parent",
    value: function parent() {
      return new Element2(this.el.parentNode);
    }
  }, {
    key: "children",
    value: function children() {
      var _this2 = this;
      for (var _len = arguments.length, eles = new Array(_len), _key = 0; _key < _len; _key++) {
        eles[_key] = arguments[_key];
      }
      if (arguments.length === 0) {
        return this.el.childNodes;
      }
      eles.forEach(function(ele) {
        return _this2.child(ele);
      });
      return this;
    }
  }, {
    key: "removeChild",
    value: function removeChild(el) {
      this.el.removeChild(el);
    }
    /*
    first() {
      return this.el.firstChild;
    }
     last() {
      return this.el.lastChild;
    }
     remove(ele) {
      return this.el.removeChild(ele);
    }
     prepend(ele) {
      const { el } = this;
      if (el.children.length > 0) {
        el.insertBefore(ele, el.firstChild);
      } else {
        el.appendChild(ele);
      }
      return this;
    }
     prev() {
      return this.el.previousSibling;
    }
     next() {
      return this.el.nextSibling;
    }
    */
  }, {
    key: "child",
    value: function child(arg) {
      var ele = arg;
      if (typeof arg === "string") {
        ele = document.createTextNode(arg);
      } else if (arg instanceof Element2) {
        ele = arg.el;
      }
      this.el.appendChild(ele);
      return this;
    }
  }, {
    key: "contains",
    value: function contains(ele) {
      return this.el.contains(ele);
    }
  }, {
    key: "className",
    value: function className(v) {
      if (v !== void 0) {
        this.el.className = v;
        return this;
      }
      return this.el.className;
    }
  }, {
    key: "addClass",
    value: function addClass(name) {
      this.el.classList.add(name);
      return this;
    }
  }, {
    key: "hasClass",
    value: function hasClass(name) {
      return this.el.classList.contains(name);
    }
  }, {
    key: "removeClass",
    value: function removeClass(name) {
      this.el.classList.remove(name);
      return this;
    }
  }, {
    key: "toggle",
    value: function toggle() {
      var cls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "active";
      return this.toggleClass(cls);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(name) {
      return this.el.classList.toggle(name);
    }
  }, {
    key: "active",
    value: function active() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var cls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "active";
      if (flag)
        this.addClass(cls);
      else
        this.removeClass(cls);
      return this;
    }
  }, {
    key: "checked",
    value: function checked() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.active(flag, "checked");
      return this;
    }
  }, {
    key: "disabled",
    value: function disabled() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (flag)
        this.addClass("disabled");
      else
        this.removeClass("disabled");
      return this;
    }
    // key, value
    // key
    // {k, v}...
  }, {
    key: "attr",
    value: function attr(key, value) {
      var _this3 = this;
      if (value !== void 0) {
        this.el.setAttribute(key, value);
      } else {
        if (typeof key === "string") {
          return this.el.getAttribute(key);
        }
        Object.keys(key).forEach(function(k) {
          _this3.el.setAttribute(k, key[k]);
        });
      }
      return this;
    }
  }, {
    key: "removeAttr",
    value: function removeAttr(key) {
      this.el.removeAttribute(key);
      return this;
    }
  }, {
    key: "html",
    value: function html(content) {
      if (content !== void 0) {
        this.el.innerHTML = content;
        return this;
      }
      return this.el.innerHTML;
    }
  }, {
    key: "val",
    value: function val(v) {
      if (v !== void 0) {
        this.el.value = v;
        return this;
      }
      return this.el.value;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.el.focus();
    }
  }, {
    key: "cssRemoveKeys",
    value: function cssRemoveKeys() {
      var _this4 = this;
      for (var _len2 = arguments.length, keys2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        keys2[_key2] = arguments[_key2];
      }
      keys2.forEach(function(k) {
        return _this4.el.style.removeProperty(k);
      });
      return this;
    }
    // css( propertyName )
    // css( propertyName, value )
    // css( properties )
  }, {
    key: "css",
    value: function css(name, value) {
      var _this5 = this;
      if (value === void 0 && typeof name !== "string") {
        Object.keys(name).forEach(function(k) {
          _this5.el.style[k] = name[k];
        });
        return this;
      }
      if (value !== void 0) {
        this.el.style[name] = value;
        return this;
      }
      return this.el.style[name];
    }
  }, {
    key: "computedStyle",
    value: function computedStyle() {
      return window.getComputedStyle(this.el, null);
    }
  }, {
    key: "show",
    value: function show() {
      this.css("display", "block");
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.css("display", "none");
      return this;
    }
  }]);
  return Element2;
}();
var h = function h2(tag) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Element(tag, className);
};
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$4(arr);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();
}
var alphabets = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
function stringAt(index2) {
  var str = "";
  var cindex = index2;
  while (cindex >= alphabets.length) {
    cindex /= alphabets.length;
    cindex -= 1;
    str += alphabets[parseInt(cindex, 10) % alphabets.length];
  }
  var last = index2 % alphabets.length;
  str += alphabets[last];
  return str;
}
function indexAt(str) {
  var ret = 0;
  for (var i = 0; i < str.length - 1; i += 1) {
    var cindex = str.charCodeAt(i) - 65;
    var exponet = str.length - 1 - i;
    ret += Math.pow(alphabets.length, exponet) + alphabets.length * cindex;
  }
  ret += str.charCodeAt(str.length - 1) - 65;
  return ret;
}
function expr2xy(src) {
  var x = "";
  var y = "";
  for (var i = 0; i < src.length; i += 1) {
    if (src.charAt(i) >= "0" && src.charAt(i) <= "9") {
      y += src.charAt(i);
    } else {
      x += src.charAt(i);
    }
  }
  return [indexAt(x), parseInt(y, 10) - 1];
}
function xy2expr(x, y) {
  return "".concat(stringAt(x)).concat(y + 1);
}
function expr2expr(src, xn, yn) {
  var condition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
    return true;
  };
  if (xn === 0 && yn === 0)
    return src;
  var _expr2xy = expr2xy(src), _expr2xy2 = _slicedToArray(_expr2xy, 2), x = _expr2xy2[0], y = _expr2xy2[1];
  if (!condition(x, y))
    return src;
  return xy2expr(x + xn, y + yn);
}
var CellRange = /* @__PURE__ */ function() {
  function CellRange2(sri, sci, eri, eci) {
    var w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var h3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    _classCallCheck(this, CellRange2);
    this.sri = sri;
    this.sci = sci;
    this.eri = eri;
    this.eci = eci;
    this.w = w;
    this.h = h3;
  }
  _createClass(CellRange2, [{
    key: "set",
    value: function set(sri, sci, eri, eci) {
      this.sri = sri;
      this.sci = sci;
      this.eri = eri;
      this.eci = eci;
    }
  }, {
    key: "multiple",
    value: function multiple() {
      return this.eri - this.sri > 0 || this.eci - this.sci > 0;
    }
    // cell-index: ri, ci
    // cell-ref: A10
  }, {
    key: "includes",
    value: function includes() {
      var ri = 0, ci = 0;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1) {
        var _expr2xy = expr2xy(args[0]);
        var _expr2xy2 = _slicedToArray(_expr2xy, 2);
        ci = _expr2xy2[0];
        ri = _expr2xy2[1];
      } else if (args.length === 2) {
        ri = args[0];
        ci = args[1];
      }
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      return sri <= ri && ri <= eri && sci <= ci && ci <= eci;
    }
  }, {
    key: "each",
    value: function each(cb) {
      var rowFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      for (var i = sri; i <= eri; i += 1) {
        if (rowFilter(i)) {
          for (var j = sci; j <= eci; j += 1) {
            cb(i, j);
          }
        }
      }
    }
  }, {
    key: "contains",
    value: function contains(other) {
      return this.sri <= other.sri && this.sci <= other.sci && this.eri >= other.eri && this.eci >= other.eci;
    }
    // within
  }, {
    key: "within",
    value: function within(other) {
      return this.sri >= other.sri && this.sci >= other.sci && this.eri <= other.eri && this.eci <= other.eci;
    }
    // disjoint
  }, {
    key: "disjoint",
    value: function disjoint(other) {
      return this.sri > other.eri || this.sci > other.eci || other.sri > this.eri || other.sci > this.eci;
    }
    // intersects
  }, {
    key: "intersects",
    value: function intersects(other) {
      return this.sri <= other.eri && this.sci <= other.eci && other.sri <= this.eri && other.sci <= this.eci;
    }
    // union
  }, {
    key: "union",
    value: function union(other) {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      return new CellRange2(other.sri < sri ? other.sri : sri, other.sci < sci ? other.sci : sci, other.eri > eri ? other.eri : eri, other.eci > eci ? other.eci : eci);
    }
    // intersection
    // intersection(other) {}
    // Returns Array<CellRange> that represents that part of this that does not intersect with other
    // difference
  }, {
    key: "difference",
    value: function difference(other) {
      var ret = [];
      var addRet = function addRet2(sri2, sci2, eri2, eci2) {
        ret.push(new CellRange2(sri2, sci2, eri2, eci2));
      };
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      var dsr = other.sri - sri;
      var dsc = other.sci - sci;
      var der = eri - other.eri;
      var dec2 = eci - other.eci;
      if (dsr > 0) {
        addRet(sri, sci, other.sri - 1, eci);
        if (der > 0) {
          addRet(other.eri + 1, sci, eri, eci);
          if (dsc > 0) {
            addRet(other.sri, sci, other.eri, other.sci - 1);
          }
          if (dec2 > 0) {
            addRet(other.sri, other.eci + 1, other.eri, eci);
          }
        } else {
          if (dsc > 0) {
            addRet(other.sri, sci, eri, other.sci - 1);
          }
          if (dec2 > 0) {
            addRet(other.sri, other.eci + 1, eri, eci);
          }
        }
      } else if (der > 0) {
        addRet(other.eri + 1, sci, eri, eci);
        if (dsc > 0) {
          addRet(sri, sci, other.eri, other.sci - 1);
        }
        if (dec2 > 0) {
          addRet(sri, other.eci + 1, other.eri, eci);
        }
      }
      if (dsc > 0) {
        addRet(sri, sci, eri, other.sci - 1);
        if (dec2 > 0) {
          addRet(sri, other.eri + 1, eri, eci);
          if (dsr > 0) {
            addRet(sri, other.sci, other.sri - 1, other.eci);
          }
          if (der > 0) {
            addRet(other.sri + 1, other.sci, eri, other.eci);
          }
        } else {
          if (dsr > 0) {
            addRet(sri, other.sci, other.sri - 1, eci);
          }
          if (der > 0) {
            addRet(other.sri + 1, other.sci, eri, eci);
          }
        }
      } else if (dec2 > 0) {
        addRet(eri, other.eci + 1, eri, eci);
        if (dsr > 0) {
          addRet(sri, sci, other.sri - 1, other.eci);
        }
        if (der > 0) {
          addRet(other.eri + 1, sci, eri, other.eci);
        }
      }
      return ret;
    }
  }, {
    key: "size",
    value: function size() {
      return [this.eri - this.sri + 1, this.eci - this.sci + 1];
    }
  }, {
    key: "toString",
    value: function toString2() {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      var ref2 = xy2expr(sci, sri);
      if (this.multiple()) {
        ref2 = "".concat(ref2, ":").concat(xy2expr(eci, eri));
      }
      return ref2;
    }
  }, {
    key: "clone",
    value: function clone2() {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci, w = this.w, h3 = this.h;
      return new CellRange2(sri, sci, eri, eci, w, h3);
    }
    /*
    toJSON() {
      return this.toString();
    }
    */
  }, {
    key: "equals",
    value: function equals2(other) {
      return this.eri === other.eri && this.eci === other.eci && this.sri === other.sri && this.sci === other.sci;
    }
  }], [{
    key: "valueOf",
    value: function valueOf(ref2) {
      var refs = ref2.split(":");
      var _expr2xy3 = expr2xy(refs[0]), _expr2xy4 = _slicedToArray(_expr2xy3, 2), sci = _expr2xy4[0], sri = _expr2xy4[1];
      var eri = sri, eci = sci;
      if (refs.length > 1) {
        var _expr2xy5 = expr2xy(refs[1]);
        var _expr2xy6 = _slicedToArray(_expr2xy5, 2);
        eci = _expr2xy6[0];
        eri = _expr2xy6[1];
      }
      return new CellRange2(sri, sci, eri, eci);
    }
  }]);
  return CellRange2;
}();
var Selector$1 = /* @__PURE__ */ function() {
  function Selector2() {
    _classCallCheck(this, Selector2);
    this.range = new CellRange(0, 0, 0, 0);
    this.ri = 0;
    this.ci = 0;
  }
  _createClass(Selector2, [{
    key: "multiple",
    value: function multiple() {
      return this.range.multiple();
    }
  }, {
    key: "setIndexes",
    value: function setIndexes(ri, ci) {
      this.ri = ri;
      this.ci = ci;
    }
  }, {
    key: "size",
    value: function size() {
      return this.range.size();
    }
  }]);
  return Selector2;
}();
var Scroll = /* @__PURE__ */ _createClass(function Scroll2() {
  _classCallCheck(this, Scroll2);
  this.x = 0;
  this.y = 0;
  this.ri = 0;
  this.ci = 0;
});
var History = /* @__PURE__ */ function() {
  function History2() {
    _classCallCheck(this, History2);
    this.undoItems = [];
    this.redoItems = [];
  }
  _createClass(History2, [{
    key: "add",
    value: function add(data) {
      this.undoItems.push(JSON.stringify(data));
      this.redoItems = [];
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return this.undoItems.length > 0;
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return this.redoItems.length > 0;
    }
  }, {
    key: "undo",
    value: function undo(currentd, cb) {
      var undoItems = this.undoItems, redoItems = this.redoItems;
      if (this.canUndo()) {
        redoItems.push(JSON.stringify(currentd));
        cb(JSON.parse(undoItems.pop()));
      }
    }
  }, {
    key: "redo",
    value: function redo(currentd, cb) {
      var undoItems = this.undoItems, redoItems = this.redoItems;
      if (this.canRedo()) {
        undoItems.push(JSON.stringify(currentd));
        cb(JSON.parse(redoItems.pop()));
      }
    }
  }]);
  return History2;
}();
var Clipboard = /* @__PURE__ */ function() {
  function Clipboard2() {
    _classCallCheck(this, Clipboard2);
    this.range = null;
    this.state = "clear";
  }
  _createClass(Clipboard2, [{
    key: "copy",
    value: function copy2(cellRange) {
      this.range = cellRange;
      this.state = "copy";
      return this;
    }
  }, {
    key: "cut",
    value: function cut2(cellRange) {
      this.range = cellRange;
      this.state = "cut";
      return this;
    }
  }, {
    key: "isCopy",
    value: function isCopy() {
      return this.state === "copy";
    }
  }, {
    key: "isCut",
    value: function isCut() {
      return this.state === "cut";
    }
  }, {
    key: "isClear",
    value: function isClear() {
      return this.state === "clear";
    }
  }, {
    key: "clear",
    value: function clear() {
      this.range = null;
      this.state = "clear";
    }
  }]);
  return Clipboard2;
}();
var Filter = /* @__PURE__ */ function() {
  function Filter2(ci, operator, value) {
    _classCallCheck(this, Filter2);
    this.ci = ci;
    this.operator = operator;
    this.value = value;
  }
  _createClass(Filter2, [{
    key: "set",
    value: function set(operator, value) {
      this.operator = operator;
      this.value = value;
    }
  }, {
    key: "includes",
    value: function includes(v) {
      var operator = this.operator, value = this.value;
      if (operator === "all") {
        return true;
      }
      if (operator === "in") {
        return value.includes(v);
      }
      return false;
    }
  }, {
    key: "vlength",
    value: function vlength() {
      var operator = this.operator, value = this.value;
      if (operator === "in") {
        return value.length;
      }
      return 0;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var ci = this.ci, operator = this.operator, value = this.value;
      return {
        ci,
        operator,
        value
      };
    }
  }]);
  return Filter2;
}();
var Sort = /* @__PURE__ */ function() {
  function Sort2(ci, order) {
    _classCallCheck(this, Sort2);
    this.ci = ci;
    this.order = order;
  }
  _createClass(Sort2, [{
    key: "asc",
    value: function asc() {
      return this.order === "asc";
    }
  }, {
    key: "desc",
    value: function desc() {
      return this.order === "desc";
    }
  }]);
  return Sort2;
}();
var AutoFilter = /* @__PURE__ */ function() {
  function AutoFilter2() {
    _classCallCheck(this, AutoFilter2);
    this.ref = null;
    this.filters = [];
    this.sort = null;
  }
  _createClass(AutoFilter2, [{
    key: "setData",
    value: function setData(_ref) {
      var ref2 = _ref.ref, filters = _ref.filters, sort = _ref.sort;
      if (ref2 != null) {
        this.ref = ref2;
        this.filters = filters.map(function(it) {
          return new Filter(it.ci, it.operator, it.value);
        });
        if (sort) {
          this.sort = new Sort(sort.ci, sort.order);
        }
      }
    }
  }, {
    key: "getData",
    value: function getData2() {
      if (this.active()) {
        var ref2 = this.ref, filters = this.filters, sort = this.sort;
        return {
          ref: ref2,
          filters: filters.map(function(it) {
            return it.getData();
          }),
          sort
        };
      }
      return {};
    }
  }, {
    key: "addFilter",
    value: function addFilter(ci, operator, value) {
      var filter = this.getFilter(ci);
      if (filter == null) {
        this.filters.push(new Filter(ci, operator, value));
      } else {
        filter.set(operator, value);
      }
    }
  }, {
    key: "setSort",
    value: function setSort(ci, order) {
      this.sort = order ? new Sort(ci, order) : null;
    }
  }, {
    key: "includes",
    value: function includes(ri, ci) {
      if (this.active()) {
        return this.hrange().includes(ri, ci);
      }
      return false;
    }
  }, {
    key: "getSort",
    value: function getSort(ci) {
      var sort = this.sort;
      if (sort && sort.ci === ci) {
        return sort;
      }
      return null;
    }
  }, {
    key: "getFilter",
    value: function getFilter(ci) {
      var filters = this.filters;
      for (var i = 0; i < filters.length; i += 1) {
        if (filters[i].ci === ci) {
          return filters[i];
        }
      }
      return null;
    }
  }, {
    key: "filteredRows",
    value: function filteredRows(getCell) {
      var rset = /* @__PURE__ */ new Set();
      var fset = /* @__PURE__ */ new Set();
      if (this.active()) {
        var _this$range = this.range(), sri = _this$range.sri, eri = _this$range.eri;
        var filters = this.filters;
        for (var ri = sri + 1; ri <= eri; ri += 1) {
          for (var i = 0; i < filters.length; i += 1) {
            var filter = filters[i];
            var cell = getCell(ri, filter.ci);
            var ctext = cell ? cell.text : "";
            if (!filter.includes(ctext)) {
              rset.add(ri);
              break;
            } else {
              fset.add(ri);
            }
          }
        }
      }
      return {
        rset,
        fset
      };
    }
  }, {
    key: "items",
    value: function items(ci, getCell) {
      var m = {};
      if (this.active()) {
        var _this$range2 = this.range(), sri = _this$range2.sri, eri = _this$range2.eri;
        for (var ri = sri + 1; ri <= eri; ri += 1) {
          var cell = getCell(ri, ci);
          if (cell !== null && !/^\s*$/.test(cell.text)) {
            var key = cell.text;
            var cnt = (m[key] || 0) + 1;
            m[key] = cnt;
          } else {
            m[""] = (m[""] || 0) + 1;
          }
        }
      }
      return m;
    }
  }, {
    key: "range",
    value: function range() {
      return CellRange.valueOf(this.ref);
    }
  }, {
    key: "hrange",
    value: function hrange() {
      var r = this.range();
      r.eri = r.sri;
      return r;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ref = null;
      this.filters = [];
      this.sort = null;
    }
  }, {
    key: "active",
    value: function active() {
      return this.ref !== null;
    }
  }]);
  return AutoFilter2;
}();
var Merges = /* @__PURE__ */ function() {
  function Merges2() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, Merges2);
    this._ = d;
  }
  _createClass(Merges2, [{
    key: "forEach",
    value: function forEach(cb) {
      this._.forEach(cb);
    }
  }, {
    key: "deleteWithin",
    value: function deleteWithin(cr) {
      this._ = this._.filter(function(it) {
        return !it.within(cr);
      });
    }
  }, {
    key: "getFirstIncludes",
    value: function getFirstIncludes(ri, ci) {
      for (var i = 0; i < this._.length; i += 1) {
        var it = this._[i];
        if (it.includes(ri, ci)) {
          return it;
        }
      }
      return null;
    }
  }, {
    key: "filterIntersects",
    value: function filterIntersects(cellRange) {
      return new Merges2(this._.filter(function(it) {
        return it.intersects(cellRange);
      }));
    }
  }, {
    key: "intersects",
    value: function intersects(cellRange) {
      for (var i = 0; i < this._.length; i += 1) {
        var it = this._[i];
        if (it.intersects(cellRange)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "union",
    value: function union(cellRange) {
      var cr = cellRange;
      this._.forEach(function(it) {
        if (it.intersects(cr)) {
          cr = it.union(cr);
        }
      });
      return cr;
    }
  }, {
    key: "add",
    value: function add(cr) {
      this.deleteWithin(cr);
      this._.push(cr);
    }
    // type: row | column
  }, {
    key: "shift",
    value: function shift(type, index2, n, cbWithin) {
      this._.forEach(function(cellRange) {
        var sri = cellRange.sri, sci = cellRange.sci, eri = cellRange.eri, eci = cellRange.eci;
        var range = cellRange;
        if (type === "row") {
          if (sri >= index2) {
            range.sri += n;
            range.eri += n;
          } else if (sri < index2 && index2 <= eri) {
            range.eri += n;
            cbWithin(sri, sci, n, 0);
          }
        } else if (type === "column") {
          if (sci >= index2) {
            range.sci += n;
            range.eci += n;
          } else if (sci < index2 && index2 <= eci) {
            range.eci += n;
            cbWithin(sri, sci, 0, n);
          }
        }
      });
    }
  }, {
    key: "move",
    value: function move(cellRange, rn, cn) {
      this._.forEach(function(it1) {
        var it = it1;
        if (it.within(cellRange)) {
          it.eri += rn;
          it.sri += rn;
          it.sci += cn;
          it.eci += cn;
        }
      });
    }
  }, {
    key: "setData",
    value: function setData(merges) {
      this._ = merges.map(function(merge2) {
        return CellRange.valueOf(merge2);
      });
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this._.map(function(merge2) {
        return merge2.toString();
      });
    }
  }]);
  return Merges2;
}();
function cloneDeep(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var mergeDeep = function mergeDeep2() {
  var object = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  sources.forEach(function(source) {
    Object.keys(source).forEach(function(key) {
      var v = source[key];
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
        object[key] = v;
      } else if (typeof v !== "function" && !Array.isArray(v) && v instanceof Object) {
        object[key] = object[key] || {};
        mergeDeep2(object[key], v);
      } else {
        object[key] = v;
      }
    });
  });
  return object;
};
function equals(obj1, obj2) {
  var keys2 = Object.keys(obj1);
  if (keys2.length !== Object.keys(obj2).length)
    return false;
  for (var i = 0; i < keys2.length; i += 1) {
    var k = keys2[i];
    var v1 = obj1[k];
    var v2 = obj2[k];
    if (v2 === void 0)
      return false;
    if (typeof v1 === "string" || typeof v1 === "number" || typeof v1 === "boolean") {
      if (v1 !== v2)
        return false;
    } else if (Array.isArray(v1)) {
      if (v1.length !== v2.length)
        return false;
      for (var ai = 0; ai < v1.length; ai += 1) {
        if (!equals(v1[ai], v2[ai]))
          return false;
      }
    } else if (typeof v1 !== "function" && !Array.isArray(v1) && v1 instanceof Object) {
      if (!equals(v1, v2))
        return false;
    }
  }
  return true;
}
var sum = function sum2(objOrAry) {
  var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(value) {
    return value;
  };
  var total = 0;
  var size = 0;
  Object.keys(objOrAry).forEach(function(key) {
    total += cb(objOrAry[key], key);
    size += 1;
  });
  return [total, size];
};
function deleteProperty(obj, property) {
  var oldv = obj["".concat(property)];
  delete obj["".concat(property)];
  return oldv;
}
function rangeReduceIf(min, max, inits, initv, ifv, getv) {
  var s = inits;
  var v = initv;
  var i = min;
  for (; i < max; i += 1) {
    if (s > ifv)
      break;
    v = getv(i);
    s += v;
  }
  return [i, s - v, v];
}
function rangeSum(min, max, getv) {
  var s = 0;
  for (var i = min; i < max; i += 1) {
    s += getv(i);
  }
  return s;
}
function rangeEach(min, max, cb) {
  for (var i = min; i < max; i += 1) {
    cb(i);
  }
}
function arrayEquals(a1, a2) {
  if (a1.length === a2.length) {
    for (var i = 0; i < a1.length; i += 1) {
      if (a1[i] !== a2[i])
        return false;
    }
  } else
    return false;
  return true;
}
function digits(a) {
  var v = "".concat(a);
  var ret = 0;
  var flag = false;
  for (var i = 0; i < v.length; i += 1) {
    if (flag === true)
      ret += 1;
    if (v.charAt(i) === ".")
      flag = true;
  }
  return ret;
}
function numberCalc(type, a1, a2) {
  if (Number.isNaN(a1) || Number.isNaN(a2)) {
    return a1 + type + a2;
  }
  var al1 = digits(a1);
  var al2 = digits(a2);
  var num1 = Number(a1);
  var num2 = Number(a2);
  var ret = 0;
  if (type === "-") {
    ret = num1 - num2;
  } else if (type === "+") {
    ret = num1 + num2;
  } else if (type === "*") {
    ret = num1 * num2;
  } else if (type === "/") {
    ret = num1 / num2;
    if (digits(ret) > 5)
      return ret.toFixed(2);
    return ret;
  }
  return ret.toFixed(Math.max(al1, al2));
}
const helper = {
  cloneDeep,
  merge: function merge() {
    for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      sources[_key2] = arguments[_key2];
    }
    return mergeDeep.apply(void 0, [{}].concat(sources));
  },
  equals,
  arrayEquals,
  sum,
  rangeEach,
  rangeSum,
  rangeReduceIf,
  deleteProperty,
  numberCalc
};
var Rows = /* @__PURE__ */ function() {
  function Rows2(_ref) {
    var len = _ref.len, height2 = _ref.height;
    _classCallCheck(this, Rows2);
    this._ = {};
    this.len = len;
    this.height = height2;
  }
  _createClass(Rows2, [{
    key: "getHeight",
    value: function getHeight(ri) {
      if (this.isHide(ri))
        return 0;
      var row = this.get(ri);
      if (row && row.height) {
        return row.height;
      }
      return this.height;
    }
  }, {
    key: "setHeight",
    value: function setHeight(ri, v) {
      var row = this.getOrNew(ri);
      row.height = v;
    }
  }, {
    key: "unhide",
    value: function unhide(idx) {
      var index2 = idx;
      while (index2 > 0) {
        index2 -= 1;
        if (this.isHide(index2)) {
          this.setHide(index2, false);
        } else
          break;
      }
    }
  }, {
    key: "isHide",
    value: function isHide(ri) {
      var row = this.get(ri);
      return row && row.hide;
    }
  }, {
    key: "setHide",
    value: function setHide(ri, v) {
      var row = this.getOrNew(ri);
      if (v === true)
        row.hide = true;
      else
        delete row.hide;
    }
  }, {
    key: "setStyle",
    value: function setStyle(ri, style) {
      var row = this.getOrNew(ri);
      row.style = style;
    }
  }, {
    key: "sumHeight",
    value: function sumHeight(min, max, exceptSet) {
      var _this = this;
      return helper.rangeSum(min, max, function(i) {
        if (exceptSet && exceptSet.has(i))
          return 0;
        return _this.getHeight(i);
      });
    }
  }, {
    key: "totalHeight",
    value: function totalHeight() {
      return this.sumHeight(0, this.len);
    }
  }, {
    key: "get",
    value: function get(ri) {
      return this._[ri];
    }
  }, {
    key: "getOrNew",
    value: function getOrNew(ri) {
      this._[ri] = this._[ri] || {
        cells: {}
      };
      return this._[ri];
    }
  }, {
    key: "getCell",
    value: function getCell(ri, ci) {
      var row = this.get(ri);
      if (row !== void 0 && row.cells !== void 0 && row.cells[ci] !== void 0) {
        return row.cells[ci];
      }
      return null;
    }
  }, {
    key: "getCellMerge",
    value: function getCellMerge(ri, ci) {
      var cell = this.getCell(ri, ci);
      if (cell && cell.merge)
        return cell.merge;
      return [0, 0];
    }
  }, {
    key: "getCellOrNew",
    value: function getCellOrNew(ri, ci) {
      var row = this.getOrNew(ri);
      row.cells[ci] = row.cells[ci] || {};
      return row.cells[ci];
    }
    // what: all | text | format
  }, {
    key: "setCell",
    value: function setCell(ri, ci, cell) {
      var what = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "all";
      var row = this.getOrNew(ri);
      if (what === "all") {
        row.cells[ci] = cell;
      } else if (what === "text") {
        row.cells[ci] = row.cells[ci] || {};
        row.cells[ci].text = cell.text;
      } else if (what === "format") {
        row.cells[ci] = row.cells[ci] || {};
        row.cells[ci].style = cell.style;
        if (cell.merge)
          row.cells[ci].merge = cell.merge;
      }
    }
  }, {
    key: "setCellText",
    value: function setCellText(ri, ci, text) {
      var cell = this.getCellOrNew(ri, ci);
      if (cell.editable !== false)
        cell.text = text;
    }
    // what: all | format | text
  }, {
    key: "copyPaste",
    value: function copyPaste2(srcCellRange, dstCellRange, what) {
      var _this2 = this;
      var autofill = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var cb = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
      };
      var sri = srcCellRange.sri, sci = srcCellRange.sci, eri = srcCellRange.eri, eci = srcCellRange.eci;
      var dsri = dstCellRange.sri;
      var dsci = dstCellRange.sci;
      var deri = dstCellRange.eri;
      var deci = dstCellRange.eci;
      var _srcCellRange$size = srcCellRange.size(), _srcCellRange$size2 = _slicedToArray(_srcCellRange$size, 2), rn = _srcCellRange$size2[0], cn = _srcCellRange$size2[1];
      var _dstCellRange$size = dstCellRange.size(), _dstCellRange$size2 = _slicedToArray(_dstCellRange$size, 2), drn = _dstCellRange$size2[0], dcn = _dstCellRange$size2[1];
      var isAdd = true;
      var dn = 0;
      if (deri < sri || deci < sci) {
        isAdd = false;
        if (deri < sri)
          dn = drn;
        else
          dn = dcn;
      }
      for (var i = sri; i <= eri; i += 1) {
        if (this._[i]) {
          for (var j = sci; j <= eci; j += 1) {
            if (this._[i].cells && this._[i].cells[j]) {
              for (var ii = dsri; ii <= deri; ii += rn) {
                var _loop = function _loop2() {
                  var nri = ii + (i - sri);
                  var nci = jj + (j - sci);
                  var ncell = helper.cloneDeep(_this2._[i].cells[j]);
                  if (autofill && ncell && ncell.text && ncell.text.length > 0) {
                    var text = ncell.text;
                    var n = jj - dsci + (ii - dsri) + 2;
                    if (!isAdd) {
                      n -= dn + 1;
                    }
                    if (text[0] === "=") {
                      ncell.text = text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                        var xn = 0, yn = 0;
                        if (sri === dsri) {
                          xn = n - 1;
                        } else {
                          yn = n - 1;
                        }
                        if (/^\d+$/.test(word))
                          return word;
                        return expr2expr(word, xn, yn);
                      });
                    } else if (rn <= 1 && cn > 1 && (dsri > eri || deri < sri) || cn <= 1 && rn > 1 && (dsci > eci || deci < sci) || rn <= 1 && cn <= 1) {
                      var result = /[\\.\d]+$/.exec(text);
                      if (result !== null) {
                        var index2 = Number(result[0]) + n - 1;
                        ncell.text = text.substring(0, result.index) + index2;
                      }
                    }
                  }
                  _this2.setCell(nri, nci, ncell, what);
                  cb(nri, nci, ncell);
                };
                for (var jj = dsci; jj <= deci; jj += cn) {
                  _loop();
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: "cutPaste",
    value: function cutPaste2(srcCellRange, dstCellRange) {
      var _this3 = this;
      var ncellmm = {};
      this.each(function(ri) {
        _this3.eachCells(ri, function(ci) {
          var nri = parseInt(ri, 10);
          var nci = parseInt(ci, 10);
          if (srcCellRange.includes(ri, ci)) {
            nri = dstCellRange.sri + (nri - srcCellRange.sri);
            nci = dstCellRange.sci + (nci - srcCellRange.sci);
          }
          ncellmm[nri] = ncellmm[nri] || {
            cells: {}
          };
          ncellmm[nri].cells[nci] = _this3._[ri].cells[ci];
        });
      });
      this._ = ncellmm;
    }
    // src: Array<Array<String>>
  }, {
    key: "paste",
    value: function paste2(src, dstCellRange) {
      var _this4 = this;
      if (src.length <= 0)
        return;
      var sri = dstCellRange.sri, sci = dstCellRange.sci;
      src.forEach(function(row, i) {
        var ri = sri + i;
        row.forEach(function(cell, j) {
          var ci = sci + j;
          _this4.setCellText(ri, ci, cell);
        });
      });
    }
  }, {
    key: "insert",
    value: function insert(sri) {
      var _this5 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var ndata = {};
      this.each(function(ri, row) {
        var nri = parseInt(ri, 10);
        if (nri >= sri) {
          nri += n;
          _this5.eachCells(ri, function(ci, cell) {
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, 0, n, function(x, y) {
                  return y >= sri;
                });
              });
            }
          });
        }
        ndata[nri] = row;
      });
      this._ = ndata;
      this.len += n;
    }
  }, {
    key: "delete",
    value: function _delete(sri, eri) {
      var _this6 = this;
      var n = eri - sri + 1;
      var ndata = {};
      this.each(function(ri, row) {
        var nri = parseInt(ri, 10);
        if (nri < sri) {
          ndata[nri] = row;
        } else if (ri > eri) {
          ndata[nri - n] = row;
          _this6.eachCells(ri, function(ci, cell) {
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, 0, -n, function(x, y) {
                  return y > eri;
                });
              });
            }
          });
        }
      });
      this._ = ndata;
      this.len -= n;
    }
  }, {
    key: "insertColumn",
    value: function insertColumn(sci) {
      var _this7 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.each(function(ri, row) {
        var rndata = {};
        _this7.eachCells(ri, function(ci, cell) {
          var nci = parseInt(ci, 10);
          if (nci >= sci) {
            nci += n;
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, n, 0, function(x) {
                  return x >= sci;
                });
              });
            }
          }
          rndata[nci] = cell;
        });
        row.cells = rndata;
      });
    }
  }, {
    key: "deleteColumn",
    value: function deleteColumn(sci, eci) {
      var _this8 = this;
      var n = eci - sci + 1;
      this.each(function(ri, row) {
        var rndata = {};
        _this8.eachCells(ri, function(ci, cell) {
          var nci = parseInt(ci, 10);
          if (nci < sci) {
            rndata[nci] = cell;
          } else if (nci > eci) {
            rndata[nci - n] = cell;
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, -n, 0, function(x) {
                  return x > eci;
                });
              });
            }
          }
        });
        row.cells = rndata;
      });
    }
    // what: all | text | format | merge
  }, {
    key: "deleteCells",
    value: function deleteCells(cellRange) {
      var _this9 = this;
      var what = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
      cellRange.each(function(i, j) {
        _this9.deleteCell(i, j, what);
      });
    }
    // what: all | text | format | merge
  }, {
    key: "deleteCell",
    value: function deleteCell(ri, ci) {
      var what = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "all";
      var row = this.get(ri);
      if (row !== null) {
        var cell = this.getCell(ri, ci);
        if (cell !== null && cell.editable !== false) {
          if (what === "all") {
            delete row.cells[ci];
          } else if (what === "text") {
            if (cell.text)
              delete cell.text;
            if (cell.value)
              delete cell.value;
          } else if (what === "format") {
            if (cell.style !== void 0)
              delete cell.style;
            if (cell.merge)
              delete cell.merge;
          } else if (what === "merge") {
            if (cell.merge)
              delete cell.merge;
          }
        }
      }
    }
  }, {
    key: "maxCell",
    value: function maxCell() {
      var keys2 = Object.keys(this._);
      var ri = keys2[keys2.length - 1];
      var col = this._[ri];
      if (col) {
        var cells = col.cells;
        var ks = Object.keys(cells);
        var ci = ks[ks.length - 1];
        return [parseInt(ri, 10), parseInt(ci, 10)];
      }
      return [0, 0];
    }
  }, {
    key: "each",
    value: function each(cb) {
      Object.entries(this._).forEach(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), ri = _ref3[0], row = _ref3[1];
        cb(ri, row);
      });
    }
  }, {
    key: "eachCells",
    value: function eachCells(ri, cb) {
      if (this._[ri] && this._[ri].cells) {
        Object.entries(this._[ri].cells).forEach(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2), ci = _ref5[0], cell = _ref5[1];
          cb(ci, cell);
        });
      }
    }
  }, {
    key: "setData",
    value: function setData(d) {
      if (d.len) {
        this.len = d.len;
        delete d.len;
      }
      this._ = d;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var len = this.len;
      return Object.assign({
        len
      }, this._);
    }
  }]);
  return Rows2;
}();
var Cols = /* @__PURE__ */ function() {
  function Cols2(_ref) {
    var len = _ref.len, width2 = _ref.width, indexWidth = _ref.indexWidth, minWidth = _ref.minWidth;
    _classCallCheck(this, Cols2);
    this._ = {};
    this.len = len;
    this.width = width2;
    this.indexWidth = indexWidth;
    this.minWidth = minWidth;
  }
  _createClass(Cols2, [{
    key: "setData",
    value: function setData(d) {
      if (d.len) {
        this.len = d.len;
        delete d.len;
      }
      this._ = d;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var len = this.len;
      return Object.assign({
        len
      }, this._);
    }
  }, {
    key: "getWidth",
    value: function getWidth(i) {
      if (this.isHide(i))
        return 0;
      var col = this._[i];
      if (col && col.width) {
        return col.width;
      }
      return this.width;
    }
  }, {
    key: "getOrNew",
    value: function getOrNew(ci) {
      this._[ci] = this._[ci] || {};
      return this._[ci];
    }
  }, {
    key: "setWidth",
    value: function setWidth(ci, width2) {
      var col = this.getOrNew(ci);
      col.width = width2;
    }
  }, {
    key: "unhide",
    value: function unhide(idx) {
      var index2 = idx;
      while (index2 > 0) {
        index2 -= 1;
        if (this.isHide(index2)) {
          this.setHide(index2, false);
        } else
          break;
      }
    }
  }, {
    key: "isHide",
    value: function isHide(ci) {
      var col = this._[ci];
      return col && col.hide;
    }
  }, {
    key: "setHide",
    value: function setHide(ci, v) {
      var col = this.getOrNew(ci);
      if (v === true)
        col.hide = true;
      else
        delete col.hide;
    }
  }, {
    key: "setStyle",
    value: function setStyle(ci, style) {
      var col = this.getOrNew(ci);
      col.style = style;
    }
  }, {
    key: "sumWidth",
    value: function sumWidth(min, max) {
      var _this = this;
      return helper.rangeSum(min, max, function(i) {
        return _this.getWidth(i);
      });
    }
  }, {
    key: "totalWidth",
    value: function totalWidth() {
      return this.sumWidth(0, this.len);
    }
  }]);
  return Cols2;
}();
const en = {
  toolbar: {
    undo: "Undo",
    redo: "Redo",
    print: "Print",
    paintformat: "Paint format",
    clearformat: "Clear format",
    format: "Format",
    fontName: "Font",
    fontSize: "Font size",
    fontBold: "Font bold",
    fontItalic: "Font italic",
    underline: "Underline",
    strike: "Strike",
    color: "Text color",
    bgcolor: "Fill color",
    border: "Borders",
    merge: "Merge cells",
    align: "Horizontal align",
    valign: "Vertical align",
    textwrap: "Text wrapping",
    freeze: "Freeze cell",
    autofilter: "Filter",
    formula: "Functions",
    more: "More"
  },
  contextmenu: {
    copy: "Copy",
    cut: "Cut",
    paste: "Paste",
    pasteValue: "Paste values only",
    pasteFormat: "Paste format only",
    hide: "Hide",
    insertRow: "Insert row",
    insertColumn: "Insert column",
    deleteSheet: "Delete",
    deleteRow: "Delete row",
    deleteColumn: "Delete column",
    deleteCell: "Delete cell",
    deleteCellText: "Delete cell text",
    validation: "Data validations",
    cellprintable: "Enable export",
    cellnonprintable: "Disable export",
    celleditable: "Enable editing",
    cellnoneditable: "Disable editing"
  },
  print: {
    size: "Paper size",
    orientation: "Page orientation",
    orientations: ["Landscape", "Portrait"]
  },
  format: {
    normal: "Normal",
    text: "Plain Text",
    number: "Number",
    percent: "Percent",
    rmb: "RMB",
    usd: "USD",
    eur: "EUR",
    date: "Date",
    time: "Time",
    datetime: "Date time",
    duration: "Duration"
  },
  formula: {
    sum: "Sum",
    average: "Average",
    max: "Max",
    min: "Min",
    _if: "IF",
    and: "AND",
    or: "OR",
    concat: "Concat"
  },
  validation: {
    required: "it must be required",
    notMatch: "it not match its validation rule",
    between: "it is between {} and {}",
    notBetween: "it is not between {} and {}",
    notIn: "it is not in list",
    equal: "it equal to {}",
    notEqual: "it not equal to {}",
    lessThan: "it less than {}",
    lessThanEqual: "it less than or equal to {}",
    greaterThan: "it greater than {}",
    greaterThanEqual: "it greater than or equal to {}"
  },
  error: {
    pasteForMergedCell: "Unable to do this for merged cells"
  },
  calendar: {
    weeks: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  button: {
    next: "Next",
    cancel: "Cancel",
    remove: "Remove",
    save: "Save",
    ok: "OK"
  },
  sort: {
    desc: "Sort Z -> A",
    asc: "Sort A -> Z"
  },
  filter: {
    empty: "empty"
  },
  dataValidation: {
    mode: "Mode",
    range: "Cell Range",
    criteria: "Criteria",
    modeType: {
      cell: "Cell",
      column: "Colun",
      row: "Row"
    },
    type: {
      list: "List",
      number: "Number",
      date: "Date",
      phone: "Phone",
      email: "Email"
    },
    operator: {
      be: "between",
      nbe: "not betwwen",
      lt: "less than",
      lte: "less than or equal to",
      gt: "greater than",
      gte: "greater than or equal to",
      eq: "equal to",
      neq: "not equal to"
    }
  }
};
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var $languages = ["en"];
var $messages = {
  en
};
function translate(key, messages) {
  if (messages) {
    var _iterator = _createForOfIteratorHelper$3($languages), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var lang = _step.value;
        if (!messages[lang])
          break;
        var message = messages[lang];
        var keys2 = key.match(/(?:\\.|[^.])+/g);
        for (var i = 0; i < keys2.length; i += 1) {
          var property = keys2[i];
          var value = message[property];
          if (!value)
            break;
          if (i === keys2.length - 1)
            return value;
          message = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return void 0;
}
function t(key) {
  var v = translate(key, $messages);
  if (!v && window && window.x_spreadsheet && window.x_spreadsheet.$messages) {
    v = translate(key, window.x_spreadsheet.$messages);
  }
  return v || "";
}
function tf(key) {
  return function() {
    return t(key);
  };
}
function locale(lang, message) {
  var clearLangList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (clearLangList) {
    $languages = [lang];
  } else {
    $languages.unshift(lang);
  }
  if (message) {
    $messages[lang] = message;
  }
}
var rules = {
  phone: /^[1-9]\d{10}$/,
  email: /w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*/
};
function returnMessage(flag, key) {
  var message = "";
  if (!flag) {
    for (var _len = arguments.length, arg = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      arg[_key - 2] = arguments[_key];
    }
    message = t.apply(void 0, ["validation.".concat(key)].concat(arg));
  }
  return [flag, message];
}
var Validator = /* @__PURE__ */ function() {
  function Validator2(type, required, value, operator) {
    _classCallCheck(this, Validator2);
    this.required = required;
    this.value = value;
    this.type = type;
    this.operator = operator;
    this.message = "";
  }
  _createClass(Validator2, [{
    key: "parseValue",
    value: function parseValue(v) {
      var type = this.type;
      if (type === "date") {
        return new Date(v);
      }
      if (type === "number") {
        return Number(v);
      }
      return v;
    }
  }, {
    key: "equals",
    value: function equals2(other) {
      var flag = this.type === other.type && this.required === other.required && this.operator === other.operator;
      if (flag) {
        if (Array.isArray(this.value)) {
          flag = helper.arrayEquals(this.value, other.value);
        } else {
          flag = this.value === other.value;
        }
      }
      return flag;
    }
  }, {
    key: "values",
    value: function values() {
      return this.value.split(",");
    }
  }, {
    key: "validate",
    value: function validate(v) {
      var required = this.required, operator = this.operator, value = this.value, type = this.type;
      if (required && /^\s*$/.test(v)) {
        return returnMessage(false, "required");
      }
      if (/^\s*$/.test(v))
        return [true];
      if (rules[type] && !rules[type].test(v)) {
        return returnMessage(false, "notMatch");
      }
      if (type === "list") {
        return returnMessage(this.values().includes(v), "notIn");
      }
      if (operator) {
        var v1 = this.parseValue(v);
        if (operator === "be") {
          var _value = _slicedToArray(value, 2), min = _value[0], max = _value[1];
          return returnMessage(v1 >= this.parseValue(min) && v1 <= this.parseValue(max), "between", min, max);
        }
        if (operator === "nbe") {
          var _value2 = _slicedToArray(value, 2), _min = _value2[0], _max = _value2[1];
          return returnMessage(v1 < this.parseValue(_min) || v1 > this.parseValue(_max), "notBetween", _min, _max);
        }
        if (operator === "eq") {
          return returnMessage(v1 === this.parseValue(value), "equal", value);
        }
        if (operator === "neq") {
          return returnMessage(v1 !== this.parseValue(value), "notEqual", value);
        }
        if (operator === "lt") {
          return returnMessage(v1 < this.parseValue(value), "lessThan", value);
        }
        if (operator === "lte") {
          return returnMessage(v1 <= this.parseValue(value), "lessThanEqual", value);
        }
        if (operator === "gt") {
          return returnMessage(v1 > this.parseValue(value), "greaterThan", value);
        }
        if (operator === "gte") {
          return returnMessage(v1 >= this.parseValue(value), "greaterThanEqual", value);
        }
      }
      return [true];
    }
  }]);
  return Validator2;
}();
var Validation = /* @__PURE__ */ function() {
  function Validation2(mode, refs, validator) {
    _classCallCheck(this, Validation2);
    this.refs = refs;
    this.mode = mode;
    this.validator = validator;
  }
  _createClass(Validation2, [{
    key: "includes",
    value: function includes(ri, ci) {
      var refs = this.refs;
      for (var i = 0; i < refs.length; i += 1) {
        var cr = CellRange.valueOf(refs[i]);
        if (cr.includes(ri, ci))
          return true;
      }
      return false;
    }
  }, {
    key: "addRef",
    value: function addRef(ref2) {
      this.remove(CellRange.valueOf(ref2));
      this.refs.push(ref2);
    }
  }, {
    key: "remove",
    value: function remove(cellRange) {
      var nrefs = [];
      this.refs.forEach(function(it) {
        var cr = CellRange.valueOf(it);
        if (cr.intersects(cellRange)) {
          var crs = cr.difference(cellRange);
          crs.forEach(function(it1) {
            return nrefs.push(it1.toString());
          });
        } else {
          nrefs.push(it);
        }
      });
      this.refs = nrefs;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var refs = this.refs, mode = this.mode, validator = this.validator;
      var type = validator.type, required = validator.required, operator = validator.operator, value = validator.value;
      return {
        refs,
        mode,
        type,
        required,
        operator,
        value
      };
    }
  }], [{
    key: "valueOf",
    value: function valueOf(_ref) {
      var refs = _ref.refs, mode = _ref.mode, type = _ref.type, required = _ref.required, operator = _ref.operator, value = _ref.value;
      return new Validation2(mode, refs, new Validator(type, required, value, operator));
    }
  }]);
  return Validation2;
}();
var Validations = /* @__PURE__ */ function() {
  function Validations2() {
    _classCallCheck(this, Validations2);
    this._ = [];
    this.errors = /* @__PURE__ */ new Map();
  }
  _createClass(Validations2, [{
    key: "getError",
    value: function getError(ri, ci) {
      return this.errors.get("".concat(ri, "_").concat(ci));
    }
  }, {
    key: "validate",
    value: function validate(ri, ci, text) {
      var v = this.get(ri, ci);
      var key = "".concat(ri, "_").concat(ci);
      var errors = this.errors;
      if (v !== null) {
        var _v$validator$validate = v.validator.validate(text), _v$validator$validate2 = _slicedToArray(_v$validator$validate, 2), flag = _v$validator$validate2[0], message = _v$validator$validate2[1];
        if (!flag) {
          errors.set(key, message);
        } else {
          errors.delete(key);
        }
      } else {
        errors.delete(key);
      }
      return true;
    }
    // type: date|number|phone|email|list
    // validator: { required, value, operator }
  }, {
    key: "add",
    value: function add(mode, ref2, _ref2) {
      var type = _ref2.type, required = _ref2.required, value = _ref2.value, operator = _ref2.operator;
      var validator = new Validator(type, required, value, operator);
      var v = this.getByValidator(validator);
      if (v !== null) {
        v.addRef(ref2);
      } else {
        this._.push(new Validation(mode, [ref2], validator));
      }
    }
  }, {
    key: "getByValidator",
    value: function getByValidator(validator) {
      for (var i = 0; i < this._.length; i += 1) {
        var v = this._[i];
        if (v.validator.equals(validator)) {
          return v;
        }
      }
      return null;
    }
  }, {
    key: "get",
    value: function get(ri, ci) {
      for (var i = 0; i < this._.length; i += 1) {
        var v = this._[i];
        if (v.includes(ri, ci))
          return v;
      }
      return null;
    }
  }, {
    key: "remove",
    value: function remove(cellRange) {
      this.each(function(it) {
        it.remove(cellRange);
      });
    }
  }, {
    key: "each",
    value: function each(cb) {
      this._.forEach(function(it) {
        return cb(it);
      });
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this._.filter(function(it) {
        return it.refs.length > 0;
      }).map(function(it) {
        return it.getData();
      });
    }
  }, {
    key: "setData",
    value: function setData(d) {
      this._ = d.map(function(it) {
        return Validation.valueOf(it);
      });
    }
  }]);
  return Validations2;
}();
var defaultSettings = {
  mode: "edit",
  // edit | read
  view: {
    height: function height() {
      return document.documentElement.clientHeight;
    },
    width: function width() {
      return document.documentElement.clientWidth;
    }
  },
  showGrid: true,
  showToolbar: true,
  showContextmenu: true,
  showBottomBar: true,
  row: {
    len: 100,
    height: 25
  },
  col: {
    len: 26,
    width: 100,
    indexWidth: 60,
    minWidth: 60
  },
  style: {
    bgcolor: "#ffffff",
    align: "left",
    valign: "middle",
    textwrap: false,
    strike: false,
    underline: false,
    color: "#0a0a0a",
    font: {
      name: "Arial",
      size: 10,
      bold: false,
      italic: false
    },
    format: "normal"
  }
};
var toolbarHeight = 41;
var bottombarHeight = 41;
var hasOwnProperty = function hasOwnProperty2(obj, name) {
  return Object.prototype.hasOwnProperty.call(obj, name);
};
function canPaste(src, dst) {
  var error = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
  };
  var merges = this.merges;
  var cellRange = dst.clone();
  var _src$size = src.size(), _src$size2 = _slicedToArray(_src$size, 2), srn = _src$size2[0], scn = _src$size2[1];
  var _dst$size = dst.size(), _dst$size2 = _slicedToArray(_dst$size, 2), drn = _dst$size2[0], dcn = _dst$size2[1];
  if (srn > drn) {
    cellRange.eri = dst.sri + srn - 1;
  }
  if (scn > dcn) {
    cellRange.eci = dst.sci + scn - 1;
  }
  if (merges.intersects(cellRange)) {
    error(t("error.pasteForMergedCell"));
    return false;
  }
  return true;
}
function copyPaste(srcCellRange, dstCellRange, what) {
  var autofill = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var rows = this.rows, merges = this.merges;
  if (what === "all" || what === "format") {
    rows.deleteCells(dstCellRange, what);
    merges.deleteWithin(dstCellRange);
  }
  rows.copyPaste(srcCellRange, dstCellRange, what, autofill, function(ri, ci, cell) {
    if (cell && cell.merge) {
      var _cell$merge = _slicedToArray(cell.merge, 2), rn = _cell$merge[0], cn = _cell$merge[1];
      if (rn <= 0 && cn <= 0)
        return;
      merges.add(new CellRange(ri, ci, ri + rn, ci + cn));
    }
  });
}
function cutPaste(srcCellRange, dstCellRange) {
  var clipboard = this.clipboard, rows = this.rows, merges = this.merges;
  rows.cutPaste(srcCellRange, dstCellRange);
  merges.move(srcCellRange, dstCellRange.sri - srcCellRange.sri, dstCellRange.sci - srcCellRange.sci);
  clipboard.clear();
}
function setStyleBorder(ri, ci, bss) {
  var styles = this.styles, rows = this.rows;
  var cell = rows.getCellOrNew(ri, ci);
  var cstyle = {};
  if (cell.style !== void 0) {
    cstyle = helper.cloneDeep(styles[cell.style]);
  }
  cstyle = helper.merge(cstyle, {
    border: bss
  });
  cell.style = this.addStyle(cstyle);
}
function setStyleBorders(_ref) {
  var _this = this;
  var mode = _ref.mode, style = _ref.style, color = _ref.color;
  var styles = this.styles, selector = this.selector, rows = this.rows;
  var _selector$range = selector.range, sri = _selector$range.sri, sci = _selector$range.sci, eri = _selector$range.eri, eci = _selector$range.eci;
  var multiple = !this.isSignleSelected();
  if (!multiple) {
    if (mode === "inside" || mode === "horizontal" || mode === "vertical") {
      return;
    }
  }
  if (mode === "outside" && !multiple) {
    setStyleBorder.call(this, sri, sci, {
      top: [style, color],
      bottom: [style, color],
      left: [style, color],
      right: [style, color]
    });
  } else if (mode === "none") {
    selector.range.each(function(ri2, ci2) {
      var cell2 = rows.getCell(ri2, ci2);
      if (cell2 && cell2.style !== void 0) {
        var ns = helper.cloneDeep(styles[cell2.style]);
        delete ns.border;
        cell2.style = _this.addStyle(ns);
      }
    });
  } else if (mode === "all" || mode === "inside" || mode === "outside" || mode === "horizontal" || mode === "vertical") {
    var merges = [];
    for (var ri = sri; ri <= eri; ri += 1) {
      for (var ci = sci; ci <= eci; ci += 1) {
        var mergeIndexes = [];
        for (var ii = 0; ii < merges.length; ii += 1) {
          var _merges$ii = _slicedToArray(merges[ii], 4), mri = _merges$ii[0], mci = _merges$ii[1], _rn = _merges$ii[2], _cn = _merges$ii[3];
          if (ri === mri + _rn + 1)
            mergeIndexes.push(ii);
          if (mri <= ri && ri <= mri + _rn) {
            if (ci === mci) {
              ci += _cn + 1;
              break;
            }
          }
        }
        mergeIndexes.forEach(function(it) {
          return merges.splice(it, 1);
        });
        if (ci > eci)
          break;
        var cell = rows.getCell(ri, ci);
        var rn = 0, cn = 0;
        if (cell && cell.merge) {
          var _cell$merge2 = _slicedToArray(cell.merge, 2);
          rn = _cell$merge2[0];
          cn = _cell$merge2[1];
          merges.push([ri, ci, rn, cn]);
        }
        var mrl = rn > 0 && ri + rn === eri;
        var mcl = cn > 0 && ci + cn === eci;
        var bss = {};
        if (mode === "all") {
          bss = {
            bottom: [style, color],
            top: [style, color],
            left: [style, color],
            right: [style, color]
          };
        } else if (mode === "inside") {
          if (!mcl && ci < eci)
            bss.right = [style, color];
          if (!mrl && ri < eri)
            bss.bottom = [style, color];
        } else if (mode === "horizontal") {
          if (!mrl && ri < eri)
            bss.bottom = [style, color];
        } else if (mode === "vertical") {
          if (!mcl && ci < eci)
            bss.right = [style, color];
        } else if (mode === "outside" && multiple) {
          if (sri === ri)
            bss.top = [style, color];
          if (mrl || eri === ri)
            bss.bottom = [style, color];
          if (sci === ci)
            bss.left = [style, color];
          if (mcl || eci === ci)
            bss.right = [style, color];
        }
        if (Object.keys(bss).length > 0) {
          setStyleBorder.call(this, ri, ci, bss);
        }
        ci += cn;
      }
    }
  } else if (mode === "top" || mode === "bottom") {
    for (var _ci = sci; _ci <= eci; _ci += 1) {
      if (mode === "top") {
        setStyleBorder.call(this, sri, _ci, {
          top: [style, color]
        });
        _ci += rows.getCellMerge(sri, _ci)[1];
      }
      if (mode === "bottom") {
        setStyleBorder.call(this, eri, _ci, {
          bottom: [style, color]
        });
        _ci += rows.getCellMerge(eri, _ci)[1];
      }
    }
  } else if (mode === "left" || mode === "right") {
    for (var _ri = sri; _ri <= eri; _ri += 1) {
      if (mode === "left") {
        setStyleBorder.call(this, _ri, sci, {
          left: [style, color]
        });
        _ri += rows.getCellMerge(_ri, sci)[0];
      }
      if (mode === "right") {
        setStyleBorder.call(this, _ri, eci, {
          right: [style, color]
        });
        _ri += rows.getCellMerge(_ri, eci)[0];
      }
    }
  }
}
function getCellRowByY(y, scrollOffsety) {
  var rows = this.rows;
  var fsh = this.freezeTotalHeight();
  var inits = rows.height;
  if (fsh + rows.height < y)
    inits -= scrollOffsety;
  var frset = this.exceptRowSet;
  var ri = 0;
  var top = inits;
  var height2 = rows.height;
  for (; ri < rows.len; ri += 1) {
    if (top > y)
      break;
    if (!frset.has(ri)) {
      height2 = rows.getHeight(ri);
      top += height2;
    }
  }
  top -= height2;
  if (top <= 0) {
    return {
      ri: -1,
      top: 0,
      height: height2
    };
  }
  return {
    ri: ri - 1,
    top,
    height: height2
  };
}
function getCellColByX(x, scrollOffsetx) {
  var cols = this.cols;
  var fsw = this.freezeTotalWidth();
  var inits = cols.indexWidth;
  if (fsw + cols.indexWidth < x)
    inits -= scrollOffsetx;
  var _helper$rangeReduceIf = helper.rangeReduceIf(0, cols.len, inits, cols.indexWidth, x, function(i) {
    return cols.getWidth(i);
  }), _helper$rangeReduceIf2 = _slicedToArray(_helper$rangeReduceIf, 3), ci = _helper$rangeReduceIf2[0], left = _helper$rangeReduceIf2[1], width2 = _helper$rangeReduceIf2[2];
  if (left <= 0) {
    return {
      ci: -1,
      left: 0,
      width: cols.indexWidth
    };
  }
  return {
    ci: ci - 1,
    left,
    width: width2
  };
}
var DataProxy = /* @__PURE__ */ function() {
  function DataProxy2(name, settings) {
    _classCallCheck(this, DataProxy2);
    this.settings = helper.merge(defaultSettings, settings || {});
    this.name = name || "sheet";
    this.freeze = [0, 0];
    this.styles = [];
    this.merges = new Merges();
    this.rows = new Rows(this.settings.row);
    this.cols = new Cols(this.settings.col);
    this.validations = new Validations();
    this.hyperlinks = {};
    this.comments = {};
    this.selector = new Selector$1();
    this.scroll = new Scroll();
    this.history = new History();
    this.clipboard = new Clipboard();
    this.autoFilter = new AutoFilter();
    this.change = function() {
    };
    this.exceptRowSet = /* @__PURE__ */ new Set();
    this.sortedRowMap = /* @__PURE__ */ new Map();
    this.unsortedRowMap = /* @__PURE__ */ new Map();
  }
  _createClass(DataProxy2, [{
    key: "addValidation",
    value: function addValidation(mode, ref2, validator) {
      var _this2 = this;
      this.changeData(function() {
        _this2.validations.add(mode, ref2, validator);
      });
    }
  }, {
    key: "removeValidation",
    value: function removeValidation() {
      var _this3 = this;
      var range = this.selector.range;
      this.changeData(function() {
        _this3.validations.remove(range);
      });
    }
  }, {
    key: "getSelectedValidator",
    value: function getSelectedValidator() {
      var _this$selector = this.selector, ri = _this$selector.ri, ci = _this$selector.ci;
      var v = this.validations.get(ri, ci);
      return v ? v.validator : null;
    }
  }, {
    key: "getSelectedValidation",
    value: function getSelectedValidation() {
      var _this$selector2 = this.selector, ri = _this$selector2.ri, ci = _this$selector2.ci, range = _this$selector2.range;
      var v = this.validations.get(ri, ci);
      var ret = {
        ref: range.toString()
      };
      if (v !== null) {
        ret.mode = v.mode;
        ret.validator = v.validator;
      }
      return ret;
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return this.history.canUndo();
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return this.history.canRedo();
    }
  }, {
    key: "undo",
    value: function undo() {
      var _this4 = this;
      this.history.undo(this.getData(), function(d) {
        _this4.setData(d);
      });
    }
  }, {
    key: "redo",
    value: function redo() {
      var _this5 = this;
      this.history.redo(this.getData(), function(d) {
        _this5.setData(d);
      });
    }
  }, {
    key: "copy",
    value: function copy2() {
      this.clipboard.copy(this.selector.range);
    }
  }, {
    key: "copyToSystemClipboard",
    value: function copyToSystemClipboard() {
      if (navigator.clipboard === void 0) {
        return;
      }
      var copyText = "";
      var rowData = this.rows.getData();
      for (var ri = this.selector.range.sri; ri <= this.selector.range.eri; ri += 1) {
        if (hasOwnProperty(rowData, ri)) {
          for (var ci = this.selector.range.sci; ci <= this.selector.range.eci; ci += 1) {
            if (ci > this.selector.range.sci) {
              copyText += "	";
            }
            if (hasOwnProperty(rowData[ri].cells, ci)) {
              var cellText = String(rowData[ri].cells[ci].text);
              if (cellText.indexOf("\n") === -1 && cellText.indexOf("	") === -1 && cellText.indexOf('"') === -1) {
                copyText += cellText;
              } else {
                copyText += '"'.concat(cellText, '"');
              }
            }
          }
        } else {
          for (var _ci2 = this.selector.range.sci; _ci2 <= this.selector.range.eci; _ci2 += 1) {
            copyText += "	";
          }
        }
        copyText += "\n";
      }
      navigator.clipboard.writeText(copyText).then(function() {
      }, function(err) {
        console.log("text copy to the system clipboard error  ", copyText, err);
      });
    }
  }, {
    key: "cut",
    value: function cut2() {
      this.clipboard.cut(this.selector.range);
    }
    // what: all | text | format
  }, {
    key: "paste",
    value: function paste2() {
      var _this6 = this;
      var what = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
      var error = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      };
      var clipboard = this.clipboard, selector = this.selector;
      if (clipboard.isClear())
        return false;
      if (!canPaste.call(this, clipboard.range, selector.range, error))
        return false;
      this.changeData(function() {
        if (clipboard.isCopy()) {
          copyPaste.call(_this6, clipboard.range, selector.range, what);
        } else if (clipboard.isCut()) {
          cutPaste.call(_this6, clipboard.range, selector.range);
        }
      });
      return true;
    }
  }, {
    key: "pasteFromText",
    value: function pasteFromText(txt) {
      var lines = txt.split("\r\n").map(function(it) {
        return it.replace(/"/g, "").split("	");
      });
      if (lines.length > 0)
        lines.length -= 1;
      var rows = this.rows, selector = this.selector;
      this.changeData(function() {
        rows.paste(lines, selector.range);
      });
    }
  }, {
    key: "autofill",
    value: function autofill(cellRange, what) {
      var _this7 = this;
      var error = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      };
      var srcRange = this.selector.range;
      if (!canPaste.call(this, srcRange, cellRange, error))
        return false;
      this.changeData(function() {
        copyPaste.call(_this7, srcRange, cellRange, what, true);
      });
      return true;
    }
  }, {
    key: "clearClipboard",
    value: function clearClipboard2() {
      this.clipboard.clear();
    }
  }, {
    key: "calSelectedRangeByEnd",
    value: function calSelectedRangeByEnd(ri, ci) {
      var selector = this.selector, rows = this.rows, cols = this.cols, merges = this.merges;
      var _selector$range2 = selector.range, sri = _selector$range2.sri, sci = _selector$range2.sci, eri = _selector$range2.eri, eci = _selector$range2.eci;
      var cri = selector.ri;
      var cci = selector.ci;
      var nri = ri, nci = ci;
      if (ri < 0)
        nri = rows.len - 1;
      if (ci < 0)
        nci = cols.len - 1;
      if (nri > cri) {
        sri = cri;
        eri = nri;
      } else {
        sri = nri;
        eri = cri;
      }
      if (nci > cci) {
        sci = cci;
        eci = nci;
      } else {
        sci = nci;
        eci = cci;
      }
      selector.range = merges.union(new CellRange(sri, sci, eri, eci));
      selector.range = merges.union(selector.range);
      return selector.range;
    }
  }, {
    key: "calSelectedRangeByStart",
    value: function calSelectedRangeByStart(ri, ci) {
      var selector = this.selector, rows = this.rows, cols = this.cols, merges = this.merges;
      var cellRange = merges.getFirstIncludes(ri, ci);
      if (cellRange === null) {
        cellRange = new CellRange(ri, ci, ri, ci);
        if (ri === -1) {
          cellRange.sri = 0;
          cellRange.eri = rows.len - 1;
        }
        if (ci === -1) {
          cellRange.sci = 0;
          cellRange.eci = cols.len - 1;
        }
      }
      selector.range = cellRange;
      return cellRange;
    }
  }, {
    key: "setSelectedCellAttr",
    value: function setSelectedCellAttr(property, value) {
      var _this8 = this;
      this.changeData(function() {
        var selector = _this8.selector, styles = _this8.styles, rows = _this8.rows;
        if (property === "merge") {
          if (value)
            _this8.merge();
          else
            _this8.unmerge();
        } else if (property === "border") {
          setStyleBorders.call(_this8, value);
        } else if (property === "formula") {
          var ri = selector.ri, ci = selector.ci, range = selector.range;
          if (selector.multiple()) {
            var _selector$size = selector.size(), _selector$size2 = _slicedToArray(_selector$size, 2), rn = _selector$size2[0], cn = _selector$size2[1];
            var sri = range.sri, sci = range.sci, eri = range.eri, eci = range.eci;
            if (rn > 1) {
              for (var i = sci; i <= eci; i += 1) {
                var cell = rows.getCellOrNew(eri + 1, i);
                cell.text = "=".concat(value, "(").concat(xy2expr(i, sri), ":").concat(xy2expr(i, eri), ")");
              }
            } else if (cn > 1) {
              var _cell2 = rows.getCellOrNew(ri, eci + 1);
              _cell2.text = "=".concat(value, "(").concat(xy2expr(sci, ri), ":").concat(xy2expr(eci, ri), ")");
            }
          } else {
            var _cell22 = rows.getCellOrNew(ri, ci);
            _cell22.text = "=".concat(value, "()");
          }
        } else {
          selector.range.each(function(ri2, ci2) {
            var cell2 = rows.getCellOrNew(ri2, ci2);
            var cstyle = {};
            if (cell2.style !== void 0) {
              cstyle = helper.cloneDeep(styles[cell2.style]);
            }
            if (property === "format") {
              cstyle.format = value;
              cell2.style = _this8.addStyle(cstyle);
            } else if (property === "font-bold" || property === "font-italic" || property === "font-name" || property === "font-size") {
              var nfont = {};
              nfont[property.split("-")[1]] = value;
              cstyle.font = Object.assign(cstyle.font || {}, nfont);
              cell2.style = _this8.addStyle(cstyle);
            } else if (property === "strike" || property === "textwrap" || property === "underline" || property === "align" || property === "valign" || property === "color" || property === "bgcolor") {
              cstyle[property] = value;
              cell2.style = _this8.addStyle(cstyle);
            } else {
              cell2[property] = value;
            }
          });
        }
      });
    }
    // state: input | finished
  }, {
    key: "setSelectedCellText",
    value: function setSelectedCellText(text) {
      var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "input";
      var autoFilter = this.autoFilter, selector = this.selector, rows = this.rows;
      var ri = selector.ri, ci = selector.ci;
      var nri = ri;
      if (this.unsortedRowMap.has(ri)) {
        nri = this.unsortedRowMap.get(ri);
      }
      var oldCell = rows.getCell(nri, ci);
      var oldText = oldCell ? oldCell.text : "";
      this.setCellText(nri, ci, text, state);
      if (autoFilter.active()) {
        var filter = autoFilter.getFilter(ci);
        if (filter) {
          var vIndex = filter.value.findIndex(function(v) {
            return v === oldText;
          });
          if (vIndex >= 0) {
            filter.value.splice(vIndex, 1, text);
          }
        }
      }
    }
  }, {
    key: "getSelectedCell",
    value: function getSelectedCell() {
      var _this$selector3 = this.selector, ri = _this$selector3.ri, ci = _this$selector3.ci;
      var nri = ri;
      if (this.unsortedRowMap.has(ri)) {
        nri = this.unsortedRowMap.get(ri);
      }
      return this.rows.getCell(nri, ci);
    }
  }, {
    key: "xyInSelectedRect",
    value: function xyInSelectedRect(x, y) {
      var _this$getSelectedRect = this.getSelectedRect(), left = _this$getSelectedRect.left, top = _this$getSelectedRect.top, width2 = _this$getSelectedRect.width, height2 = _this$getSelectedRect.height;
      var x1 = x - this.cols.indexWidth;
      var y1 = y - this.rows.height;
      return x1 > left && x1 < left + width2 && y1 > top && y1 < top + height2;
    }
  }, {
    key: "getSelectedRect",
    value: function getSelectedRect() {
      return this.getRect(this.selector.range);
    }
  }, {
    key: "getClipboardRect",
    value: function getClipboardRect() {
      var clipboard = this.clipboard;
      if (!clipboard.isClear()) {
        return this.getRect(clipboard.range);
      }
      return {
        left: -100,
        top: -100
      };
    }
  }, {
    key: "getRect",
    value: function getRect(cellRange) {
      var scroll = this.scroll, rows = this.rows, cols = this.cols, exceptRowSet = this.exceptRowSet;
      var sri = cellRange.sri, sci = cellRange.sci, eri = cellRange.eri, eci = cellRange.eci;
      if (sri < 0 && sci < 0) {
        return {
          left: 0,
          l: 0,
          top: 0,
          t: 0,
          scroll
        };
      }
      var left = cols.sumWidth(0, sci);
      var top = rows.sumHeight(0, sri, exceptRowSet);
      var height2 = rows.sumHeight(sri, eri + 1, exceptRowSet);
      var width2 = cols.sumWidth(sci, eci + 1);
      var left0 = left - scroll.x;
      var top0 = top - scroll.y;
      var fsh = this.freezeTotalHeight();
      var fsw = this.freezeTotalWidth();
      if (fsw > 0 && fsw > left) {
        left0 = left;
      }
      if (fsh > 0 && fsh > top) {
        top0 = top;
      }
      return {
        l: left,
        t: top,
        left: left0,
        top: top0,
        height: height2,
        width: width2,
        scroll
      };
    }
  }, {
    key: "getCellRectByXY",
    value: function getCellRectByXY(x, y) {
      var scroll = this.scroll, merges = this.merges, rows = this.rows, cols = this.cols;
      var _getCellRowByY$call = getCellRowByY.call(this, y, scroll.y), ri = _getCellRowByY$call.ri, top = _getCellRowByY$call.top, height2 = _getCellRowByY$call.height;
      var _getCellColByX$call = getCellColByX.call(this, x, scroll.x), ci = _getCellColByX$call.ci, left = _getCellColByX$call.left, width2 = _getCellColByX$call.width;
      if (ci === -1) {
        width2 = cols.totalWidth();
      }
      if (ri === -1) {
        height2 = rows.totalHeight();
      }
      if (ri >= 0 || ci >= 0) {
        var merge2 = merges.getFirstIncludes(ri, ci);
        if (merge2) {
          ri = merge2.sri;
          ci = merge2.sci;
          var _this$cellRect = this.cellRect(ri, ci);
          left = _this$cellRect.left;
          top = _this$cellRect.top;
          width2 = _this$cellRect.width;
          height2 = _this$cellRect.height;
        }
      }
      return {
        ri,
        ci,
        left,
        top,
        width: width2,
        height: height2
      };
    }
  }, {
    key: "isSignleSelected",
    value: function isSignleSelected() {
      var _this$selector$range = this.selector.range, sri = _this$selector$range.sri, sci = _this$selector$range.sci, eri = _this$selector$range.eri, eci = _this$selector$range.eci;
      var cell = this.getCell(sri, sci);
      if (cell && cell.merge) {
        var _cell$merge3 = _slicedToArray(cell.merge, 2), rn = _cell$merge3[0], cn = _cell$merge3[1];
        if (sri + rn === eri && sci + cn === eci)
          return true;
      }
      return !this.selector.multiple();
    }
  }, {
    key: "canUnmerge",
    value: function canUnmerge() {
      var _this$selector$range2 = this.selector.range, sri = _this$selector$range2.sri, sci = _this$selector$range2.sci, eri = _this$selector$range2.eri, eci = _this$selector$range2.eci;
      var cell = this.getCell(sri, sci);
      if (cell && cell.merge) {
        var _cell$merge4 = _slicedToArray(cell.merge, 2), rn = _cell$merge4[0], cn = _cell$merge4[1];
        if (sri + rn === eri && sci + cn === eci)
          return true;
      }
      return false;
    }
  }, {
    key: "merge",
    value: function merge2() {
      var _this9 = this;
      var selector = this.selector, rows = this.rows;
      if (this.isSignleSelected())
        return;
      var _selector$size3 = selector.size(), _selector$size4 = _slicedToArray(_selector$size3, 2), rn = _selector$size4[0], cn = _selector$size4[1];
      if (rn > 1 || cn > 1) {
        var _selector$range3 = selector.range, sri = _selector$range3.sri, sci = _selector$range3.sci;
        this.changeData(function() {
          var cell = rows.getCellOrNew(sri, sci);
          cell.merge = [rn - 1, cn - 1];
          _this9.merges.add(selector.range);
          _this9.rows.deleteCells(selector.range);
          _this9.rows.setCell(sri, sci, cell);
        });
      }
    }
  }, {
    key: "unmerge",
    value: function unmerge() {
      var _this10 = this;
      var selector = this.selector;
      if (!this.isSignleSelected())
        return;
      var _selector$range4 = selector.range, sri = _selector$range4.sri, sci = _selector$range4.sci;
      this.changeData(function() {
        _this10.rows.deleteCell(sri, sci, "merge");
        _this10.merges.deleteWithin(selector.range);
      });
    }
  }, {
    key: "canAutofilter",
    value: function canAutofilter() {
      return !this.autoFilter.active();
    }
  }, {
    key: "autofilter",
    value: function autofilter2() {
      var _this11 = this;
      var autoFilter = this.autoFilter, selector = this.selector;
      this.changeData(function() {
        if (autoFilter.active()) {
          autoFilter.clear();
          _this11.exceptRowSet = /* @__PURE__ */ new Set();
          _this11.sortedRowMap = /* @__PURE__ */ new Map();
          _this11.unsortedRowMap = /* @__PURE__ */ new Map();
        } else {
          autoFilter.ref = selector.range.toString();
        }
      });
    }
  }, {
    key: "setAutoFilter",
    value: function setAutoFilter(ci, order, operator, value) {
      var autoFilter = this.autoFilter;
      autoFilter.addFilter(ci, operator, value);
      autoFilter.setSort(ci, order);
      this.resetAutoFilter();
    }
  }, {
    key: "resetAutoFilter",
    value: function resetAutoFilter() {
      var _this12 = this;
      var autoFilter = this.autoFilter, rows = this.rows;
      if (!autoFilter.active())
        return;
      var sort = autoFilter.sort;
      var _autoFilter$filteredR = autoFilter.filteredRows(function(r, c) {
        return rows.getCell(r, c);
      }), rset = _autoFilter$filteredR.rset, fset = _autoFilter$filteredR.fset;
      var fary = Array.from(fset);
      var oldAry = Array.from(fset);
      if (sort) {
        fary.sort(function(a, b) {
          if (sort.order === "asc")
            return a - b;
          if (sort.order === "desc")
            return b - a;
          return 0;
        });
      }
      this.exceptRowSet = rset;
      this.sortedRowMap = /* @__PURE__ */ new Map();
      this.unsortedRowMap = /* @__PURE__ */ new Map();
      fary.forEach(function(it, index2) {
        _this12.sortedRowMap.set(oldAry[index2], it);
        _this12.unsortedRowMap.set(it, oldAry[index2]);
      });
    }
  }, {
    key: "deleteCell",
    value: function deleteCell() {
      var _this13 = this;
      var what = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
      var selector = this.selector;
      this.changeData(function() {
        _this13.rows.deleteCells(selector.range, what);
        if (what === "all" || what === "format") {
          _this13.merges.deleteWithin(selector.range);
        }
      });
    }
    // type: row | column
  }, {
    key: "insert",
    value: function insert(type) {
      var _this14 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.changeData(function() {
        var _this14$selector$rang = _this14.selector.range, sri = _this14$selector$rang.sri, sci = _this14$selector$rang.sci;
        var rows = _this14.rows, merges = _this14.merges, cols = _this14.cols;
        var si = sri;
        if (type === "row") {
          rows.insert(sri, n);
        } else if (type === "column") {
          rows.insertColumn(sci, n);
          si = sci;
          cols.len += 1;
        }
        merges.shift(type, si, n, function(ri, ci, rn, cn) {
          var cell = rows.getCell(ri, ci);
          cell.merge[0] += rn;
          cell.merge[1] += cn;
        });
      });
    }
    // type: row | column
  }, {
    key: "delete",
    value: function _delete(type) {
      var _this15 = this;
      this.changeData(function() {
        var rows = _this15.rows, merges = _this15.merges, selector = _this15.selector, cols = _this15.cols;
        var range = selector.range;
        var _selector$range5 = selector.range, sri = _selector$range5.sri, sci = _selector$range5.sci, eri = _selector$range5.eri, eci = _selector$range5.eci;
        var _selector$range$size = selector.range.size(), _selector$range$size2 = _slicedToArray(_selector$range$size, 2), rsize = _selector$range$size2[0], csize = _selector$range$size2[1];
        var si = sri;
        var size = rsize;
        if (type === "row") {
          rows.delete(sri, eri);
        } else if (type === "column") {
          rows.deleteColumn(sci, eci);
          si = range.sci;
          size = csize;
          cols.len -= 1;
        }
        merges.shift(type, si, -size, function(ri, ci, rn, cn) {
          var cell = rows.getCell(ri, ci);
          cell.merge[0] += rn;
          cell.merge[1] += cn;
          if (cell.merge[0] === 0 && cell.merge[1] === 0) {
            delete cell.merge;
          }
        });
      });
    }
  }, {
    key: "scrollx",
    value: function scrollx(x, cb) {
      var scroll = this.scroll, freeze = this.freeze, cols = this.cols;
      var _freeze = _slicedToArray(freeze, 2), fci = _freeze[1];
      var _helper$rangeReduceIf3 = helper.rangeReduceIf(fci, cols.len, 0, 0, x, function(i) {
        return cols.getWidth(i);
      }), _helper$rangeReduceIf4 = _slicedToArray(_helper$rangeReduceIf3, 3), ci = _helper$rangeReduceIf4[0], left = _helper$rangeReduceIf4[1], width2 = _helper$rangeReduceIf4[2];
      var x1 = left;
      if (x > 0)
        x1 += width2;
      if (scroll.x !== x1) {
        scroll.ci = x > 0 ? ci : 0;
        scroll.x = x1;
        cb();
      }
    }
  }, {
    key: "scrolly",
    value: function scrolly(y, cb) {
      var scroll = this.scroll, freeze = this.freeze, rows = this.rows;
      var _freeze2 = _slicedToArray(freeze, 1), fri = _freeze2[0];
      var _helper$rangeReduceIf5 = helper.rangeReduceIf(fri, rows.len, 0, 0, y, function(i) {
        return rows.getHeight(i);
      }), _helper$rangeReduceIf6 = _slicedToArray(_helper$rangeReduceIf5, 3), ri = _helper$rangeReduceIf6[0], top = _helper$rangeReduceIf6[1], height2 = _helper$rangeReduceIf6[2];
      var y1 = top;
      if (y > 0)
        y1 += height2;
      if (scroll.y !== y1) {
        scroll.ri = y > 0 ? ri : 0;
        scroll.y = y1;
        cb();
      }
    }
  }, {
    key: "cellRect",
    value: function cellRect(ri, ci) {
      var rows = this.rows, cols = this.cols;
      var left = cols.sumWidth(0, ci);
      var top = rows.sumHeight(0, ri);
      var cell = rows.getCell(ri, ci);
      var width2 = cols.getWidth(ci);
      var height2 = rows.getHeight(ri);
      if (cell !== null) {
        if (cell.merge) {
          var _cell$merge5 = _slicedToArray(cell.merge, 2), rn = _cell$merge5[0], cn = _cell$merge5[1];
          if (rn > 0) {
            for (var i = 1; i <= rn; i += 1) {
              height2 += rows.getHeight(ri + i);
            }
          }
          if (cn > 0) {
            for (var _i = 1; _i <= cn; _i += 1) {
              width2 += cols.getWidth(ci + _i);
            }
          }
        }
      }
      return {
        left,
        top,
        width: width2,
        height: height2,
        cell
      };
    }
  }, {
    key: "getCell",
    value: function getCell(ri, ci) {
      return this.rows.getCell(ri, ci);
    }
  }, {
    key: "getCellTextOrDefault",
    value: function getCellTextOrDefault(ri, ci) {
      var cell = this.getCell(ri, ci);
      return cell && cell.text ? cell.text : "";
    }
  }, {
    key: "getCellStyle",
    value: function getCellStyle(ri, ci) {
      var cell = this.getCell(ri, ci);
      if (cell && cell.style !== void 0) {
        return this.styles[cell.style];
      }
      return null;
    }
  }, {
    key: "getCellStyleOrDefault",
    value: function getCellStyleOrDefault(ri, ci) {
      var styles = this.styles, rows = this.rows;
      var cell = rows.getCell(ri, ci);
      var cellStyle = cell && cell.style !== void 0 ? styles[cell.style] : {};
      return helper.merge(this.defaultStyle(), cellStyle);
    }
  }, {
    key: "getSelectedCellStyle",
    value: function getSelectedCellStyle() {
      var _this$selector4 = this.selector, ri = _this$selector4.ri, ci = _this$selector4.ci;
      return this.getCellStyleOrDefault(ri, ci);
    }
    // state: input | finished
  }, {
    key: "setCellText",
    value: function setCellText(ri, ci, text, state) {
      var rows = this.rows, history = this.history, validations = this.validations;
      if (state === "finished") {
        rows.setCellText(ri, ci, "");
        history.add(this.getData());
        rows.setCellText(ri, ci, text);
      } else {
        rows.setCellText(ri, ci, text);
        this.change(this.getData());
      }
      validations.validate(ri, ci, text);
    }
  }, {
    key: "freezeIsActive",
    value: function freezeIsActive() {
      var _this$freeze = _slicedToArray(this.freeze, 2), ri = _this$freeze[0], ci = _this$freeze[1];
      return ri > 0 || ci > 0;
    }
  }, {
    key: "setFreeze",
    value: function setFreeze(ri, ci) {
      var _this16 = this;
      this.changeData(function() {
        _this16.freeze = [ri, ci];
      });
    }
  }, {
    key: "freezeTotalWidth",
    value: function freezeTotalWidth() {
      return this.cols.sumWidth(0, this.freeze[1]);
    }
  }, {
    key: "freezeTotalHeight",
    value: function freezeTotalHeight() {
      return this.rows.sumHeight(0, this.freeze[0]);
    }
  }, {
    key: "setRowHeight",
    value: function setRowHeight(ri, height2) {
      var _this17 = this;
      this.changeData(function() {
        _this17.rows.setHeight(ri, height2);
      });
    }
  }, {
    key: "setColWidth",
    value: function setColWidth(ci, width2) {
      var _this18 = this;
      this.changeData(function() {
        _this18.cols.setWidth(ci, width2);
      });
    }
  }, {
    key: "viewHeight",
    value: function viewHeight() {
      var _this$settings = this.settings, view = _this$settings.view, showToolbar = _this$settings.showToolbar, showBottomBar = _this$settings.showBottomBar;
      var h3 = view.height();
      if (showBottomBar) {
        h3 -= bottombarHeight;
      }
      if (showToolbar) {
        h3 -= toolbarHeight;
      }
      return h3;
    }
  }, {
    key: "viewWidth",
    value: function viewWidth() {
      return this.settings.view.width();
    }
  }, {
    key: "freezeViewRange",
    value: function freezeViewRange() {
      var _this$freeze2 = _slicedToArray(this.freeze, 2), ri = _this$freeze2[0], ci = _this$freeze2[1];
      return new CellRange(0, 0, ri - 1, ci - 1, this.freezeTotalWidth(), this.freezeTotalHeight());
    }
  }, {
    key: "contentRange",
    value: function contentRange() {
      var rows = this.rows, cols = this.cols;
      var _rows$maxCell = rows.maxCell(), _rows$maxCell2 = _slicedToArray(_rows$maxCell, 2), ri = _rows$maxCell2[0], ci = _rows$maxCell2[1];
      var h3 = rows.sumHeight(0, ri + 1);
      var w = cols.sumWidth(0, ci + 1);
      return new CellRange(0, 0, ri, ci, w, h3);
    }
  }, {
    key: "exceptRowTotalHeight",
    value: function exceptRowTotalHeight(sri, eri) {
      var exceptRowSet = this.exceptRowSet, rows = this.rows;
      var exceptRows = Array.from(exceptRowSet);
      var exceptRowTH = 0;
      exceptRows.forEach(function(ri) {
        if (ri < sri || ri > eri) {
          var height2 = rows.getHeight(ri);
          exceptRowTH += height2;
        }
      });
      return exceptRowTH;
    }
  }, {
    key: "viewRange",
    value: function viewRange() {
      var scroll = this.scroll, rows = this.rows, cols = this.cols, freeze = this.freeze, exceptRowSet = this.exceptRowSet;
      var ri = scroll.ri, ci = scroll.ci;
      if (ri <= 0) {
        var _freeze3 = _slicedToArray(freeze, 1);
        ri = _freeze3[0];
      }
      if (ci <= 0) {
        var _freeze4 = _slicedToArray(freeze, 2);
        ci = _freeze4[1];
      }
      var x = 0, y = 0;
      var _ref2 = [rows.len, cols.len], eri = _ref2[0], eci = _ref2[1];
      for (var i = ri; i < rows.len; i += 1) {
        if (!exceptRowSet.has(i)) {
          y += rows.getHeight(i);
          eri = i;
        }
        if (y > this.viewHeight())
          break;
      }
      for (var j = ci; j < cols.len; j += 1) {
        x += cols.getWidth(j);
        eci = j;
        if (x > this.viewWidth())
          break;
      }
      return new CellRange(ri, ci, eri, eci, x, y);
    }
  }, {
    key: "eachMergesInView",
    value: function eachMergesInView(viewRange, cb) {
      this.merges.filterIntersects(viewRange).forEach(function(it) {
        return cb(it);
      });
    }
  }, {
    key: "hideRowsOrCols",
    value: function hideRowsOrCols2() {
      var rows = this.rows, cols = this.cols, selector = this.selector;
      var _selector$size5 = selector.size(), _selector$size6 = _slicedToArray(_selector$size5, 2), rlen = _selector$size6[0], clen = _selector$size6[1];
      var _selector$range6 = selector.range, sri = _selector$range6.sri, sci = _selector$range6.sci, eri = _selector$range6.eri, eci = _selector$range6.eci;
      if (rlen === rows.len) {
        for (var ci = sci; ci <= eci; ci += 1) {
          cols.setHide(ci, true);
        }
      } else if (clen === cols.len) {
        for (var ri = sri; ri <= eri; ri += 1) {
          rows.setHide(ri, true);
        }
      }
    }
    // type: row | col
    // index row-index | col-index
  }, {
    key: "unhideRowsOrCols",
    value: function unhideRowsOrCols2(type, index2) {
      this["".concat(type, "s")].unhide(index2);
    }
  }, {
    key: "rowEach",
    value: function rowEach(min, max, cb) {
      var y = 0;
      var rows = this.rows;
      var frset = this.exceptRowSet;
      var frary = _toConsumableArray(frset);
      var offset = 0;
      for (var i = 0; i < frary.length; i += 1) {
        if (frary[i] < min) {
          offset += 1;
        }
      }
      for (var _i2 = min + offset; _i2 <= max + offset; _i2 += 1) {
        if (frset.has(_i2)) {
          offset += 1;
        } else {
          var rowHeight = rows.getHeight(_i2);
          if (rowHeight > 0) {
            cb(_i2, y, rowHeight);
            y += rowHeight;
            if (y > this.viewHeight())
              break;
          }
        }
      }
    }
  }, {
    key: "colEach",
    value: function colEach(min, max, cb) {
      var x = 0;
      var cols = this.cols;
      for (var i = min; i <= max; i += 1) {
        var colWidth = cols.getWidth(i);
        if (colWidth > 0) {
          cb(i, x, colWidth);
          x += colWidth;
          if (x > this.viewWidth())
            break;
        }
      }
    }
  }, {
    key: "defaultStyle",
    value: function defaultStyle() {
      return this.settings.style;
    }
  }, {
    key: "addStyle",
    value: function addStyle(nstyle) {
      var styles = this.styles;
      for (var i = 0; i < styles.length; i += 1) {
        var style = styles[i];
        if (helper.equals(style, nstyle))
          return i;
      }
      styles.push(nstyle);
      return styles.length - 1;
    }
  }, {
    key: "changeData",
    value: function changeData(cb) {
      this.history.add(this.getData());
      cb();
      this.change(this.getData());
    }
  }, {
    key: "setData",
    value: function setData(d) {
      var _this19 = this;
      Object.keys(d).forEach(function(property) {
        if (property === "merges" || property === "rows" || property === "cols" || property === "validations") {
          _this19[property].setData(d[property]);
        } else if (property === "freeze") {
          var _expr2xy = expr2xy(d[property]), _expr2xy2 = _slicedToArray(_expr2xy, 2), x = _expr2xy2[0], y = _expr2xy2[1];
          _this19.freeze = [y, x];
        } else if (property === "autofilter") {
          _this19.autoFilter.setData(d[property]);
        } else if (d[property] !== void 0) {
          _this19[property] = d[property];
        }
      });
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var name = this.name, freeze = this.freeze, styles = this.styles, merges = this.merges, rows = this.rows, cols = this.cols, validations = this.validations, autoFilter = this.autoFilter;
      return {
        name,
        freeze: xy2expr(freeze[1], freeze[0]),
        styles,
        merges: merges.getData(),
        rows: rows.getData(),
        cols: cols.getData(),
        validations: validations.getData(),
        autofilter: autoFilter.getData()
      };
    }
  }]);
  return DataProxy2;
}();
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function bind(target, name, fn) {
  target.addEventListener(name, fn);
}
function unbind(target, name, fn) {
  target.removeEventListener(name, fn);
}
function unbindClickoutside(el) {
  if (el.xclickoutside) {
    unbind(window.document.body, "click", el.xclickoutside);
    delete el.xclickoutside;
  }
}
function bindClickoutside(el, cb) {
  el.xclickoutside = function(evt) {
    if (evt.detail === 2 || el.contains(evt.target))
      return;
    if (cb)
      cb(el);
    else {
      el.hide();
      unbindClickoutside(el);
    }
  };
  bind(window.document.body, "click", el.xclickoutside);
}
function mouseMoveUp(target, movefunc, upfunc) {
  bind(target, "mousemove", movefunc);
  var t2 = target;
  t2.xEvtUp = function(evt) {
    unbind(target, "mousemove", movefunc);
    unbind(target, "mouseup", target.xEvtUp);
    upfunc(evt);
  };
  bind(target, "mouseup", target.xEvtUp);
}
function calTouchDirection(spanx, spany, evt, cb) {
  var direction = "";
  if (Math.abs(spanx) > Math.abs(spany)) {
    direction = spanx > 0 ? "right" : "left";
    cb(direction, spanx, evt);
  } else {
    direction = spany > 0 ? "down" : "up";
    cb(direction, spany, evt);
  }
}
function bindTouch(target, _ref) {
  var move = _ref.move, end = _ref.end;
  var startx = 0;
  var starty = 0;
  bind(target, "touchstart", function(evt) {
    var _evt$touches$ = evt.touches[0], pageX = _evt$touches$.pageX, pageY = _evt$touches$.pageY;
    startx = pageX;
    starty = pageY;
  });
  bind(target, "touchmove", function(evt) {
    if (!move)
      return;
    var _evt$changedTouches$ = evt.changedTouches[0], pageX = _evt$changedTouches$.pageX, pageY = _evt$changedTouches$.pageY;
    var spanx = pageX - startx;
    var spany = pageY - starty;
    if (Math.abs(spanx) > 10 || Math.abs(spany) > 10) {
      calTouchDirection(spanx, spany, evt, move);
      startx = pageX;
      starty = pageY;
    }
    evt.preventDefault();
  });
  bind(target, "touchend", function(evt) {
    if (!end)
      return;
    var _evt$changedTouches$2 = evt.changedTouches[0], pageX = _evt$changedTouches$2.pageX, pageY = _evt$changedTouches$2.pageY;
    var spanx = pageX - startx;
    var spany = pageY - starty;
    calTouchDirection(spanx, spany, evt, end);
  });
}
function createEventEmitter() {
  var listeners = /* @__PURE__ */ new Map();
  function on(eventName, callback) {
    var push = function push2() {
      var currentListener = listeners.get(eventName);
      return Array.isArray(currentListener) && currentListener.push(callback) || false;
    };
    var create = function create2() {
      return listeners.set(eventName, [].concat(callback));
    };
    return listeners.has(eventName) && push() || create();
  }
  function fire(eventName, args) {
    var exec = function exec2() {
      var currentListener = listeners.get(eventName);
      var _iterator = _createForOfIteratorHelper$2(currentListener), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var callback = _step.value;
          callback.call.apply(callback, [null].concat(_toConsumableArray(args)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    return listeners.has(eventName) && exec();
  }
  function removeListener(eventName, callback) {
    var remove = function remove2() {
      var currentListener = listeners.get(eventName);
      var idx = currentListener.indexOf(callback);
      return idx >= 0 && currentListener.splice(idx, 1) && listeners.get(eventName).length === 0 && listeners.delete(eventName);
    };
    return listeners.has(eventName) && remove();
  }
  function once(eventName, callback) {
    var execCalllback = function execCalllback2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.call.apply(callback, [null].concat(args));
      removeListener(eventName, execCalllback2);
    };
    return on(eventName, execCalllback);
  }
  function removeAllListeners() {
    listeners.clear();
  }
  return {
    get current() {
      return listeners;
    },
    on,
    once,
    fire,
    removeListener,
    removeAllListeners
  };
}
var cssPrefix = "x-spreadsheet";
var Resizer = /* @__PURE__ */ function() {
  function Resizer2() {
    var _this = this;
    var vertical = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var minDistance = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, Resizer2);
    this.moving = false;
    this.vertical = vertical;
    this.el = h("div", "".concat(cssPrefix, "-resizer ").concat(vertical ? "vertical" : "horizontal")).children(this.unhideHoverEl = h("div", "".concat(cssPrefix, "-resizer-hover")).on("dblclick.stop", function(evt) {
      return _this.mousedblclickHandler(evt);
    }).css("position", "absolute").hide(), this.hoverEl = h("div", "".concat(cssPrefix, "-resizer-hover")).on("mousedown.stop", function(evt) {
      return _this.mousedownHandler(evt);
    }), this.lineEl = h("div", "".concat(cssPrefix, "-resizer-line")).hide()).hide();
    this.cRect = null;
    this.finishedFn = null;
    this.minDistance = minDistance;
    this.unhideFn = function() {
    };
  }
  _createClass(Resizer2, [{
    key: "showUnhide",
    value: function showUnhide(index2) {
      this.unhideIndex = index2;
      this.unhideHoverEl.show();
    }
  }, {
    key: "hideUnhide",
    value: function hideUnhide() {
      this.unhideHoverEl.hide();
    }
    // rect : {top, left, width, height}
    // line : {width, height}
  }, {
    key: "show",
    value: function show(rect, line) {
      var moving = this.moving, vertical = this.vertical, hoverEl = this.hoverEl, lineEl = this.lineEl, el = this.el, unhideHoverEl = this.unhideHoverEl;
      if (moving)
        return;
      this.cRect = rect;
      var left = rect.left, top = rect.top, width2 = rect.width, height2 = rect.height;
      el.offset({
        left: vertical ? left + width2 - 5 : left,
        top: vertical ? top : top + height2 - 5
      }).show();
      hoverEl.offset({
        width: vertical ? 5 : width2,
        height: vertical ? height2 : 5
      });
      lineEl.offset({
        width: vertical ? 0 : line.width,
        height: vertical ? line.height : 0
      });
      unhideHoverEl.offset({
        left: vertical ? 5 - width2 : left,
        top: vertical ? top : 5 - height2,
        width: vertical ? 5 : width2,
        height: vertical ? height2 : 5
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.offset({
        left: 0,
        top: 0
      }).hide();
      this.hideUnhide();
    }
  }, {
    key: "mousedblclickHandler",
    value: function mousedblclickHandler() {
      if (this.unhideIndex)
        this.unhideFn(this.unhideIndex);
    }
  }, {
    key: "mousedownHandler",
    value: function mousedownHandler(evt) {
      var _this2 = this;
      var startEvt = evt;
      var el = this.el, lineEl = this.lineEl, cRect = this.cRect, vertical = this.vertical, minDistance = this.minDistance;
      var distance = vertical ? cRect.width : cRect.height;
      lineEl.show();
      mouseMoveUp(window, function(e) {
        _this2.moving = true;
        if (startEvt !== null && e.buttons === 1) {
          if (vertical) {
            distance += e.movementX;
            if (distance > minDistance) {
              el.css("left", "".concat(cRect.left + distance, "px"));
            }
          } else {
            distance += e.movementY;
            if (distance > minDistance) {
              el.css("top", "".concat(cRect.top + distance, "px"));
            }
          }
          startEvt = e;
        }
      }, function() {
        startEvt = null;
        lineEl.hide();
        _this2.moving = false;
        _this2.hide();
        if (_this2.finishedFn) {
          if (distance < minDistance)
            distance = minDistance;
          _this2.finishedFn(cRect, distance);
        }
      });
    }
  }]);
  return Resizer2;
}();
var Scrollbar = /* @__PURE__ */ function() {
  function Scrollbar2(vertical) {
    var _this = this;
    _classCallCheck(this, Scrollbar2);
    this.vertical = vertical;
    this.moveFn = null;
    this.el = h("div", "".concat(cssPrefix, "-scrollbar ").concat(vertical ? "vertical" : "horizontal")).child(this.contentEl = h("div", "")).on("mousemove.stop", function() {
    }).on("scroll.stop", function(evt) {
      var _evt$target = evt.target, scrollTop = _evt$target.scrollTop, scrollLeft = _evt$target.scrollLeft;
      if (_this.moveFn) {
        _this.moveFn(_this.vertical ? scrollTop : scrollLeft, evt);
      }
    });
  }
  _createClass(Scrollbar2, [{
    key: "move",
    value: function move(v) {
      this.el.scroll(v);
      return this;
    }
  }, {
    key: "scroll",
    value: function scroll() {
      return this.el.scroll();
    }
  }, {
    key: "set",
    value: function set(distance, contentDistance) {
      var d = distance - 1;
      if (contentDistance > d) {
        var cssKey = this.vertical ? "height" : "width";
        this.el.css(cssKey, "".concat(d - 15, "px")).show();
        this.contentEl.css(this.vertical ? "width" : "height", "1px").css(cssKey, "".concat(contentDistance, "px"));
      } else {
        this.el.hide();
      }
      return this;
    }
  }]);
  return Scrollbar2;
}();
var selectorHeightBorderWidth = 2 * 2 - 1;
var startZIndex = 10;
var SelectorElement = /* @__PURE__ */ function() {
  function SelectorElement2() {
    var _this = this;
    var useHideInput = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck(this, SelectorElement2);
    this.useHideInput = useHideInput;
    this.inputChange = function() {
    };
    this.cornerEl = h("div", "".concat(cssPrefix, "-selector-corner"));
    this.areaEl = h("div", "".concat(cssPrefix, "-selector-area")).child(this.cornerEl).hide();
    this.clipboardEl = h("div", "".concat(cssPrefix, "-selector-clipboard")).hide();
    this.autofillEl = h("div", "".concat(cssPrefix, "-selector-autofill")).hide();
    this.el = h("div", "".concat(cssPrefix, "-selector")).css("z-index", "".concat(startZIndex)).children(this.areaEl, this.clipboardEl, this.autofillEl).hide();
    if (useHideInput) {
      this.hideInput = h("input", "").on("compositionend", function(evt) {
        _this.inputChange(evt.target.value);
      });
      this.el.child(this.hideInputDiv = h("div", "hide-input").child(this.hideInput));
      this.el.child(this.hideInputDiv = h("div", "hide-input").child(this.hideInput));
    }
    startZIndex += 1;
  }
  _createClass(SelectorElement2, [{
    key: "setOffset",
    value: function setOffset(v) {
      this.el.offset(v).show();
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      return this;
    }
  }, {
    key: "setAreaOffset",
    value: function setAreaOffset(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      var of = {
        width: width2 - selectorHeightBorderWidth + 0.8,
        height: height2 - selectorHeightBorderWidth + 0.8,
        left: left - 0.8,
        top: top - 0.8
      };
      this.areaEl.offset(of).show();
      if (this.useHideInput) {
        this.hideInputDiv.offset(of);
        this.hideInput.val("").focus();
      }
    }
  }, {
    key: "setClipboardOffset",
    value: function setClipboardOffset(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      this.clipboardEl.offset({
        left,
        top,
        width: width2 - 5,
        height: height2 - 5
      });
    }
  }, {
    key: "showAutofill",
    value: function showAutofill(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      this.autofillEl.offset({
        width: width2 - selectorHeightBorderWidth,
        height: height2 - selectorHeightBorderWidth,
        left,
        top
      }).show();
    }
  }, {
    key: "hideAutofill",
    value: function hideAutofill() {
      this.autofillEl.hide();
    }
  }, {
    key: "showClipboard",
    value: function showClipboard() {
      this.clipboardEl.show();
    }
  }, {
    key: "hideClipboard",
    value: function hideClipboard() {
      this.clipboardEl.hide();
    }
  }]);
  return SelectorElement2;
}();
function calBRAreaOffset(offset) {
  var data = this.data;
  var left = offset.left, top = offset.top, width2 = offset.width, height2 = offset.height, scroll = offset.scroll, l = offset.l, t2 = offset.t;
  var ftwidth = data.freezeTotalWidth();
  var ftheight = data.freezeTotalHeight();
  var left0 = left - ftwidth;
  if (ftwidth > l)
    left0 -= scroll.x;
  var top0 = top - ftheight;
  if (ftheight > t2)
    top0 -= scroll.y;
  return {
    left: left0,
    top: top0,
    width: width2,
    height: height2
  };
}
function calTAreaOffset(offset) {
  var data = this.data;
  var left = offset.left, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t, scroll = offset.scroll;
  var ftwidth = data.freezeTotalWidth();
  var left0 = left - ftwidth;
  if (ftwidth > l)
    left0 -= scroll.x;
  return {
    left: left0,
    top: t2,
    width: width2,
    height: height2
  };
}
function calLAreaOffset(offset) {
  var data = this.data;
  var top = offset.top, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t, scroll = offset.scroll;
  var ftheight = data.freezeTotalHeight();
  var top0 = top - ftheight;
  if (ftheight > t2)
    top0 -= scroll.y;
  return {
    left: l,
    top: top0,
    width: width2,
    height: height2
  };
}
function setBRAreaOffset(offset) {
  var br = this.br;
  br.setAreaOffset(calBRAreaOffset.call(this, offset));
}
function setTLAreaOffset(offset) {
  var tl = this.tl;
  tl.setAreaOffset(offset);
}
function setTAreaOffset(offset) {
  var t2 = this.t;
  t2.setAreaOffset(calTAreaOffset.call(this, offset));
}
function setLAreaOffset(offset) {
  var l = this.l;
  l.setAreaOffset(calLAreaOffset.call(this, offset));
}
function setLClipboardOffset(offset) {
  var l = this.l;
  l.setClipboardOffset(calLAreaOffset.call(this, offset));
}
function setBRClipboardOffset(offset) {
  var br = this.br;
  br.setClipboardOffset(calBRAreaOffset.call(this, offset));
}
function setTLClipboardOffset(offset) {
  var tl = this.tl;
  tl.setClipboardOffset(offset);
}
function setTClipboardOffset(offset) {
  var t2 = this.t;
  t2.setClipboardOffset(calTAreaOffset.call(this, offset));
}
function setAllAreaOffset(offset) {
  setBRAreaOffset.call(this, offset);
  setTLAreaOffset.call(this, offset);
  setTAreaOffset.call(this, offset);
  setLAreaOffset.call(this, offset);
}
function setAllClipboardOffset(offset) {
  setBRClipboardOffset.call(this, offset);
  setTLClipboardOffset.call(this, offset);
  setTClipboardOffset.call(this, offset);
  setLClipboardOffset.call(this, offset);
}
var Selector = /* @__PURE__ */ function() {
  function Selector2(data) {
    var _this2 = this;
    _classCallCheck(this, Selector2);
    this.inputChange = function() {
    };
    this.data = data;
    this.br = new SelectorElement(true);
    this.t = new SelectorElement();
    this.l = new SelectorElement();
    this.tl = new SelectorElement();
    this.br.inputChange = function(v) {
      _this2.inputChange(v);
    };
    this.br.el.show();
    this.offset = null;
    this.areaOffset = null;
    this.indexes = null;
    this.range = null;
    this.arange = null;
    this.el = h("div", "".concat(cssPrefix, "-selectors")).children(this.tl.el, this.t.el, this.l.el, this.br.el).hide();
    this.lastri = -1;
    this.lastci = -1;
    startZIndex += 1;
  }
  _createClass(Selector2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.range = data.selector.range;
      this.resetAreaOffset();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }, {
    key: "resetOffset",
    value: function resetOffset() {
      var data = this.data, tl = this.tl, t2 = this.t, l = this.l, br = this.br;
      var freezeHeight = data.freezeTotalHeight();
      var freezeWidth = data.freezeTotalWidth();
      if (freezeHeight > 0 || freezeWidth > 0) {
        tl.setOffset({
          width: freezeWidth,
          height: freezeHeight
        });
        t2.setOffset({
          left: freezeWidth,
          height: freezeHeight
        });
        l.setOffset({
          top: freezeHeight,
          width: freezeWidth
        });
        br.setOffset({
          left: freezeWidth,
          top: freezeHeight
        });
      } else {
        tl.hide();
        t2.hide();
        l.hide();
        br.setOffset({
          left: 0,
          top: 0
        });
      }
    }
  }, {
    key: "resetAreaOffset",
    value: function resetAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setAllAreaOffset.call(this, offset);
      setAllClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "resetBRTAreaOffset",
    value: function resetBRTAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setBRAreaOffset.call(this, offset);
      setTAreaOffset.call(this, offset);
      setBRClipboardOffset.call(this, coffset);
      setTClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "resetBRLAreaOffset",
    value: function resetBRLAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setBRAreaOffset.call(this, offset);
      setLAreaOffset.call(this, offset);
      setBRClipboardOffset.call(this, coffset);
      setLClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "set",
    value: function set(ri, ci) {
      var indexesUpdated = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var data = this.data;
      var cellRange = data.calSelectedRangeByStart(ri, ci);
      var sri = cellRange.sri, sci = cellRange.sci;
      if (indexesUpdated) {
        var cri = ri, cci = ci;
        if (ri < 0)
          cri = 0;
        if (ci < 0)
          cci = 0;
        data.selector.setIndexes(cri, cci);
        this.indexes = [cri, cci];
      }
      this.moveIndexes = [sri, sci];
      this.range = cellRange;
      this.resetAreaOffset();
      this.el.show();
    }
  }, {
    key: "setEnd",
    value: function setEnd(ri, ci) {
      var moving = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var data = this.data, lastri = this.lastri, lastci = this.lastci;
      if (moving) {
        if (ri === lastri && ci === lastci)
          return;
        this.lastri = ri;
        this.lastci = ci;
      }
      this.range = data.calSelectedRangeByEnd(ri, ci);
      setAllAreaOffset.call(this, this.data.getSelectedRect());
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this$data$selector$r = this.data.selector.range, eri = _this$data$selector$r.eri, eci = _this$data$selector$r.eci;
      this.setEnd(eri, eci);
    }
  }, {
    key: "showAutofill",
    value: function showAutofill(ri, ci) {
      if (ri === -1 && ci === -1)
        return;
      var _this$range = this.range, sri = _this$range.sri, sci = _this$range.sci, eri = _this$range.eri, eci = _this$range.eci;
      var nri = ri, nci = ci;
      var srn = sri - ri;
      var scn = sci - ci;
      var ern = eri - ri;
      var ecn = eci - ci;
      if (scn > 0) {
        this.arange = new CellRange(sri, nci, eri, sci - 1);
      } else if (srn > 0) {
        this.arange = new CellRange(nri, sci, sri - 1, eci);
      } else if (ecn < 0) {
        this.arange = new CellRange(sri, eci + 1, eri, nci);
      } else if (ern < 0) {
        this.arange = new CellRange(eri + 1, sci, nri, eci);
      } else {
        this.arange = null;
        return;
      }
      if (this.arange !== null) {
        var offset = this.data.getRect(this.arange);
        offset.width += 2;
        offset.height += 2;
        var br = this.br, l = this.l, t2 = this.t, tl = this.tl;
        br.showAutofill(calBRAreaOffset.call(this, offset));
        l.showAutofill(calLAreaOffset.call(this, offset));
        t2.showAutofill(calTAreaOffset.call(this, offset));
        tl.showAutofill(offset);
      }
    }
  }, {
    key: "hideAutofill",
    value: function hideAutofill() {
      var _this3 = this;
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this3[property].hideAutofill();
      });
    }
  }, {
    key: "showClipboard",
    value: function showClipboard() {
      var _this4 = this;
      var coffset = this.data.getClipboardRect();
      setAllClipboardOffset.call(this, coffset);
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this4[property].showClipboard();
      });
    }
  }, {
    key: "hideClipboard",
    value: function hideClipboard() {
      var _this5 = this;
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this5[property].hideClipboard();
      });
    }
  }]);
  return Selector2;
}();
function inputMovePrev(evt) {
  evt.preventDefault();
  evt.stopPropagation();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  if (this.itemIndex >= 0)
    filterItems[this.itemIndex].toggle();
  this.itemIndex -= 1;
  if (this.itemIndex < 0) {
    this.itemIndex = filterItems.length - 1;
  }
  filterItems[this.itemIndex].toggle();
}
function inputMoveNext(evt) {
  evt.stopPropagation();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  if (this.itemIndex >= 0)
    filterItems[this.itemIndex].toggle();
  this.itemIndex += 1;
  if (this.itemIndex > filterItems.length - 1) {
    this.itemIndex = 0;
  }
  filterItems[this.itemIndex].toggle();
}
function inputEnter(evt) {
  evt.preventDefault();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  evt.stopPropagation();
  if (this.itemIndex < 0)
    this.itemIndex = 0;
  filterItems[this.itemIndex].el.click();
  this.hide();
}
function inputKeydownHandler(evt) {
  var keyCode = evt.keyCode;
  if (evt.ctrlKey) {
    evt.stopPropagation();
  }
  switch (keyCode) {
    case 37:
      evt.stopPropagation();
      break;
    case 38:
      inputMovePrev.call(this, evt);
      break;
    case 39:
      evt.stopPropagation();
      break;
    case 40:
      inputMoveNext.call(this, evt);
      break;
    case 13:
      inputEnter.call(this, evt);
      break;
    case 9:
      inputEnter.call(this, evt);
      break;
    default:
      evt.stopPropagation();
      break;
  }
}
var Suggest = /* @__PURE__ */ function() {
  function Suggest2(items, itemClick) {
    var width2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "200px";
    _classCallCheck(this, Suggest2);
    this.filterItems = [];
    this.items = items;
    this.el = h("div", "".concat(cssPrefix, "-suggest")).css("width", width2).hide();
    this.itemClick = itemClick;
    this.itemIndex = -1;
  }
  _createClass(Suggest2, [{
    key: "setOffset",
    value: function setOffset(v) {
      this.el.cssRemoveKeys("top", "bottom").offset(v);
    }
  }, {
    key: "hide",
    value: function hide() {
      var el = this.el;
      this.filterItems = [];
      this.itemIndex = -1;
      el.hide();
      unbindClickoutside(this.el.parent());
    }
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = items;
    }
  }, {
    key: "search",
    value: function search(word) {
      var _this = this, _el$html;
      var items = this.items;
      if (!/^\s*$/.test(word)) {
        items = items.filter(function(it) {
          return (it.key || it).startsWith(word.toUpperCase());
        });
      }
      items = items.map(function(it) {
        var title = it.title;
        if (title) {
          if (typeof title === "function") {
            title = title();
          }
        } else {
          title = it;
        }
        var item = h("div", "".concat(cssPrefix, "-item")).child(title).on("click.stop", function() {
          _this.itemClick(it);
          _this.hide();
        });
        if (it.label) {
          item.child(h("div", "label").html(it.label));
        }
        return item;
      });
      this.filterItems = items;
      if (items.length <= 0) {
        return;
      }
      var el = this.el;
      (_el$html = el.html("")).children.apply(_el$html, _toConsumableArray(items)).show();
      bindClickoutside(el.parent(), function() {
        _this.hide();
      });
    }
  }, {
    key: "bindInputEvents",
    value: function bindInputEvents(input) {
      var _this2 = this;
      input.on("keydown", function(evt) {
        return inputKeydownHandler.call(_this2, evt);
      });
    }
  }]);
  return Suggest2;
}();
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _createSuper$D(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$D();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$D() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Icon = /* @__PURE__ */ function(_Element) {
  _inherits(Icon2, _Element);
  var _super = _createSuper$D(Icon2);
  function Icon2(name) {
    var _this;
    _classCallCheck(this, Icon2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-icon"));
    _this.iconNameEl = h("div", "".concat(cssPrefix, "-icon-img ").concat(name));
    _this.child(_this.iconNameEl);
    return _this;
  }
  _createClass(Icon2, [{
    key: "setName",
    value: function setName(name) {
      this.iconNameEl.className("".concat(cssPrefix, "-icon-img ").concat(name));
    }
  }]);
  return Icon2;
}(Element);
function addMonth(date, step) {
  date.setMonth(date.getMonth() + step);
}
function weekday(date, index2) {
  var d = new Date(date);
  d.setDate(index2 - date.getDay() + 1);
  return d;
}
function monthDays(year, month, cdate) {
  var startDate = new Date(year, month, 1, 23, 59, 59);
  var datess = [[], [], [], [], [], []];
  for (var i = 0; i < 6; i += 1) {
    for (var j = 0; j < 7; j += 1) {
      var index2 = i * 7 + j;
      var d = weekday(startDate, index2);
      var disabled = d.getMonth() !== month;
      var active = d.getMonth() === cdate.getMonth() && d.getDate() === cdate.getDate();
      datess[i][j] = {
        d,
        disabled,
        active
      };
    }
  }
  return datess;
}
var Calendar = /* @__PURE__ */ function() {
  function Calendar2(value) {
    var _this = this, _h;
    _classCallCheck(this, Calendar2);
    this.value = value;
    this.cvalue = new Date(value);
    this.headerLeftEl = h("div", "calendar-header-left");
    this.bodyEl = h("tbody", "");
    this.buildAll();
    this.el = h("div", "x-spreadsheet-calendar").children(h("div", "calendar-header").children(this.headerLeftEl, h("div", "calendar-header-right").children(h("a", "calendar-prev").on("click.stop", function() {
      return _this.prev();
    }).child(new Icon("chevron-left")), h("a", "calendar-next").on("click.stop", function() {
      return _this.next();
    }).child(new Icon("chevron-right")))), h("table", "calendar-body").children(h("thead", "").child((_h = h("tr", "")).children.apply(_h, _toConsumableArray(t("calendar.weeks").map(function(week) {
      return h("th", "cell").child(week);
    })))), this.bodyEl));
    this.selectChange = function() {
    };
  }
  _createClass(Calendar2, [{
    key: "setValue",
    value: function setValue(value) {
      this.value = value;
      this.cvalue = new Date(value);
      this.buildAll();
    }
  }, {
    key: "prev",
    value: function prev() {
      var value = this.value;
      addMonth(value, -1);
      this.buildAll();
    }
  }, {
    key: "next",
    value: function next() {
      var value = this.value;
      addMonth(value, 1);
      this.buildAll();
    }
  }, {
    key: "buildAll",
    value: function buildAll() {
      this.buildHeaderLeft();
      this.buildBody();
    }
  }, {
    key: "buildHeaderLeft",
    value: function buildHeaderLeft() {
      var value = this.value;
      this.headerLeftEl.html("".concat(t("calendar.months")[value.getMonth()], " ").concat(value.getFullYear()));
    }
  }, {
    key: "buildBody",
    value: function buildBody() {
      var _this2 = this, _bodyEl$html;
      var value = this.value, cvalue = this.cvalue, bodyEl = this.bodyEl;
      var mDays = monthDays(value.getFullYear(), value.getMonth(), cvalue);
      var trs = mDays.map(function(it) {
        var _h2;
        var tds = it.map(function(it1) {
          var cls = "cell";
          if (it1.disabled)
            cls += " disabled";
          if (it1.active)
            cls += " active";
          return h("td", "").child(h("div", cls).on("click.stop", function() {
            _this2.selectChange(it1.d);
          }).child(it1.d.getDate().toString()));
        });
        return (_h2 = h("tr", "")).children.apply(_h2, _toConsumableArray(tds));
      });
      (_bodyEl$html = bodyEl.html("")).children.apply(_bodyEl$html, _toConsumableArray(trs));
    }
  }]);
  return Calendar2;
}();
var Datepicker = /* @__PURE__ */ function() {
  function Datepicker2() {
    _classCallCheck(this, Datepicker2);
    this.calendar = new Calendar(/* @__PURE__ */ new Date());
    this.el = h("div", "".concat(cssPrefix, "-datepicker")).child(this.calendar.el).hide();
  }
  _createClass(Datepicker2, [{
    key: "setValue",
    value: function setValue(date) {
      var calendar = this.calendar;
      if (typeof date === "string") {
        if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(date)) {
          calendar.setValue(new Date(date.replace(new RegExp("-", "g"), "/")));
        }
      } else if (date instanceof Date) {
        calendar.setValue(date);
      }
      return this;
    }
  }, {
    key: "change",
    value: function change(cb) {
      var _this = this;
      this.calendar.selectChange = function(d) {
        cb(d);
        _this.hide();
      };
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }]);
  return Datepicker2;
}();
function resetTextareaSize() {
  var inputText = this.inputText;
  if (!/^\s*$/.test(inputText)) {
    var textlineEl = this.textlineEl, textEl = this.textEl, areaOffset = this.areaOffset;
    var txts = inputText.split("\n");
    var maxTxtSize = Math.max.apply(Math, _toConsumableArray(txts.map(function(it) {
      return it.length;
    })));
    var tlOffset = textlineEl.offset();
    var fontWidth = tlOffset.width / inputText.length;
    var tlineWidth = (maxTxtSize + 1) * fontWidth + 5;
    var maxWidth = this.viewFn().width - areaOffset.left - fontWidth;
    var h1 = txts.length;
    if (tlineWidth > areaOffset.width) {
      var twidth = tlineWidth;
      if (tlineWidth > maxWidth) {
        twidth = maxWidth;
        h1 += parseInt(tlineWidth / maxWidth, 10);
        h1 += tlineWidth % maxWidth > 0 ? 1 : 0;
      }
      textEl.css("width", "".concat(twidth, "px"));
    }
    h1 *= this.rowHeight;
    if (h1 > areaOffset.height) {
      textEl.css("height", "".concat(h1, "px"));
    }
  }
}
function insertText(_ref, itxt) {
  var target = _ref.target;
  var value = target.value, selectionEnd = target.selectionEnd;
  var ntxt = "".concat(value.slice(0, selectionEnd)).concat(itxt).concat(value.slice(selectionEnd));
  target.value = ntxt;
  target.setSelectionRange(selectionEnd + 1, selectionEnd + 1);
  this.inputText = ntxt;
  this.textlineEl.html(ntxt);
  resetTextareaSize.call(this);
}
function keydownEventHandler(evt) {
  var keyCode = evt.keyCode, altKey = evt.altKey;
  if (keyCode !== 13 && keyCode !== 9)
    evt.stopPropagation();
  if (keyCode === 13 && altKey) {
    insertText.call(this, evt, "\n");
    evt.stopPropagation();
  }
  if (keyCode === 13 && !altKey)
    evt.preventDefault();
}
function inputEventHandler(evt) {
  var v = evt.target.value;
  var suggest = this.suggest, textlineEl = this.textlineEl, validator = this.validator;
  var cell = this.cell;
  if (cell !== null) {
    if ("editable" in cell && cell.editable === true || cell.editable === void 0) {
      this.inputText = v;
      if (validator) {
        if (validator.type === "list") {
          suggest.search(v);
        } else {
          suggest.hide();
        }
      } else {
        var start = v.lastIndexOf("=");
        if (start !== -1) {
          suggest.search(v.substring(start + 1));
        } else {
          suggest.hide();
        }
      }
      textlineEl.html(v);
      resetTextareaSize.call(this);
      this.change("input", v);
    } else {
      evt.target.value = cell.text;
    }
  } else {
    this.inputText = v;
    if (validator) {
      if (validator.type === "list") {
        suggest.search(v);
      } else {
        suggest.hide();
      }
    } else {
      var _start = v.lastIndexOf("=");
      if (_start !== -1) {
        suggest.search(v.substring(_start + 1));
      } else {
        suggest.hide();
      }
    }
    textlineEl.html(v);
    resetTextareaSize.call(this);
    this.change("input", v);
  }
}
function setTextareaRange(position) {
  var el = this.textEl.el;
  setTimeout(function() {
    el.focus();
    el.setSelectionRange(position, position);
  }, 0);
}
function _setText(text, position) {
  var textEl = this.textEl, textlineEl = this.textlineEl;
  textEl.el.blur();
  textEl.val(text);
  textlineEl.html(text);
  setTextareaRange.call(this, position);
}
function suggestItemClick(it) {
  var inputText = this.inputText, validator = this.validator;
  var position = 0;
  if (validator && validator.type === "list") {
    this.inputText = it;
    position = this.inputText.length;
  } else {
    var start = inputText.lastIndexOf("=");
    var sit = inputText.substring(0, start + 1);
    var eit = inputText.substring(start + 1);
    if (eit.indexOf(")") !== -1) {
      eit = eit.substring(eit.indexOf(")"));
    } else {
      eit = "";
    }
    this.inputText = "".concat(sit + it.key, "(");
    position = this.inputText.length;
    this.inputText += ")".concat(eit);
  }
  _setText.call(this, this.inputText, position);
}
function resetSuggestItems() {
  this.suggest.setItems(this.formulas);
}
function dateFormat(d) {
  var month = d.getMonth() + 1;
  var date = d.getDate();
  if (month < 10)
    month = "0".concat(month);
  if (date < 10)
    date = "0".concat(date);
  return "".concat(d.getFullYear(), "-").concat(month, "-").concat(date);
}
var Editor = /* @__PURE__ */ function() {
  function Editor2(formulas2, viewFn, rowHeight) {
    var _this = this;
    _classCallCheck(this, Editor2);
    this.viewFn = viewFn;
    this.rowHeight = rowHeight;
    this.formulas = formulas2;
    this.suggest = new Suggest(formulas2, function(it) {
      suggestItemClick.call(_this, it);
    });
    this.datepicker = new Datepicker();
    this.datepicker.change(function(d) {
      _this.setText(dateFormat(d));
      _this.clear();
    });
    this.areaEl = h("div", "".concat(cssPrefix, "-editor-area")).children(this.textEl = h("textarea", "").on("input", function(evt) {
      return inputEventHandler.call(_this, evt);
    }).on("paste.stop", function() {
    }).on("keydown", function(evt) {
      return keydownEventHandler.call(_this, evt);
    }), this.textlineEl = h("div", "textline"), this.suggest.el, this.datepicker.el).on("mousemove.stop", function() {
    }).on("mousedown.stop", function() {
    });
    this.el = h("div", "".concat(cssPrefix, "-editor")).child(this.areaEl).hide();
    this.suggest.bindInputEvents(this.textEl);
    this.areaOffset = null;
    this.freeze = {
      w: 0,
      h: 0
    };
    this.cell = null;
    this.inputText = "";
    this.change = function() {
    };
  }
  _createClass(Editor2, [{
    key: "setFreezeLengths",
    value: function setFreezeLengths(width2, height2) {
      this.freeze.w = width2;
      this.freeze.h = height2;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.inputText !== "") {
        this.change("finished", this.inputText);
      }
      this.cell = null;
      this.areaOffset = null;
      this.inputText = "";
      this.el.hide();
      this.textEl.val("");
      this.textlineEl.html("");
      resetSuggestItems.call(this);
      this.datepicker.hide();
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      var suggestPosition = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
      var textEl = this.textEl, areaEl = this.areaEl, suggest = this.suggest, freeze = this.freeze, el = this.el;
      if (offset) {
        this.areaOffset = offset;
        var left = offset.left, top = offset.top, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t;
        var elOffset = {
          left: 0,
          top: 0
        };
        if (freeze.w > l && freeze.h > t2)
          ;
        else if (freeze.w < l && freeze.h < t2) {
          elOffset.left = freeze.w;
          elOffset.top = freeze.h;
        } else if (freeze.w > l) {
          elOffset.top = freeze.h;
        } else if (freeze.h > t2) {
          elOffset.left = freeze.w;
        }
        el.offset(elOffset);
        areaEl.offset({
          left: left - elOffset.left - 0.8,
          top: top - elOffset.top - 0.8
        });
        textEl.offset({
          width: width2 - 9 + 0.8,
          height: height2 - 3 + 0.8
        });
        var sOffset = {
          left: 0
        };
        sOffset[suggestPosition] = height2;
        suggest.setOffset(sOffset);
        suggest.hide();
      }
    }
  }, {
    key: "setCell",
    value: function setCell(cell, validator) {
      var el = this.el, datepicker = this.datepicker, suggest = this.suggest;
      el.show();
      this.cell = cell;
      var text = cell && cell.text || "";
      this.setText(text);
      this.validator = validator;
      if (validator) {
        var type = validator.type;
        if (type === "date") {
          datepicker.show();
          if (!/^\s*$/.test(text)) {
            datepicker.setValue(text);
          }
        }
        if (type === "list") {
          suggest.setItems(validator.values());
          suggest.search("");
        }
      }
    }
  }, {
    key: "setText",
    value: function setText(text) {
      this.inputText = text;
      _setText.call(this, text, text.length);
      resetTextareaSize.call(this);
    }
  }]);
  return Editor2;
}();
function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Button = /* @__PURE__ */ function(_Element) {
  _inherits(Button2, _Element);
  var _super = _createSuper$C(Button2);
  function Button2(title) {
    var _this;
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    _classCallCheck(this, Button2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-button ").concat(type));
    _this.child(t("button.".concat(title)));
    return _this;
  }
  return _createClass(Button2);
}(Element);
function dpr() {
  return window.devicePixelRatio || 1;
}
function thinLineWidth() {
  return dpr() - 0.5;
}
function npx(px) {
  return parseInt(px * dpr(), 10);
}
function npxLine(px) {
  var n = npx(px);
  return n > 0 ? n - 0.5 : 0.5;
}
var DrawBox = /* @__PURE__ */ function() {
  function DrawBox2(x, y, w, h3) {
    var padding = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    _classCallCheck(this, DrawBox2);
    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h3;
    this.padding = padding;
    this.bgcolor = "#ffffff";
    this.borderTop = null;
    this.borderRight = null;
    this.borderBottom = null;
    this.borderLeft = null;
  }
  _createClass(DrawBox2, [{
    key: "setBorders",
    value: function setBorders(_ref) {
      var top = _ref.top, bottom = _ref.bottom, left = _ref.left, right = _ref.right;
      if (top)
        this.borderTop = top;
      if (right)
        this.borderRight = right;
      if (bottom)
        this.borderBottom = bottom;
      if (left)
        this.borderLeft = left;
    }
  }, {
    key: "innerWidth",
    value: function innerWidth() {
      return this.width - this.padding * 2 - 2;
    }
  }, {
    key: "innerHeight",
    value: function innerHeight() {
      return this.height - this.padding * 2 - 2;
    }
  }, {
    key: "textx",
    value: function textx(align) {
      var width2 = this.width, padding = this.padding;
      var x = this.x;
      if (align === "left") {
        x += padding;
      } else if (align === "center") {
        x += width2 / 2;
      } else if (align === "right") {
        x += width2 - padding;
      }
      return x;
    }
  }, {
    key: "texty",
    value: function texty(align, h3) {
      var height2 = this.height, padding = this.padding;
      var y = this.y;
      if (align === "top") {
        y += padding;
      } else if (align === "middle") {
        y += height2 / 2 - h3 / 2;
      } else if (align === "bottom") {
        y += height2 - padding - h3;
      }
      return y;
    }
  }, {
    key: "topxys",
    value: function topxys() {
      var x = this.x, y = this.y, width2 = this.width;
      return [[x, y], [x + width2, y]];
    }
  }, {
    key: "rightxys",
    value: function rightxys() {
      var x = this.x, y = this.y, width2 = this.width, height2 = this.height;
      return [[x + width2, y], [x + width2, y + height2]];
    }
  }, {
    key: "bottomxys",
    value: function bottomxys() {
      var x = this.x, y = this.y, width2 = this.width, height2 = this.height;
      return [[x, y + height2], [x + width2, y + height2]];
    }
  }, {
    key: "leftxys",
    value: function leftxys() {
      var x = this.x, y = this.y, height2 = this.height;
      return [[x, y], [x, y + height2]];
    }
  }]);
  return DrawBox2;
}();
function drawFontLine(type, tx, ty, align, valign, blheight, blwidth) {
  var floffset = {
    x: 0,
    y: 0
  };
  if (type === "underline") {
    if (valign === "bottom") {
      floffset.y = 0;
    } else if (valign === "top") {
      floffset.y = -(blheight + 2);
    } else {
      floffset.y = -blheight / 2;
    }
  } else if (type === "strike") {
    if (valign === "bottom") {
      floffset.y = blheight / 2;
    } else if (valign === "top") {
      floffset.y = -(blheight / 2 + 2);
    }
  }
  if (align === "center") {
    floffset.x = blwidth / 2;
  } else if (align === "right") {
    floffset.x = blwidth;
  }
  this.line([tx - floffset.x, ty - floffset.y], [tx - floffset.x + blwidth, ty - floffset.y]);
}
var Draw = /* @__PURE__ */ function() {
  function Draw2(el, width2, height2) {
    _classCallCheck(this, Draw2);
    this.el = el;
    this.ctx = el.getContext("2d");
    this.resize(width2, height2);
    this.ctx.scale(dpr(), dpr());
  }
  _createClass(Draw2, [{
    key: "resize",
    value: function resize(width2, height2) {
      this.el.style.width = "".concat(width2, "px");
      this.el.style.height = "".concat(height2, "px");
      this.el.width = npx(width2);
      this.el.height = npx(height2);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this$el = this.el, width2 = _this$el.width, height2 = _this$el.height;
      this.ctx.clearRect(0, 0, width2, height2);
      return this;
    }
  }, {
    key: "attr",
    value: function attr(options) {
      Object.assign(this.ctx, options);
      return this;
    }
  }, {
    key: "save",
    value: function save() {
      this.ctx.save();
      this.ctx.beginPath();
      return this;
    }
  }, {
    key: "restore",
    value: function restore() {
      this.ctx.restore();
      return this;
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      this.ctx.beginPath();
      return this;
    }
  }, {
    key: "translate",
    value: function translate2(x, y) {
      this.ctx.translate(npx(x), npx(y));
      return this;
    }
  }, {
    key: "scale",
    value: function scale(x, y) {
      this.ctx.scale(x, y);
      return this;
    }
  }, {
    key: "clearRect",
    value: function clearRect(x, y, w, h3) {
      this.ctx.clearRect(x, y, w, h3);
      return this;
    }
  }, {
    key: "fillRect",
    value: function fillRect(x, y, w, h3) {
      this.ctx.fillRect(npx(x) - 0.5, npx(y) - 0.5, npx(w), npx(h3));
      return this;
    }
  }, {
    key: "fillText",
    value: function fillText(text, x, y) {
      this.ctx.fillText(text, npx(x), npx(y));
      return this;
    }
    /*
      txt: render text
      box: DrawBox
      attr: {
        align: left | center | right
        valign: top | middle | bottom
        color: '#333333',
        strike: false,
        font: {
          name: 'Arial',
          size: 14,
          bold: false,
          italic: false,
        }
      }
      textWrap: text wrapping
    */
  }, {
    key: "text",
    value: function text(mtxt, box) {
      var _this = this;
      var attr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var textWrap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var ctx = this.ctx;
      var align = attr.align, valign = attr.valign, font = attr.font, color = attr.color, strike = attr.strike, underline = attr.underline;
      var tx = box.textx(align);
      ctx.save();
      ctx.beginPath();
      this.attr({
        textAlign: align,
        textBaseline: valign,
        font: "".concat(font.italic ? "italic" : "", " ").concat(font.bold ? "bold" : "", " ").concat(npx(font.size), "px ").concat(font.name),
        fillStyle: color,
        strokeStyle: color
      });
      var txts = "".concat(mtxt).split("\n");
      var biw = box.innerWidth();
      var ntxts = [];
      txts.forEach(function(it) {
        var txtWidth = ctx.measureText(it).width;
        if (textWrap && txtWidth > npx(biw)) {
          var textLine = {
            w: 0,
            len: 0,
            start: 0
          };
          for (var i = 0; i < it.length; i += 1) {
            if (textLine.w >= npx(biw)) {
              ntxts.push(it.substr(textLine.start, textLine.len));
              textLine = {
                w: 0,
                len: 0,
                start: i
              };
            }
            textLine.len += 1;
            textLine.w += ctx.measureText(it[i]).width + 1;
          }
          if (textLine.len > 0) {
            ntxts.push(it.substr(textLine.start, textLine.len));
          }
        } else {
          ntxts.push(it);
        }
      });
      var txtHeight = (ntxts.length - 1) * (font.size + 2);
      var ty = box.texty(valign, txtHeight);
      ntxts.forEach(function(txt) {
        var txtWidth = ctx.measureText(txt).width;
        _this.fillText(txt, tx, ty);
        if (strike) {
          drawFontLine.call(_this, "strike", tx, ty, align, valign, font.size, txtWidth);
        }
        if (underline) {
          drawFontLine.call(_this, "underline", tx, ty, align, valign, font.size, txtWidth);
        }
        ty += font.size + 2;
      });
      ctx.restore();
      return this;
    }
  }, {
    key: "border",
    value: function border(style, color) {
      var ctx = this.ctx;
      ctx.lineWidth = thinLineWidth;
      ctx.strokeStyle = color;
      if (style === "medium") {
        ctx.lineWidth = npx(2) - 0.5;
      } else if (style === "thick") {
        ctx.lineWidth = npx(3);
      } else if (style === "dashed") {
        ctx.setLineDash([npx(3), npx(2)]);
      } else if (style === "dotted") {
        ctx.setLineDash([npx(1), npx(1)]);
      } else if (style === "double") {
        ctx.setLineDash([npx(2), 0]);
      }
      return this;
    }
  }, {
    key: "line",
    value: function line() {
      var ctx = this.ctx;
      if (arguments.length > 1) {
        ctx.beginPath();
        var _ref2 = arguments.length <= 0 ? void 0 : arguments[0], _ref3 = _slicedToArray(_ref2, 2), x = _ref3[0], y = _ref3[1];
        ctx.moveTo(npxLine(x), npxLine(y));
        for (var i = 1; i < arguments.length; i += 1) {
          var _ref4 = i < 0 || arguments.length <= i ? void 0 : arguments[i], _ref5 = _slicedToArray(_ref4, 2), x1 = _ref5[0], y1 = _ref5[1];
          ctx.lineTo(npxLine(x1), npxLine(y1));
        }
        ctx.stroke();
      }
      return this;
    }
  }, {
    key: "strokeBorders",
    value: function strokeBorders(box) {
      var ctx = this.ctx;
      ctx.save();
      var borderTop = box.borderTop, borderRight = box.borderRight, borderBottom = box.borderBottom, borderLeft = box.borderLeft;
      if (borderTop) {
        this.border.apply(this, _toConsumableArray(borderTop));
        this.line.apply(this, _toConsumableArray(box.topxys()));
      }
      if (borderRight) {
        this.border.apply(this, _toConsumableArray(borderRight));
        this.line.apply(this, _toConsumableArray(box.rightxys()));
      }
      if (borderBottom) {
        this.border.apply(this, _toConsumableArray(borderBottom));
        this.line.apply(this, _toConsumableArray(box.bottomxys()));
      }
      if (borderLeft) {
        this.border.apply(this, _toConsumableArray(borderLeft));
        this.line.apply(this, _toConsumableArray(box.leftxys()));
      }
      ctx.restore();
    }
  }, {
    key: "dropdown",
    value: function dropdown(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width, height2 = box.height;
      var sx = x + width2 - 15;
      var sy = y + height2 - 15;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx), npx(sy));
      ctx.lineTo(npx(sx + 8), npx(sy));
      ctx.lineTo(npx(sx + 4), npx(sy + 6));
      ctx.closePath();
      ctx.fillStyle = "rgba(0, 0, 0, .45)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "error",
    value: function error(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width;
      var sx = x + width2 - 1;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx - 8), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y + 8));
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 0, 0, .65)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "frozen",
    value: function frozen(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width;
      var sx = x + width2 - 1;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx - 8), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y + 8));
      ctx.closePath();
      ctx.fillStyle = "rgba(0, 255, 0, .85)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "rect",
    value: function rect(box, dtextcb) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width, height2 = box.height, bgcolor = box.bgcolor;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = bgcolor || "#fff";
      ctx.rect(npxLine(x + 1), npxLine(y + 1), npx(width2 - 2), npx(height2 - 2));
      ctx.clip();
      ctx.fill();
      dtextcb();
      ctx.restore();
    }
  }]);
  return Draw2;
}();
var baseFonts = [{
  key: "Arial",
  title: "Arial"
}, {
  key: "Helvetica",
  title: "Helvetica"
}, {
  key: "Source Sans Pro",
  title: "Source Sans Pro"
}, {
  key: "Comic Sans MS",
  title: "Comic Sans MS"
}, {
  key: "Courier New",
  title: "Courier New"
}, {
  key: "Verdana",
  title: "Verdana"
}, {
  key: "Lato",
  title: "Lato"
}];
var fontSizes = [
  {
    pt: 7.5,
    px: 10
  },
  {
    pt: 8,
    px: 11
  },
  {
    pt: 9,
    px: 12
  },
  {
    pt: 10,
    px: 13
  },
  {
    pt: 10.5,
    px: 14
  },
  {
    pt: 11,
    px: 15
  },
  {
    pt: 12,
    px: 16
  },
  {
    pt: 14,
    px: 18.7
  },
  {
    pt: 15,
    px: 20
  },
  {
    pt: 16,
    px: 21.3
  },
  {
    pt: 18,
    px: 24
  },
  {
    pt: 22,
    px: 29.3
  },
  {
    pt: 24,
    px: 32
  },
  {
    pt: 26,
    px: 34.7
  },
  {
    pt: 36,
    px: 48
  },
  {
    pt: 42,
    px: 56
  }
  // { pt: 54, px: 71.7 },
  // { pt: 63, px: 83.7 },
  // { pt: 72, px: 95.6 },
];
function getFontSizePxByPt(pt) {
  for (var i = 0; i < fontSizes.length; i += 1) {
    var fontSize = fontSizes[i];
    if (fontSize.pt === pt) {
      return fontSize.px;
    }
  }
  return pt;
}
var infixExprToSuffixExpr = function infixExprToSuffixExpr2(src) {
  var operatorStack = [];
  var stack = [];
  var subStrs = [];
  var fnArgType = 0;
  var fnArgOperator = "";
  var fnArgsLen = 1;
  var oldc = "";
  for (var i = 0; i < src.length; i += 1) {
    var c = src.charAt(i);
    if (c !== " ") {
      if (c >= "a" && c <= "z") {
        subStrs.push(c.toUpperCase());
      } else if (c >= "0" && c <= "9" || c >= "A" && c <= "Z" || c === ".") {
        subStrs.push(c);
      } else if (c === '"') {
        i += 1;
        while (src.charAt(i) !== '"') {
          subStrs.push(src.charAt(i));
          i += 1;
        }
        stack.push('"'.concat(subStrs.join("")));
        subStrs = [];
      } else if (c === "-" && /[+\-*/,(]/.test(oldc)) {
        subStrs.push(c);
      } else {
        if (c !== "(" && subStrs.length > 0) {
          stack.push(subStrs.join(""));
        }
        if (c === ")") {
          var c1 = operatorStack.pop();
          if (fnArgType === 2) {
            try {
              var _expr2xy = expr2xy(stack.pop()), _expr2xy2 = _slicedToArray(_expr2xy, 2), ex = _expr2xy2[0], ey = _expr2xy2[1];
              var _expr2xy3 = expr2xy(stack.pop()), _expr2xy4 = _slicedToArray(_expr2xy3, 2), sx = _expr2xy4[0], sy = _expr2xy4[1];
              var rangelen = 0;
              for (var x = sx; x <= ex; x += 1) {
                for (var y = sy; y <= ey; y += 1) {
                  stack.push(xy2expr(x, y));
                  rangelen += 1;
                }
              }
              stack.push([c1, rangelen]);
            } catch (e) {
            }
          } else if (fnArgType === 1 || fnArgType === 3) {
            if (fnArgType === 3)
              stack.push(fnArgOperator);
            stack.push([c1, fnArgsLen]);
            fnArgsLen = 1;
          } else {
            while (c1 !== "(") {
              stack.push(c1);
              if (operatorStack.length <= 0)
                break;
              c1 = operatorStack.pop();
            }
          }
          fnArgType = 0;
        } else if (c === "=" || c === ">" || c === "<") {
          var nc = src.charAt(i + 1);
          fnArgOperator = c;
          if (nc === "=" || nc === "-") {
            fnArgOperator += nc;
            i += 1;
          }
          fnArgType = 3;
        } else if (c === ":") {
          fnArgType = 2;
        } else if (c === ",") {
          if (fnArgType === 3) {
            stack.push(fnArgOperator);
          }
          fnArgType = 1;
          fnArgsLen += 1;
        } else if (c === "(" && subStrs.length > 0) {
          operatorStack.push(subStrs.join(""));
        } else {
          if (operatorStack.length > 0 && (c === "+" || c === "-")) {
            var top = operatorStack[operatorStack.length - 1];
            if (top !== "(")
              stack.push(operatorStack.pop());
            if (top === "*" || top === "/") {
              while (operatorStack.length > 0) {
                top = operatorStack[operatorStack.length - 1];
                if (top !== "(")
                  stack.push(operatorStack.pop());
                else
                  break;
              }
            }
          } else if (operatorStack.length > 0) {
            var _top = operatorStack[operatorStack.length - 1];
            if (_top === "*" || _top === "/")
              stack.push(operatorStack.pop());
          }
          operatorStack.push(c);
        }
        subStrs = [];
      }
      oldc = c;
    }
  }
  if (subStrs.length > 0) {
    stack.push(subStrs.join(""));
  }
  while (operatorStack.length > 0) {
    stack.push(operatorStack.pop());
  }
  return stack;
};
var evalSubExpr = function evalSubExpr2(subExpr, cellRender3) {
  var _subExpr = _slicedToArray(subExpr, 1), fl = _subExpr[0];
  var expr = subExpr;
  if (fl === '"') {
    return subExpr.substring(1);
  }
  var ret = 1;
  if (fl === "-") {
    expr = subExpr.substring(1);
    ret = -1;
  }
  if (expr[0] >= "0" && expr[0] <= "9") {
    return ret * Number(expr);
  }
  var _expr2xy5 = expr2xy(expr), _expr2xy6 = _slicedToArray(_expr2xy5, 2), x = _expr2xy6[0], y = _expr2xy6[1];
  return ret * cellRender3(x, y);
};
var evalSuffixExpr = function evalSuffixExpr2(srcStack, formulaMap, cellRender3, cellList) {
  var stack = [];
  for (var i = 0; i < srcStack.length; i += 1) {
    var expr = srcStack[i];
    var fc = expr[0];
    if (expr === "+") {
      var top = stack.pop();
      stack.push(numberCalc("+", stack.pop(), top));
    } else if (expr === "-") {
      if (stack.length === 1) {
        var _top2 = stack.pop();
        stack.push(numberCalc("*", _top2, -1));
      } else {
        var _top3 = stack.pop();
        stack.push(numberCalc("-", stack.pop(), _top3));
      }
    } else if (expr === "*") {
      stack.push(numberCalc("*", stack.pop(), stack.pop()));
    } else if (expr === "/") {
      var _top4 = stack.pop();
      stack.push(numberCalc("/", stack.pop(), _top4));
    } else if (fc === "=" || fc === ">" || fc === "<") {
      var _top5 = stack.pop();
      if (!Number.isNaN(_top5))
        _top5 = Number(_top5);
      var left = stack.pop();
      if (!Number.isNaN(left))
        left = Number(left);
      var ret = false;
      if (fc === "=") {
        ret = left === _top5;
      } else if (expr === ">") {
        ret = left > _top5;
      } else if (expr === ">=") {
        ret = left >= _top5;
      } else if (expr === "<") {
        ret = left < _top5;
      } else if (expr === "<=") {
        ret = left <= _top5;
      }
      stack.push(ret);
    } else if (Array.isArray(expr)) {
      var _expr = _slicedToArray(expr, 2), formula = _expr[0], len = _expr[1];
      var params = [];
      for (var j = 0; j < len; j += 1) {
        params.push(stack.pop());
      }
      stack.push(formulaMap[formula].render(params.reverse()));
    } else {
      if (cellList.includes(expr)) {
        return 0;
      }
      if (fc >= "a" && fc <= "z" || fc >= "A" && fc <= "Z") {
        cellList.push(expr);
      }
      stack.push(evalSubExpr(expr, cellRender3));
      cellList.pop();
    }
  }
  return stack[0];
};
var cellRender = function cellRender2(src, formulaMap, getCellText2) {
  var cellList = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (src[0] === "=") {
    var stack = infixExprToSuffixExpr(src.substring(1));
    if (stack.length <= 0)
      return src;
    return evalSuffixExpr(stack, formulaMap, function(x, y) {
      return cellRender2(getCellText2(x, y), formulaMap, getCellText2, cellList);
    }, cellList);
  }
  return src;
};
const _cell = {
  render: cellRender
};
var baseFormulas = [
  {
    key: "SUM",
    title: tf("formula.sum"),
    render: function render(ary) {
      return ary.reduce(function(a, b) {
        return numberCalc("+", a, b);
      }, 0);
    }
  },
  {
    key: "AVERAGE",
    title: tf("formula.average"),
    render: function render2(ary) {
      return ary.reduce(function(a, b) {
        return Number(a) + Number(b);
      }, 0) / ary.length;
    }
  },
  {
    key: "MAX",
    title: tf("formula.max"),
    render: function render3(ary) {
      return Math.max.apply(Math, _toConsumableArray(ary.map(function(v) {
        return Number(v);
      })));
    }
  },
  {
    key: "MIN",
    title: tf("formula.min"),
    render: function render4(ary) {
      return Math.min.apply(Math, _toConsumableArray(ary.map(function(v) {
        return Number(v);
      })));
    }
  },
  {
    key: "IF",
    title: tf("formula._if"),
    render: function render5(_ref) {
      var _ref2 = _slicedToArray(_ref, 3), b = _ref2[0], t2 = _ref2[1], f = _ref2[2];
      return b ? t2 : f;
    }
  },
  {
    key: "AND",
    title: tf("formula.and"),
    render: function render6(ary) {
      return ary.every(function(it) {
        return it;
      });
    }
  },
  {
    key: "OR",
    title: tf("formula.or"),
    render: function render7(ary) {
      return ary.some(function(it) {
        return it;
      });
    }
  },
  {
    key: "CONCAT",
    title: tf("formula.concat"),
    render: function render8(ary) {
      return ary.join("");
    }
  }
  /* support:  1 + A1 + B2 * 3
  {
    key: 'DIVIDE',
    title: tf('formula.divide'),
    render: ary => ary.reduce((a, b) => Number(a) / Number(b)),
  },
  {
    key: 'PRODUCT',
    title: tf('formula.product'),
    render: ary => ary.reduce((a, b) => Number(a) * Number(b),1),
  },
  {
    key: 'SUBTRACT',
    title: tf('formula.subtract'),
    render: ary => ary.reduce((a, b) => Number(a) - Number(b)),
  },
  */
];
var formulas = baseFormulas;
var formulam = {};
baseFormulas.forEach(function(f) {
  formulam[f.key] = f;
});
var formatStringRender = function formatStringRender2(v) {
  return v;
};
var formatNumberRender = function formatNumberRender2(v) {
  if (/^(-?\d*.?\d*)$/.test(v)) {
    var v1 = Number(v).toFixed(2).toString();
    var _v1$split = v1.split("\\."), _v1$split2 = _toArray(_v1$split), first = _v1$split2[0], parts = _v1$split2.slice(1);
    return [first.replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,")].concat(_toConsumableArray(parts));
  }
  return v;
};
var baseFormats = [{
  key: "normal",
  title: tf("format.normal"),
  type: "string",
  render: formatStringRender
}, {
  key: "text",
  title: tf("format.text"),
  type: "string",
  render: formatStringRender
}, {
  key: "number",
  title: tf("format.number"),
  type: "number",
  label: "1,000.12",
  render: formatNumberRender
}, {
  key: "percent",
  title: tf("format.percent"),
  type: "number",
  label: "10.12%",
  render: function render9(v) {
    return "".concat(v, "%");
  }
}, {
  key: "rmb",
  title: tf("format.rmb"),
  type: "number",
  label: "10.00",
  render: function render10(v) {
    return "".concat(formatNumberRender(v));
  }
}, {
  key: "usd",
  title: tf("format.usd"),
  type: "number",
  label: "$10.00",
  render: function render11(v) {
    return "$".concat(formatNumberRender(v));
  }
}, {
  key: "eur",
  title: tf("format.eur"),
  type: "number",
  label: "10.00",
  render: function render12(v) {
    return "".concat(formatNumberRender(v));
  }
}, {
  key: "date",
  title: tf("format.date"),
  type: "date",
  label: "26/09/2008",
  render: formatStringRender
}, {
  key: "time",
  title: tf("format.time"),
  type: "date",
  label: "15:59:00",
  render: formatStringRender
}, {
  key: "datetime",
  title: tf("format.datetime"),
  type: "date",
  label: "26/09/2008 15:59:00",
  render: formatStringRender
}, {
  key: "duration",
  title: tf("format.duration"),
  type: "date",
  label: "24:01:00",
  render: formatStringRender
}];
var formatm = {};
baseFormats.forEach(function(f) {
  formatm[f.key] = f;
});
var cellPaddingWidth = 5;
var tableFixedHeaderCleanStyle = {
  fillStyle: "#f4f5f8"
};
var tableGridStyle = {
  fillStyle: "#fff",
  lineWidth: thinLineWidth,
  strokeStyle: "#e6e6e6"
};
function tableFixedHeaderStyle() {
  return {
    textAlign: "center",
    textBaseline: "middle",
    font: "500 ".concat(npx(12), "px Source Sans Pro"),
    fillStyle: "#585757",
    lineWidth: thinLineWidth(),
    strokeStyle: "#e6e6e6"
  };
}
function getDrawBox(data, rindex, cindex) {
  var yoffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var _data$cellRect = data.cellRect(rindex, cindex), left = _data$cellRect.left, top = _data$cellRect.top, width2 = _data$cellRect.width, height2 = _data$cellRect.height;
  return new DrawBox(left, top + yoffset, width2, height2, cellPaddingWidth);
}
function renderCell(draw, data, rindex, cindex) {
  var yoffset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var sortedRowMap = data.sortedRowMap, rows = data.rows, cols = data.cols;
  if (rows.isHide(rindex) || cols.isHide(cindex))
    return;
  var nrindex = rindex;
  if (sortedRowMap.has(rindex)) {
    nrindex = sortedRowMap.get(rindex);
  }
  var cell = data.getCell(nrindex, cindex);
  if (cell === null)
    return;
  var frozen = false;
  if ("editable" in cell && cell.editable === false) {
    frozen = true;
  }
  var style = data.getCellStyleOrDefault(nrindex, cindex);
  var dbox = getDrawBox(data, rindex, cindex, yoffset);
  dbox.bgcolor = style.bgcolor;
  if (style.border !== void 0) {
    dbox.setBorders(style.border);
    draw.strokeBorders(dbox);
  }
  draw.rect(dbox, function() {
    var cellText = "";
    if (!data.settings.evalPaused) {
      cellText = _cell.render(cell.text || "", formulam, function(y, x) {
        return data.getCellTextOrDefault(x, y);
      });
    } else {
      cellText = cell.text || "";
    }
    if (style.format) {
      cellText = formatm[style.format].render(cellText);
    }
    var font = Object.assign({}, style.font);
    font.size = getFontSizePxByPt(font.size);
    draw.text(cellText, dbox, {
      align: style.align,
      valign: style.valign,
      font,
      color: style.color,
      strike: style.strike,
      underline: style.underline
    }, style.textwrap);
    var error = data.validations.getError(rindex, cindex);
    if (error) {
      draw.error(dbox);
    }
    if (frozen) {
      draw.frozen(dbox);
    }
  });
}
function renderAutofilter(viewRange) {
  var data = this.data, draw = this.draw;
  if (viewRange) {
    var autoFilter = data.autoFilter;
    if (!autoFilter.active())
      return;
    var afRange = autoFilter.hrange();
    if (viewRange.intersects(afRange)) {
      afRange.each(function(ri, ci) {
        var dbox = getDrawBox(data, ri, ci);
        draw.dropdown(dbox);
      });
    }
  }
}
function renderContent(viewRange, fw, fh, tx, ty) {
  var draw = this.draw, data = this.data;
  draw.save();
  draw.translate(fw, fh).translate(tx, ty);
  var exceptRowSet = data.exceptRowSet;
  var filteredTranslateFunc = function filteredTranslateFunc2(ri) {
    var ret = exceptRowSet.has(ri);
    if (ret) {
      var height2 = data.rows.getHeight(ri);
      draw.translate(0, -height2);
    }
    return !ret;
  };
  var exceptRowTotalHeight = data.exceptRowTotalHeight(viewRange.sri, viewRange.eri);
  draw.save();
  draw.translate(0, -exceptRowTotalHeight);
  viewRange.each(function(ri, ci) {
    renderCell(draw, data, ri, ci);
  }, function(ri) {
    return filteredTranslateFunc(ri);
  });
  draw.restore();
  var rset = /* @__PURE__ */ new Set();
  draw.save();
  draw.translate(0, -exceptRowTotalHeight);
  data.eachMergesInView(viewRange, function(_ref) {
    var sri = _ref.sri, sci = _ref.sci, eri = _ref.eri;
    if (!exceptRowSet.has(sri)) {
      renderCell(draw, data, sri, sci);
    } else if (!rset.has(sri)) {
      rset.add(sri);
      var height2 = data.rows.sumHeight(sri, eri + 1);
      draw.translate(0, -height2);
    }
  });
  draw.restore();
  renderAutofilter.call(this, viewRange);
  draw.restore();
}
function renderSelectedHeaderCell(x, y, w, h3) {
  var draw = this.draw;
  draw.save();
  draw.attr({
    fillStyle: "rgba(75, 137, 255, 0.08)"
  }).fillRect(x, y, w, h3);
  draw.restore();
}
function renderFixedHeaders(type, viewRange, w, h3, tx, ty) {
  var _this = this;
  var draw = this.draw, data = this.data;
  var sumHeight = viewRange.h;
  var sumWidth = viewRange.w;
  var nty = ty + h3;
  var ntx = tx + w;
  draw.save();
  draw.attr(tableFixedHeaderCleanStyle);
  if (type === "all" || type === "left")
    draw.fillRect(0, nty, w, sumHeight);
  if (type === "all" || type === "top")
    draw.fillRect(ntx, 0, sumWidth, h3);
  var _data$selector$range = data.selector.range, sri = _data$selector$range.sri, sci = _data$selector$range.sci, eri = _data$selector$range.eri, eci = _data$selector$range.eci;
  draw.attr(tableFixedHeaderStyle());
  if (type === "all" || type === "left") {
    data.rowEach(viewRange.sri, viewRange.eri, function(i, y1, rowHeight) {
      var y = nty + y1;
      var ii = i;
      draw.line([0, y], [w, y]);
      if (sri <= ii && ii < eri + 1) {
        renderSelectedHeaderCell.call(_this, 0, y, w, rowHeight);
      }
      draw.fillText(ii + 1, w / 2, y + rowHeight / 2);
      if (i > 0 && data.rows.isHide(i - 1)) {
        draw.save();
        draw.attr({
          strokeStyle: "#c6c6c6"
        });
        draw.line([5, y + 5], [w - 5, y + 5]);
        draw.restore();
      }
    });
    draw.line([0, sumHeight + nty], [w, sumHeight + nty]);
    draw.line([w, nty], [w, sumHeight + nty]);
  }
  if (type === "all" || type === "top") {
    data.colEach(viewRange.sci, viewRange.eci, function(i, x1, colWidth) {
      var x = ntx + x1;
      var ii = i;
      draw.line([x, 0], [x, h3]);
      if (sci <= ii && ii < eci + 1) {
        renderSelectedHeaderCell.call(_this, x, 0, colWidth, h3);
      }
      draw.fillText(stringAt(ii), x + colWidth / 2, h3 / 2);
      if (i > 0 && data.cols.isHide(i - 1)) {
        draw.save();
        draw.attr({
          strokeStyle: "#c6c6c6"
        });
        draw.line([x + 5, 5], [x + 5, h3 - 5]);
        draw.restore();
      }
    });
    draw.line([sumWidth + ntx, 0], [sumWidth + ntx, h3]);
    draw.line([0, h3], [sumWidth + ntx, h3]);
  }
  draw.restore();
}
function renderFixedLeftTopCell(fw, fh) {
  var draw = this.draw;
  draw.save();
  draw.attr({
    fillStyle: "#f4f5f8"
  }).fillRect(0, 0, fw, fh);
  draw.restore();
}
function renderContentGrid(_ref2, fw, fh, tx, ty) {
  var sri = _ref2.sri, sci = _ref2.sci, eri = _ref2.eri, eci = _ref2.eci, w = _ref2.w, h3 = _ref2.h;
  var draw = this.draw, data = this.data;
  var settings = data.settings;
  draw.save();
  draw.attr(tableGridStyle).translate(fw + tx, fh + ty);
  if (!settings.showGrid) {
    draw.restore();
    return;
  }
  data.rowEach(sri, eri, function(i, y, ch) {
    if (i !== sri)
      draw.line([0, y], [w, y]);
    if (i === eri)
      draw.line([0, y + ch], [w, y + ch]);
  });
  data.colEach(sci, eci, function(i, x, cw) {
    if (i !== sci)
      draw.line([x, 0], [x, h3]);
    if (i === eci)
      draw.line([x + cw, 0], [x + cw, h3]);
  });
  draw.restore();
}
function renderFreezeHighlightLine(fw, fh, ftw, fth) {
  var draw = this.draw, data = this.data;
  var twidth = data.viewWidth() - fw;
  var theight = data.viewHeight() - fh;
  draw.save().translate(fw, fh).attr({
    strokeStyle: "rgba(75, 137, 255, .6)"
  });
  draw.line([0, fth], [twidth, fth]);
  draw.line([ftw, 0], [ftw, theight]);
  draw.restore();
}
var Table = /* @__PURE__ */ function() {
  function Table2(el, data) {
    _classCallCheck(this, Table2);
    this.el = el;
    this.draw = new Draw(el, data.viewWidth(), data.viewHeight());
    this.data = data;
  }
  _createClass(Table2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.render();
    }
  }, {
    key: "render",
    value: function render13() {
      var data = this.data;
      var rows = data.rows, cols = data.cols;
      var fw = cols.indexWidth;
      var fh = rows.height;
      this.draw.resize(data.viewWidth(), data.viewHeight());
      this.clear();
      var viewRange = data.viewRange();
      var tx = data.freezeTotalWidth();
      var ty = data.freezeTotalHeight();
      var _data$scroll = data.scroll, x = _data$scroll.x, y = _data$scroll.y;
      renderContentGrid.call(this, viewRange, fw, fh, tx, ty);
      renderContent.call(this, viewRange, fw, fh, -x, -y);
      renderFixedHeaders.call(this, "all", viewRange, fw, fh, tx, ty);
      renderFixedLeftTopCell.call(this, fw, fh);
      var _data$freeze = _slicedToArray(data.freeze, 2), fri = _data$freeze[0], fci = _data$freeze[1];
      if (fri > 0 || fci > 0) {
        if (fri > 0) {
          var vr = viewRange.clone();
          vr.sri = 0;
          vr.eri = fri - 1;
          vr.h = ty;
          renderContentGrid.call(this, vr, fw, fh, tx, 0);
          renderContent.call(this, vr, fw, fh, -x, 0);
          renderFixedHeaders.call(this, "top", vr, fw, fh, tx, 0);
        }
        if (fci > 0) {
          var _vr = viewRange.clone();
          _vr.sci = 0;
          _vr.eci = fci - 1;
          _vr.w = tx;
          renderContentGrid.call(this, _vr, fw, fh, 0, ty);
          renderFixedHeaders.call(this, "left", _vr, fw, fh, 0, ty);
          renderContent.call(this, _vr, fw, fh, 0, -y);
        }
        var freezeViewRange = data.freezeViewRange();
        renderContentGrid.call(this, freezeViewRange, fw, fh, 0, 0);
        renderFixedHeaders.call(this, "all", freezeViewRange, fw, fh, 0, 0);
        renderContent.call(this, freezeViewRange, fw, fh, 0, 0);
        renderFreezeHighlightLine.call(this, fw, fh, tx, ty);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.draw.clear();
    }
  }]);
  return Table2;
}();
var PAGER_SIZES = [["A3", 11.69, 16.54], ["A4", 8.27, 11.69], ["A5", 5.83, 8.27], ["B4", 9.84, 13.9], ["B5", 6.93, 9.84]];
var PAGER_ORIENTATIONS = ["landscape", "portrait"];
function inches2px(inc) {
  return parseInt(96 * inc, 10);
}
function btnClick(type) {
  if (type === "cancel") {
    this.el.hide();
  } else {
    this.toPrint();
  }
}
function pagerSizeChange(evt) {
  var paper = this.paper;
  var value = evt.target.value;
  var ps = PAGER_SIZES[value];
  paper.w = inches2px(ps[1]);
  paper.h = inches2px(ps[2]);
  this.preview();
}
function pagerOrientationChange(evt) {
  var paper = this.paper;
  var value = evt.target.value;
  var v = PAGER_ORIENTATIONS[value];
  paper.orientation = v;
  this.preview();
}
var Print$1 = /* @__PURE__ */ function() {
  function Print2(data) {
    var _h, _h2;
    _classCallCheck(this, Print2);
    this.paper = {
      w: inches2px(PAGER_SIZES[0][1]),
      h: inches2px(PAGER_SIZES[0][2]),
      padding: 50,
      orientation: PAGER_ORIENTATIONS[0],
      get width() {
        return this.orientation === "landscape" ? this.h : this.w;
      },
      get height() {
        return this.orientation === "landscape" ? this.w : this.h;
      }
    };
    this.data = data;
    this.el = h("div", "".concat(cssPrefix, "-print")).children(h("div", "".concat(cssPrefix, "-print-bar")).children(h("div", "-title").child("Print settings"), h("div", "-right").children(h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", btnClick.bind(this, "cancel")), new Button("next", "primary").on("click", btnClick.bind(this, "next"))))), h("div", "".concat(cssPrefix, "-print-content")).children(this.contentEl = h("div", "-content"), h("div", "-sider").child(h("form", "").children(h("fieldset", "").children(h("label", "").child("".concat(t("print.size"))), (_h = h("select", "")).children.apply(_h, _toConsumableArray(PAGER_SIZES.map(function(it, index2) {
      return h("option", "").attr("value", index2).child("".concat(it[0], " ( ").concat(it[1], "''x").concat(it[2], "'' )"));
    }))).on("change", pagerSizeChange.bind(this))), h("fieldset", "").children(h("label", "").child("".concat(t("print.orientation"))), (_h2 = h("select", "")).children.apply(_h2, _toConsumableArray(PAGER_ORIENTATIONS.map(function(it, index2) {
      return h("option", "").attr("value", index2).child("".concat(t("print.orientations")[index2]));
    }))).on("change", pagerOrientationChange.bind(this))))))).hide();
  }
  _createClass(Print2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
    }
  }, {
    key: "preview",
    value: function preview() {
      var _this = this;
      var data = this.data, paper = this.paper;
      var width2 = paper.width, height2 = paper.height, padding = paper.padding;
      var iwidth = width2 - padding * 2;
      var iheight = height2 - padding * 2;
      var cr = data.contentRange();
      var pages = parseInt(cr.h / iheight, 10) + 1;
      var scale = iwidth / cr.w;
      var left = padding;
      var top = padding;
      if (scale > 1) {
        left += (iwidth - cr.w) / 2;
      }
      var ri = 0;
      var yoffset = 0;
      this.contentEl.html("");
      this.canvases = [];
      var mViewRange = {
        sri: 0,
        sci: 0,
        eri: 0,
        eci: 0
      };
      var _loop = function _loop2() {
        var th = 0;
        var yo = 0;
        var wrap = h("div", "".concat(cssPrefix, "-canvas-card"));
        var canvas = h("canvas", "".concat(cssPrefix, "-canvas"));
        _this.canvases.push(canvas.el);
        var draw = new Draw(canvas.el, width2, height2);
        draw.save();
        draw.translate(left, top);
        if (scale < 1)
          draw.scale(scale, scale);
        for (; ri <= cr.eri; ri += 1) {
          var rh = data.rows.getHeight(ri);
          th += rh;
          if (th < iheight) {
            for (var ci = 0; ci <= cr.eci; ci += 1) {
              renderCell(draw, data, ri, ci, yoffset);
              mViewRange.eci = ci;
            }
          } else {
            yo = -(th - rh);
            break;
          }
        }
        mViewRange.eri = ri;
        draw.restore();
        draw.save();
        draw.translate(left, top);
        if (scale < 1)
          draw.scale(scale, scale);
        var yof = yoffset;
        data.eachMergesInView(mViewRange, function(_ref) {
          var sri = _ref.sri, sci = _ref.sci;
          renderCell(draw, data, sri, sci, yof);
        });
        draw.restore();
        mViewRange.sri = mViewRange.eri;
        mViewRange.sci = mViewRange.eci;
        yoffset += yo;
        _this.contentEl.child(h("div", "".concat(cssPrefix, "-canvas-card-wraper")).child(wrap.child(canvas)));
      };
      for (var i = 0; i < pages; i += 1) {
        _loop();
      }
      this.el.show();
    }
  }, {
    key: "toPrint",
    value: function toPrint() {
      this.el.hide();
      var paper = this.paper;
      var iframe = h("iframe", "").hide();
      var el = iframe.el;
      window.document.body.appendChild(el);
      var contentWindow = el.contentWindow;
      var idoc = contentWindow.document;
      var style = document.createElement("style");
      style.innerHTML = "\n      @page { size: ".concat(paper.width, "px ").concat(paper.height, "px; };\n      canvas {\n        page-break-before: auto;        \n        page-break-after: always;\n        image-rendering: pixelated;\n      };\n    ");
      idoc.head.appendChild(style);
      this.canvases.forEach(function(it) {
        var cn = it.cloneNode(false);
        var ctx = cn.getContext("2d");
        ctx.drawImage(it, 0, 0);
        idoc.body.appendChild(cn);
      });
      contentWindow.print();
    }
  }]);
  return Print2;
}();
var menuItems$1 = [{
  key: "copy",
  title: tf("contextmenu.copy"),
  label: "Ctrl+C"
}, {
  key: "cut",
  title: tf("contextmenu.cut"),
  label: "Ctrl+X"
}, {
  key: "paste",
  title: tf("contextmenu.paste"),
  label: "Ctrl+V"
}, {
  key: "paste-value",
  title: tf("contextmenu.pasteValue"),
  label: "Ctrl+Shift+V"
}, {
  key: "paste-format",
  title: tf("contextmenu.pasteFormat"),
  label: "Ctrl+Alt+V"
}, {
  key: "divider"
}, {
  key: "insert-row",
  title: tf("contextmenu.insertRow")
}, {
  key: "insert-column",
  title: tf("contextmenu.insertColumn")
}, {
  key: "divider"
}, {
  key: "delete-row",
  title: tf("contextmenu.deleteRow")
}, {
  key: "delete-column",
  title: tf("contextmenu.deleteColumn")
}, {
  key: "delete-cell-text",
  title: tf("contextmenu.deleteCellText")
}, {
  key: "hide",
  title: tf("contextmenu.hide")
}, {
  key: "divider"
}, {
  key: "validation",
  title: tf("contextmenu.validation")
}, {
  key: "divider"
}, {
  key: "cell-printable",
  title: tf("contextmenu.cellprintable")
}, {
  key: "cell-non-printable",
  title: tf("contextmenu.cellnonprintable")
}, {
  key: "divider"
}, {
  key: "cell-editable",
  title: tf("contextmenu.celleditable")
}, {
  key: "cell-non-editable",
  title: tf("contextmenu.cellnoneditable")
}];
function buildMenuItem$1(item) {
  var _this = this;
  if (item.key === "divider") {
    return h("div", "".concat(cssPrefix, "-item divider"));
  }
  return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
    _this.itemClick(item.key);
    _this.hide();
  }).children(item.title(), h("div", "label").child(item.label || ""));
}
function buildMenu$2() {
  var _this2 = this;
  return menuItems$1.map(function(it) {
    return buildMenuItem$1.call(_this2, it);
  });
}
var ContextMenu$1 = /* @__PURE__ */ function() {
  function ContextMenu2(viewFn) {
    var _h;
    var isHide = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    _classCallCheck(this, ContextMenu2);
    this.menuItems = buildMenu$2.call(this);
    this.el = (_h = h("div", "".concat(cssPrefix, "-contextmenu"))).children.apply(_h, _toConsumableArray(this.menuItems)).hide();
    this.viewFn = viewFn;
    this.itemClick = function() {
    };
    this.isHide = isHide;
    this.setMode("range");
  }
  _createClass(ContextMenu2, [{
    key: "setMode",
    value: function setMode(mode) {
      var hideEl = this.menuItems[12];
      if (mode === "row-col") {
        hideEl.show();
      } else {
        hideEl.hide();
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      var el = this.el;
      el.hide();
      unbindClickoutside(el);
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y) {
      if (this.isHide)
        return;
      var el = this.el;
      var _el$show$offset = el.show().offset(), width2 = _el$show$offset.width;
      var view = this.viewFn();
      var vhf = view.height / 2;
      var left = x;
      if (view.width - x <= width2) {
        left -= width2;
      }
      el.css("left", "".concat(left, "px"));
      if (y > vhf) {
        el.css("bottom", "".concat(view.height - y, "px")).css("max-height", "".concat(y, "px")).css("top", "auto");
      } else {
        el.css("top", "".concat(y, "px")).css("max-height", "".concat(view.height - y, "px")).css("bottom", "auto");
      }
      bindClickoutside(el);
    }
  }]);
  return ContextMenu2;
}();
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function tooltip(html, target) {
  if (target.classList.contains("active")) {
    return;
  }
  var _target$getBoundingCl = target.getBoundingClientRect(), left = _target$getBoundingCl.left, top = _target$getBoundingCl.top, width2 = _target$getBoundingCl.width, height2 = _target$getBoundingCl.height;
  var el = h("div", "".concat(cssPrefix, "-tooltip")).html(html).show();
  document.body.appendChild(el.el);
  var elBox = el.box();
  el.css("left", "".concat(left + width2 / 2 - elBox.width / 2, "px")).css("top", "".concat(top + height2 + 2, "px"));
  bind(target, "mouseleave", function() {
    if (document.body.contains(el.el)) {
      document.body.removeChild(el.el);
    }
  });
  bind(target, "click", function() {
    if (document.body.contains(el.el)) {
      document.body.removeChild(el.el);
    }
  });
}
var Item = /* @__PURE__ */ function() {
  function Item2(tag, shortcut, value) {
    _classCallCheck(this, Item2);
    this.tip = t("toolbar.".concat(tag.replace(/-[a-z]/g, function(c) {
      return c[1].toUpperCase();
    })));
    if (shortcut)
      this.tip += " (".concat(shortcut, ")");
    this.tag = tag;
    this.shortcut = shortcut;
    this.value = value;
    this.el = this.element();
    this.change = function() {
    };
  }
  _createClass(Item2, [{
    key: "element",
    value: function element() {
      var tip = this.tip;
      return h("div", "".concat(cssPrefix, "-toolbar-btn")).on("mouseenter", function(evt) {
        tooltip(tip, evt.target);
      }).attr("data-tooltip", tip);
    }
  }, {
    key: "setState",
    value: function setState() {
    }
  }]);
  return Item2;
}();
function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownItem = /* @__PURE__ */ function(_Item) {
  _inherits(DropdownItem2, _Item);
  var _super = _createSuper$B(DropdownItem2);
  function DropdownItem2() {
    _classCallCheck(this, DropdownItem2);
    return _super.apply(this, arguments);
  }
  _createClass(DropdownItem2, [{
    key: "dropdown",
    value: function dropdown() {
    }
  }, {
    key: "getValue",
    value: function getValue(v) {
      return v;
    }
  }, {
    key: "element",
    value: function element() {
      var _this = this;
      var tag = this.tag;
      this.dd = this.dropdown();
      this.dd.change = function(it) {
        return _this.change(tag, _this.getValue(it));
      };
      return _get(_getPrototypeOf(DropdownItem2.prototype), "element", this).call(this).child(this.dd);
    }
  }, {
    key: "setState",
    value: function setState(v) {
      if (v) {
        this.value = v;
        this.dd.setTitle(v);
      }
    }
  }]);
  return DropdownItem2;
}(Item);
function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Dropdown = /* @__PURE__ */ function(_Element) {
  _inherits(Dropdown2, _Element);
  var _super = _createSuper$A(Dropdown2);
  function Dropdown2(title, width2, showArrow, placement) {
    var _this2;
    var _this;
    _classCallCheck(this, Dropdown2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-dropdown ").concat(placement));
    _this.title = title;
    _this.change = function() {
    };
    _this.headerClick = function() {
    };
    if (typeof title === "string") {
      _this.title = h("div", "".concat(cssPrefix, "-dropdown-title")).child(title);
    } else if (showArrow) {
      _this.title.addClass("arrow-left");
    }
    _this.contentEl = h("div", "".concat(cssPrefix, "-dropdown-content")).css("width", width2).hide();
    for (var _len = arguments.length, children = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      children[_key - 4] = arguments[_key];
    }
    (_this2 = _this).setContentChildren.apply(_this2, children);
    _this.headerEl = h("div", "".concat(cssPrefix, "-dropdown-header"));
    _this.headerEl.on("click", function() {
      if (_this.contentEl.css("display") !== "block") {
        _this.show();
      } else {
        _this.hide();
      }
    }).children(_this.title, showArrow ? h("div", "".concat(cssPrefix, "-icon arrow-right")).child(h("div", "".concat(cssPrefix, "-icon-img arrow-down"))) : "");
    _this.children(_this.headerEl, _this.contentEl);
    return _this;
  }
  _createClass(Dropdown2, [{
    key: "setContentChildren",
    value: function setContentChildren() {
      this.contentEl.html("");
      if (arguments.length > 0) {
        var _this$contentEl;
        (_this$contentEl = this.contentEl).children.apply(_this$contentEl, arguments);
      }
    }
  }, {
    key: "setTitle",
    value: function setTitle(title) {
      this.title.html(title);
      this.hide();
    }
  }, {
    key: "show",
    value: function show() {
      var _this3 = this;
      var contentEl = this.contentEl;
      contentEl.show();
      this.parent().active();
      bindClickoutside(this.parent(), function() {
        _this3.hide();
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.parent().active(false);
      this.contentEl.hide();
      unbindClickoutside(this.parent());
    }
  }]);
  return Dropdown2;
}(Element);
function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function buildItemWithIcon(iconName) {
  return h("div", "".concat(cssPrefix, "-item")).child(new Icon(iconName));
}
var DropdownAlign = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownAlign2, _Dropdown);
  var _super = _createSuper$z(DropdownAlign2);
  function DropdownAlign2(aligns, align) {
    var _this;
    _classCallCheck(this, DropdownAlign2);
    var icon = new Icon("align-".concat(align));
    var naligns = aligns.map(function(it) {
      return buildItemWithIcon("align-".concat(it)).on("click", function() {
        _this.setTitle(it);
        _this.change(it);
      });
    });
    return _this = _super.call.apply(_super, [this, icon, "auto", true, "bottom-left"].concat(_toConsumableArray(naligns)));
  }
  _createClass(DropdownAlign2, [{
    key: "setTitle",
    value: function setTitle(align) {
      this.title.setName("align-".concat(align));
      this.hide();
    }
  }]);
  return DropdownAlign2;
}(Dropdown);
function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Align = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Align2, _DropdownItem);
  var _super = _createSuper$y(Align2);
  function Align2(value) {
    _classCallCheck(this, Align2);
    return _super.call(this, "align", "", value);
  }
  _createClass(Align2, [{
    key: "dropdown",
    value: function dropdown() {
      var value = this.value;
      return new DropdownAlign(["left", "center", "right"], value);
    }
  }]);
  return Align2;
}(DropdownItem);
function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Valign = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Valign2, _DropdownItem);
  var _super = _createSuper$x(Valign2);
  function Valign2(value) {
    _classCallCheck(this, Valign2);
    return _super.call(this, "valign", "", value);
  }
  _createClass(Valign2, [{
    key: "dropdown",
    value: function dropdown() {
      var value = this.value;
      return new DropdownAlign(["top", "middle", "bottom"], value);
    }
  }]);
  return Valign2;
}(DropdownItem);
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ToggleItem = /* @__PURE__ */ function(_Item) {
  _inherits(ToggleItem2, _Item);
  var _super = _createSuper$w(ToggleItem2);
  function ToggleItem2() {
    _classCallCheck(this, ToggleItem2);
    return _super.apply(this, arguments);
  }
  _createClass(ToggleItem2, [{
    key: "element",
    value: function element() {
      var _this = this;
      var tag = this.tag;
      return _get(_getPrototypeOf(ToggleItem2.prototype), "element", this).call(this).child(new Icon(tag)).on("click", function() {
        return _this.click();
      });
    }
  }, {
    key: "click",
    value: function click() {
      this.change(this.tag, this.toggle());
    }
  }, {
    key: "setState",
    value: function setState(active) {
      this.el.active(active);
    }
  }, {
    key: "toggle",
    value: function toggle() {
      return this.el.toggle();
    }
  }, {
    key: "active",
    value: function active() {
      return this.el.hasClass("active");
    }
  }]);
  return ToggleItem2;
}(Item);
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Autofilter = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Autofilter2, _ToggleItem);
  var _super = _createSuper$v(Autofilter2);
  function Autofilter2() {
    _classCallCheck(this, Autofilter2);
    return _super.call(this, "autofilter");
  }
  _createClass(Autofilter2, [{
    key: "setState",
    value: function setState() {
    }
  }]);
  return Autofilter2;
}(ToggleItem);
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Bold = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Bold2, _ToggleItem);
  var _super = _createSuper$u(Bold2);
  function Bold2() {
    _classCallCheck(this, Bold2);
    return _super.call(this, "font-bold", "Ctrl+B");
  }
  return _createClass(Bold2);
}(ToggleItem);
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Italic = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Italic2, _ToggleItem);
  var _super = _createSuper$t(Italic2);
  function Italic2() {
    _classCallCheck(this, Italic2);
    return _super.call(this, "font-italic", "Ctrl+I");
  }
  return _createClass(Italic2);
}(ToggleItem);
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Strike = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Strike2, _ToggleItem);
  var _super = _createSuper$s(Strike2);
  function Strike2() {
    _classCallCheck(this, Strike2);
    return _super.call(this, "strike", "Ctrl+U");
  }
  return _createClass(Strike2);
}(ToggleItem);
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Underline = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Underline2, _ToggleItem);
  var _super = _createSuper$r(Underline2);
  function Underline2() {
    _classCallCheck(this, Underline2);
    return _super.call(this, "underline", "Ctrl+U");
  }
  return _createClass(Underline2);
}(ToggleItem);
var themeColorPlaceHolders = ["#ffffff", "#000100", "#e7e5e6", "#445569", "#5b9cd6", "#ed7d31", "#a5a5a5", "#ffc001", "#4371c6", "#71ae47"];
var themeColors = [["#f2f2f2", "#7f7f7f", "#d0cecf", "#d5dce4", "#deeaf6", "#fce5d5", "#ededed", "#fff2cd", "#d9e2f3", "#e3efd9"], ["#d8d8d8", "#595959", "#afabac", "#adb8ca", "#bdd7ee", "#f7ccac", "#dbdbdb", "#ffe59a", "#b3c6e7", "#c5e0b3"], ["#bfbfbf", "#3f3f3f", "#756f6f", "#8596b0", "#9cc2e6", "#f4b184", "#c9c9c9", "#fed964", "#8eaada", "#a7d08c"], ["#a5a5a5", "#262626", "#3a3839", "#333f4f", "#2e75b5", "#c45a10", "#7b7b7b", "#bf8e01", "#2f5596", "#538136"], ["#7f7f7f", "#0c0c0c", "#171516", "#222a35", "#1f4e7a", "#843c0a", "#525252", "#7e6000", "#203864", "#365624"]];
var standardColors = ["#c00000", "#fe0000", "#fdc101", "#ffff01", "#93d051", "#00b04e", "#01b0f1", "#0170c1", "#012060", "#7030a0"];
function buildTd$1(bgcolor) {
  var _this = this;
  return h("td", "").child(h("div", "".concat(cssPrefix, "-color-palette-cell")).on("click.stop", function() {
    return _this.change(bgcolor);
  }).css("background-color", bgcolor));
}
var ColorPalette = /* @__PURE__ */ _createClass(function ColorPalette2() {
  var _h, _h2, _this2 = this, _h4;
  _classCallCheck(this, ColorPalette2);
  this.el = h("div", "".concat(cssPrefix, "-color-palette"));
  this.change = function() {
  };
  var table = h("table", "").children((_h = h("tbody", "")).children.apply(_h, [(_h2 = h("tr", "".concat(cssPrefix, "-theme-color-placeholders"))).children.apply(_h2, _toConsumableArray(themeColorPlaceHolders.map(function(color) {
    return buildTd$1.call(_this2, color);
  })))].concat(_toConsumableArray(themeColors.map(function(it) {
    var _h3;
    return (_h3 = h("tr", "".concat(cssPrefix, "-theme-colors"))).children.apply(_h3, _toConsumableArray(it.map(function(color) {
      return buildTd$1.call(_this2, color);
    })));
  })), [(_h4 = h("tr", "".concat(cssPrefix, "-standard-colors"))).children.apply(_h4, _toConsumableArray(standardColors.map(function(color) {
    return buildTd$1.call(_this2, color);
  })))])));
  this.el.child(table);
});
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownColor = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownColor2, _Dropdown);
  var _super = _createSuper$q(DropdownColor2);
  function DropdownColor2(iconName, color) {
    var _this;
    _classCallCheck(this, DropdownColor2);
    var icon = new Icon(iconName).css("height", "16px").css("border-bottom", "3px solid ".concat(color));
    var colorPalette = new ColorPalette();
    colorPalette.change = function(v) {
      _this.setTitle(v);
      _this.change(v);
    };
    return _this = _super.call(this, icon, "auto", false, "bottom-left", colorPalette.el);
  }
  _createClass(DropdownColor2, [{
    key: "setTitle",
    value: function setTitle(color) {
      this.title.css("border-color", color);
      this.hide();
    }
  }]);
  return DropdownColor2;
}(Dropdown);
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var lineTypes = [
  ["thin", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" style="user-select: none;"></line></svg>'],
  ["medium", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="2" style="user-select: none;"><line x1="0" y1="1.0" x2="50" y2="1.0" stroke-width="2" stroke="black" style="user-select: none;"></line></svg>'],
  ["thick", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="3" style="user-select: none;"><line x1="0" y1="1.5" x2="50" y2="1.5" stroke-width="3" stroke="black" style="user-select: none;"></line></svg>'],
  ["dashed", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" stroke-dasharray="2" style="user-select: none;"></line></svg>'],
  ["dotted", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" stroke-dasharray="1" style="user-select: none;"></line></svg>']
  // ['double', '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="3" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" style="user-select: none;"></line><line x1="0" y1="2.5" x2="50" y2="2.5" stroke-width="1" stroke="black" style="user-select: none;"></line></svg>'],
];
var DropdownLineType = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownLineType2, _Dropdown);
  var _super = _createSuper$p(DropdownLineType2);
  function DropdownLineType2(type) {
    var _this;
    _classCallCheck(this, DropdownLineType2);
    var icon = new Icon("line-type");
    var beforei = 0;
    var lineTypeEls = lineTypes.map(function(it, iti) {
      return h("div", "".concat(cssPrefix, "-item state ").concat(type === it[0] ? "checked" : "")).on("click", function() {
        lineTypeEls[beforei].toggle("checked");
        lineTypeEls[iti].toggle("checked");
        beforei = iti;
        _this.hide();
        _this.change(it);
      }).child(h("div", "".concat(cssPrefix, "-line-type")).html(it[1]));
    });
    return _this = _super.call.apply(_super, [this, icon, "auto", false, "bottom-left"].concat(_toConsumableArray(lineTypeEls)));
  }
  return _createClass(DropdownLineType2);
}(Dropdown);
function buildTable() {
  var _h;
  return h("table", "").child((_h = h("tbody", "")).children.apply(_h, arguments));
}
function buildTd(iconName) {
  var _this = this;
  return h("td", "").child(h("div", "".concat(cssPrefix, "-border-palette-cell")).child(new Icon("border-".concat(iconName))).on("click", function() {
    _this.mode = iconName;
    var mode = _this.mode, style = _this.style, color = _this.color;
    _this.change({
      mode,
      style,
      color
    });
  }));
}
var BorderPalette = /* @__PURE__ */ _createClass(function BorderPalette2() {
  var _this2 = this, _h2, _h3;
  _classCallCheck(this, BorderPalette2);
  this.color = "#000";
  this.style = "thin";
  this.mode = "all";
  this.change = function() {
  };
  this.ddColor = new DropdownColor("line-color", this.color);
  this.ddColor.change = function(color) {
    _this2.color = color;
  };
  this.ddType = new DropdownLineType(this.style);
  this.ddType.change = function(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), s = _ref2[0];
    _this2.style = s;
  };
  this.el = h("div", "".concat(cssPrefix, "-border-palette"));
  var table = buildTable(h("tr", "").children(h("td", "".concat(cssPrefix, "-border-palette-left")).child(buildTable((_h2 = h("tr", "")).children.apply(_h2, _toConsumableArray(["all", "inside", "horizontal", "vertical", "outside"].map(function(it) {
    return buildTd.call(_this2, it);
  }))), (_h3 = h("tr", "")).children.apply(_h3, _toConsumableArray(["left", "top", "right", "bottom", "none"].map(function(it) {
    return buildTd.call(_this2, it);
  }))))), h("td", "".concat(cssPrefix, "-border-palette-right")).children(h("div", "".concat(cssPrefix, "-toolbar-btn")).child(this.ddColor.el), h("div", "".concat(cssPrefix, "-toolbar-btn")).child(this.ddType.el))));
  this.el.child(table);
});
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownBorder = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownBorder2, _Dropdown);
  var _super = _createSuper$o(DropdownBorder2);
  function DropdownBorder2() {
    var _this;
    _classCallCheck(this, DropdownBorder2);
    var icon = new Icon("border-all");
    var borderPalette = new BorderPalette();
    borderPalette.change = function(v) {
      _this.change(v);
      _this.hide();
    };
    return _this = _super.call(this, icon, "auto", false, "bottom-left", borderPalette.el);
  }
  return _createClass(DropdownBorder2);
}(Dropdown);
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Border = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Border2, _DropdownItem);
  var _super = _createSuper$n(Border2);
  function Border2() {
    _classCallCheck(this, Border2);
    return _super.call(this, "border");
  }
  _createClass(Border2, [{
    key: "dropdown",
    value: function dropdown() {
      return new DropdownBorder();
    }
  }]);
  return Border2;
}(DropdownItem);
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var IconItem = /* @__PURE__ */ function(_Item) {
  _inherits(IconItem2, _Item);
  var _super = _createSuper$m(IconItem2);
  function IconItem2() {
    _classCallCheck(this, IconItem2);
    return _super.apply(this, arguments);
  }
  _createClass(IconItem2, [{
    key: "element",
    value: function element() {
      var _this = this;
      return _get(_getPrototypeOf(IconItem2.prototype), "element", this).call(this).child(new Icon(this.tag)).on("click", function() {
        return _this.change(_this.tag);
      });
    }
  }, {
    key: "setState",
    value: function setState(disabled) {
      this.el.disabled(disabled);
    }
  }]);
  return IconItem2;
}(Item);
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Clearformat = /* @__PURE__ */ function(_IconItem) {
  _inherits(Clearformat2, _IconItem);
  var _super = _createSuper$l(Clearformat2);
  function Clearformat2() {
    _classCallCheck(this, Clearformat2);
    return _super.call(this, "clearformat");
  }
  return _createClass(Clearformat2);
}(IconItem);
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Paintformat = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Paintformat2, _ToggleItem);
  var _super = _createSuper$k(Paintformat2);
  function Paintformat2() {
    _classCallCheck(this, Paintformat2);
    return _super.call(this, "paintformat");
  }
  _createClass(Paintformat2, [{
    key: "setState",
    value: function setState() {
    }
  }]);
  return Paintformat2;
}(ToggleItem);
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var TextColor = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(TextColor2, _DropdownItem);
  var _super = _createSuper$j(TextColor2);
  function TextColor2(color) {
    _classCallCheck(this, TextColor2);
    return _super.call(this, "color", void 0, color);
  }
  _createClass(TextColor2, [{
    key: "dropdown",
    value: function dropdown() {
      var tag = this.tag, value = this.value;
      return new DropdownColor(tag, value);
    }
  }]);
  return TextColor2;
}(DropdownItem);
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var FillColor = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(FillColor2, _DropdownItem);
  var _super = _createSuper$i(FillColor2);
  function FillColor2(color) {
    _classCallCheck(this, FillColor2);
    return _super.call(this, "bgcolor", void 0, color);
  }
  _createClass(FillColor2, [{
    key: "dropdown",
    value: function dropdown() {
      var tag = this.tag, value = this.value;
      return new DropdownColor(tag, value);
    }
  }]);
  return FillColor2;
}(DropdownItem);
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFontSize = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFontSize2, _Dropdown);
  var _super = _createSuper$h(DropdownFontSize2);
  function DropdownFontSize2() {
    var _this;
    _classCallCheck(this, DropdownFontSize2);
    var nfontSizes = fontSizes.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.setTitle("".concat(it.pt));
        _this.change(it);
      }).child("".concat(it.pt));
    });
    return _this = _super.call.apply(_super, [this, "10", "60px", true, "bottom-left"].concat(_toConsumableArray(nfontSizes)));
  }
  return _createClass(DropdownFontSize2);
}(Dropdown);
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format$2 = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$g(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "font-size");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.pt;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFontSize();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFont = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFont2, _Dropdown);
  var _super = _createSuper$f(DropdownFont2);
  function DropdownFont2() {
    var _this;
    _classCallCheck(this, DropdownFont2);
    var nfonts = baseFonts.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.setTitle(it.title);
        _this.change(it);
      }).child(it.title);
    });
    return _this = _super.call.apply(_super, [this, baseFonts[0].title, "160px", true, "bottom-left"].concat(_toConsumableArray(nfonts)));
  }
  return _createClass(DropdownFont2);
}(Dropdown);
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Font = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Font2, _DropdownItem);
  var _super = _createSuper$e(Font2);
  function Font2() {
    _classCallCheck(this, Font2);
    return _super.call(this, "font-name");
  }
  _createClass(Font2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFont();
    }
  }]);
  return Font2;
}(DropdownItem);
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFormat = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFormat2, _Dropdown);
  var _super = _createSuper$d(DropdownFormat2);
  function DropdownFormat2() {
    var _this;
    _classCallCheck(this, DropdownFormat2);
    var nformats = baseFormats.slice(0);
    nformats.splice(2, 0, {
      key: "divider"
    });
    nformats.splice(8, 0, {
      key: "divider"
    });
    nformats = nformats.map(function(it) {
      var item = h("div", "".concat(cssPrefix, "-item"));
      if (it.key === "divider") {
        item.addClass("divider");
      } else {
        item.child(it.title()).on("click", function() {
          _this.setTitle(it.title());
          _this.change(it);
        });
        if (it.label)
          item.child(h("div", "label").html(it.label));
      }
      return item;
    });
    return _this = _super.call.apply(_super, [this, "Normal", "220px", true, "bottom-left"].concat(_toConsumableArray(nformats)));
  }
  _createClass(DropdownFormat2, [{
    key: "setTitle",
    value: function setTitle(key) {
      for (var i = 0; i < baseFormats.length; i += 1) {
        if (baseFormats[i].key === key) {
          this.title.html(baseFormats[i].title());
        }
      }
      this.hide();
    }
  }]);
  return DropdownFormat2;
}(Dropdown);
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format$1 = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$c(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "format");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFormat();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFormula = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFormula2, _Dropdown);
  var _super = _createSuper$b(DropdownFormula2);
  function DropdownFormula2() {
    var _this;
    _classCallCheck(this, DropdownFormula2);
    var nformulas = baseFormulas.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.hide();
        _this.change(it);
      }).child(it.key);
    });
    return _this = _super.call.apply(_super, [this, new Icon("formula"), "180px", true, "bottom-left"].concat(_toConsumableArray(nformulas)));
  }
  return _createClass(DropdownFormula2);
}(Dropdown);
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$a(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "formula");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFormula();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Freeze = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Freeze2, _ToggleItem);
  var _super = _createSuper$9(Freeze2);
  function Freeze2() {
    _classCallCheck(this, Freeze2);
    return _super.call(this, "freeze");
  }
  return _createClass(Freeze2);
}(ToggleItem);
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Merge = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Merge2, _ToggleItem);
  var _super = _createSuper$8(Merge2);
  function Merge2() {
    _classCallCheck(this, Merge2);
    return _super.call(this, "merge");
  }
  _createClass(Merge2, [{
    key: "setState",
    value: function setState(active, disabled) {
      this.el.active(active).disabled(disabled);
    }
  }]);
  return Merge2;
}(ToggleItem);
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Redo = /* @__PURE__ */ function(_IconItem) {
  _inherits(Redo2, _IconItem);
  var _super = _createSuper$7(Redo2);
  function Redo2() {
    _classCallCheck(this, Redo2);
    return _super.call(this, "redo", "Ctrl+Y");
  }
  return _createClass(Redo2);
}(IconItem);
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Undo = /* @__PURE__ */ function(_IconItem) {
  _inherits(Undo2, _IconItem);
  var _super = _createSuper$6(Undo2);
  function Undo2() {
    _classCallCheck(this, Undo2);
    return _super.call(this, "undo", "Ctrl+Z");
  }
  return _createClass(Undo2);
}(IconItem);
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Print = /* @__PURE__ */ function(_IconItem) {
  _inherits(Print2, _IconItem);
  var _super = _createSuper$5(Print2);
  function Print2() {
    _classCallCheck(this, Print2);
    return _super.call(this, "print", "Ctrl+P");
  }
  return _createClass(Print2);
}(IconItem);
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Textwrap = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Textwrap2, _ToggleItem);
  var _super = _createSuper$4(Textwrap2);
  function Textwrap2() {
    _classCallCheck(this, Textwrap2);
    return _super.call(this, "textwrap");
  }
  return _createClass(Textwrap2);
}(ToggleItem);
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownMore$1 = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownMore2, _Dropdown);
  var _super = _createSuper$3(DropdownMore2);
  function DropdownMore2() {
    var _this;
    _classCallCheck(this, DropdownMore2);
    var icon = new Icon("ellipsis");
    var moreBtns = h("div", "".concat(cssPrefix, "-toolbar-more"));
    _this = _super.call(this, icon, "auto", false, "bottom-right", moreBtns);
    _this.moreBtns = moreBtns;
    _this.contentEl.css("max-width", "420px");
    return _this;
  }
  return _createClass(DropdownMore2);
}(Dropdown);
var More = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(More2, _DropdownItem);
  var _super2 = _createSuper$3(More2);
  function More2() {
    var _this2;
    _classCallCheck(this, More2);
    _this2 = _super2.call(this, "more");
    _this2.el.hide();
    return _this2;
  }
  _createClass(More2, [{
    key: "dropdown",
    value: function dropdown() {
      return new DropdownMore$1();
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }]);
  return More2;
}(DropdownItem);
function buildDivider() {
  return h("div", "".concat(cssPrefix, "-toolbar-divider"));
}
function initBtns2() {
  var _this = this;
  this.btns2 = [];
  this.items.forEach(function(it) {
    if (Array.isArray(it)) {
      it.forEach(function(_ref) {
        var el = _ref.el;
        var rect2 = el.box();
        var _el$computedStyle = el.computedStyle(), marginLeft2 = _el$computedStyle.marginLeft, marginRight2 = _el$computedStyle.marginRight;
        _this.btns2.push([el, rect2.width + parseInt(marginLeft2, 10) + parseInt(marginRight2, 10)]);
      });
    } else {
      var rect = it.box();
      var _it$computedStyle = it.computedStyle(), marginLeft = _it$computedStyle.marginLeft, marginRight = _it$computedStyle.marginRight;
      _this.btns2.push([it, rect.width + parseInt(marginLeft, 10) + parseInt(marginRight, 10)]);
    }
  });
}
function moreResize() {
  var _btns$html, _moreBtns$html;
  var el = this.el, btns = this.btns, moreEl = this.moreEl, btns2 = this.btns2;
  var _moreEl$dd = moreEl.dd, moreBtns = _moreEl$dd.moreBtns, contentEl = _moreEl$dd.contentEl;
  el.css("width", "".concat(this.widthFn() - 60, "px"));
  var elBox = el.box();
  var sumWidth = 160;
  var sumWidth2 = 12;
  var list1 = [];
  var list2 = [];
  btns2.forEach(function(_ref2, index2) {
    var _ref3 = _slicedToArray(_ref2, 2), it = _ref3[0], w = _ref3[1];
    sumWidth += w;
    if (index2 === btns2.length - 1 || sumWidth < elBox.width) {
      list1.push(it);
    } else {
      sumWidth2 += w;
      list2.push(it);
    }
  });
  (_btns$html = btns.html("")).children.apply(_btns$html, list1);
  (_moreBtns$html = moreBtns.html("")).children.apply(_moreBtns$html, list2);
  contentEl.css("width", "".concat(sumWidth2, "px"));
  if (list2.length > 0) {
    moreEl.show();
  } else {
    moreEl.hide();
  }
}
var Toolbar = /* @__PURE__ */ function() {
  function Toolbar2(data, widthFn) {
    var _this2 = this;
    var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    _classCallCheck(this, Toolbar2);
    this.data = data;
    this.change = function() {
    };
    this.widthFn = widthFn;
    this.isHide = isHide;
    var style = data.defaultStyle();
    this.items = [[this.undoEl = new Undo(), this.redoEl = new Redo(), new Print(), this.paintformatEl = new Paintformat(), this.clearformatEl = new Clearformat()], buildDivider(), [this.formatEl = new Format$1()], buildDivider(), [this.fontEl = new Font(), this.fontSizeEl = new Format$2()], buildDivider(), [this.boldEl = new Bold(), this.italicEl = new Italic(), this.underlineEl = new Underline(), this.strikeEl = new Strike(), this.textColorEl = new TextColor(style.color)], buildDivider(), [this.fillColorEl = new FillColor(style.bgcolor), this.borderEl = new Border(), this.mergeEl = new Merge()], buildDivider(), [this.alignEl = new Align(style.align), this.valignEl = new Valign(style.valign), this.textwrapEl = new Textwrap()], buildDivider(), [this.freezeEl = new Freeze(), this.autofilterEl = new Autofilter(), this.formulaEl = new Format(), this.moreEl = new More()]];
    this.el = h("div", "".concat(cssPrefix, "-toolbar"));
    this.btns = h("div", "".concat(cssPrefix, "-toolbar-btns"));
    this.items.forEach(function(it) {
      if (Array.isArray(it)) {
        it.forEach(function(i) {
          _this2.btns.child(i.el);
          i.change = function() {
            _this2.change.apply(_this2, arguments);
          };
        });
      } else {
        _this2.btns.child(it.el);
      }
    });
    this.el.child(this.btns);
    if (isHide) {
      this.el.hide();
    } else {
      this.reset();
      setTimeout(function() {
        initBtns2.call(_this2);
        moreResize.call(_this2);
      }, 0);
      bind(window, "resize", function() {
        moreResize.call(_this2);
      });
    }
  }
  _createClass(Toolbar2, [{
    key: "paintformatActive",
    value: function paintformatActive() {
      return this.paintformatEl.active();
    }
  }, {
    key: "paintformatToggle",
    value: function paintformatToggle() {
      this.paintformatEl.toggle();
    }
  }, {
    key: "trigger",
    value: function trigger(type) {
      this["".concat(type, "El")].click();
    }
  }, {
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.isHide)
        return;
      var data = this.data;
      var style = data.getSelectedCellStyle();
      this.undoEl.setState(!data.canUndo());
      this.redoEl.setState(!data.canRedo());
      this.mergeEl.setState(data.canUnmerge(), !data.selector.multiple());
      this.autofilterEl.setState(!data.canAutofilter());
      var font = style.font, format = style.format;
      this.formatEl.setState(format);
      this.fontEl.setState(font.name);
      this.fontSizeEl.setState(font.size);
      this.boldEl.setState(font.bold);
      this.italicEl.setState(font.italic);
      this.underlineEl.setState(style.underline);
      this.strikeEl.setState(style.strike);
      this.textColorEl.setState(style.color);
      this.fillColorEl.setState(style.bgcolor);
      this.alignEl.setState(style.align);
      this.valignEl.setState(style.valign);
      this.textwrapEl.setState(style.textwrap);
      this.freezeEl.setState(data.freezeIsActive());
    }
  }]);
  return Toolbar2;
}();
var Modal = /* @__PURE__ */ function() {
  function Modal2(title, content) {
    var _this = this, _h;
    var width2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "600px";
    _classCallCheck(this, Modal2);
    this.title = title;
    this.el = h("div", "".concat(cssPrefix, "-modal")).css("width", width2).children(h("div", "".concat(cssPrefix, "-modal-header")).children(new Icon("close").on("click.stop", function() {
      return _this.hide();
    }), this.title), (_h = h("div", "".concat(cssPrefix, "-modal-content"))).children.apply(_h, _toConsumableArray(content))).hide();
  }
  _createClass(Modal2, [{
    key: "show",
    value: function show() {
      var _this2 = this;
      this.dimmer = h("div", "".concat(cssPrefix, "-dimmer active"));
      document.body.appendChild(this.dimmer.el);
      var _this$el$show$box = this.el.show().box(), width2 = _this$el$show$box.width, height2 = _this$el$show$box.height;
      var _document$documentEle = document.documentElement, clientHeight = _document$documentEle.clientHeight, clientWidth = _document$documentEle.clientWidth;
      this.el.offset({
        left: (clientWidth - width2) / 2,
        top: (clientHeight - height2) / 3
      });
      window.xkeydownEsc = function(evt) {
        if (evt.keyCode === 27) {
          _this2.hide();
        }
      };
      bind(window, "keydown", window.xkeydownEsc);
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      document.body.removeChild(this.dimmer.el);
      unbind(window, "keydown", window.xkeydownEsc);
      delete window.xkeydownEsc;
    }
  }]);
  return Modal2;
}();
var FormInput = /* @__PURE__ */ function() {
  function FormInput2(width2, hint) {
    var _this = this;
    _classCallCheck(this, FormInput2);
    this.vchange = function() {
    };
    this.el = h("div", "".concat(cssPrefix, "-form-input"));
    this.input = h("input", "").css("width", width2).on("input", function(evt) {
      return _this.vchange(evt);
    }).attr("placeholder", hint);
    this.el.child(this.input);
  }
  _createClass(FormInput2, [{
    key: "focus",
    value: function focus() {
      var _this2 = this;
      setTimeout(function() {
        _this2.input.el.focus();
      }, 10);
    }
  }, {
    key: "hint",
    value: function hint(v) {
      this.input.attr("placeholder", v);
    }
  }, {
    key: "val",
    value: function val(v) {
      return this.input.val(v);
    }
  }]);
  return FormInput2;
}();
var FormSelect = /* @__PURE__ */ function() {
  function FormSelect2(key, items, width2) {
    var _this = this;
    var getTitle = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function(it) {
      return it;
    };
    var change = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
    };
    _classCallCheck(this, FormSelect2);
    this.key = key;
    this.getTitle = getTitle;
    this.vchange = function() {
    };
    this.el = h("div", "".concat(cssPrefix, "-form-select"));
    this.suggest = new Suggest(items.map(function(it) {
      return {
        key: it,
        title: _this.getTitle(it)
      };
    }), function(it) {
      _this.itemClick(it.key);
      change(it.key);
      _this.vchange(it.key);
    }, width2, this.el);
    this.el.children(this.itemEl = h("div", "input-text").html(this.getTitle(key)), this.suggest.el).on("click", function() {
      return _this.show();
    });
  }
  _createClass(FormSelect2, [{
    key: "show",
    value: function show() {
      this.suggest.search("");
    }
  }, {
    key: "itemClick",
    value: function itemClick(it) {
      this.key = it;
      this.itemEl.html(this.getTitle(it));
    }
  }, {
    key: "val",
    value: function val(v) {
      if (v !== void 0) {
        this.key = v;
        this.itemEl.html(this.getTitle(v));
        return this;
      }
      return this.key;
    }
  }]);
  return FormSelect2;
}();
var patterns = {
  number: /(^\d+$)|(^\d+(\.\d{0,4})?$)/,
  date: /^\d{4}-\d{1,2}-\d{1,2}$/
};
var FormField = /* @__PURE__ */ function() {
  function FormField2(input, rule, label, labelWidth) {
    var _this = this;
    _classCallCheck(this, FormField2);
    this.label = "";
    this.rule = rule;
    if (label) {
      this.label = h("label", "label").css("width", "".concat(labelWidth, "px")).html(label);
    }
    this.tip = h("div", "tip").child("tip").hide();
    this.input = input;
    this.input.vchange = function() {
      return _this.validate();
    };
    this.el = h("div", "".concat(cssPrefix, "-form-field")).children(this.label, input.el, this.tip);
  }
  _createClass(FormField2, [{
    key: "isShow",
    value: function isShow() {
      return this.el.css("display") !== "none";
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      return this;
    }
  }, {
    key: "val",
    value: function val(v) {
      return this.input.val(v);
    }
  }, {
    key: "hint",
    value: function hint(_hint) {
      this.input.hint(_hint);
    }
  }, {
    key: "validate",
    value: function validate() {
      var input = this.input, rule = this.rule, tip = this.tip, el = this.el;
      var v = input.val();
      if (rule.required) {
        if (/^\s*$/.test(v)) {
          tip.html(t("validation.required"));
          el.addClass("error");
          return false;
        }
      }
      if (rule.type || rule.pattern) {
        var pattern = rule.pattern || patterns[rule.type];
        if (!pattern.test(v)) {
          tip.html(t("validation.notMatch"));
          el.addClass("error");
          return false;
        }
      }
      el.removeClass("error");
      return true;
    }
  }]);
  return FormField2;
}();
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var fieldLabelWidth = 100;
var ModalValidation = /* @__PURE__ */ function(_Modal) {
  _inherits(ModalValidation2, _Modal);
  var _super = _createSuper$2(ModalValidation2);
  function ModalValidation2() {
    var _this;
    _classCallCheck(this, ModalValidation2);
    var mf = new FormField(new FormSelect(
      "cell",
      ["cell"],
      // cell|row|column
      "100%",
      function(it) {
        return t("dataValidation.modeType.".concat(it));
      }
    ), {
      required: true
    }, "".concat(t("dataValidation.range"), ":"), fieldLabelWidth);
    var rf = new FormField(new FormInput("120px", "E3 or E3:F12"), {
      required: true,
      pattern: /^([A-Z]{1,2}[1-9]\d*)(:[A-Z]{1,2}[1-9]\d*)?$/
    });
    var cf = new FormField(new FormSelect("list", ["list", "number", "date", "phone", "email"], "100%", function(it) {
      return t("dataValidation.type.".concat(it));
    }, function(it) {
      return _this.criteriaSelected(it);
    }), {
      required: true
    }, "".concat(t("dataValidation.criteria"), ":"), fieldLabelWidth);
    var of = new FormField(new FormSelect("be", ["be", "nbe", "eq", "neq", "lt", "lte", "gt", "gte"], "160px", function(it) {
      return t("dataValidation.operator.".concat(it));
    }, function(it) {
      return _this.criteriaOperatorSelected(it);
    }), {
      required: true
    }).hide();
    var minvf = new FormField(new FormInput("70px", "10"), {
      required: true
    }).hide();
    var maxvf = new FormField(new FormInput("70px", "100"), {
      required: true,
      type: "number"
    }).hide();
    var svf = new FormField(new FormInput("120px", "a,b,c"), {
      required: true
    });
    var vf = new FormField(new FormInput("70px", "10"), {
      required: true,
      type: "number"
    }).hide();
    _this = _super.call(this, t("contextmenu.validation"), [h("div", "".concat(cssPrefix, "-form-fields")).children(mf.el, rf.el), h("div", "".concat(cssPrefix, "-form-fields")).children(cf.el, of.el, minvf.el, maxvf.el, vf.el, svf.el), h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", function() {
      return _this.btnClick("cancel");
    }), new Button("remove").on("click", function() {
      return _this.btnClick("remove");
    }), new Button("save", "primary").on("click", function() {
      return _this.btnClick("save");
    }))]);
    _this.mf = mf;
    _this.rf = rf;
    _this.cf = cf;
    _this.of = of;
    _this.minvf = minvf;
    _this.maxvf = maxvf;
    _this.vf = vf;
    _this.svf = svf;
    _this.change = function() {
    };
    return _this;
  }
  _createClass(ModalValidation2, [{
    key: "showVf",
    value: function showVf(it) {
      var hint = it === "date" ? "2018-11-12" : "10";
      var vf = this.vf;
      vf.input.hint(hint);
      vf.show();
    }
  }, {
    key: "criteriaSelected",
    value: function criteriaSelected(it) {
      var of = this.of, minvf = this.minvf, maxvf = this.maxvf, vf = this.vf, svf = this.svf;
      if (it === "date" || it === "number") {
        of.show();
        minvf.rule.type = it;
        maxvf.rule.type = it;
        if (it === "date") {
          minvf.hint("2018-11-12");
          maxvf.hint("2019-11-12");
        } else {
          minvf.hint("10");
          maxvf.hint("100");
        }
        minvf.show();
        maxvf.show();
        vf.hide();
        svf.hide();
      } else {
        if (it === "list") {
          svf.show();
        } else {
          svf.hide();
        }
        vf.hide();
        of.hide();
        minvf.hide();
        maxvf.hide();
      }
    }
  }, {
    key: "criteriaOperatorSelected",
    value: function criteriaOperatorSelected(it) {
      if (!it)
        return;
      var minvf = this.minvf, maxvf = this.maxvf, vf = this.vf;
      if (it === "be" || it === "nbe") {
        minvf.show();
        maxvf.show();
        vf.hide();
      } else {
        var type = this.cf.val();
        vf.rule.type = type;
        if (type === "date") {
          vf.hint("2018-11-12");
        } else {
          vf.hint("10");
        }
        vf.show();
        minvf.hide();
        maxvf.hide();
      }
    }
  }, {
    key: "btnClick",
    value: function btnClick2(action) {
      if (action === "cancel") {
        this.hide();
      } else if (action === "remove") {
        this.change("remove");
        this.hide();
      } else if (action === "save") {
        var attrs = ["mf", "rf", "cf", "of", "svf", "vf", "minvf", "maxvf"];
        for (var i = 0; i < attrs.length; i += 1) {
          var field = this[attrs[i]];
          if (field.isShow()) {
            if (!field.validate())
              return;
          }
        }
        var mode = this.mf.val();
        var ref2 = this.rf.val();
        var type = this.cf.val();
        var operator = this.of.val();
        var value = this.svf.val();
        if (type === "number" || type === "date") {
          if (operator === "be" || operator === "nbe") {
            value = [this.minvf.val(), this.maxvf.val()];
          } else {
            value = this.vf.val();
          }
        }
        this.change("save", mode, ref2, {
          type,
          operator,
          required: false,
          value
        });
        this.hide();
      }
    }
    // validation: { mode, ref, validator }
  }, {
    key: "setValue",
    value: function setValue(v) {
      if (v) {
        var mf = this.mf, rf = this.rf, cf = this.cf, of = this.of, svf = this.svf, vf = this.vf, minvf = this.minvf, maxvf = this.maxvf;
        var mode = v.mode, ref2 = v.ref, validator = v.validator;
        var _ref = validator || {
          type: "list"
        }, type = _ref.type, operator = _ref.operator, value = _ref.value;
        mf.val(mode || "cell");
        rf.val(ref2);
        cf.val(type);
        of.val(operator);
        if (Array.isArray(value)) {
          minvf.val(value[0]);
          maxvf.val(value[1]);
        } else {
          svf.val(value || "");
          vf.val(value || "");
        }
        this.criteriaSelected(type);
        this.criteriaOperatorSelected(operator);
      }
      this.show();
    }
  }]);
  return ModalValidation2;
}(Modal);
function buildMenu$1(clsName) {
  return h("div", "".concat(cssPrefix, "-item ").concat(clsName));
}
function buildSortItem(it) {
  var _this = this;
  return buildMenu$1("state").child(t("sort.".concat(it))).on("click.stop", function() {
    return _this.itemClick(it);
  });
}
function buildFilterBody(items) {
  var _this2 = this;
  var filterbEl = this.filterbEl, filterValues = this.filterValues;
  filterbEl.html("");
  var itemKeys = Object.keys(items);
  itemKeys.forEach(function(it, index2) {
    var cnt = items[it];
    var active = filterValues.includes(it) ? "checked" : "";
    filterbEl.child(h("div", "".concat(cssPrefix, "-item state ").concat(active)).on("click.stop", function() {
      return _this2.filterClick(index2, it);
    }).children(it === "" ? t("filter.empty") : it, h("div", "label").html("(".concat(cnt, ")"))));
  });
}
function resetFilterHeader() {
  var filterhEl = this.filterhEl, filterValues = this.filterValues, values = this.values;
  filterhEl.html("".concat(filterValues.length, " / ").concat(values.length));
  filterhEl.checked(filterValues.length === values.length);
}
var SortFilter = /* @__PURE__ */ function() {
  function SortFilter2() {
    var _this3 = this;
    _classCallCheck(this, SortFilter2);
    this.filterbEl = h("div", "".concat(cssPrefix, "-body"));
    this.filterhEl = h("div", "".concat(cssPrefix, "-header state")).on("click.stop", function() {
      return _this3.filterClick(0, "all");
    });
    this.el = h("div", "".concat(cssPrefix, "-sort-filter")).children(this.sortAscEl = buildSortItem.call(this, "asc"), this.sortDescEl = buildSortItem.call(this, "desc"), buildMenu$1("divider"), h("div", "".concat(cssPrefix, "-filter")).children(this.filterhEl, this.filterbEl), h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", function() {
      return _this3.btnClick("cancel");
    }), new Button("ok", "primary").on("click", function() {
      return _this3.btnClick("ok");
    }))).hide();
    this.ci = null;
    this.sortDesc = null;
    this.values = null;
    this.filterValues = [];
  }
  _createClass(SortFilter2, [{
    key: "btnClick",
    value: function btnClick2(it) {
      if (it === "ok") {
        var ci = this.ci, sort = this.sort, filterValues = this.filterValues;
        if (this.ok) {
          this.ok(ci, sort, "in", filterValues);
        }
      }
      this.hide();
    }
  }, {
    key: "itemClick",
    value: function itemClick(it) {
      this.sort = it;
      var sortAscEl = this.sortAscEl, sortDescEl = this.sortDescEl;
      sortAscEl.checked(it === "asc");
      sortDescEl.checked(it === "desc");
    }
  }, {
    key: "filterClick",
    value: function filterClick(index2, it) {
      var filterbEl = this.filterbEl, filterValues = this.filterValues, values = this.values;
      var children = filterbEl.children();
      if (it === "all") {
        if (children.length === filterValues.length) {
          this.filterValues = [];
          children.forEach(function(i) {
            return h(i).checked(false);
          });
        } else {
          this.filterValues = Array.from(values);
          children.forEach(function(i) {
            return h(i).checked(true);
          });
        }
      } else {
        var checked = h(children[index2]).toggle("checked");
        if (checked) {
          filterValues.push(it);
        } else {
          filterValues.splice(filterValues.findIndex(function(i) {
            return i === it;
          }), 1);
        }
      }
      resetFilterHeader.call(this);
    }
    // v: autoFilter
    // items: {value: cnt}
    // sort { ci, order }
  }, {
    key: "set",
    value: function set(ci, items, filter, sort) {
      this.ci = ci;
      var sortAscEl = this.sortAscEl, sortDescEl = this.sortDescEl;
      if (sort !== null) {
        this.sort = sort.order;
        sortAscEl.checked(sort.asc());
        sortDescEl.checked(sort.desc());
      } else {
        this.sortDesc = null;
        sortAscEl.checked(false);
        sortDescEl.checked(false);
      }
      this.values = Object.keys(items);
      this.filterValues = filter ? Array.from(filter.value) : Object.keys(items);
      buildFilterBody.call(this, items, filter);
      resetFilterHeader.call(this);
    }
  }, {
    key: "setOffset",
    value: function setOffset(v) {
      var _this4 = this;
      this.el.offset(v).show();
      var tindex = 1;
      bindClickoutside(this.el, function() {
        if (tindex <= 0) {
          _this4.hide();
        }
        tindex -= 1;
      });
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      unbindClickoutside(this.el);
    }
  }]);
  return SortFilter2;
}();
function xtoast(title, content) {
  var el = h("div", "".concat(cssPrefix, "-toast"));
  var dimmer = h("div", "".concat(cssPrefix, "-dimmer active"));
  var remove = function remove2() {
    document.body.removeChild(el.el);
    document.body.removeChild(dimmer.el);
  };
  el.children(h("div", "".concat(cssPrefix, "-toast-header")).children(new Icon("close").on("click.stop", function() {
    return remove();
  }), title), h("div", "".concat(cssPrefix, "-toast-content")).html(content));
  document.body.appendChild(el.el);
  document.body.appendChild(dimmer.el);
  var _el$box = el.box(), width2 = _el$box.width, height2 = _el$box.height;
  var _document$documentEle = document.documentElement, clientHeight = _document$documentEle.clientHeight, clientWidth = _document$documentEle.clientWidth;
  el.offset({
    left: (clientWidth - width2) / 2,
    top: (clientHeight - height2) / 3
  });
}
function throttle(func, wait) {
  var _this = this;
  var timeout;
  return function() {
    var that = _this;
    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
      arg[_key] = arguments[_key];
    }
    var args = arg;
    if (!timeout) {
      timeout = setTimeout(function() {
        timeout = null;
        func.apply(that, args);
      }, wait);
    }
  };
}
function scrollbarMove() {
  var data = this.data, verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar;
  var _data$getSelectedRect = data.getSelectedRect(), l = _data$getSelectedRect.l, t2 = _data$getSelectedRect.t, left = _data$getSelectedRect.left, top = _data$getSelectedRect.top, width2 = _data$getSelectedRect.width, height2 = _data$getSelectedRect.height;
  var tableOffset = this.getTableOffset();
  if (Math.abs(left) + width2 > tableOffset.width) {
    horizontalScrollbar.move({
      left: l + width2 - tableOffset.width
    });
  } else {
    var fsw = data.freezeTotalWidth();
    if (left < fsw) {
      horizontalScrollbar.move({
        left: l - 1 - fsw
      });
    }
  }
  if (Math.abs(top) + height2 > tableOffset.height) {
    verticalScrollbar.move({
      top: t2 + height2 - tableOffset.height - 1
    });
  } else {
    var fsh = data.freezeTotalHeight();
    if (top < fsh) {
      verticalScrollbar.move({
        top: t2 - 1 - fsh
      });
    }
  }
}
function selectorSet(multiple, ri, ci) {
  var indexesUpdated = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var moving = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  if (ri === -1 && ci === -1)
    return;
  var table = this.table, selector = this.selector, toolbar = this.toolbar, data = this.data, contextMenu = this.contextMenu;
  contextMenu.setMode(ri === -1 || ci === -1 ? "row-col" : "range");
  var cell = data.getCell(ri, ci);
  if (multiple) {
    selector.setEnd(ri, ci, moving);
    this.trigger("cells-selected", cell, selector.range);
  } else {
    selector.set(ri, ci, indexesUpdated);
    this.trigger("cell-selected", cell, ri, ci);
  }
  toolbar.reset();
  table.render();
}
function selectorMove(multiple, direction) {
  var selector = this.selector, data = this.data;
  var rows = data.rows, cols = data.cols;
  var _selector$indexes = _slicedToArray(selector.indexes, 2), ri = _selector$indexes[0], ci = _selector$indexes[1];
  var _selector$range = selector.range, eri = _selector$range.eri, eci = _selector$range.eci;
  if (multiple) {
    var _selector$moveIndexes = _slicedToArray(selector.moveIndexes, 2);
    ri = _selector$moveIndexes[0];
    ci = _selector$moveIndexes[1];
  }
  if (direction === "left") {
    if (ci > 0)
      ci -= 1;
  } else if (direction === "right") {
    if (eci !== ci)
      ci = eci;
    if (ci < cols.len - 1)
      ci += 1;
  } else if (direction === "up") {
    if (ri > 0)
      ri -= 1;
  } else if (direction === "down") {
    if (eri !== ri)
      ri = eri;
    if (ri < rows.len - 1)
      ri += 1;
  } else if (direction === "row-first") {
    ci = 0;
  } else if (direction === "row-last") {
    ci = cols.len - 1;
  } else if (direction === "col-first") {
    ri = 0;
  } else if (direction === "col-last") {
    ri = rows.len - 1;
  }
  if (multiple) {
    selector.moveIndexes = [ri, ci];
  }
  selectorSet.call(this, multiple, ri, ci);
  scrollbarMove.call(this);
}
function overlayerMousemove(evt) {
  if (evt.buttons !== 0)
    return;
  if (evt.target.className === "".concat(cssPrefix, "-resizer-hover"))
    return;
  var offsetX = evt.offsetX, offsetY = evt.offsetY;
  var rowResizer = this.rowResizer, colResizer = this.colResizer, tableEl = this.tableEl, data = this.data;
  var rows = data.rows, cols = data.cols;
  if (offsetX > cols.indexWidth && offsetY > rows.height) {
    rowResizer.hide();
    colResizer.hide();
    return;
  }
  var tRect = tableEl.box();
  var cRect = data.getCellRectByXY(evt.offsetX, evt.offsetY);
  if (cRect.ri >= 0 && cRect.ci === -1) {
    cRect.width = cols.indexWidth;
    rowResizer.show(cRect, {
      width: tRect.width
    });
    if (rows.isHide(cRect.ri - 1)) {
      rowResizer.showUnhide(cRect.ri);
    } else {
      rowResizer.hideUnhide();
    }
  } else {
    rowResizer.hide();
  }
  if (cRect.ri === -1 && cRect.ci >= 0) {
    cRect.height = rows.height;
    colResizer.show(cRect, {
      height: tRect.height
    });
    if (cols.isHide(cRect.ci - 1)) {
      colResizer.showUnhide(cRect.ci);
    } else {
      colResizer.hideUnhide();
    }
  } else {
    colResizer.hide();
  }
}
function overlayerMousescroll(evt) {
  var verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar, data = this.data;
  var _verticalScrollbar$sc = verticalScrollbar.scroll(), top = _verticalScrollbar$sc.top;
  var _horizontalScrollbar$ = horizontalScrollbar.scroll(), left = _horizontalScrollbar$.left;
  var rows = data.rows, cols = data.cols;
  var deltaY = evt.deltaY, deltaX = evt.deltaX;
  var loopValue = function loopValue2(ii, vFunc) {
    var i = ii;
    var v = 0;
    do {
      v = vFunc(i);
      i += 1;
    } while (v <= 0);
    return v;
  };
  var moveY = function moveY2(vertical) {
    if (vertical > 0) {
      var ri = data.scroll.ri + 1;
      if (ri < rows.len) {
        var rh = loopValue(ri, function(i) {
          return rows.getHeight(i);
        });
        verticalScrollbar.move({
          top: top + rh - 1
        });
      }
    } else {
      var _ri = data.scroll.ri - 1;
      if (_ri >= 0) {
        var _rh = loopValue(_ri, function(i) {
          return rows.getHeight(i);
        });
        verticalScrollbar.move({
          top: _ri === 0 ? 0 : top - _rh
        });
      }
    }
  };
  var moveX = function moveX2(horizontal) {
    if (horizontal > 0) {
      var ci = data.scroll.ci + 1;
      if (ci < cols.len) {
        var cw = loopValue(ci, function(i) {
          return cols.getWidth(i);
        });
        horizontalScrollbar.move({
          left: left + cw - 1
        });
      }
    } else {
      var _ci = data.scroll.ci - 1;
      if (_ci >= 0) {
        var _cw = loopValue(_ci, function(i) {
          return cols.getWidth(i);
        });
        horizontalScrollbar.move({
          left: _ci === 0 ? 0 : left - _cw
        });
      }
    }
  };
  var tempY = Math.abs(deltaY);
  var tempX = Math.abs(deltaX);
  var temp = Math.max(tempY, tempX);
  if (/Firefox/i.test(window.navigator.userAgent))
    throttle(moveY(evt.detail), 50);
  if (temp === tempX)
    throttle(moveX(deltaX), 50);
  if (temp === tempY)
    throttle(moveY(deltaY), 50);
}
function overlayerTouch(direction, distance) {
  var verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar;
  var _verticalScrollbar$sc2 = verticalScrollbar.scroll(), top = _verticalScrollbar$sc2.top;
  var _horizontalScrollbar$2 = horizontalScrollbar.scroll(), left = _horizontalScrollbar$2.left;
  if (direction === "left" || direction === "right") {
    horizontalScrollbar.move({
      left: left - distance
    });
  } else if (direction === "up" || direction === "down") {
    verticalScrollbar.move({
      top: top - distance
    });
  }
}
function verticalScrollbarSet() {
  var data = this.data, verticalScrollbar = this.verticalScrollbar;
  var _this$getTableOffset = this.getTableOffset(), height2 = _this$getTableOffset.height;
  var erth = data.exceptRowTotalHeight(0, -1);
  verticalScrollbar.set(height2, data.rows.totalHeight() - erth);
}
function horizontalScrollbarSet() {
  var data = this.data, horizontalScrollbar = this.horizontalScrollbar;
  var _this$getTableOffset2 = this.getTableOffset(), width2 = _this$getTableOffset2.width;
  if (data) {
    horizontalScrollbar.set(width2, data.cols.totalWidth());
  }
}
function sheetFreeze() {
  var selector = this.selector, data = this.data, editor = this.editor;
  var _data$freeze = _slicedToArray(data.freeze, 2), ri = _data$freeze[0], ci = _data$freeze[1];
  if (ri > 0 || ci > 0) {
    var fwidth = data.freezeTotalWidth();
    var fheight = data.freezeTotalHeight();
    editor.setFreezeLengths(fwidth, fheight);
  }
  selector.resetAreaOffset();
}
function sheetReset() {
  var tableEl = this.tableEl, overlayerEl = this.overlayerEl, overlayerCEl = this.overlayerCEl, table = this.table, toolbar = this.toolbar, selector = this.selector, el = this.el;
  var tOffset = this.getTableOffset();
  var vRect = this.getRect();
  tableEl.attr(vRect);
  overlayerEl.offset(vRect);
  overlayerCEl.offset(tOffset);
  el.css("width", "".concat(vRect.width, "px"));
  verticalScrollbarSet.call(this);
  horizontalScrollbarSet.call(this);
  sheetFreeze.call(this);
  table.render();
  toolbar.reset();
  selector.reset();
}
function clearClipboard() {
  var data = this.data, selector = this.selector;
  data.clearClipboard();
  selector.hideClipboard();
}
function copy() {
  var data = this.data, selector = this.selector;
  data.copy();
  data.copyToSystemClipboard();
  selector.showClipboard();
}
function cut() {
  var data = this.data, selector = this.selector;
  data.cut();
  selector.showClipboard();
}
function paste(what, evt) {
  var data = this.data;
  if (data.settings.mode === "read")
    return;
  if (data.paste(what, function(msg) {
    return xtoast("Tip", msg);
  })) {
    sheetReset.call(this);
  } else if (evt) {
    var cdata = evt.clipboardData.getData("text/plain");
    this.data.pasteFromText(cdata);
    sheetReset.call(this);
  }
}
function hideRowsOrCols() {
  this.data.hideRowsOrCols();
  sheetReset.call(this);
}
function unhideRowsOrCols(type, index2) {
  this.data.unhideRowsOrCols(type, index2);
  sheetReset.call(this);
}
function autofilter() {
  var data = this.data;
  data.autofilter();
  sheetReset.call(this);
}
function toolbarChangePaintformatPaste() {
  var toolbar = this.toolbar;
  if (toolbar.paintformatActive()) {
    paste.call(this, "format");
    clearClipboard.call(this);
    toolbar.paintformatToggle();
  }
}
function overlayerMousedown(evt) {
  var _this2 = this;
  var selector = this.selector, data = this.data, table = this.table, sortFilter = this.sortFilter;
  var offsetX = evt.offsetX, offsetY = evt.offsetY;
  var isAutofillEl = evt.target.className === "".concat(cssPrefix, "-selector-corner");
  var cellRect = data.getCellRectByXY(offsetX, offsetY);
  var left = cellRect.left, top = cellRect.top, width2 = cellRect.width, height2 = cellRect.height;
  var ri = cellRect.ri, ci = cellRect.ci;
  var autoFilter = data.autoFilter;
  if (autoFilter.includes(ri, ci)) {
    if (left + width2 - 20 < offsetX && top + height2 - 20 < offsetY) {
      var items = autoFilter.items(ci, function(r, c) {
        return data.rows.getCell(r, c);
      });
      sortFilter.hide();
      sortFilter.set(ci, items, autoFilter.getFilter(ci), autoFilter.getSort(ci));
      sortFilter.setOffset({
        left,
        top: top + height2 + 2
      });
      return;
    }
  }
  if (!evt.shiftKey) {
    if (isAutofillEl) {
      selector.showAutofill(ri, ci);
    } else {
      selectorSet.call(this, false, ri, ci);
    }
    mouseMoveUp(window, function(e) {
      var _data$getCellRectByXY = data.getCellRectByXY(e.offsetX, e.offsetY);
      ri = _data$getCellRectByXY.ri;
      ci = _data$getCellRectByXY.ci;
      if (isAutofillEl) {
        selector.showAutofill(ri, ci);
      } else if (e.buttons === 1 && !e.shiftKey) {
        selectorSet.call(_this2, true, ri, ci, true, true);
      }
    }, function() {
      if (isAutofillEl && selector.arange && data.settings.mode !== "read") {
        if (data.autofill(selector.arange, "all", function(msg) {
          return xtoast("Tip", msg);
        })) {
          table.render();
        }
      }
      selector.hideAutofill();
      toolbarChangePaintformatPaste.call(_this2);
    });
  }
  if (!isAutofillEl && evt.buttons === 1) {
    if (evt.shiftKey) {
      selectorSet.call(this, true, ri, ci);
    }
  }
}
function editorSetOffset() {
  var editor = this.editor, data = this.data;
  var sOffset = data.getSelectedRect();
  var tOffset = this.getTableOffset();
  var sPosition = "top";
  if (sOffset.top > tOffset.height / 2) {
    sPosition = "bottom";
  }
  editor.setOffset(sOffset, sPosition);
}
function editorSet() {
  var editor = this.editor, data = this.data;
  if (data.settings.mode === "read")
    return;
  editorSetOffset.call(this);
  editor.setCell(data.getSelectedCell(), data.getSelectedValidator());
  clearClipboard.call(this);
}
function verticalScrollbarMove(distance) {
  var _this3 = this;
  var data = this.data, table = this.table, selector = this.selector;
  data.scrolly(distance, function() {
    selector.resetBRLAreaOffset();
    editorSetOffset.call(_this3);
    table.render();
  });
}
function horizontalScrollbarMove(distance) {
  var _this4 = this;
  var data = this.data, table = this.table, selector = this.selector;
  data.scrollx(distance, function() {
    selector.resetBRTAreaOffset();
    editorSetOffset.call(_this4);
    table.render();
  });
}
function rowResizerFinished(cRect, distance) {
  var ri = cRect.ri;
  var table = this.table, selector = this.selector, data = this.data;
  data.rows.setHeight(ri, distance);
  table.render();
  selector.resetAreaOffset();
  verticalScrollbarSet.call(this);
  editorSetOffset.call(this);
}
function colResizerFinished(cRect, distance) {
  var ci = cRect.ci;
  var table = this.table, selector = this.selector, data = this.data;
  data.cols.setWidth(ci, distance);
  table.render();
  selector.resetAreaOffset();
  horizontalScrollbarSet.call(this);
  editorSetOffset.call(this);
}
function dataSetCellText(text) {
  var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "finished";
  var data = this.data, table = this.table;
  if (data.settings.mode === "read")
    return;
  data.setSelectedCellText(text, state);
  var _data$selector = data.selector, ri = _data$selector.ri, ci = _data$selector.ci;
  if (state === "finished") {
    table.render();
  } else {
    this.trigger("cell-edited", text, ri, ci);
  }
}
function insertDeleteRowColumn(type) {
  var data = this.data;
  if (data.settings.mode === "read")
    return;
  if (type === "insert-row") {
    data.insert("row");
  } else if (type === "delete-row") {
    data.delete("row");
  } else if (type === "insert-column") {
    data.insert("column");
  } else if (type === "delete-column") {
    data.delete("column");
  } else if (type === "delete-cell") {
    data.deleteCell();
  } else if (type === "delete-cell-format") {
    data.deleteCell("format");
  } else if (type === "delete-cell-text") {
    data.deleteCell("text");
  } else if (type === "cell-printable") {
    data.setSelectedCellAttr("printable", true);
  } else if (type === "cell-non-printable") {
    data.setSelectedCellAttr("printable", false);
  } else if (type === "cell-editable") {
    data.setSelectedCellAttr("editable", true);
  } else if (type === "cell-non-editable") {
    data.setSelectedCellAttr("editable", false);
  }
  clearClipboard.call(this);
  sheetReset.call(this);
}
function toolbarChange(type, value) {
  var data = this.data;
  if (type === "undo") {
    this.undo();
  } else if (type === "redo") {
    this.redo();
  } else if (type === "print") {
    this.print.preview();
  } else if (type === "paintformat") {
    if (value === true)
      copy.call(this);
    else
      clearClipboard.call(this);
  } else if (type === "clearformat") {
    insertDeleteRowColumn.call(this, "delete-cell-format");
  } else if (type === "link")
    ;
  else if (type === "chart")
    ;
  else if (type === "autofilter") {
    autofilter.call(this);
  } else if (type === "freeze") {
    if (value) {
      var _data$selector2 = data.selector, ri = _data$selector2.ri, ci = _data$selector2.ci;
      this.freeze(ri, ci);
    } else {
      this.freeze(0, 0);
    }
  } else {
    data.setSelectedCellAttr(type, value);
    if (type === "formula" && !data.selector.multiple()) {
      editorSet.call(this);
    }
    sheetReset.call(this);
  }
}
function sortFilterChange(ci, order, operator, value) {
  this.data.setAutoFilter(ci, order, operator, value);
  sheetReset.call(this);
}
function sheetInitEvents() {
  var _this5 = this;
  var selector = this.selector, overlayerEl = this.overlayerEl, rowResizer = this.rowResizer, colResizer = this.colResizer, verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar, editor = this.editor, contextMenu = this.contextMenu, toolbar = this.toolbar, modalValidation = this.modalValidation, sortFilter = this.sortFilter;
  overlayerEl.on("mousemove", function(evt) {
    overlayerMousemove.call(_this5, evt);
  }).on("mousedown", function(evt) {
    editor.clear();
    contextMenu.hide();
    if (evt.buttons === 2) {
      if (_this5.data.xyInSelectedRect(evt.offsetX, evt.offsetY)) {
        contextMenu.setPosition(evt.offsetX, evt.offsetY);
      } else {
        overlayerMousedown.call(_this5, evt);
        contextMenu.setPosition(evt.offsetX, evt.offsetY);
      }
      evt.stopPropagation();
    } else if (evt.detail === 2) {
      editorSet.call(_this5);
    } else {
      overlayerMousedown.call(_this5, evt);
    }
  }).on("mousewheel.stop", function(evt) {
    overlayerMousescroll.call(_this5, evt);
  }).on("mouseout", function(evt) {
    var offsetX = evt.offsetX, offsetY = evt.offsetY;
    if (offsetY <= 0)
      colResizer.hide();
    if (offsetX <= 0)
      rowResizer.hide();
  });
  selector.inputChange = function(v) {
    dataSetCellText.call(_this5, v, "input");
    editorSet.call(_this5);
  };
  bindTouch(overlayerEl.el, {
    move: function move(direction, d) {
      overlayerTouch.call(_this5, direction, d);
    }
  });
  toolbar.change = function(type, value) {
    return toolbarChange.call(_this5, type, value);
  };
  sortFilter.ok = function(ci, order, o, v) {
    return sortFilterChange.call(_this5, ci, order, o, v);
  };
  rowResizer.finishedFn = function(cRect, distance) {
    rowResizerFinished.call(_this5, cRect, distance);
  };
  colResizer.finishedFn = function(cRect, distance) {
    colResizerFinished.call(_this5, cRect, distance);
  };
  rowResizer.unhideFn = function(index2) {
    unhideRowsOrCols.call(_this5, "row", index2);
  };
  colResizer.unhideFn = function(index2) {
    unhideRowsOrCols.call(_this5, "col", index2);
  };
  verticalScrollbar.moveFn = function(distance, evt) {
    verticalScrollbarMove.call(_this5, distance, evt);
  };
  horizontalScrollbar.moveFn = function(distance, evt) {
    horizontalScrollbarMove.call(_this5, distance, evt);
  };
  editor.change = function(state, itext) {
    dataSetCellText.call(_this5, itext, state);
  };
  modalValidation.change = function(action) {
    if (action === "save") {
      var _this5$data;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      (_this5$data = _this5.data).addValidation.apply(_this5$data, args);
    } else {
      _this5.data.removeValidation();
    }
  };
  contextMenu.itemClick = function(type) {
    if (type === "validation") {
      modalValidation.setValue(_this5.data.getSelectedValidation());
    } else if (type === "copy") {
      copy.call(_this5);
    } else if (type === "cut") {
      cut.call(_this5);
    } else if (type === "paste") {
      paste.call(_this5, "all");
    } else if (type === "paste-value") {
      paste.call(_this5, "text");
    } else if (type === "paste-format") {
      paste.call(_this5, "format");
    } else if (type === "hide") {
      hideRowsOrCols.call(_this5);
    } else {
      insertDeleteRowColumn.call(_this5, type);
    }
  };
  bind(window, "resize", function() {
    _this5.reload();
  });
  bind(window, "click", function(evt) {
    _this5.focusing = overlayerEl.contains(evt.target);
  });
  bind(window, "paste", function(evt) {
    if (!_this5.focusing)
      return;
    paste.call(_this5, "all", evt);
    evt.preventDefault();
  });
  bind(window, "keydown", function(evt) {
    if (!_this5.focusing)
      return;
    var keyCode = evt.keyCode || evt.which;
    var key = evt.key, ctrlKey = evt.ctrlKey, shiftKey = evt.shiftKey, metaKey = evt.metaKey;
    if (ctrlKey || metaKey) {
      switch (keyCode) {
        case 90:
          _this5.undo();
          evt.preventDefault();
          break;
        case 89:
          _this5.redo();
          evt.preventDefault();
          break;
        case 67:
          copy.call(_this5);
          evt.preventDefault();
          break;
        case 88:
          cut.call(_this5);
          evt.preventDefault();
          break;
        case 85:
          toolbar.trigger("underline");
          evt.preventDefault();
          break;
        case 86:
          break;
        case 37:
          selectorMove.call(_this5, shiftKey, "row-first");
          evt.preventDefault();
          break;
        case 38:
          selectorMove.call(_this5, shiftKey, "col-first");
          evt.preventDefault();
          break;
        case 39:
          selectorMove.call(_this5, shiftKey, "row-last");
          evt.preventDefault();
          break;
        case 40:
          selectorMove.call(_this5, shiftKey, "col-last");
          evt.preventDefault();
          break;
        case 32:
          selectorSet.call(_this5, false, -1, _this5.data.selector.ci, false);
          evt.preventDefault();
          break;
        case 66:
          toolbar.trigger("bold");
          break;
        case 73:
          toolbar.trigger("italic");
          break;
      }
    } else {
      switch (keyCode) {
        case 32:
          if (shiftKey) {
            selectorSet.call(_this5, false, _this5.data.selector.ri, -1, false);
          }
          break;
        case 27:
          contextMenu.hide();
          clearClipboard.call(_this5);
          break;
        case 37:
          selectorMove.call(_this5, shiftKey, "left");
          evt.preventDefault();
          break;
        case 38:
          selectorMove.call(_this5, shiftKey, "up");
          evt.preventDefault();
          break;
        case 39:
          selectorMove.call(_this5, shiftKey, "right");
          evt.preventDefault();
          break;
        case 40:
          selectorMove.call(_this5, shiftKey, "down");
          evt.preventDefault();
          break;
        case 9:
          editor.clear();
          selectorMove.call(_this5, false, shiftKey ? "left" : "right");
          evt.preventDefault();
          break;
        case 13:
          editor.clear();
          selectorMove.call(_this5, false, shiftKey ? "up" : "down");
          evt.preventDefault();
          break;
        case 8:
          insertDeleteRowColumn.call(_this5, "delete-cell-text");
          evt.preventDefault();
          break;
      }
      if (key === "Delete") {
        insertDeleteRowColumn.call(_this5, "delete-cell-text");
        evt.preventDefault();
      } else if (keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || evt.key === "=") {
        dataSetCellText.call(_this5, evt.key, "input");
        editorSet.call(_this5);
      } else if (keyCode === 113) {
        editorSet.call(_this5);
      }
    }
  });
}
var Sheet = /* @__PURE__ */ function() {
  function Sheet2(targetEl, data) {
    var _this6 = this;
    _classCallCheck(this, Sheet2);
    this.eventMap = createEventEmitter();
    var _data$settings = data.settings, view = _data$settings.view, showToolbar = _data$settings.showToolbar, showContextmenu = _data$settings.showContextmenu;
    this.el = h("div", "".concat(cssPrefix, "-sheet"));
    this.toolbar = new Toolbar(data, view.width, !showToolbar);
    this.print = new Print$1(data);
    targetEl.children(this.toolbar.el, this.el, this.print.el);
    this.data = data;
    this.tableEl = h("canvas", "".concat(cssPrefix, "-table"));
    this.rowResizer = new Resizer(false, data.rows.height);
    this.colResizer = new Resizer(true, data.cols.minWidth);
    this.verticalScrollbar = new Scrollbar(true);
    this.horizontalScrollbar = new Scrollbar(false);
    this.editor = new Editor(formulas, function() {
      return _this6.getTableOffset();
    }, data.rows.height);
    this.modalValidation = new ModalValidation();
    this.contextMenu = new ContextMenu$1(function() {
      return _this6.getRect();
    }, !showContextmenu);
    this.selector = new Selector(data);
    this.overlayerCEl = h("div", "".concat(cssPrefix, "-overlayer-content")).children(this.editor.el, this.selector.el);
    this.overlayerEl = h("div", "".concat(cssPrefix, "-overlayer")).child(this.overlayerCEl);
    this.sortFilter = new SortFilter();
    this.el.children(this.tableEl, this.overlayerEl.el, this.rowResizer.el, this.colResizer.el, this.verticalScrollbar.el, this.horizontalScrollbar.el, this.contextMenu.el, this.modalValidation.el, this.sortFilter.el);
    this.table = new Table(this.tableEl.el, data);
    sheetInitEvents.call(this);
    sheetReset.call(this);
    selectorSet.call(this, false, 0, 0);
  }
  _createClass(Sheet2, [{
    key: "on",
    value: function on(eventName, func) {
      this.eventMap.on(eventName, func);
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(eventName) {
      var eventMap = this.eventMap;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      eventMap.fire(eventName, args);
    }
  }, {
    key: "resetData",
    value: function resetData(data) {
      this.editor.clear();
      this.data = data;
      verticalScrollbarSet.call(this);
      horizontalScrollbarSet.call(this);
      this.toolbar.resetData(data);
      this.print.resetData(data);
      this.selector.resetData(data);
      this.table.resetData(data);
    }
  }, {
    key: "loadData",
    value: function loadData(data) {
      this.data.setData(data);
      sheetReset.call(this);
      return this;
    }
    // freeze rows or cols
  }, {
    key: "freeze",
    value: function freeze(ri, ci) {
      var data = this.data;
      data.setFreeze(ri, ci);
      sheetReset.call(this);
      return this;
    }
  }, {
    key: "undo",
    value: function undo() {
      this.data.undo();
      sheetReset.call(this);
    }
  }, {
    key: "redo",
    value: function redo() {
      this.data.redo();
      sheetReset.call(this);
    }
  }, {
    key: "reload",
    value: function reload() {
      sheetReset.call(this);
      return this;
    }
  }, {
    key: "getRect",
    value: function getRect() {
      var data = this.data;
      return {
        width: data.viewWidth(),
        height: data.viewHeight()
      };
    }
  }, {
    key: "getTableOffset",
    value: function getTableOffset() {
      var _this$data = this.data, rows = _this$data.rows, cols = _this$data.cols;
      var _this$getRect = this.getRect(), width2 = _this$getRect.width, height2 = _this$getRect.height;
      return {
        width: width2 - cols.indexWidth,
        height: height2 - rows.height,
        left: cols.indexWidth,
        top: rows.height
      };
    }
  }]);
  return Sheet2;
}();
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownMore = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownMore2, _Dropdown);
  var _super = _createSuper$1(DropdownMore2);
  function DropdownMore2(click) {
    var _this;
    _classCallCheck(this, DropdownMore2);
    var icon = new Icon("ellipsis");
    _this = _super.call(this, icon, "auto", false, "top-left");
    _this.contentClick = click;
    return _this;
  }
  _createClass(DropdownMore2, [{
    key: "reset",
    value: function reset(items) {
      var _this2 = this;
      var eles = items.map(function(it, i) {
        return h("div", "".concat(cssPrefix, "-item")).css("width", "150px").css("font-weight", "normal").on("click", function() {
          _this2.contentClick(i);
          _this2.hide();
        }).child(it);
      });
      this.setContentChildren.apply(this, _toConsumableArray(eles));
    }
  }, {
    key: "setTitle",
    value: function setTitle() {
    }
  }]);
  return DropdownMore2;
}(Dropdown);
var menuItems = [{
  key: "delete",
  title: tf("contextmenu.deleteSheet")
}];
function buildMenuItem(item) {
  var _this3 = this;
  return h("div", "".concat(cssPrefix, "-item")).child(item.title()).on("click", function() {
    _this3.itemClick(item.key);
    _this3.hide();
  });
}
function buildMenu() {
  var _this4 = this;
  return menuItems.map(function(it) {
    return buildMenuItem.call(_this4, it);
  });
}
var ContextMenu = /* @__PURE__ */ function() {
  function ContextMenu2() {
    var _h$css;
    _classCallCheck(this, ContextMenu2);
    this.el = (_h$css = h("div", "".concat(cssPrefix, "-contextmenu")).css("width", "160px")).children.apply(_h$css, _toConsumableArray(buildMenu.call(this))).hide();
    this.itemClick = function() {
    };
  }
  _createClass(ContextMenu2, [{
    key: "hide",
    value: function hide() {
      var el = this.el;
      el.hide();
      unbindClickoutside(el);
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      var el = this.el;
      el.offset(offset);
      el.show();
      bindClickoutside(el);
    }
  }]);
  return ContextMenu2;
}();
var Bottombar = /* @__PURE__ */ function() {
  function Bottombar2() {
    var _this5 = this;
    var addFunc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    var swapFunc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    var deleteFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    };
    var updateFunc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
    };
    _classCallCheck(this, Bottombar2);
    this.swapFunc = swapFunc;
    this.updateFunc = updateFunc;
    this.dataNames = [];
    this.activeEl = null;
    this.deleteEl = null;
    this.items = [];
    this.moreEl = new DropdownMore(function(i) {
      _this5.clickSwap2(_this5.items[i]);
    });
    this.contextMenu = new ContextMenu();
    this.contextMenu.itemClick = deleteFunc;
    this.el = h("div", "".concat(cssPrefix, "-bottombar")).children(this.contextMenu.el, this.menuEl = h("ul", "".concat(cssPrefix, "-menu")).child(h("li", "").children(new Icon("add").on("click", function() {
      addFunc();
    }), h("span", "").child(this.moreEl))));
  }
  _createClass(Bottombar2, [{
    key: "addItem",
    value: function addItem(name, active) {
      var _this6 = this;
      this.dataNames.push(name);
      var item = h("li", active ? "active" : "").child(name);
      item.on("click", function() {
        _this6.clickSwap2(item);
      }).on("contextmenu", function(evt) {
        var _evt$target = evt.target, offsetLeft = _evt$target.offsetLeft, offsetHeight = _evt$target.offsetHeight;
        _this6.contextMenu.setOffset({
          left: offsetLeft,
          bottom: offsetHeight + 1
        });
        _this6.deleteEl = item;
      }).on("dblclick", function() {
        var v = item.html();
        var input = new FormInput("auto", "");
        input.val(v);
        input.input.on("blur", function(_ref) {
          var target = _ref.target;
          var value = target.value;
          var nindex = _this6.dataNames.findIndex(function(it) {
            return it === v;
          });
          _this6.renameItem(nindex, value);
        });
        item.html("").child(input.el);
        input.focus();
      });
      if (active) {
        this.clickSwap(item);
      }
      this.items.push(item);
      this.menuEl.child(item);
      this.moreEl.reset(this.dataNames);
    }
  }, {
    key: "renameItem",
    value: function renameItem(index2, value) {
      this.dataNames.splice(index2, 1, value);
      this.moreEl.reset(this.dataNames);
      this.items[index2].html("").child(value);
      this.updateFunc(index2, value);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this7 = this;
      this.items.forEach(function(it) {
        _this7.menuEl.removeChild(it.el);
      });
      this.items = [];
      this.dataNames = [];
      this.moreEl.reset(this.dataNames);
    }
  }, {
    key: "deleteItem",
    value: function deleteItem() {
      var activeEl = this.activeEl, deleteEl = this.deleteEl;
      if (this.items.length > 1) {
        var index2 = this.items.findIndex(function(it) {
          return it === deleteEl;
        });
        this.items.splice(index2, 1);
        this.dataNames.splice(index2, 1);
        this.menuEl.removeChild(deleteEl.el);
        this.moreEl.reset(this.dataNames);
        if (activeEl === deleteEl) {
          var _this$items = _slicedToArray(this.items, 1), f = _this$items[0];
          this.activeEl = f;
          this.activeEl.toggle();
          return [index2, 0];
        }
        return [index2, -1];
      }
      return [-1];
    }
  }, {
    key: "clickSwap2",
    value: function clickSwap2(item) {
      var index2 = this.items.findIndex(function(it) {
        return it === item;
      });
      this.clickSwap(item);
      this.activeEl.toggle();
      this.swapFunc(index2);
    }
  }, {
    key: "clickSwap",
    value: function clickSwap(item) {
      if (this.activeEl !== null) {
        this.activeEl.toggle();
      }
      this.activeEl = item;
    }
  }]);
  return Bottombar2;
}();
const index = "";
function ownKeys$3(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
var Spreadsheet = /* @__PURE__ */ function() {
  function Spreadsheet2(selectors) {
    var _this = this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Spreadsheet2);
    var targetEl = selectors;
    this.options = _objectSpread$2({
      showBottomBar: true
    }, options);
    this.sheetIndex = 1;
    this.datas = [];
    if (typeof selectors === "string") {
      targetEl = document.querySelector(selectors);
    }
    this.bottombar = this.options.showBottomBar ? new Bottombar(function() {
      var d = _this.addSheet();
      _this.sheet.resetData(d);
    }, function(index2) {
      var d = _this.datas[index2];
      _this.sheet.resetData(d);
    }, function() {
      _this.deleteSheet();
    }, function(index2, value) {
      _this.datas[index2].name = value;
    }) : null;
    this.data = this.addSheet();
    var rootEl = h("div", "".concat(cssPrefix)).on("contextmenu", function(evt) {
      return evt.preventDefault();
    });
    targetEl.appendChild(rootEl.el);
    this.sheet = new Sheet(rootEl, this.data);
    if (this.bottombar !== null) {
      rootEl.child(this.bottombar.el);
    }
  }
  _createClass(Spreadsheet2, [{
    key: "addSheet",
    value: function addSheet(name) {
      var _this2 = this;
      var active = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var n = name || "sheet".concat(this.sheetIndex);
      var d = new DataProxy(n, this.options);
      d.change = function() {
        var _this2$sheet;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_this2$sheet = _this2.sheet).trigger.apply(_this2$sheet, ["change"].concat(args));
      };
      this.datas.push(d);
      if (this.bottombar !== null) {
        this.bottombar.addItem(n, active);
      }
      this.sheetIndex += 1;
      return d;
    }
  }, {
    key: "deleteSheet",
    value: function deleteSheet() {
      if (this.bottombar === null)
        return;
      var _this$bottombar$delet = this.bottombar.deleteItem(), _this$bottombar$delet2 = _slicedToArray(_this$bottombar$delet, 2), oldIndex = _this$bottombar$delet2[0], nindex = _this$bottombar$delet2[1];
      if (oldIndex >= 0) {
        this.datas.splice(oldIndex, 1);
        if (nindex >= 0)
          this.sheet.resetData(this.datas[nindex]);
      }
    }
  }, {
    key: "loadData",
    value: function loadData(data) {
      var ds = Array.isArray(data) ? data : [data];
      if (this.bottombar !== null) {
        this.bottombar.clear();
      }
      this.datas = [];
      if (ds.length > 0) {
        for (var i = 0; i < ds.length; i += 1) {
          var it = ds[i];
          var nd = this.addSheet(it.name, i === 0);
          nd.setData(it);
          if (i === 0) {
            this.sheet.resetData(nd);
          }
        }
      }
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this.datas.map(function(it) {
        return it.getData();
      });
    }
  }, {
    key: "cellText",
    value: function cellText(ri, ci, text) {
      var sheetIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      this.datas[sheetIndex].setCellText(ri, ci, text, "finished");
      return this;
    }
  }, {
    key: "cell",
    value: function cell(ri, ci) {
      var sheetIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return this.datas[sheetIndex].getCell(ri, ci);
    }
  }, {
    key: "cellStyle",
    value: function cellStyle(ri, ci) {
      var sheetIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return this.datas[sheetIndex].getCellStyle(ri, ci);
    }
  }, {
    key: "reRender",
    value: function reRender() {
      this.sheet.table.render();
      return this;
    }
  }, {
    key: "on",
    value: function on(eventName, func) {
      this.sheet.on(eventName, func);
      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var validations = this.data.validations;
      return validations.errors.size <= 0;
    }
  }, {
    key: "change",
    value: function change(cb) {
      this.sheet.on("change", cb);
      return this;
    }
  }], [{
    key: "locale",
    value: function locale$1(lang, message) {
      locale(lang, message);
    }
  }]);
  return Spreadsheet2;
}();
var spreadsheet = function spreadsheet2(el) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Spreadsheet(el, options);
};
if (window) {
  window.x_spreadsheet = spreadsheet;
  window.x_spreadsheet.locale = function(lang, message) {
    return locale(lang, message);
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _OverloadYield(t2, e) {
  this.v = t2, this.k = e;
}
function _awaitAsyncGenerator(e) {
  return new _OverloadYield(e, 0);
}
function AsyncGenerator(e) {
  var r, t2;
  function resume(r2, t3) {
    try {
      var n = e[r2](t3), o = n.value, u = o instanceof _OverloadYield;
      Promise.resolve(u ? o.v : o).then(function(t4) {
        if (u) {
          var i = "return" === r2 ? "return" : "next";
          if (!o.k || t4.done)
            return resume(i, t4);
          t4 = e[i](t4).value;
        }
        settle(n.done ? "return" : "normal", t4);
      }, function(e2) {
        resume("throw", e2);
      });
    } catch (e2) {
      settle("throw", e2);
    }
  }
  function settle(e2, n) {
    switch (e2) {
      case "return":
        r.resolve({
          value: n,
          done: true
        });
        break;
      case "throw":
        r.reject(n);
        break;
      default:
        r.resolve({
          value: n,
          done: false
        });
    }
    (r = r.next) ? resume(r.key, r.arg) : t2 = null;
  }
  this._invoke = function(e2, n) {
    return new Promise(function(o, u) {
      var i = {
        key: e2,
        arg: n,
        resolve: o,
        reject: u,
        next: null
      };
      t2 ? t2 = t2.next = i : (r = t2 = i, resume(e2, n));
    });
  }, "function" != typeof e["return"] && (this["return"] = void 0);
}
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
  return this;
}, AsyncGenerator.prototype.next = function(e) {
  return this._invoke("next", e);
}, AsyncGenerator.prototype["throw"] = function(e) {
  return this._invoke("throw", e);
}, AsyncGenerator.prototype["return"] = function(e) {
  return this._invoke("return", e);
};
function _wrapAsyncGenerator(fn) {
  return function() {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var regeneratorRuntime$1 = { exports: {} };
var _typeof$1 = { exports: {} };
(function(module) {
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;
(function(module) {
  var _typeof2 = _typeofExports["default"];
  function _regeneratorRuntime2() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t2, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t3, e2, r2) {
      t3[e2] = r2.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define(t3, e2, r2) {
      return Object.defineProperty(t3, e2, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t3[e2];
    }
    try {
      define({}, "");
    } catch (t3) {
      define = function define2(t4, e2, r2) {
        return t4[e2] = r2;
      };
    }
    function wrap(t3, e2, r2, n2) {
      var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
      return o(a2, "_invoke", {
        value: makeInvokeMethod(t3, r2, c2)
      }), a2;
    }
    function tryCatch(t3, e2, r2) {
      try {
        return {
          type: "normal",
          arg: t3.call(e2, r2)
        };
      } catch (t4) {
        return {
          type: "throw",
          arg: t4
        };
      }
    }
    e.wrap = wrap;
    var h3 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p = {};
    define(p, a, function() {
      return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t3) {
      ["next", "throw", "return"].forEach(function(e2) {
        define(t3, e2, function(t4) {
          return this._invoke(e2, t4);
        });
      });
    }
    function AsyncIterator(t3, e2) {
      function invoke(r3, o2, i2, a2) {
        var c2 = tryCatch(t3[r3], t3, o2);
        if ("throw" !== c2.type) {
          var u2 = c2.arg, h4 = u2.value;
          return h4 && "object" == _typeof2(h4) && n.call(h4, "__await") ? e2.resolve(h4.__await).then(function(t4) {
            invoke("next", t4, i2, a2);
          }, function(t4) {
            invoke("throw", t4, i2, a2);
          }) : e2.resolve(h4).then(function(t4) {
            u2.value = t4, i2(u2);
          }, function(t4) {
            return invoke("throw", t4, i2, a2);
          });
        }
        a2(c2.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value(t4, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t4, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e2, r2, n2) {
      var o2 = h3;
      return function(i2, a2) {
        if (o2 === f)
          throw new Error("Generator is already running");
        if (o2 === s) {
          if ("throw" === i2)
            throw a2;
          return {
            value: t2,
            done: true
          };
        }
        for (n2.method = i2, n2.arg = a2; ; ) {
          var c2 = n2.delegate;
          if (c2) {
            var u2 = maybeInvokeDelegate(c2, n2);
            if (u2) {
              if (u2 === y)
                continue;
              return u2;
            }
          }
          if ("next" === n2.method)
            n2.sent = n2._sent = n2.arg;
          else if ("throw" === n2.method) {
            if (o2 === h3)
              throw o2 = s, n2.arg;
            n2.dispatchException(n2.arg);
          } else
            "return" === n2.method && n2.abrupt("return", n2.arg);
          o2 = f;
          var p2 = tryCatch(e2, r2, n2);
          if ("normal" === p2.type) {
            if (o2 = n2.done ? s : l, p2.arg === y)
              continue;
            return {
              value: p2.arg,
              done: n2.done
            };
          }
          "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
        }
      };
    }
    function maybeInvokeDelegate(e2, r2) {
      var n2 = r2.method, o2 = e2.iterator[n2];
      if (o2 === t2)
        return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t2, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
      var i2 = tryCatch(o2, e2.iterator, r2.arg);
      if ("throw" === i2.type)
        return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
      var a2 = i2.arg;
      return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t2), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
    }
    function pushTryEntry(t3) {
      var e2 = {
        tryLoc: t3[0]
      };
      1 in t3 && (e2.catchLoc = t3[1]), 2 in t3 && (e2.finallyLoc = t3[2], e2.afterLoc = t3[3]), this.tryEntries.push(e2);
    }
    function resetTryEntry(t3) {
      var e2 = t3.completion || {};
      e2.type = "normal", delete e2.arg, t3.completion = e2;
    }
    function Context(t3) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t3.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(e2) {
      if (e2 || "" === e2) {
        var r2 = e2[a];
        if (r2)
          return r2.call(e2);
        if ("function" == typeof e2.next)
          return e2;
        if (!isNaN(e2.length)) {
          var o2 = -1, i2 = function next() {
            for (; ++o2 < e2.length; )
              if (n.call(e2, o2))
                return next.value = e2[o2], next.done = false, next;
            return next.value = t2, next.done = true, next;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof2(e2) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t3) {
      var e2 = "function" == typeof t3 && t3.constructor;
      return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
    }, e.mark = function(t3) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u, "GeneratorFunction")), t3.prototype = Object.create(g), t3;
    }, e.awrap = function(t3) {
      return {
        __await: t3
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t3, r2, n2, o2, i2) {
      void 0 === i2 && (i2 = Promise);
      var a2 = new AsyncIterator(wrap(t3, r2, n2, o2), i2);
      return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t4) {
        return t4.done ? t4.value : a2.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
      return this;
    }), define(g, "toString", function() {
      return "[object Generator]";
    }), e.keys = function(t3) {
      var e2 = Object(t3), r2 = [];
      for (var n2 in e2)
        r2.push(n2);
      return r2.reverse(), function next() {
        for (; r2.length; ) {
          var t4 = r2.pop();
          if (t4 in e2)
            return next.value = t4, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e2)
          for (var r2 in this)
            "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t2);
      },
      stop: function stop() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type)
          throw t3.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e2) {
        if (this.done)
          throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t2), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc)
            return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
            } else {
              if (!u2)
                throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t3, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t3, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      },
      complete: function complete(t3, e2) {
        if ("throw" === t3.type)
          throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e2 && (this.next = e2), y;
      },
      finish: function finish(t3) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t3)
            return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      },
      "catch": function _catch(t3) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t3) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = {
          iterator: values(e2),
          resultName: r2,
          nextLoc: n2
        }, "next" === this.method && (this.arg = t2), y;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;
var runtime = regeneratorRuntimeExports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
const _regeneratorRuntime = /* @__PURE__ */ getDefaultExportFromCjs(regenerator);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var exceljs = { exports: {} };
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$2(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _asyncIterator(r) {
  var n, t2, o, e = 2;
  for ("undefined" != typeof Symbol && (t2 = Symbol.asyncIterator, o = Symbol.iterator); e--; ) {
    if (t2 && null != (n = r[t2]))
      return n.call(r);
    if (o && null != (n = r[o]))
      return new AsyncFromSyncIterator(n.call(r));
    t2 = "@@asyncIterator", o = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(r) {
  function AsyncFromSyncIteratorContinuation(r2) {
    if (Object(r2) !== r2)
      return Promise.reject(new TypeError(r2 + " is not an object."));
    var n = r2.done;
    return Promise.resolve(r2.value).then(function(r3) {
      return { value: r3, done: n };
    });
  }
  return AsyncFromSyncIterator = function AsyncFromSyncIterator2(r2) {
    this.s = r2, this.n = r2.next;
  }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() {
    return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
  }, return: function _return(r2) {
    var n = this.s.return;
    return void 0 === n ? Promise.resolve({ value: r2, done: true }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
  }, throw: function _throw(r2) {
    var n = this.s.return;
    return void 0 === n ? Promise.reject(r2) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
  } }, new AsyncFromSyncIterator(r);
}
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function() {
      function r(e, n, t2) {
        function o(i2, f) {
          if (!n[i2]) {
            if (!e[i2]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c)
                return c(i2, true);
              if (u)
                return u(i2, true);
              var a = new Error("Cannot find module '" + i2 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i2] = { exports: {} };
            e[i2][0].call(p.exports, function(r2) {
              var n2 = e[i2][1][r2];
              return o(n2 || r2);
            }, p, p.exports, r, e, n, t2);
          }
          return n[i2].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t2.length; i++)
          o(t2[i]);
        return o;
      }
      return r;
    }()({ 1: [function(require2, module2, exports2) {
      var fs = require2("fs");
      var fastCsv = require2("fast-csv");
      var customParseFormat = require2("dayjs/plugin/customParseFormat");
      var utc = require2("dayjs/plugin/utc");
      var dayjs2 = require2("dayjs").extend(customParseFormat).extend(utc);
      var StreamBuf = require2("../utils/stream-buf");
      var _require3 = require2("../utils/utils"), exists = _require3.fs.exists;
      var SpecialValues = { true: true, false: false, "#N/A": { error: "#N/A" }, "#REF!": { error: "#REF!" }, "#NAME?": { error: "#NAME?" }, "#DIV/0!": { error: "#DIV/0!" }, "#NULL!": { error: "#NULL!" }, "#VALUE!": { error: "#VALUE!" }, "#NUM!": { error: "#NUM!" } };
      var CSV = /* @__PURE__ */ function() {
        function CSV2(workbook) {
          _classCallCheck(this, CSV2);
          this.workbook = workbook;
          this.worksheet = null;
        }
        _createClass(CSV2, [{ key: "readFile", value: function() {
          var _readFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(filename, options) {
            var stream, worksheet;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    _context.next = 3;
                    return exists(filename);
                  case 3:
                    if (_context.sent) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("File not found: ".concat(filename));
                  case 5:
                    stream = fs.createReadStream(filename);
                    _context.next = 8;
                    return this.read(stream, options);
                  case 8:
                    worksheet = _context.sent;
                    stream.close();
                    return _context.abrupt("return", worksheet);
                  case 11:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function readFile(_x2, _x3) {
            return _readFile.apply(this, arguments);
          }
          return readFile;
        }() }, {
          key: "read",
          value: function read(stream, options) {
            var _this3 = this;
            options = options || {};
            return new Promise(function(resolve, reject) {
              var worksheet = _this3.workbook.addWorksheet(options.sheetName);
              var dateFormats = options.dateFormats || ["YYYY-MM-DD[T]HH:mm:ssZ", "YYYY-MM-DD[T]HH:mm:ss", "MM-DD-YYYY", "YYYY-MM-DD"];
              var map = options.map || function(datum) {
                if (datum === "") {
                  return null;
                }
                var datumNumber = Number(datum);
                if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
                  return datumNumber;
                }
                var dt = dateFormats.reduce(function(matchingDate, currentDateFormat) {
                  if (matchingDate) {
                    return matchingDate;
                  }
                  var dayjsObj = dayjs2(datum, currentDateFormat, true);
                  if (dayjsObj.isValid()) {
                    return dayjsObj;
                  }
                  return null;
                }, null);
                if (dt) {
                  return new Date(dt.valueOf());
                }
                var special = SpecialValues[datum];
                if (special !== void 0) {
                  return special;
                }
                return datum;
              };
              var csvStream = fastCsv.parse(options.parserOptions).on("data", function(data) {
                worksheet.addRow(data.map(map));
              }).on("end", function() {
                csvStream.emit("worksheet", worksheet);
              });
              csvStream.on("worksheet", resolve).on("error", reject);
              stream.pipe(csvStream);
            });
          }
          /**
          * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
          */
        }, { key: "createInputStream", value: function createInputStream() {
          throw new Error("`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
        } }, { key: "write", value: function write(stream, options) {
          var _this4 = this;
          return new Promise(function(resolve, reject) {
            options = options || {};
            var worksheet = _this4.workbook.getWorksheet(options.sheetName || options.sheetId);
            var csvStream = fastCsv.format(options.formatterOptions);
            stream.on("finish", function() {
              resolve();
            });
            csvStream.on("error", reject);
            csvStream.pipe(stream);
            var _options = options, dateFormat2 = _options.dateFormat, dateUTC = _options.dateUTC;
            var map = options.map || function(value) {
              if (value) {
                if (value.text || value.hyperlink) {
                  return value.hyperlink || value.text || "";
                }
                if (value.formula || value.result) {
                  return value.result || "";
                }
                if (value instanceof Date) {
                  if (dateFormat2) {
                    return dateUTC ? dayjs2.utc(value).format(dateFormat2) : dayjs2(value).format(dateFormat2);
                  }
                  return dateUTC ? dayjs2.utc(value).format() : dayjs2(value).format();
                }
                if (value.error) {
                  return value.error;
                }
                if (typeof value === "object") {
                  return JSON.stringify(value);
                }
              }
              return value;
            };
            var includeEmptyRows = options.includeEmptyRows === void 0 || options.includeEmptyRows;
            var lastRow = 1;
            if (worksheet) {
              worksheet.eachRow(function(row, rowNumber) {
                if (includeEmptyRows) {
                  while (lastRow++ < rowNumber - 1) {
                    csvStream.write([]);
                  }
                }
                var values = row.values;
                values.shift();
                csvStream.write(values.map(map));
                lastRow = rowNumber;
              });
            }
            csvStream.end();
          });
        } }, { key: "writeFile", value: function writeFile(filename, options) {
          options = options || {};
          var streamOptions = { encoding: options.encoding || "utf8" };
          var stream = fs.createWriteStream(filename, streamOptions);
          return this.write(stream, options);
        } }, { key: "writeBuffer", value: function() {
          var _writeBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee2(options) {
            var stream;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    stream = new StreamBuf();
                    _context2.next = 3;
                    return this.write(stream, options);
                  case 3:
                    return _context2.abrupt("return", stream.read());
                  case 4:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function writeBuffer(_x4) {
            return _writeBuffer.apply(this, arguments);
          }
          return writeBuffer;
        }() }]);
        return CSV2;
      }();
      module2.exports = CSV;
    }, { "../utils/stream-buf": 24, "../utils/utils": 27, "dayjs": 391, "dayjs/plugin/customParseFormat": 392, "dayjs/plugin/utc": 393, "fast-csv": 424, "fs": 216 }], 2: [function(require2, module2, exports2) {
      var colCache = require2("../utils/col-cache");
      var Anchor = /* @__PURE__ */ function() {
        function Anchor2(worksheet, address) {
          _classCallCheck(this, Anchor2);
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          this.worksheet = worksheet;
          if (!address) {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
          } else if (typeof address === "string") {
            var decoded = colCache.decodeAddress(address);
            this.nativeCol = decoded.col + offset;
            this.nativeColOff = 0;
            this.nativeRow = decoded.row + offset;
            this.nativeRowOff = 0;
          } else if (address.nativeCol !== void 0) {
            this.nativeCol = address.nativeCol || 0;
            this.nativeColOff = address.nativeColOff || 0;
            this.nativeRow = address.nativeRow || 0;
            this.nativeRowOff = address.nativeRowOff || 0;
          } else if (address.col !== void 0) {
            this.col = address.col + offset;
            this.row = address.row + offset;
          } else {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
          }
        }
        _createClass(Anchor2, [{ key: "col", get: function get() {
          return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
        }, set: function set(v) {
          this.nativeCol = Math.floor(v);
          this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
        } }, { key: "row", get: function get() {
          return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
        }, set: function set(v) {
          this.nativeRow = Math.floor(v);
          this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
        } }, { key: "colWidth", get: function get() {
          return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 1e4) : 64e4;
        } }, { key: "rowHeight", get: function get() {
          return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 1e4) : 18e4;
        } }, { key: "model", get: function get() {
          return { nativeCol: this.nativeCol, nativeColOff: this.nativeColOff, nativeRow: this.nativeRow, nativeRowOff: this.nativeRowOff };
        }, set: function set(value) {
          this.nativeCol = value.nativeCol;
          this.nativeColOff = value.nativeColOff;
          this.nativeRow = value.nativeRow;
          this.nativeRowOff = value.nativeRowOff;
        } }], [{ key: "asInstance", value: function asInstance(model) {
          return model instanceof Anchor2 || model == null ? model : new Anchor2(model);
        } }]);
        return Anchor2;
      }();
      module2.exports = Anchor;
    }, { "../utils/col-cache": 19 }], 3: [function(require2, module2, exports2) {
      var colCache = require2("../utils/col-cache");
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var _require4 = require2("../utils/shared-formula"), slideFormula = _require4.slideFormula;
      var Note = require2("./note");
      var Cell = /* @__PURE__ */ function() {
        function Cell2(row, column, address) {
          _classCallCheck(this, Cell2);
          if (!row || !column) {
            throw new Error("A Cell needs a Row");
          }
          this._row = row;
          this._column = column;
          colCache.validateAddress(address);
          this._address = address;
          this._value = Value.create(Cell2.Types.Null, this);
          this.style = this._mergeStyle(row.style, column.style, {});
          this._mergeCount = 0;
        }
        _createClass(Cell2, [{ key: "worksheet", get: function get() {
          return this._row.worksheet;
        } }, {
          key: "workbook",
          get: function get() {
            return this._row.worksheet.workbook;
          }
          // help GC by removing cyclic (and other) references
        }, {
          key: "destroy",
          value: function destroy() {
            delete this.style;
            delete this._value;
            delete this._row;
            delete this._column;
            delete this._address;
          }
          // =========================================================================
          // Styles stuff
        }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this.style.numFmt = value;
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this.style.font = value;
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this.style.alignment = value;
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this.style.border = value;
        } }, { key: "fill", get: function get() {
          return this.style.fill;
        }, set: function set(value) {
          this.style.fill = value;
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this.style.protection = value;
        } }, {
          key: "_mergeStyle",
          value: function _mergeStyle(rowStyle, colStyle, style) {
            var numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
            if (numFmt)
              style.numFmt = numFmt;
            var font = rowStyle && rowStyle.font || colStyle && colStyle.font;
            if (font)
              style.font = font;
            var alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
            if (alignment)
              style.alignment = alignment;
            var border = rowStyle && rowStyle.border || colStyle && colStyle.border;
            if (border)
              style.border = border;
            var fill2 = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
            if (fill2)
              style.fill = fill2;
            var protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
            if (protection)
              style.protection = protection;
            return style;
          }
          // =========================================================================
          // return the address for this cell
        }, { key: "address", get: function get() {
          return this._address;
        } }, { key: "row", get: function get() {
          return this._row.number;
        } }, { key: "col", get: function get() {
          return this._column.number;
        } }, {
          key: "$col$row",
          get: function get() {
            return "$".concat(this._column.letter, "$").concat(this.row);
          }
          // =========================================================================
          // Value stuff
        }, { key: "type", get: function get() {
          return this._value.type;
        } }, { key: "effectiveType", get: function get() {
          return this._value.effectiveType;
        } }, {
          key: "toCsvString",
          value: function toCsvString() {
            return this._value.toCsvString();
          }
          // =========================================================================
          // Merge stuff
        }, { key: "addMergeRef", value: function addMergeRef() {
          this._mergeCount++;
        } }, { key: "releaseMergeRef", value: function releaseMergeRef() {
          this._mergeCount--;
        } }, { key: "isMerged", get: function get() {
          return this._mergeCount > 0 || this.type === Cell2.Types.Merge;
        } }, { key: "merge", value: function merge2(master, ignoreStyle) {
          this._value.release();
          this._value = Value.create(Cell2.Types.Merge, this, master);
          if (!ignoreStyle) {
            this.style = master.style;
          }
        } }, { key: "unmerge", value: function unmerge() {
          if (this.type === Cell2.Types.Merge) {
            this._value.release();
            this._value = Value.create(Cell2.Types.Null, this);
            this.style = this._mergeStyle(this._row.style, this._column.style, {});
          }
        } }, { key: "isMergedTo", value: function isMergedTo(master) {
          if (this._value.type !== Cell2.Types.Merge)
            return false;
          return this._value.isMergedTo(master);
        } }, { key: "master", get: function get() {
          if (this.type === Cell2.Types.Merge) {
            return this._value.master;
          }
          return this;
        } }, { key: "isHyperlink", get: function get() {
          return this._value.type === Cell2.Types.Hyperlink;
        } }, {
          key: "hyperlink",
          get: function get() {
            return this._value.hyperlink;
          }
          // return the value
        }, {
          key: "value",
          get: function get() {
            return this._value.value;
          },
          set: function set(v) {
            if (this.type === Cell2.Types.Merge) {
              this._value.master.value = v;
              return;
            }
            this._value.release();
            this._value = Value.create(Value.getType(v), this, v);
          }
        }, { key: "note", get: function get() {
          return this._comment && this._comment.note;
        }, set: function set(note) {
          this._comment = new Note(note);
        } }, { key: "text", get: function get() {
          return this._value.toString();
        } }, { key: "html", get: function get() {
          return _.escapeHtml(this.text);
        } }, { key: "toString", value: function toString2() {
          return this.text;
        } }, {
          key: "_upgradeToHyperlink",
          value: function _upgradeToHyperlink(hyperlink) {
            if (this.type === Cell2.Types.String) {
              this._value = Value.create(Cell2.Types.Hyperlink, this, { text: this._value.value, hyperlink });
            }
          }
          // =========================================================================
          // Formula stuff
        }, { key: "formula", get: function get() {
          return this._value.formula;
        } }, { key: "result", get: function get() {
          return this._value.result;
        } }, {
          key: "formulaType",
          get: function get() {
            return this._value.formulaType;
          }
          // =========================================================================
          // Name stuff
        }, { key: "fullAddress", get: function get() {
          var worksheet = this._row.worksheet;
          return { sheetName: worksheet.name, address: this.address, row: this.row, col: this.col };
        } }, { key: "name", get: function get() {
          return this.names[0];
        }, set: function set(value) {
          this.names = [value];
        } }, { key: "names", get: function get() {
          return this.workbook.definedNames.getNamesEx(this.fullAddress);
        }, set: function set(value) {
          var _this5 = this;
          var definedNames = this.workbook.definedNames;
          definedNames.removeAllNames(this.fullAddress);
          value.forEach(function(name) {
            definedNames.addEx(_this5.fullAddress, name);
          });
        } }, { key: "addName", value: function addName(name) {
          this.workbook.definedNames.addEx(this.fullAddress, name);
        } }, { key: "removeName", value: function removeName(name) {
          this.workbook.definedNames.removeEx(this.fullAddress, name);
        } }, {
          key: "removeAllNames",
          value: function removeAllNames() {
            this.workbook.definedNames.removeAllNames(this.fullAddress);
          }
          // =========================================================================
          // Data Validation stuff
        }, { key: "_dataValidations", get: function get() {
          return this.worksheet.dataValidations;
        } }, {
          key: "dataValidation",
          get: function get() {
            return this._dataValidations.find(this.address);
          },
          set: function set(value) {
            this._dataValidations.add(this.address, value);
          }
          // =========================================================================
          // Model stuff
        }, { key: "model", get: function get() {
          var model = this._value.model;
          model.style = this.style;
          if (this._comment) {
            model.comment = this._comment.model;
          }
          return model;
        }, set: function set(value) {
          this._value.release();
          this._value = Value.create(value.type, this);
          this._value.model = value;
          if (value.comment) {
            switch (value.comment.type) {
              case "note":
                this._comment = Note.fromModel(value.comment);
                break;
            }
          }
          if (value.style) {
            this.style = value.style;
          } else {
            this.style = {};
          }
        } }]);
        return Cell2;
      }();
      Cell.Types = Enums.ValueType;
      var NullValue = /* @__PURE__ */ function() {
        function NullValue2(cell) {
          _classCallCheck(this, NullValue2);
          this.model = { address: cell.address, type: Cell.Types.Null };
        }
        _createClass(NullValue2, [{ key: "value", get: function get() {
          return null;
        }, set: function set(value) {
        } }, { key: "type", get: function get() {
          return Cell.Types.Null;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Null;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return "";
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return "";
        } }]);
        return NullValue2;
      }();
      var NumberValue = /* @__PURE__ */ function() {
        function NumberValue2(cell, value) {
          _classCallCheck(this, NumberValue2);
          this.model = { address: cell.address, type: Cell.Types.Number, value };
        }
        _createClass(NumberValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Number;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Number;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.value.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }]);
        return NumberValue2;
      }();
      var StringValue = /* @__PURE__ */ function() {
        function StringValue2(cell, value) {
          _classCallCheck(this, StringValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value };
        }
        _createClass(StringValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.String;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.String;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return '"'.concat(this.model.value.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value;
        } }]);
        return StringValue2;
      }();
      var RichTextValue = /* @__PURE__ */ function() {
        function RichTextValue2(cell, value) {
          _classCallCheck(this, RichTextValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value };
        }
        _createClass(RichTextValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "toString", value: function toString2() {
          return this.model.value.richText.map(function(t2) {
            return t2.text;
          }).join("");
        } }, { key: "type", get: function get() {
          return Cell.Types.RichText;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.RichText;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return '"'.concat(this.text.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function release() {
        } }]);
        return RichTextValue2;
      }();
      var DateValue = /* @__PURE__ */ function() {
        function DateValue2(cell, value) {
          _classCallCheck(this, DateValue2);
          this.model = { address: cell.address, type: Cell.Types.Date, value };
        }
        _createClass(DateValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Date;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Date;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.value.toISOString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }]);
        return DateValue2;
      }();
      var HyperlinkValue = /* @__PURE__ */ function() {
        function HyperlinkValue2(cell, value) {
          _classCallCheck(this, HyperlinkValue2);
          this.model = { address: cell.address, type: Cell.Types.Hyperlink, text: value ? value.text : void 0, hyperlink: value ? value.hyperlink : void 0 };
          if (value && value.tooltip) {
            this.model.tooltip = value.tooltip;
          }
        }
        _createClass(HyperlinkValue2, [{ key: "value", get: function get() {
          var v = { text: this.model.text, hyperlink: this.model.hyperlink };
          if (this.model.tooltip) {
            v.tooltip = this.model.tooltip;
          }
          return v;
        }, set: function set(value) {
          this.model = { text: value.text, hyperlink: value.hyperlink };
          if (value.tooltip) {
            this.model.tooltip = value.tooltip;
          }
        } }, {
          key: "text",
          get: function get() {
            return this.model.text;
          },
          set: function set(value) {
            this.model.text = value;
          }
          /*
          get tooltip() {
            return this.model.tooltip;
          }
           set tooltip(value) {
            this.model.tooltip = value;
          } */
        }, { key: "hyperlink", get: function get() {
          return this.model.hyperlink;
        }, set: function set(value) {
          this.model.hyperlink = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Hyperlink;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Hyperlink;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.hyperlink;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.text;
        } }]);
        return HyperlinkValue2;
      }();
      var MergeValue = /* @__PURE__ */ function() {
        function MergeValue2(cell, master) {
          _classCallCheck(this, MergeValue2);
          this.model = { address: cell.address, type: Cell.Types.Merge, master: master ? master.address : void 0 };
          this._master = master;
          if (master) {
            master.addMergeRef();
          }
        }
        _createClass(MergeValue2, [{ key: "value", get: function get() {
          return this._master.value;
        }, set: function set(value) {
          if (value instanceof Cell) {
            if (this._master) {
              this._master.releaseMergeRef();
            }
            value.addMergeRef();
            this._master = value;
          } else {
            this._master.value = value;
          }
        } }, { key: "isMergedTo", value: function isMergedTo(master) {
          return master === this._master;
        } }, { key: "master", get: function get() {
          return this._master;
        } }, { key: "type", get: function get() {
          return Cell.Types.Merge;
        } }, { key: "effectiveType", get: function get() {
          return this._master.effectiveType;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return "";
        } }, { key: "release", value: function release() {
          this._master.releaseMergeRef();
        } }, { key: "toString", value: function toString2() {
          return this.value.toString();
        } }]);
        return MergeValue2;
      }();
      var FormulaValue = /* @__PURE__ */ function() {
        function FormulaValue2(cell, value) {
          _classCallCheck(this, FormulaValue2);
          this.cell = cell;
          this.model = { address: cell.address, type: Cell.Types.Formula, shareType: value ? value.shareType : void 0, ref: value ? value.ref : void 0, formula: value ? value.formula : void 0, sharedFormula: value ? value.sharedFormula : void 0, result: value ? value.result : void 0 };
        }
        _createClass(FormulaValue2, [{ key: "_copyModel", value: function _copyModel(model) {
          var copy2 = {};
          var cp = function cp2(name) {
            var value = model[name];
            if (value) {
              copy2[name] = value;
            }
          };
          cp("formula");
          cp("result");
          cp("ref");
          cp("shareType");
          cp("sharedFormula");
          return copy2;
        } }, { key: "value", get: function get() {
          return this._copyModel(this.model);
        }, set: function set(value) {
          this.model = this._copyModel(value);
        } }, { key: "validate", value: function validate(value) {
          switch (Value.getType(value)) {
            case Cell.Types.Null:
            case Cell.Types.String:
            case Cell.Types.Number:
            case Cell.Types.Date:
              break;
            case Cell.Types.Hyperlink:
            case Cell.Types.Formula:
            default:
              throw new Error("Cannot process that type of result value");
          }
        } }, { key: "dependencies", get: function get() {
          var ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
          var cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
          return { ranges, cells };
        } }, { key: "formula", get: function get() {
          return this.model.formula || this._getTranslatedFormula();
        }, set: function set(value) {
          this.model.formula = value;
        } }, { key: "formulaType", get: function get() {
          if (this.model.formula) {
            return Enums.FormulaType.Master;
          }
          if (this.model.sharedFormula) {
            return Enums.FormulaType.Shared;
          }
          return Enums.FormulaType.None;
        } }, { key: "result", get: function get() {
          return this.model.result;
        }, set: function set(value) {
          this.model.result = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Formula;
        } }, { key: "effectiveType", get: function get() {
          var v = this.model.result;
          if (v === null || v === void 0) {
            return Enums.ValueType.Null;
          }
          if (v instanceof String || typeof v === "string") {
            return Enums.ValueType.String;
          }
          if (typeof v === "number") {
            return Enums.ValueType.Number;
          }
          if (v instanceof Date) {
            return Enums.ValueType.Date;
          }
          if (v.text && v.hyperlink) {
            return Enums.ValueType.Hyperlink;
          }
          if (v.formula) {
            return Enums.ValueType.Formula;
          }
          return Enums.ValueType.Null;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "_getTranslatedFormula", value: function _getTranslatedFormula() {
          if (!this._translatedFormula && this.model.sharedFormula) {
            var worksheet = this.cell.worksheet;
            var master = worksheet.findCell(this.model.sharedFormula);
            this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
          }
          return this._translatedFormula;
        } }, { key: "toCsvString", value: function toCsvString() {
          return "".concat(this.model.result || "");
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.result ? this.model.result.toString() : "";
        } }]);
        return FormulaValue2;
      }();
      var SharedStringValue = /* @__PURE__ */ function() {
        function SharedStringValue2(cell, value) {
          _classCallCheck(this, SharedStringValue2);
          this.model = { address: cell.address, type: Cell.Types.SharedString, value };
        }
        _createClass(SharedStringValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.SharedString;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.SharedString;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.value.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }]);
        return SharedStringValue2;
      }();
      var BooleanValue = /* @__PURE__ */ function() {
        function BooleanValue2(cell, value) {
          _classCallCheck(this, BooleanValue2);
          this.model = { address: cell.address, type: Cell.Types.Boolean, value };
        }
        _createClass(BooleanValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Boolean;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Boolean;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.value ? 1 : 0;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }]);
        return BooleanValue2;
      }();
      var ErrorValue = /* @__PURE__ */ function() {
        function ErrorValue2(cell, value) {
          _classCallCheck(this, ErrorValue2);
          this.model = { address: cell.address, type: Cell.Types.Error, value };
        }
        _createClass(ErrorValue2, [{ key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Error;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Error;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.error.toString();
        } }]);
        return ErrorValue2;
      }();
      var JSONValue = /* @__PURE__ */ function() {
        function JSONValue2(cell, value) {
          _classCallCheck(this, JSONValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value: JSON.stringify(value), rawValue: value };
        }
        _createClass(JSONValue2, [{ key: "value", get: function get() {
          return this.model.rawValue;
        }, set: function set(value) {
          this.model.rawValue = value;
          this.model.value = JSON.stringify(value);
        } }, { key: "type", get: function get() {
          return Cell.Types.String;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.String;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }, { key: "toCsvString", value: function toCsvString() {
          return this.model.value;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value;
        } }]);
        return JSONValue2;
      }();
      var Value = {
        getType: function getType(value) {
          if (value === null || value === void 0) {
            return Cell.Types.Null;
          }
          if (value instanceof String || typeof value === "string") {
            return Cell.Types.String;
          }
          if (typeof value === "number") {
            return Cell.Types.Number;
          }
          if (typeof value === "boolean") {
            return Cell.Types.Boolean;
          }
          if (value instanceof Date) {
            return Cell.Types.Date;
          }
          if (value.text && value.hyperlink) {
            return Cell.Types.Hyperlink;
          }
          if (value.formula || value.sharedFormula) {
            return Cell.Types.Formula;
          }
          if (value.richText) {
            return Cell.Types.RichText;
          }
          if (value.sharedString) {
            return Cell.Types.SharedString;
          }
          if (value.error) {
            return Cell.Types.Error;
          }
          return Cell.Types.JSON;
        },
        // map valueType to constructor
        types: [{ t: Cell.Types.Null, f: NullValue }, { t: Cell.Types.Number, f: NumberValue }, { t: Cell.Types.String, f: StringValue }, { t: Cell.Types.Date, f: DateValue }, { t: Cell.Types.Hyperlink, f: HyperlinkValue }, { t: Cell.Types.Formula, f: FormulaValue }, { t: Cell.Types.Merge, f: MergeValue }, { t: Cell.Types.JSON, f: JSONValue }, { t: Cell.Types.SharedString, f: SharedStringValue }, { t: Cell.Types.RichText, f: RichTextValue }, { t: Cell.Types.Boolean, f: BooleanValue }, { t: Cell.Types.Error, f: ErrorValue }].reduce(function(p, t2) {
          p[t2.t] = t2.f;
          return p;
        }, []),
        create: function create(type, cell, value) {
          var T = this.types[type];
          if (!T) {
            throw new Error("Could not create Value of type ".concat(type));
          }
          return new T(cell, value);
        }
      };
      module2.exports = Cell;
    }, { "../utils/col-cache": 19, "../utils/shared-formula": 23, "../utils/under-dash": 26, "./enums": 7, "./note": 9 }], 4: [function(require2, module2, exports2) {
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var colCache = require2("../utils/col-cache");
      var DEFAULT_COLUMN_WIDTH = 9;
      var Column = /* @__PURE__ */ function() {
        function Column2(worksheet, number, defn) {
          _classCallCheck(this, Column2);
          this._worksheet = worksheet;
          this._number = number;
          if (defn !== false) {
            this.defn = defn;
          }
        }
        _createClass(Column2, [{ key: "number", get: function get() {
          return this._number;
        } }, { key: "worksheet", get: function get() {
          return this._worksheet;
        } }, { key: "letter", get: function get() {
          return colCache.n2l(this._number);
        } }, { key: "isCustomWidth", get: function get() {
          return this.width !== void 0 && this.width !== DEFAULT_COLUMN_WIDTH;
        } }, { key: "defn", get: function get() {
          return { header: this._header, key: this.key, width: this.width, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel };
        }, set: function set(value) {
          if (value) {
            this.key = value.key;
            this.width = value.width !== void 0 ? value.width : DEFAULT_COLUMN_WIDTH;
            this.outlineLevel = value.outlineLevel;
            if (value.style) {
              this.style = value.style;
            } else {
              this.style = {};
            }
            this.header = value.header;
            this._hidden = !!value.hidden;
          } else {
            delete this._header;
            delete this._key;
            delete this.width;
            this.style = {};
            this.outlineLevel = 0;
          }
        } }, { key: "headers", get: function get() {
          return this._header && this._header instanceof Array ? this._header : [this._header];
        } }, { key: "header", get: function get() {
          return this._header;
        }, set: function set(value) {
          var _this6 = this;
          if (value !== void 0) {
            this._header = value;
            this.headers.forEach(function(text, index2) {
              _this6._worksheet.getCell(index2 + 1, _this6.number).value = text;
            });
          } else {
            this._header = void 0;
          }
        } }, { key: "key", get: function get() {
          return this._key;
        }, set: function set(value) {
          var column = this._key && this._worksheet.getColumnKey(this._key);
          if (column === this) {
            this._worksheet.deleteColumnKey(this._key);
          }
          this._key = value;
          if (value) {
            this._worksheet.setColumnKey(this._key, this);
          }
        } }, { key: "hidden", get: function get() {
          return !!this._hidden;
        }, set: function set(value) {
          this._hidden = value;
        } }, { key: "outlineLevel", get: function get() {
          return this._outlineLevel || 0;
        }, set: function set(value) {
          this._outlineLevel = value;
        } }, { key: "collapsed", get: function get() {
          return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
        } }, { key: "toString", value: function toString2() {
          return JSON.stringify({ key: this.key, width: this.width, headers: this.headers.length ? this.headers : void 0 });
        } }, { key: "equivalentTo", value: function equivalentTo(other) {
          return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _.isEqual(this.style, other.style);
        } }, { key: "isDefault", get: function get() {
          if (this.isCustomWidth) {
            return false;
          }
          if (this.hidden) {
            return false;
          }
          if (this.outlineLevel) {
            return false;
          }
          var s = this.style;
          if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
            return false;
          }
          return true;
        } }, { key: "headerCount", get: function get() {
          return this.headers.length;
        } }, { key: "eachCell", value: function eachCell(options, iteratee) {
          var colNumber = this.number;
          if (!iteratee) {
            iteratee = options;
            options = null;
          }
          this._worksheet.eachRow(options, function(row, rowNumber) {
            iteratee(row.getCell(colNumber), rowNumber);
          });
        } }, {
          key: "values",
          get: function get() {
            var v = [];
            this.eachCell(function(cell, rowNumber) {
              if (cell && cell.type !== Enums.ValueType.Null) {
                v[rowNumber] = cell.value;
              }
            });
            return v;
          },
          set: function set(v) {
            var _this7 = this;
            if (!v) {
              return;
            }
            var colNumber = this.number;
            var offset = 0;
            if (v.hasOwnProperty("0")) {
              offset = 1;
            }
            v.forEach(function(value, index2) {
              _this7._worksheet.getCell(index2 + offset, colNumber).value = value;
            });
          }
          // =========================================================================
          // styles
        }, { key: "_applyStyle", value: function _applyStyle(name, value) {
          this.style[name] = value;
          this.eachCell(function(cell) {
            cell[name] = value;
          });
          return value;
        } }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this._applyStyle("numFmt", value);
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this._applyStyle("font", value);
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this._applyStyle("alignment", value);
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this._applyStyle("protection", value);
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this._applyStyle("border", value);
        } }, {
          key: "fill",
          get: function get() {
            return this.style.fill;
          },
          set: function set(value) {
            this._applyStyle("fill", value);
          }
          // =============================================================================
          // static functions
        }], [{ key: "toModel", value: function toModel(columns) {
          var cols = [];
          var col = null;
          if (columns) {
            columns.forEach(function(column, index2) {
              if (column.isDefault) {
                if (col) {
                  col = null;
                }
              } else if (!col || !column.equivalentTo(col)) {
                col = { min: index2 + 1, max: index2 + 1, width: column.width !== void 0 ? column.width : DEFAULT_COLUMN_WIDTH, style: column.style, isCustomWidth: column.isCustomWidth, hidden: column.hidden, outlineLevel: column.outlineLevel, collapsed: column.collapsed };
                cols.push(col);
              } else {
                col.max = index2 + 1;
              }
            });
          }
          return cols.length ? cols : void 0;
        } }, { key: "fromModel", value: function fromModel(worksheet, cols) {
          cols = cols || [];
          var columns = [];
          var count = 1;
          var index2 = 0;
          cols = cols.sort(function(pre, next) {
            return pre.min - next.min;
          });
          while (index2 < cols.length) {
            var col = cols[index2++];
            while (count < col.min) {
              columns.push(new Column2(worksheet, count++));
            }
            while (count <= col.max) {
              columns.push(new Column2(worksheet, count++, col));
            }
          }
          return columns.length ? columns : null;
        } }]);
        return Column2;
      }();
      module2.exports = Column;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 26, "./enums": 7 }], 5: [function(require2, module2, exports2) {
      var DataValidations = /* @__PURE__ */ function() {
        function DataValidations2(model) {
          _classCallCheck(this, DataValidations2);
          this.model = model || {};
        }
        _createClass(DataValidations2, [{ key: "add", value: function add(address, validation) {
          return this.model[address] = validation;
        } }, { key: "find", value: function find(address) {
          return this.model[address];
        } }, { key: "remove", value: function remove(address) {
          this.model[address] = void 0;
        } }]);
        return DataValidations2;
      }();
      module2.exports = DataValidations;
    }, {}], 6: [function(require2, module2, exports2) {
      var _ = require2("../utils/under-dash");
      var colCache = require2("../utils/col-cache");
      var CellMatrix = require2("../utils/cell-matrix");
      var Range = require2("./range");
      var rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
      var DefinedNames = /* @__PURE__ */ function() {
        function DefinedNames2() {
          _classCallCheck(this, DefinedNames2);
          this.matrixMap = {};
        }
        _createClass(DefinedNames2, [{
          key: "getMatrix",
          value: function getMatrix(name) {
            var matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());
            return matrix;
          }
          // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
        }, { key: "add", value: function add(locStr, name) {
          var location = colCache.decodeEx(locStr);
          this.addEx(location, name);
        } }, { key: "addEx", value: function addEx(location, name) {
          var matrix = this.getMatrix(name);
          if (location.top) {
            for (var col = location.left; col <= location.right; col++) {
              for (var row = location.top; row <= location.bottom; row++) {
                var address = { sheetName: location.sheetName, address: colCache.n2l(col) + row, row, col };
                matrix.addCellEx(address);
              }
            }
          } else {
            matrix.addCellEx(location);
          }
        } }, { key: "remove", value: function remove(locStr, name) {
          var location = colCache.decodeEx(locStr);
          this.removeEx(location, name);
        } }, { key: "removeEx", value: function removeEx(location, name) {
          var matrix = this.getMatrix(name);
          matrix.removeCellEx(location);
        } }, { key: "removeAllNames", value: function removeAllNames(location) {
          _.each(this.matrixMap, function(matrix) {
            matrix.removeCellEx(location);
          });
        } }, {
          key: "forEach",
          value: function forEach(callback) {
            _.each(this.matrixMap, function(matrix, name) {
              matrix.forEach(function(cell) {
                callback(name, cell);
              });
            });
          }
          // get all the names of a cell
        }, { key: "getNames", value: function getNames(addressStr) {
          return this.getNamesEx(colCache.decodeEx(addressStr));
        } }, { key: "getNamesEx", value: function getNamesEx(address) {
          return _.map(this.matrixMap, function(matrix, name) {
            return matrix.findCellEx(address) && name;
          }).filter(Boolean);
        } }, { key: "_explore", value: function _explore(matrix, cell) {
          cell.mark = false;
          var sheetName = cell.sheetName;
          var range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);
          var x;
          var y;
          function vGrow(yy, edge) {
            var c = matrix.findCellAt(sheetName, yy, cell.col);
            if (!c || !c.mark) {
              return false;
            }
            range[edge] = yy;
            c.mark = false;
            return true;
          }
          for (y = cell.row - 1; vGrow(y, "top"); y--)
            ;
          for (y = cell.row + 1; vGrow(y, "bottom"); y++)
            ;
          function hGrow(xx, edge) {
            var cells = [];
            for (y = range.top; y <= range.bottom; y++) {
              var c = matrix.findCellAt(sheetName, y, xx);
              if (c && c.mark) {
                cells.push(c);
              } else {
                return false;
              }
            }
            range[edge] = xx;
            for (var i = 0; i < cells.length; i++) {
              cells[i].mark = false;
            }
            return true;
          }
          for (x = cell.col - 1; hGrow(x, "left"); x--)
            ;
          for (x = cell.col + 1; hGrow(x, "right"); x++)
            ;
          return range;
        } }, { key: "getRanges", value: function getRanges(name, matrix) {
          var _this8 = this;
          matrix = matrix || this.matrixMap[name];
          if (!matrix) {
            return { name, ranges: [] };
          }
          matrix.forEach(function(cell) {
            cell.mark = true;
          });
          var ranges = matrix.map(function(cell) {
            return cell.mark && _this8._explore(matrix, cell);
          }).filter(Boolean).map(function(range) {
            return range.$shortRange;
          });
          return { name, ranges };
        } }, { key: "normaliseMatrix", value: function normaliseMatrix(matrix, sheetName) {
          matrix.forEachInSheet(sheetName, function(cell, row, col) {
            if (cell) {
              if (cell.row !== row || cell.col !== col) {
                cell.row = row;
                cell.col = col;
                cell.address = colCache.n2l(col) + row;
              }
            }
          });
        } }, { key: "spliceRows", value: function spliceRows(sheetName, start, numDelete, numInsert) {
          var _this9 = this;
          _.each(this.matrixMap, function(matrix) {
            matrix.spliceRows(sheetName, start, numDelete, numInsert);
            _this9.normaliseMatrix(matrix, sheetName);
          });
        } }, { key: "spliceColumns", value: function spliceColumns(sheetName, start, numDelete, numInsert) {
          var _this10 = this;
          _.each(this.matrixMap, function(matrix) {
            matrix.spliceColumns(sheetName, start, numDelete, numInsert);
            _this10.normaliseMatrix(matrix, sheetName);
          });
        } }, { key: "model", get: function get() {
          var _this11 = this;
          return _.map(this.matrixMap, function(matrix, name) {
            return _this11.getRanges(name, matrix);
          }).filter(function(definedName) {
            return definedName.ranges.length;
          });
        }, set: function set(value) {
          var matrixMap = this.matrixMap = {};
          value.forEach(function(definedName) {
            var matrix = matrixMap[definedName.name] = new CellMatrix();
            definedName.ranges.forEach(function(rangeStr) {
              if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
                matrix.addCell(rangeStr);
              }
            });
          });
        } }]);
        return DefinedNames2;
      }();
      module2.exports = DefinedNames;
    }, { "../utils/cell-matrix": 18, "../utils/col-cache": 19, "../utils/under-dash": 26, "./range": 10 }], 7: [function(require2, module2, exports2) {
      module2.exports = { ValueType: { Null: 0, Merge: 1, Number: 2, String: 3, Date: 4, Hyperlink: 5, Formula: 6, SharedString: 7, RichText: 8, Boolean: 9, Error: 10 }, FormulaType: { None: 0, Master: 1, Shared: 2 }, RelationshipType: { None: 0, OfficeDocument: 1, Worksheet: 2, CalcChain: 3, SharedStrings: 4, Styles: 5, Theme: 6, Hyperlink: 7 }, DocumentType: { Xlsx: 1 }, ReadingOrder: { LeftToRight: 1, RightToLeft: 2 }, ErrorValue: { NotApplicable: "#N/A", Ref: "#REF!", Name: "#NAME?", DivZero: "#DIV/0!", Null: "#NULL!", Value: "#VALUE!", Num: "#NUM!" } };
    }, {}], 8: [function(require2, module2, exports2) {
      var colCache = require2("../utils/col-cache");
      var Anchor = require2("./anchor");
      var Image2 = /* @__PURE__ */ function() {
        function Image3(worksheet, model) {
          _classCallCheck(this, Image3);
          this.worksheet = worksheet;
          this.model = model;
        }
        _createClass(Image3, [{ key: "model", get: function get() {
          switch (this.type) {
            case "background":
              return { type: this.type, imageId: this.imageId };
            case "image":
              return { type: this.type, imageId: this.imageId, hyperlinks: this.range.hyperlinks, range: { tl: this.range.tl.model, br: this.range.br && this.range.br.model, ext: this.range.ext, editAs: this.range.editAs } };
            default:
              throw new Error("Invalid Image Type");
          }
        }, set: function set(_ref) {
          var type = _ref.type, imageId = _ref.imageId, range = _ref.range, hyperlinks = _ref.hyperlinks;
          this.type = type;
          this.imageId = imageId;
          if (type === "image") {
            if (typeof range === "string") {
              var decoded = colCache.decode(range);
              this.range = { tl: new Anchor(this.worksheet, { col: decoded.left, row: decoded.top }, -1), br: new Anchor(this.worksheet, { col: decoded.right, row: decoded.bottom }, 0), editAs: "oneCell" };
            } else {
              this.range = { tl: new Anchor(this.worksheet, range.tl, 0), br: range.br && new Anchor(this.worksheet, range.br, 0), ext: range.ext, editAs: range.editAs, hyperlinks: hyperlinks || range.hyperlinks };
            }
          }
        } }]);
        return Image3;
      }();
      module2.exports = Image2;
    }, { "../utils/col-cache": 19, "./anchor": 2 }], 9: [function(require2, module2, exports2) {
      var _ = require2("../utils/under-dash");
      var Note = /* @__PURE__ */ function() {
        function Note2(note) {
          _classCallCheck(this, Note2);
          this.note = note;
        }
        _createClass(Note2, [{ key: "model", get: function get() {
          var value = null;
          switch (typeof this.note) {
            case "string":
              value = { type: "note", note: { texts: [{ text: this.note }] } };
              break;
            default:
              value = { type: "note", note: this.note };
              break;
          }
          return _.deepMerge({}, Note2.DEFAULT_CONFIGS, value);
        }, set: function set(value) {
          var note = value.note;
          var texts = note.texts;
          if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
            this.note = texts[0].text;
          } else {
            this.note = note;
          }
        } }], [{ key: "fromModel", value: function fromModel(model) {
          var note = new Note2();
          note.model = model;
          return note;
        } }]);
        return Note2;
      }();
      Note.DEFAULT_CONFIGS = { note: { margins: { insetmode: "auto", inset: [0.13, 0.13, 0.25, 0.25] }, protection: { locked: "True", lockText: "True" }, editAs: "absolute" } };
      module2.exports = Note;
    }, { "../utils/under-dash": 26 }], 10: [function(require2, module2, exports2) {
      var colCache = require2("../utils/col-cache");
      var Range = /* @__PURE__ */ function() {
        function Range2() {
          _classCallCheck(this, Range2);
          this.decode(arguments);
        }
        _createClass(Range2, [{ key: "setTLBR", value: function setTLBR(t2, l, b, r, s) {
          if (arguments.length < 4) {
            var tl = colCache.decodeAddress(t2);
            var br = colCache.decodeAddress(l);
            this.model = { top: Math.min(tl.row, br.row), left: Math.min(tl.col, br.col), bottom: Math.max(tl.row, br.row), right: Math.max(tl.col, br.col), sheetName: b };
            this.setTLBR(tl.row, tl.col, br.row, br.col, s);
          } else {
            this.model = { top: Math.min(t2, b), left: Math.min(l, r), bottom: Math.max(t2, b), right: Math.max(l, r), sheetName: s };
          }
        } }, { key: "decode", value: function decode(argv) {
          switch (argv.length) {
            case 5:
              this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
              break;
            case 4:
              this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
              break;
            case 3:
              this.setTLBR(argv[0], argv[1], argv[2]);
              break;
            case 2:
              this.setTLBR(argv[0], argv[1]);
              break;
            case 1: {
              var value = argv[0];
              if (value instanceof Range2) {
                this.model = { top: value.model.top, left: value.model.left, bottom: value.model.bottom, right: value.model.right, sheetName: value.sheetName };
              } else if (value instanceof Array) {
                this.decode(value);
              } else if (value.top && value.left && value.bottom && value.right) {
                this.model = { top: value.top, left: value.left, bottom: value.bottom, right: value.right, sheetName: value.sheetName };
              } else {
                var tlbr = colCache.decodeEx(value);
                if (tlbr.top) {
                  this.model = { top: tlbr.top, left: tlbr.left, bottom: tlbr.bottom, right: tlbr.right, sheetName: tlbr.sheetName };
                } else {
                  this.model = { top: tlbr.row, left: tlbr.col, bottom: tlbr.row, right: tlbr.col, sheetName: tlbr.sheetName };
                }
              }
              break;
            }
            case 0:
              this.model = { top: 0, left: 0, bottom: 0, right: 0 };
              break;
            default:
              throw new Error("Invalid number of arguments to _getDimensions() - ".concat(argv.length));
          }
        } }, { key: "top", get: function get() {
          return this.model.top || 1;
        }, set: function set(value) {
          this.model.top = value;
        } }, { key: "left", get: function get() {
          return this.model.left || 1;
        }, set: function set(value) {
          this.model.left = value;
        } }, { key: "bottom", get: function get() {
          return this.model.bottom || 1;
        }, set: function set(value) {
          this.model.bottom = value;
        } }, { key: "right", get: function get() {
          return this.model.right || 1;
        }, set: function set(value) {
          this.model.right = value;
        } }, { key: "sheetName", get: function get() {
          return this.model.sheetName;
        }, set: function set(value) {
          this.model.sheetName = value;
        } }, { key: "_serialisedSheetName", get: function get() {
          var sheetName = this.model.sheetName;
          if (sheetName) {
            if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
              return "".concat(sheetName, "!");
            }
            return "'".concat(sheetName, "'!");
          }
          return "";
        } }, { key: "expand", value: function expand(top, left, bottom, right) {
          if (!this.model.top || top < this.top)
            this.top = top;
          if (!this.model.left || left < this.left)
            this.left = left;
          if (!this.model.bottom || bottom > this.bottom)
            this.bottom = bottom;
          if (!this.model.right || right > this.right)
            this.right = right;
        } }, { key: "expandRow", value: function expandRow(row) {
          if (row) {
            var dimensions = row.dimensions, number = row.number;
            if (dimensions) {
              this.expand(number, dimensions.min, number, dimensions.max);
            }
          }
        } }, { key: "expandToAddress", value: function expandToAddress(addressStr) {
          var address = colCache.decodeEx(addressStr);
          this.expand(address.row, address.col, address.row, address.col);
        } }, { key: "tl", get: function get() {
          return colCache.n2l(this.left) + this.top;
        } }, { key: "$t$l", get: function get() {
          return "$".concat(colCache.n2l(this.left), "$").concat(this.top);
        } }, { key: "br", get: function get() {
          return colCache.n2l(this.right) + this.bottom;
        } }, { key: "$b$r", get: function get() {
          return "$".concat(colCache.n2l(this.right), "$").concat(this.bottom);
        } }, { key: "range", get: function get() {
          return "".concat(this._serialisedSheetName + this.tl, ":").concat(this.br);
        } }, { key: "$range", get: function get() {
          return "".concat(this._serialisedSheetName + this.$t$l, ":").concat(this.$b$r);
        } }, { key: "shortRange", get: function get() {
          return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
        } }, { key: "$shortRange", get: function get() {
          return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
        } }, { key: "count", get: function get() {
          return (1 + this.bottom - this.top) * (1 + this.right - this.left);
        } }, { key: "toString", value: function toString2() {
          return this.range;
        } }, { key: "intersects", value: function intersects(other) {
          if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName)
            return false;
          if (other.bottom < this.top)
            return false;
          if (other.top > this.bottom)
            return false;
          if (other.right < this.left)
            return false;
          if (other.left > this.right)
            return false;
          return true;
        } }, { key: "contains", value: function contains(addressStr) {
          var address = colCache.decodeEx(addressStr);
          return this.containsEx(address);
        } }, { key: "containsEx", value: function containsEx(address) {
          if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName)
            return false;
          return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
        } }, { key: "forEachAddress", value: function forEachAddress(cb) {
          for (var col = this.left; col <= this.right; col++) {
            for (var row = this.top; row <= this.bottom; row++) {
              cb(colCache.encodeAddress(row, col), row, col);
            }
          }
        } }]);
        return Range2;
      }();
      module2.exports = Range;
    }, { "../utils/col-cache": 19 }], 11: [function(require2, module2, exports2) {
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var colCache = require2("../utils/col-cache");
      var Cell = require2("./cell");
      var Row = /* @__PURE__ */ function() {
        function Row2(worksheet, number) {
          _classCallCheck(this, Row2);
          this._worksheet = worksheet;
          this._number = number;
          this._cells = [];
          this.style = {};
          this.outlineLevel = 0;
        }
        _createClass(Row2, [{ key: "number", get: function get() {
          return this._number;
        } }, {
          key: "worksheet",
          get: function get() {
            return this._worksheet;
          }
          // Inform Streaming Writer that this row (and all rows before it) are complete
          // and ready to write. Has no effect on Worksheet document
        }, {
          key: "commit",
          value: function commit() {
            this._worksheet._commitRow(this);
          }
          // helps GC by breaking cyclic references
        }, { key: "destroy", value: function destroy() {
          delete this._worksheet;
          delete this._cells;
          delete this.style;
        } }, {
          key: "findCell",
          value: function findCell(colNumber) {
            return this._cells[colNumber - 1];
          }
          // given {address, row, col}, find or create new cell
        }, {
          key: "getCellEx",
          value: function getCellEx(address) {
            var cell = this._cells[address.col - 1];
            if (!cell) {
              var column = this._worksheet.getColumn(address.col);
              cell = new Cell(this, column, address.address);
              this._cells[address.col - 1] = cell;
            }
            return cell;
          }
          // get cell by key, letter or column number
        }, {
          key: "getCell",
          value: function getCell(col) {
            if (typeof col === "string") {
              var column = this._worksheet.getColumnKey(col);
              if (column) {
                col = column.number;
              } else {
                col = colCache.l2n(col);
              }
            }
            return this._cells[col - 1] || this.getCellEx({ address: colCache.encodeAddress(this._number, col), row: this._number, col });
          }
          // remove cell(s) and shift all higher cells down by count
        }, {
          key: "splice",
          value: function splice(start, count) {
            var nKeep = start + count;
            for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              inserts[_key - 2] = arguments[_key];
            }
            var nExpand = inserts.length - count;
            var nEnd = this._cells.length;
            var i;
            var cSrc;
            var cDst;
            if (nExpand < 0) {
              for (i = start + inserts.length; i <= nEnd; i++) {
                cDst = this._cells[i - 1];
                cSrc = this._cells[i - nExpand - 1];
                if (cSrc) {
                  cDst = this.getCell(i);
                  cDst.value = cSrc.value;
                  cDst.style = cSrc.style;
                  cDst._comment = cSrc._comment;
                } else if (cDst) {
                  cDst.value = null;
                  cDst.style = {};
                  cDst._comment = void 0;
                }
              }
            } else if (nExpand > 0) {
              for (i = nEnd; i >= nKeep; i--) {
                cSrc = this._cells[i - 1];
                if (cSrc) {
                  cDst = this.getCell(i + nExpand);
                  cDst.value = cSrc.value;
                  cDst.style = cSrc.style;
                  cDst._comment = cSrc._comment;
                } else {
                  this._cells[i + nExpand - 1] = void 0;
                }
              }
            }
            for (i = 0; i < inserts.length; i++) {
              cDst = this.getCell(start + i);
              cDst.value = inserts[i];
              cDst.style = {};
              cDst._comment = void 0;
            }
          }
          // Iterate over all non-null cells in this row
        }, {
          key: "eachCell",
          value: function eachCell(options, iteratee) {
            if (!iteratee) {
              iteratee = options;
              options = null;
            }
            if (options && options.includeEmpty) {
              var n = this._cells.length;
              for (var i = 1; i <= n; i++) {
                iteratee(this.getCell(i), i);
              }
            } else {
              this._cells.forEach(function(cell, index2) {
                if (cell && cell.type !== Enums.ValueType.Null) {
                  iteratee(cell, index2 + 1);
                }
              });
            }
          }
          // ===========================================================================
          // Page Breaks
        }, {
          key: "addPageBreak",
          value: function addPageBreak(lft, rght) {
            var ws = this._worksheet;
            var left = Math.max(0, lft - 1) || 0;
            var right = Math.max(0, rght - 1) || 16838;
            var pb = { id: this._number, max: right, man: 1 };
            if (left)
              pb.min = left;
            ws.rowBreaks.push(pb);
          }
          // return a sparse array of cell values
        }, {
          key: "values",
          get: function get() {
            var values = [];
            this._cells.forEach(function(cell) {
              if (cell && cell.type !== Enums.ValueType.Null) {
                values[cell.col] = cell.value;
              }
            });
            return values;
          },
          set: function set(value) {
            var _this12 = this;
            this._cells = [];
            if (!value)
              ;
            else if (value instanceof Array) {
              var offset = 0;
              if (value.hasOwnProperty("0")) {
                offset = 1;
              }
              value.forEach(function(item, index2) {
                if (item !== void 0) {
                  _this12.getCellEx({ address: colCache.encodeAddress(_this12._number, index2 + offset), row: _this12._number, col: index2 + offset }).value = item;
                }
              });
            } else {
              this._worksheet.eachColumnKey(function(column, key) {
                if (value[key] !== void 0) {
                  _this12.getCellEx({ address: colCache.encodeAddress(_this12._number, column.number), row: _this12._number, col: column.number }).value = value[key];
                }
              });
            }
          }
          // returns true if the row includes at least one cell with a value
        }, { key: "hasValues", get: function get() {
          return _.some(this._cells, function(cell) {
            return cell && cell.type !== Enums.ValueType.Null;
          });
        } }, { key: "cellCount", get: function get() {
          return this._cells.length;
        } }, {
          key: "actualCellCount",
          get: function get() {
            var count = 0;
            this.eachCell(function() {
              count++;
            });
            return count;
          }
          // get the min and max column number for the non-null cells in this row or null
        }, {
          key: "dimensions",
          get: function get() {
            var min = 0;
            var max = 0;
            this._cells.forEach(function(cell) {
              if (cell && cell.type !== Enums.ValueType.Null) {
                if (!min || min > cell.col) {
                  min = cell.col;
                }
                if (max < cell.col) {
                  max = cell.col;
                }
              }
            });
            return min > 0 ? { min, max } : null;
          }
          // =========================================================================
          // styles
        }, { key: "_applyStyle", value: function _applyStyle(name, value) {
          this.style[name] = value;
          this._cells.forEach(function(cell) {
            if (cell) {
              cell[name] = value;
            }
          });
          return value;
        } }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this._applyStyle("numFmt", value);
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this._applyStyle("font", value);
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this._applyStyle("alignment", value);
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this._applyStyle("protection", value);
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this._applyStyle("border", value);
        } }, { key: "fill", get: function get() {
          return this.style.fill;
        }, set: function set(value) {
          this._applyStyle("fill", value);
        } }, { key: "hidden", get: function get() {
          return !!this._hidden;
        }, set: function set(value) {
          this._hidden = value;
        } }, { key: "outlineLevel", get: function get() {
          return this._outlineLevel || 0;
        }, set: function set(value) {
          this._outlineLevel = value;
        } }, {
          key: "collapsed",
          get: function get() {
            return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
          }
          // =========================================================================
        }, { key: "model", get: function get() {
          var cells = [];
          var min = 0;
          var max = 0;
          this._cells.forEach(function(cell) {
            if (cell) {
              var cellModel = cell.model;
              if (cellModel) {
                if (!min || min > cell.col) {
                  min = cell.col;
                }
                if (max < cell.col) {
                  max = cell.col;
                }
                cells.push(cellModel);
              }
            }
          });
          return this.height || cells.length ? { cells, number: this.number, min, max, height: this.height, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel, collapsed: this.collapsed } : null;
        }, set: function set(value) {
          var _this13 = this;
          if (value.number !== this._number) {
            throw new Error("Invalid row number in model");
          }
          this._cells = [];
          var previousAddress;
          value.cells.forEach(function(cellModel) {
            switch (cellModel.type) {
              case Cell.Types.Merge:
                break;
              default: {
                var address;
                if (cellModel.address) {
                  address = colCache.decodeAddress(cellModel.address);
                } else if (previousAddress) {
                  var _previousAddress = previousAddress, row = _previousAddress.row;
                  var col = previousAddress.col + 1;
                  address = { row, col, address: colCache.encodeAddress(row, col), $col$row: "$".concat(colCache.n2l(col), "$").concat(row) };
                }
                previousAddress = address;
                var cell = _this13.getCellEx(address);
                cell.model = cellModel;
                break;
              }
            }
          });
          if (value.height) {
            this.height = value.height;
          } else {
            delete this.height;
          }
          this.hidden = value.hidden;
          this.outlineLevel = value.outlineLevel || 0;
          this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
        } }]);
        return Row2;
      }();
      module2.exports = Row;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 26, "./cell": 3, "./enums": 7 }], 12: [function(require2, module2, exports2) {
      var colCache = require2("../utils/col-cache");
      var Column = /* @__PURE__ */ function() {
        function Column2(table, column, index2) {
          _classCallCheck(this, Column2);
          this.table = table;
          this.column = column;
          this.index = index2;
        }
        _createClass(Column2, [{
          key: "_set",
          value: function _set(name, value) {
            this.table.cacheState();
            this.column[name] = value;
          }
          /* eslint-disable lines-between-class-members */
        }, { key: "name", get: function get() {
          return this.column.name;
        }, set: function set(value) {
          this._set("name", value);
        } }, { key: "filterButton", get: function get() {
          return this.column.filterButton;
        }, set: function set(value) {
          this.column.filterButton = value;
        } }, { key: "style", get: function get() {
          return this.column.style;
        }, set: function set(value) {
          this.column.style = value;
        } }, { key: "totalsRowLabel", get: function get() {
          return this.column.totalsRowLabel;
        }, set: function set(value) {
          this._set("totalsRowLabel", value);
        } }, { key: "totalsRowFunction", get: function get() {
          return this.column.totalsRowFunction;
        }, set: function set(value) {
          this._set("totalsRowFunction", value);
        } }, { key: "totalsRowResult", get: function get() {
          return this.column.totalsRowResult;
        }, set: function set(value) {
          this._set("totalsRowResult", value);
        } }, {
          key: "totalsRowFormula",
          get: function get() {
            return this.column.totalsRowFormula;
          },
          set: function set(value) {
            this._set("totalsRowFormula", value);
          }
          /* eslint-enable lines-between-class-members */
        }]);
        return Column2;
      }();
      var Table2 = /* @__PURE__ */ function() {
        function Table3(worksheet, table) {
          _classCallCheck(this, Table3);
          this.worksheet = worksheet;
          if (table) {
            this.table = table;
            this.validate();
            this.store();
          }
        }
        _createClass(Table3, [{ key: "getFormula", value: function getFormula(column) {
          switch (column.totalsRowFunction) {
            case "none":
              return null;
            case "average":
              return "SUBTOTAL(101,".concat(this.table.name, "[").concat(column.name, "])");
            case "countNums":
              return "SUBTOTAL(102,".concat(this.table.name, "[").concat(column.name, "])");
            case "count":
              return "SUBTOTAL(103,".concat(this.table.name, "[").concat(column.name, "])");
            case "max":
              return "SUBTOTAL(104,".concat(this.table.name, "[").concat(column.name, "])");
            case "min":
              return "SUBTOTAL(105,".concat(this.table.name, "[").concat(column.name, "])");
            case "stdDev":
              return "SUBTOTAL(106,".concat(this.table.name, "[").concat(column.name, "])");
            case "var":
              return "SUBTOTAL(107,".concat(this.table.name, "[").concat(column.name, "])");
            case "sum":
              return "SUBTOTAL(109,".concat(this.table.name, "[").concat(column.name, "])");
            case "custom":
              return column.totalsRowFormula;
            default:
              throw new Error("Invalid Totals Row Function: ".concat(column.totalsRowFunction));
          }
        } }, { key: "width", get: function get() {
          return this.table.columns.length;
        } }, { key: "height", get: function get() {
          return this.table.rows.length;
        } }, { key: "filterHeight", get: function get() {
          return this.height + (this.table.headerRow ? 1 : 0);
        } }, { key: "tableHeight", get: function get() {
          return this.filterHeight + (this.table.totalsRow ? 1 : 0);
        } }, { key: "validate", value: function validate() {
          var _this14 = this;
          var table = this.table;
          var assign = function assign2(o, name, dflt) {
            if (o[name] === void 0) {
              o[name] = dflt;
            }
          };
          assign(table, "headerRow", true);
          assign(table, "totalsRow", false);
          assign(table, "style", {});
          assign(table.style, "theme", "TableStyleMedium2");
          assign(table.style, "showFirstColumn", false);
          assign(table.style, "showLastColumn", false);
          assign(table.style, "showRowStripes", false);
          assign(table.style, "showColumnStripes", false);
          var assert = function assert2(test, message) {
            if (!test) {
              throw new Error(message);
            }
          };
          assert(table.ref, "Table must have ref");
          assert(table.columns, "Table must have column definitions");
          assert(table.rows, "Table must have row definitions");
          table.tl = colCache.decodeAddress(table.ref);
          var _table$tl = table.tl, row = _table$tl.row, col = _table$tl.col;
          assert(row > 0, "Table must be on valid row");
          assert(col > 0, "Table must be on valid col");
          var width2 = this.width, filterHeight = this.filterHeight, tableHeight = this.tableHeight;
          table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width2 - 1);
          table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width2 - 1);
          table.columns.forEach(function(column, i) {
            assert(column.name, "Column ".concat(i, " must have a name"));
            if (i === 0) {
              assign(column, "totalsRowLabel", "Total");
            } else {
              assign(column, "totalsRowFunction", "none");
              column.totalsRowFormula = _this14.getFormula(column);
            }
          });
        } }, { key: "store", value: function store() {
          var _this15 = this;
          var assignStyle = function assignStyle2(cell, style) {
            if (style) {
              Object.keys(style).forEach(function(key) {
                cell[key] = style[key];
              });
            }
          };
          var worksheet = this.worksheet, table = this.table;
          var _table$tl2 = table.tl, row = _table$tl2.row, col = _table$tl2.col;
          var count = 0;
          if (table.headerRow) {
            var r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var style = column.style, name = column.name;
              var cell = r.getCell(col + j);
              cell.value = name;
              assignStyle(cell, style);
            });
          }
          table.rows.forEach(function(data) {
            var r2 = worksheet.getRow(row + count++);
            data.forEach(function(value, j) {
              var cell = r2.getCell(col + j);
              cell.value = value;
              assignStyle(cell, table.columns[j].style);
            });
          });
          if (table.totalsRow) {
            var _r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = _r.getCell(col + j);
              if (j === 0) {
                cell.value = column.totalsRowLabel;
              } else {
                var formula = _this15.getFormula(column);
                if (formula) {
                  cell.value = { formula: column.totalsRowFormula, result: column.totalsRowResult };
                } else {
                  cell.value = null;
                }
              }
              assignStyle(cell, column.style);
            });
          }
        } }, { key: "load", value: function load(worksheet) {
          var _this16 = this;
          var table = this.table;
          var _table$tl3 = table.tl, row = _table$tl3.row, col = _table$tl3.col;
          var count = 0;
          if (table.headerRow) {
            var r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = r.getCell(col + j);
              cell.value = column.name;
            });
          }
          table.rows.forEach(function(data) {
            var r2 = worksheet.getRow(row + count++);
            data.forEach(function(value, j) {
              var cell = r2.getCell(col + j);
              cell.value = value;
            });
          });
          if (table.totalsRow) {
            var _r2 = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = _r2.getCell(col + j);
              if (j === 0) {
                cell.value = column.totalsRowLabel;
              } else {
                var formula = _this16.getFormula(column);
                if (formula) {
                  cell.value = { formula: column.totalsRowFormula, result: column.totalsRowResult };
                }
              }
            });
          }
        } }, {
          key: "model",
          get: function get() {
            return this.table;
          },
          set: function set(value) {
            this.table = value;
          }
          // ================================================================
          // TODO: Mutating methods
        }, { key: "cacheState", value: function cacheState() {
          if (!this._cache) {
            this._cache = { ref: this.ref, width: this.width, tableHeight: this.tableHeight };
          }
        } }, { key: "commit", value: function commit() {
          if (!this._cache) {
            return;
          }
          this.validate();
          var ref2 = colCache.decodeAddress(this._cache.ref);
          if (this.ref !== this._cache.ref) {
            for (var i = 0; i < this._cache.tableHeight; i++) {
              var row = this.worksheet.getRow(ref2.row + i);
              for (var j = 0; j < this._cache.width; j++) {
                var cell = row.getCell(ref2.col + j);
                cell.value = null;
              }
            }
          } else {
            for (var _i = this.tableHeight; _i < this._cache.tableHeight; _i++) {
              var _row = this.worksheet.getRow(ref2.row + _i);
              for (var _j = 0; _j < this._cache.width; _j++) {
                var _cell2 = _row.getCell(ref2.col + _j);
                _cell2.value = null;
              }
            }
            for (var _i2 = 0; _i2 < this.tableHeight; _i2++) {
              var _row2 = this.worksheet.getRow(ref2.row + _i2);
              for (var _j2 = this.width; _j2 < this._cache.width; _j2++) {
                var _cell22 = _row2.getCell(ref2.col + _j2);
                _cell22.value = null;
              }
            }
          }
          this.store();
        } }, { key: "addRow", value: function addRow(values, rowNumber) {
          this.cacheState();
          if (rowNumber === void 0) {
            this.table.rows.push(values);
          } else {
            this.table.rows.splice(rowNumber, 0, values);
          }
        } }, { key: "removeRows", value: function removeRows(rowIndex) {
          var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState();
          this.table.rows.splice(rowIndex, count);
        } }, { key: "getColumn", value: function getColumn(colIndex) {
          var column = this.table.columns[colIndex];
          return new Column(this, column, colIndex);
        } }, { key: "addColumn", value: function addColumn(column, values, colIndex) {
          this.cacheState();
          if (colIndex === void 0) {
            this.table.columns.push(column);
            this.table.rows.forEach(function(row, i) {
              row.push(values[i]);
            });
          } else {
            this.table.columns.splice(colIndex, 0, column);
            this.table.rows.forEach(function(row, i) {
              row.splice(colIndex, 0, values[i]);
            });
          }
        } }, { key: "removeColumns", value: function removeColumns(colIndex) {
          var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState();
          this.table.columns.splice(colIndex, count);
          this.table.rows.forEach(function(row) {
            row.splice(colIndex, count);
          });
        } }, {
          key: "_assign",
          value: function _assign(target, prop, value) {
            this.cacheState();
            target[prop] = value;
          }
          /* eslint-disable lines-between-class-members */
        }, { key: "ref", get: function get() {
          return this.table.ref;
        }, set: function set(value) {
          this._assign(this.table, "ref", value);
        } }, { key: "name", get: function get() {
          return this.table.name;
        }, set: function set(value) {
          this.table.name = value;
        } }, { key: "displayName", get: function get() {
          return this.table.displyName || this.table.name;
        } }, { key: "displayNamename", set: function set(value) {
          this.table.displayName = value;
        } }, { key: "headerRow", get: function get() {
          return this.table.headerRow;
        }, set: function set(value) {
          this._assign(this.table, "headerRow", value);
        } }, { key: "totalsRow", get: function get() {
          return this.table.totalsRow;
        }, set: function set(value) {
          this._assign(this.table, "totalsRow", value);
        } }, { key: "theme", get: function get() {
          return this.table.style.name;
        }, set: function set(value) {
          this.table.style.name = value;
        } }, { key: "showFirstColumn", get: function get() {
          return this.table.style.showFirstColumn;
        }, set: function set(value) {
          this.table.style.showFirstColumn = value;
        } }, { key: "showLastColumn", get: function get() {
          return this.table.style.showLastColumn;
        }, set: function set(value) {
          this.table.style.showLastColumn = value;
        } }, { key: "showRowStripes", get: function get() {
          return this.table.style.showRowStripes;
        }, set: function set(value) {
          this.table.style.showRowStripes = value;
        } }, {
          key: "showColumnStripes",
          get: function get() {
            return this.table.style.showColumnStripes;
          },
          set: function set(value) {
            this.table.style.showColumnStripes = value;
          }
          /* eslint-enable lines-between-class-members */
        }]);
        return Table3;
      }();
      module2.exports = Table2;
    }, { "../utils/col-cache": 19 }], 13: [function(require2, module2, exports2) {
      var Worksheet = require2("./worksheet");
      var DefinedNames = require2("./defined-names");
      var XLSX2 = require2("../xlsx/xlsx");
      var CSV = require2("../csv/csv");
      var Workbook = /* @__PURE__ */ function() {
        function Workbook2() {
          _classCallCheck(this, Workbook2);
          this.category = "";
          this.company = "";
          this.created = /* @__PURE__ */ new Date();
          this.description = "";
          this.keywords = "";
          this.manager = "";
          this.modified = this.created;
          this.properties = {};
          this.calcProperties = {};
          this._worksheets = [];
          this.subject = "";
          this.title = "";
          this.views = [];
          this.media = [];
          this._definedNames = new DefinedNames();
        }
        _createClass(Workbook2, [{ key: "xlsx", get: function get() {
          if (!this._xlsx)
            this._xlsx = new XLSX2(this);
          return this._xlsx;
        } }, { key: "csv", get: function get() {
          if (!this._csv)
            this._csv = new CSV(this);
          return this._csv;
        } }, { key: "nextId", get: function get() {
          for (var i = 1; i < this._worksheets.length; i++) {
            if (!this._worksheets[i]) {
              return i;
            }
          }
          return this._worksheets.length || 1;
        } }, { key: "addWorksheet", value: function addWorksheet(name, options) {
          var id = this.nextId;
          if (options) {
            if (typeof options === "string") {
              console.trace('tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }');
              options = { properties: { tabColor: { argb: options } } };
            } else if (options.argb || options.theme || options.indexed) {
              console.trace("tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }");
              options = { properties: { tabColor: options } };
            }
          }
          var lastOrderNo = this._worksheets.reduce(function(acc, ws) {
            return (ws && ws.orderNo) > acc ? ws.orderNo : acc;
          }, 0);
          var worksheetOptions = Object.assign({}, options, { id, name, orderNo: lastOrderNo + 1, workbook: this });
          var worksheet = new Worksheet(worksheetOptions);
          this._worksheets[id] = worksheet;
          return worksheet;
        } }, { key: "removeWorksheetEx", value: function removeWorksheetEx(worksheet) {
          delete this._worksheets[worksheet.id];
        } }, { key: "removeWorksheet", value: function removeWorksheet(id) {
          var worksheet = this.getWorksheet(id);
          if (worksheet) {
            worksheet.destroy();
          }
        } }, { key: "getWorksheet", value: function getWorksheet(id) {
          if (id === void 0) {
            return this._worksheets.find(Boolean);
          }
          if (typeof id === "number") {
            return this._worksheets[id];
          }
          if (typeof id === "string") {
            return this._worksheets.find(function(worksheet) {
              return worksheet && worksheet.name === id;
            });
          }
          return void 0;
        } }, { key: "worksheets", get: function get() {
          return this._worksheets.slice(1).sort(function(a, b) {
            return a.orderNo - b.orderNo;
          }).filter(Boolean);
        } }, { key: "eachSheet", value: function eachSheet(iteratee) {
          this.worksheets.forEach(function(sheet) {
            iteratee(sheet, sheet.id);
          });
        } }, { key: "definedNames", get: function get() {
          return this._definedNames;
        } }, { key: "clearThemes", value: function clearThemes() {
          this._themes = void 0;
        } }, { key: "addImage", value: function addImage(image) {
          var id = this.media.length;
          this.media.push(Object.assign({}, image, { type: "image" }));
          return id;
        } }, { key: "getImage", value: function getImage2(id) {
          return this.media[id];
        } }, { key: "model", get: function get() {
          return { creator: this.creator || "Unknown", lastModifiedBy: this.lastModifiedBy || "Unknown", lastPrinted: this.lastPrinted, created: this.created, modified: this.modified, properties: this.properties, worksheets: this.worksheets.map(function(worksheet) {
            return worksheet.model;
          }), sheets: this.worksheets.map(function(ws) {
            return ws.model;
          }).filter(Boolean), definedNames: this._definedNames.model, views: this.views, company: this.company, manager: this.manager, title: this.title, subject: this.subject, keywords: this.keywords, category: this.category, description: this.description, language: this.language, revision: this.revision, contentStatus: this.contentStatus, themes: this._themes, media: this.media, calcProperties: this.calcProperties };
        }, set: function set(value) {
          var _this17 = this;
          this.creator = value.creator;
          this.lastModifiedBy = value.lastModifiedBy;
          this.lastPrinted = value.lastPrinted;
          this.created = value.created;
          this.modified = value.modified;
          this.company = value.company;
          this.manager = value.manager;
          this.title = value.title;
          this.subject = value.subject;
          this.keywords = value.keywords;
          this.category = value.category;
          this.description = value.description;
          this.language = value.language;
          this.revision = value.revision;
          this.contentStatus = value.contentStatus;
          this.properties = value.properties;
          this.calcProperties = value.calcProperties;
          this._worksheets = [];
          value.worksheets.forEach(function(worksheetModel) {
            var id = worksheetModel.id, name = worksheetModel.name, state = worksheetModel.state;
            var orderNo = value.sheets && value.sheets.findIndex(function(ws) {
              return ws.id === id;
            });
            var worksheet = _this17._worksheets[id] = new Worksheet({ id, name, orderNo, state, workbook: _this17 });
            worksheet.model = worksheetModel;
          });
          this._definedNames.model = value.definedNames;
          this.views = value.views;
          this._themes = value.themes;
          this.media = value.media || [];
        } }]);
        return Workbook2;
      }();
      module2.exports = Workbook;
    }, { "../csv/csv": 1, "../xlsx/xlsx": 144, "./defined-names": 6, "./worksheet": 14 }], 14: [function(require2, module2, exports2) {
      var _ = require2("../utils/under-dash");
      var colCache = require2("../utils/col-cache");
      var Range = require2("./range");
      var Row = require2("./row");
      var Column = require2("./column");
      var Enums = require2("./enums");
      var Image2 = require2("./image");
      var Table2 = require2("./table");
      var DataValidations = require2("./data-validations");
      var Encryptor = require2("../utils/encryptor");
      var _require5 = require2("../utils/copy-style"), copyStyle = _require5.copyStyle;
      var Worksheet = /* @__PURE__ */ function() {
        function Worksheet2(options) {
          _classCallCheck(this, Worksheet2);
          options = options || {};
          this._workbook = options.workbook;
          this.id = options.id;
          this.orderNo = options.orderNo;
          this.name = options.name;
          this.state = options.state || "visible";
          this._rows = [];
          this._columns = null;
          this._keys = {};
          this._merges = {};
          this.rowBreaks = [];
          this.properties = Object.assign({}, { defaultRowHeight: 15, dyDescent: 55, outlineLevelCol: 0, outlineLevelRow: 0 }, options.properties);
          this.pageSetup = Object.assign({}, { margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }, orientation: "portrait", horizontalDpi: 4294967295, verticalDpi: 4294967295, fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale), pageOrder: "downThenOver", blackAndWhite: false, draft: false, cellComments: "None", errors: "displayed", scale: 100, fitToWidth: 1, fitToHeight: 1, paperSize: void 0, showRowColHeaders: false, showGridLines: false, firstPageNumber: void 0, horizontalCentered: false, verticalCentered: false, rowBreaks: null, colBreaks: null }, options.pageSetup);
          this.headerFooter = Object.assign({}, { differentFirst: false, differentOddEven: false, oddHeader: null, oddFooter: null, evenHeader: null, evenFooter: null, firstHeader: null, firstFooter: null }, options.headerFooter);
          this.dataValidations = new DataValidations();
          this.views = options.views || [];
          this.autoFilter = options.autoFilter || null;
          this._media = [];
          this.sheetProtection = null;
          this.tables = {};
          this.conditionalFormattings = [];
        }
        _createClass(Worksheet2, [{ key: "name", get: function get() {
          return this._name;
        }, set: function set(name) {
          if (name === void 0) {
            name = "sheet".concat(this.id);
          }
          if (this._name === name)
            return;
          if (typeof name !== "string") {
            throw new Error("The name has to be a string.");
          }
          if (name === "") {
            throw new Error("The name can't be empty.");
          }
          if (name === "History") {
            throw new Error('The name "History" is protected. Please use a different name.');
          }
          if (/[*?:/\\[\]]/.test(name)) {
            throw new Error("Worksheet name ".concat(name, " cannot include any of the following characters: * ? : \\ / [ ]"));
          }
          if (/(^')|('$)/.test(name)) {
            throw new Error("The first or last character of worksheet name cannot be a single quotation mark: ".concat(name));
          }
          if (name && name.length > 31) {
            console.warn("Worksheet name ".concat(name, " exceeds 31 chars. This will be truncated"));
            name = name.substring(0, 31);
          }
          if (this._workbook._worksheets.find(function(ws) {
            return ws && ws.name.toLowerCase() === name.toLowerCase();
          })) {
            throw new Error("Worksheet name already exists: ".concat(name));
          }
          this._name = name;
        } }, {
          key: "workbook",
          get: function get() {
            return this._workbook;
          }
          // when you're done with this worksheet, call this to remove from workbook
        }, {
          key: "destroy",
          value: function destroy() {
            this._workbook.removeWorksheetEx(this);
          }
          // Get the bounding range of the cells in this worksheet
        }, {
          key: "dimensions",
          get: function get() {
            var dimensions = new Range();
            this._rows.forEach(function(row) {
              if (row) {
                var rowDims = row.dimensions;
                if (rowDims) {
                  dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);
                }
              }
            });
            return dimensions;
          }
          // =========================================================================
          // Columns
          // get the current columns array.
        }, {
          key: "columns",
          get: function get() {
            return this._columns;
          },
          set: function set(value) {
            var _this18 = this;
            this._headerRowCount = value.reduce(function(pv, cv) {
              var headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
              return Math.max(pv, headerCount);
            }, 0);
            var count = 1;
            var columns = this._columns = [];
            value.forEach(function(defn) {
              var column = new Column(_this18, count++, false);
              columns.push(column);
              column.defn = defn;
            });
          }
        }, { key: "getColumnKey", value: function getColumnKey(key) {
          return this._keys[key];
        } }, { key: "setColumnKey", value: function setColumnKey(key, value) {
          this._keys[key] = value;
        } }, { key: "deleteColumnKey", value: function deleteColumnKey(key) {
          delete this._keys[key];
        } }, {
          key: "eachColumnKey",
          value: function eachColumnKey(f) {
            _.each(this._keys, f);
          }
          // get a single column by col number. If it doesn't exist, create it and any gaps before it
        }, { key: "getColumn", value: function getColumn(c) {
          if (typeof c === "string") {
            var col = this._keys[c];
            if (col)
              return col;
            c = colCache.l2n(c);
          }
          if (!this._columns) {
            this._columns = [];
          }
          if (c > this._columns.length) {
            var n = this._columns.length + 1;
            while (n <= c) {
              this._columns.push(new Column(this, n++));
            }
          }
          return this._columns[c - 1];
        } }, { key: "spliceColumns", value: function spliceColumns(start, count) {
          var _this19 = this;
          var rows = this._rows;
          var nRows = rows.length;
          for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            inserts[_key - 2] = arguments[_key];
          }
          if (inserts.length > 0) {
            var _loop = function _loop2(i2) {
              var rowArguments = [start, count];
              inserts.forEach(function(insert) {
                rowArguments.push(insert[i2] || null);
              });
              var row = _this19.getRow(i2 + 1);
              row.splice.apply(row, rowArguments);
            };
            for (var i = 0; i < nRows; i++) {
              _loop(i);
            }
          } else {
            this._rows.forEach(function(r) {
              if (r) {
                r.splice(start, count);
              }
            });
          }
          var nExpand = inserts.length - count;
          var nKeep = start + count;
          var nEnd = this._columns.length;
          if (nExpand < 0) {
            for (var _i3 = start + inserts.length; _i3 <= nEnd; _i3++) {
              this.getColumn(_i3).defn = this.getColumn(_i3 - nExpand).defn;
            }
          } else if (nExpand > 0) {
            for (var _i4 = nEnd; _i4 >= nKeep; _i4--) {
              this.getColumn(_i4 + nExpand).defn = this.getColumn(_i4).defn;
            }
          }
          for (var _i5 = start; _i5 < start + inserts.length; _i5++) {
            this.getColumn(_i5).defn = null;
          }
          this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
        } }, { key: "lastColumn", get: function get() {
          return this.getColumn(this.columnCount);
        } }, { key: "columnCount", get: function get() {
          var maxCount = 0;
          this.eachRow(function(row) {
            maxCount = Math.max(maxCount, row.cellCount);
          });
          return maxCount;
        } }, {
          key: "actualColumnCount",
          get: function get() {
            var counts = [];
            var count = 0;
            this.eachRow(function(row) {
              row.eachCell(function(_ref) {
                var col = _ref.col;
                if (!counts[col]) {
                  counts[col] = true;
                  count++;
                }
              });
            });
            return count;
          }
          // =========================================================================
          // Rows
        }, { key: "_commitRow", value: function _commitRow() {
        } }, { key: "_lastRowNumber", get: function get() {
          var rows = this._rows;
          var n = rows.length;
          while (n > 0 && rows[n - 1] === void 0) {
            n--;
          }
          return n;
        } }, { key: "_nextRow", get: function get() {
          return this._lastRowNumber + 1;
        } }, {
          key: "lastRow",
          get: function get() {
            if (this._rows.length) {
              return this._rows[this._rows.length - 1];
            }
            return void 0;
          }
          // find a row (if exists) by row number
        }, {
          key: "findRow",
          value: function findRow(r) {
            return this._rows[r - 1];
          }
          // find multiple rows (if exists) by row number
        }, { key: "findRows", value: function findRows(start, length) {
          return this._rows.slice(start - 1, start - 1 + length);
        } }, { key: "rowCount", get: function get() {
          return this._lastRowNumber;
        } }, {
          key: "actualRowCount",
          get: function get() {
            var count = 0;
            this.eachRow(function() {
              count++;
            });
            return count;
          }
          // get a row by row number.
        }, {
          key: "getRow",
          value: function getRow(r) {
            var row = this._rows[r - 1];
            if (!row) {
              row = this._rows[r - 1] = new Row(this, r);
            }
            return row;
          }
          // get multiple rows by row number.
        }, { key: "getRows", value: function getRows(start, length) {
          if (length < 1)
            return void 0;
          var rows = [];
          for (var i = start; i < start + length; i++) {
            rows.push(this.getRow(i));
          }
          return rows;
        } }, { key: "addRow", value: function addRow(value) {
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          var rowNo = this._nextRow;
          var row = this.getRow(rowNo);
          row.values = value;
          this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
          return row;
        } }, { key: "addRows", value: function addRows(value) {
          var _this20 = this;
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          var rows = [];
          value.forEach(function(row) {
            rows.push(_this20.addRow(row, style));
          });
          return rows;
        } }, { key: "insertRow", value: function insertRow(pos, value) {
          var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
          this.spliceRows(pos, 0, value);
          this._setStyleOption(pos, style);
          return this.getRow(pos);
        } }, {
          key: "insertRows",
          value: function insertRows(pos, values) {
            var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
            this.spliceRows.apply(this, [pos, 0].concat(_toConsumableArray(values)));
            if (style !== "n") {
              for (var i = 0; i < values.length; i++) {
                if (style[0] === "o" && this.findRow(values.length + pos + i) !== void 0) {
                  this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
                } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
                  this._copyStyle(pos - 1, pos + i, style[1] === "+");
                }
              }
            }
            return this.getRows(pos, values.length);
          }
          // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
        }, { key: "_setStyleOption", value: function _setStyleOption(pos) {
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          if (style[0] === "o" && this.findRow(pos + 1) !== void 0) {
            this._copyStyle(pos + 1, pos, style[1] === "+");
          } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
            this._copyStyle(pos - 1, pos, style[1] === "+");
          }
        } }, { key: "_copyStyle", value: function _copyStyle(src, dest) {
          var styleEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var rSrc = this.getRow(src);
          var rDst = this.getRow(dest);
          rDst.style = copyStyle(rSrc.style);
          rSrc.eachCell({ includeEmpty: styleEmpty }, function(cell, colNumber) {
            rDst.getCell(colNumber).style = copyStyle(cell.style);
          });
          rDst.height = rSrc.height;
        } }, { key: "duplicateRow", value: function duplicateRow(rowNum, count) {
          var _this21 = this;
          var insert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var rSrc = this._rows[rowNum - 1];
          var inserts = new Array(count).fill(rSrc.values);
          this.spliceRows.apply(this, [rowNum + 1, insert ? 0 : count].concat(_toConsumableArray(inserts)));
          var _loop2 = function _loop22() {
            var rDst = _this21._rows[rowNum + i];
            rDst.style = rSrc.style;
            rDst.height = rSrc.height;
            rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
              rDst.getCell(colNumber).style = cell.style;
            });
          };
          for (var i = 0; i < count; i++) {
            _loop2();
          }
        } }, {
          key: "spliceRows",
          value: function spliceRows(start, count) {
            var _this22 = this;
            var nKeep = start + count;
            for (var _len2 = arguments.length, inserts = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              inserts[_key2 - 2] = arguments[_key2];
            }
            var nInserts = inserts.length;
            var nExpand = nInserts - count;
            var nEnd = this._rows.length;
            var i;
            var rSrc;
            if (nExpand < 0) {
              if (start === nEnd) {
                this._rows[nEnd - 1] = void 0;
              }
              var _loop3 = function _loop32() {
                rSrc = _this22._rows[i - 1];
                if (rSrc) {
                  var rDst2 = _this22.getRow(i + nExpand);
                  rDst2.values = rSrc.values;
                  rDst2.style = rSrc.style;
                  rDst2.height = rSrc.height;
                  rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
                    rDst2.getCell(colNumber).style = cell.style;
                  });
                  _this22._rows[i - 1] = void 0;
                } else {
                  _this22._rows[i + nExpand - 1] = void 0;
                }
              };
              for (i = nKeep; i <= nEnd; i++) {
                _loop3();
              }
            } else if (nExpand > 0) {
              var _loop4 = function _loop42() {
                rSrc = _this22._rows[i - 1];
                if (rSrc) {
                  var rDst2 = _this22.getRow(i + nExpand);
                  rDst2.values = rSrc.values;
                  rDst2.style = rSrc.style;
                  rDst2.height = rSrc.height;
                  rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
                    rDst2.getCell(colNumber).style = cell.style;
                    if (cell._value.constructor.name === "MergeValue") {
                      var cellToBeMerged = _this22.getRow(cell._row._number + nInserts).getCell(colNumber);
                      var prevMaster = cell._value._master;
                      var newMaster = _this22.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
                      cellToBeMerged.merge(newMaster);
                    }
                  });
                } else {
                  _this22._rows[i + nExpand - 1] = void 0;
                }
              };
              for (i = nEnd; i >= nKeep; i--) {
                _loop4();
              }
            }
            for (i = 0; i < nInserts; i++) {
              var rDst = this.getRow(start + i);
              rDst.style = {};
              rDst.values = inserts[i];
            }
            this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
          }
          // iterate over every row in the worksheet, including maybe empty rows
        }, {
          key: "eachRow",
          value: function eachRow(options, iteratee) {
            if (!iteratee) {
              iteratee = options;
              options = void 0;
            }
            if (options && options.includeEmpty) {
              var n = this._rows.length;
              for (var i = 1; i <= n; i++) {
                iteratee(this.getRow(i), i);
              }
            } else {
              this._rows.forEach(function(row) {
                if (row && row.hasValues) {
                  iteratee(row, row.number);
                }
              });
            }
          }
          // return all rows as sparse array
        }, {
          key: "getSheetValues",
          value: function getSheetValues() {
            var rows = [];
            this._rows.forEach(function(row) {
              if (row) {
                rows[row.number] = row.values;
              }
            });
            return rows;
          }
          // =========================================================================
          // Cells
          // returns the cell at [r,c] or address given by r. If not found, return undefined
        }, {
          key: "findCell",
          value: function findCell(r, c) {
            var address = colCache.getAddress(r, c);
            var row = this._rows[address.row - 1];
            return row ? row.findCell(address.col) : void 0;
          }
          // return the cell at [r,c] or address given by r. If not found, create a new one.
        }, {
          key: "getCell",
          value: function getCell(r, c) {
            var address = colCache.getAddress(r, c);
            var row = this.getRow(address.row);
            return row.getCellEx(address);
          }
          // =========================================================================
          // Merge
          // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
        }, { key: "mergeCells", value: function mergeCells() {
          for (var _len3 = arguments.length, cells = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            cells[_key3] = arguments[_key3];
          }
          var dimensions = new Range(cells);
          this._mergeCellsInternal(dimensions);
        } }, { key: "mergeCellsWithoutStyle", value: function mergeCellsWithoutStyle() {
          for (var _len4 = arguments.length, cells = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            cells[_key4] = arguments[_key4];
          }
          var dimensions = new Range(cells);
          this._mergeCellsInternal(dimensions, true);
        } }, { key: "_mergeCellsInternal", value: function _mergeCellsInternal(dimensions, ignoreStyle) {
          _.each(this._merges, function(merge2) {
            if (merge2.intersects(dimensions)) {
              throw new Error("Cannot merge already merged cells");
            }
          });
          var master = this.getCell(dimensions.top, dimensions.left);
          for (var i = dimensions.top; i <= dimensions.bottom; i++) {
            for (var j = dimensions.left; j <= dimensions.right; j++) {
              if (i > dimensions.top || j > dimensions.left) {
                this.getCell(i, j).merge(master, ignoreStyle);
              }
            }
          }
          this._merges[master.address] = dimensions;
        } }, { key: "_unMergeMaster", value: function _unMergeMaster(master) {
          var merge2 = this._merges[master.address];
          if (merge2) {
            for (var i = merge2.top; i <= merge2.bottom; i++) {
              for (var j = merge2.left; j <= merge2.right; j++) {
                this.getCell(i, j).unmerge();
              }
            }
            delete this._merges[master.address];
          }
        } }, {
          key: "hasMerges",
          get: function get() {
            return _.some(this._merges, Boolean);
          }
          // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
          // un-merge the group. Note this function can affect multiple merges and merge-blocks are
          // atomic - either they're all merged or all un-merged.
        }, {
          key: "unMergeCells",
          value: function unMergeCells() {
            for (var _len5 = arguments.length, cells = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              cells[_key5] = arguments[_key5];
            }
            var dimensions = new Range(cells);
            for (var i = dimensions.top; i <= dimensions.bottom; i++) {
              for (var j = dimensions.left; j <= dimensions.right; j++) {
                var cell = this.findCell(i, j);
                if (cell) {
                  if (cell.type === Enums.ValueType.Merge) {
                    this._unMergeMaster(cell.master);
                  } else if (this._merges[cell.address]) {
                    this._unMergeMaster(cell);
                  }
                }
              }
            }
          }
          // ===========================================================================
          // Shared/Array Formula
        }, {
          key: "fillFormula",
          value: function fillFormula(range, formula, results) {
            var shareType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "shared";
            var decoded = colCache.decode(range);
            var top = decoded.top, left = decoded.left, bottom = decoded.bottom, right = decoded.right;
            var width2 = right - left + 1;
            var masterAddress = colCache.encodeAddress(top, left);
            var isShared = shareType === "shared";
            var getResult;
            if (typeof results === "function") {
              getResult = results;
            } else if (Array.isArray(results)) {
              if (Array.isArray(results[0])) {
                getResult = function getResult2(row, col) {
                  return results[row - top][col - left];
                };
              } else {
                getResult = function getResult2(row, col) {
                  return results[(row - top) * width2 + (col - left)];
                };
              }
            } else {
              getResult = function getResult2() {
                return void 0;
              };
            }
            var first = true;
            for (var r = top; r <= bottom; r++) {
              for (var c = left; c <= right; c++) {
                if (first) {
                  this.getCell(r, c).value = { shareType, formula, ref: range, result: getResult(r, c) };
                  first = false;
                } else {
                  this.getCell(r, c).value = isShared ? { sharedFormula: masterAddress, result: getResult(r, c) } : getResult(r, c);
                }
              }
            }
          }
          // =========================================================================
          // Images
        }, { key: "addImage", value: function addImage(imageId, range) {
          var model = { type: "image", imageId, range };
          this._media.push(new Image2(this, model));
        } }, { key: "getImages", value: function getImages() {
          return this._media.filter(function(m) {
            return m.type === "image";
          });
        } }, { key: "addBackgroundImage", value: function addBackgroundImage(imageId) {
          var model = { type: "background", imageId };
          this._media.push(new Image2(this, model));
        } }, {
          key: "getBackgroundImageId",
          value: function getBackgroundImageId() {
            var image = this._media.find(function(m) {
              return m.type === "background";
            });
            return image && image.imageId;
          }
          // =========================================================================
          // Worksheet Protection
        }, { key: "protect", value: function protect(password, options) {
          var _this23 = this;
          return new Promise(function(resolve) {
            _this23.sheetProtection = { sheet: true };
            if (options && "spinCount" in options) {
              options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
            }
            if (password) {
              _this23.sheetProtection.algorithmName = "SHA-512";
              _this23.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
              _this23.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
              _this23.sheetProtection.hashValue = Encryptor.convertPasswordToHash(password, "SHA512", _this23.sheetProtection.saltValue, _this23.sheetProtection.spinCount);
            }
            if (options) {
              _this23.sheetProtection = Object.assign(_this23.sheetProtection, options);
              if (!password && "spinCount" in options) {
                delete _this23.sheetProtection.spinCount;
              }
            }
            resolve();
          });
        } }, {
          key: "unprotect",
          value: function unprotect() {
            this.sheetProtection = null;
          }
          // =========================================================================
          // Tables
        }, { key: "addTable", value: function addTable(model) {
          var table = new Table2(this, model);
          this.tables[model.name] = table;
          return table;
        } }, { key: "getTable", value: function getTable(name) {
          return this.tables[name];
        } }, { key: "removeTable", value: function removeTable(name) {
          delete this.tables[name];
        } }, {
          key: "getTables",
          value: function getTables() {
            return Object.values(this.tables);
          }
          // ===========================================================================
          // Conditional Formatting
        }, { key: "addConditionalFormatting", value: function addConditionalFormatting(cf) {
          this.conditionalFormattings.push(cf);
        } }, {
          key: "removeConditionalFormatting",
          value: function removeConditionalFormatting(filter) {
            if (typeof filter === "number") {
              this.conditionalFormattings.splice(filter, 1);
            } else if (filter instanceof Function) {
              this.conditionalFormattings = this.conditionalFormattings.filter(filter);
            } else {
              this.conditionalFormattings = [];
            }
          }
          // ===========================================================================
          // Deprecated
        }, {
          key: "tabColor",
          get: function get() {
            console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
            return this.properties.tabColor;
          },
          set: function set(value) {
            console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
            this.properties.tabColor = value;
          }
          // ===========================================================================
          // Model
        }, { key: "model", get: function get() {
          var model = { id: this.id, name: this.name, dataValidations: this.dataValidations.model, properties: this.properties, state: this.state, pageSetup: this.pageSetup, headerFooter: this.headerFooter, rowBreaks: this.rowBreaks, views: this.views, autoFilter: this.autoFilter, media: this._media.map(function(medium) {
            return medium.model;
          }), sheetProtection: this.sheetProtection, tables: Object.values(this.tables).map(function(table) {
            return table.model;
          }), conditionalFormattings: this.conditionalFormattings };
          model.cols = Column.toModel(this.columns);
          var rows = model.rows = [];
          var dimensions = model.dimensions = new Range();
          this._rows.forEach(function(row) {
            var rowModel = row && row.model;
            if (rowModel) {
              dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
              rows.push(rowModel);
            }
          });
          model.merges = [];
          _.each(this._merges, function(merge2) {
            model.merges.push(merge2.range);
          });
          return model;
        }, set: function set(value) {
          var _this24 = this;
          this.name = value.name;
          this._columns = Column.fromModel(this, value.cols);
          this._parseRows(value);
          this._parseMergeCells(value);
          this.dataValidations = new DataValidations(value.dataValidations);
          this.properties = value.properties;
          this.pageSetup = value.pageSetup;
          this.headerFooter = value.headerFooter;
          this.views = value.views;
          this.autoFilter = value.autoFilter;
          this._media = value.media.map(function(medium) {
            return new Image2(_this24, medium);
          });
          this.sheetProtection = value.sheetProtection;
          this.tables = value.tables.reduce(function(tables, table) {
            var t2 = new Table2();
            t2.model = table;
            tables[table.name] = t2;
            return tables;
          }, {});
          this.conditionalFormattings = value.conditionalFormattings;
        } }, { key: "_parseRows", value: function _parseRows(model) {
          var _this25 = this;
          this._rows = [];
          model.rows.forEach(function(rowModel) {
            var row = new Row(_this25, rowModel.number);
            _this25._rows[row.number - 1] = row;
            row.model = rowModel;
          });
        } }, { key: "_parseMergeCells", value: function _parseMergeCells(model) {
          var _this26 = this;
          _.each(model.mergeCells, function(merge2) {
            _this26.mergeCellsWithoutStyle(merge2);
          });
        } }]);
        return Worksheet2;
      }();
      module2.exports = Worksheet;
    }, { "../utils/col-cache": 19, "../utils/copy-style": 20, "../utils/encryptor": 21, "../utils/under-dash": 26, "./column": 4, "./data-validations": 5, "./enums": 7, "./image": 8, "./range": 10, "./row": 11, "./table": 12 }], 15: [function(require2, module2, exports2) {
      require2("core-js/modules/es.promise");
      require2("core-js/modules/es.promise.finally");
      require2("core-js/modules/es.object.assign");
      require2("core-js/modules/es.object.keys");
      require2("core-js/modules/es.object.values");
      require2("core-js/modules/es.symbol");
      require2("core-js/modules/es.symbol.async-iterator");
      require2("core-js/modules/es.array.iterator");
      require2("core-js/modules/es.array.includes");
      require2("core-js/modules/es.array.find-index");
      require2("core-js/modules/es.array.find");
      require2("core-js/modules/es.string.from-code-point");
      require2("core-js/modules/es.string.includes");
      require2("core-js/modules/es.number.is-nan");
      require2("regenerator-runtime/runtime");
      var ExcelJS = { Workbook: require2("./doc/workbook") };
      var Enums = require2("./doc/enums");
      Object.keys(Enums).forEach(function(key) {
        ExcelJS[key] = Enums[key];
      });
      module2.exports = ExcelJS;
    }, { "./doc/enums": 7, "./doc/workbook": 13, "core-js/modules/es.array.find": 359, "core-js/modules/es.array.find-index": 358, "core-js/modules/es.array.includes": 360, "core-js/modules/es.array.iterator": 361, "core-js/modules/es.number.is-nan": 363, "core-js/modules/es.object.assign": 364, "core-js/modules/es.object.keys": 366, "core-js/modules/es.object.values": 367, "core-js/modules/es.promise": 372, "core-js/modules/es.promise.finally": 371, "core-js/modules/es.string.from-code-point": 376, "core-js/modules/es.string.includes": 377, "core-js/modules/es.symbol": 381, "core-js/modules/es.symbol.async-iterator": 378, "regenerator-runtime/runtime": 492 }], 16: [function(require2, module2, exports2) {
      var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      function bufferToString(chunk) {
        if (typeof chunk === "string") {
          return chunk;
        }
        if (textDecoder) {
          return textDecoder.decode(chunk);
        }
        return chunk.toString();
      }
      exports2.bufferToString = bufferToString;
    }, {}], 17: [function(require2, module2, exports2) {
      var textEncoder = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
      var _require6 = require2("buffer"), Buffer2 = _require6.Buffer;
      function stringToBuffer(str) {
        if (typeof str !== "string") {
          return str;
        }
        if (textEncoder) {
          return Buffer2.from(textEncoder.encode(str).buffer);
        }
        return Buffer2.from(str);
      }
      exports2.stringToBuffer = stringToBuffer;
    }, { "buffer": 220 }], 18: [function(require2, module2, exports2) {
      var _ = require2("./under-dash");
      var colCache = require2("./col-cache");
      var CellMatrix = /* @__PURE__ */ function() {
        function CellMatrix2(template) {
          _classCallCheck(this, CellMatrix2);
          this.template = template;
          this.sheets = {};
        }
        _createClass(CellMatrix2, [{ key: "addCell", value: function addCell(addressStr) {
          this.addCellEx(colCache.decodeEx(addressStr));
        } }, { key: "getCell", value: function getCell(addressStr) {
          return this.findCellEx(colCache.decodeEx(addressStr), true);
        } }, { key: "findCell", value: function findCell(addressStr) {
          return this.findCellEx(colCache.decodeEx(addressStr), false);
        } }, { key: "findCellAt", value: function findCellAt(sheetName, rowNumber, colNumber) {
          var sheet = this.sheets[sheetName];
          var row = sheet && sheet[rowNumber];
          return row && row[colNumber];
        } }, { key: "addCellEx", value: function addCellEx(address) {
          if (address.top) {
            for (var row = address.top; row <= address.bottom; row++) {
              for (var col = address.left; col <= address.right; col++) {
                this.getCellAt(address.sheetName, row, col);
              }
            }
          } else {
            this.findCellEx(address, true);
          }
        } }, { key: "getCellEx", value: function getCellEx(address) {
          return this.findCellEx(address, true);
        } }, { key: "findCellEx", value: function findCellEx(address, create) {
          var sheet = this.findSheet(address, create);
          var row = this.findSheetRow(sheet, address, create);
          return this.findRowCell(row, address, create);
        } }, { key: "getCellAt", value: function getCellAt(sheetName, rowNumber, colNumber) {
          var sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
          var row = sheet[rowNumber] || (sheet[rowNumber] = []);
          var cell = row[colNumber] || (row[colNumber] = { sheetName, address: colCache.n2l(colNumber) + rowNumber, row: rowNumber, col: colNumber });
          return cell;
        } }, { key: "removeCellEx", value: function removeCellEx(address) {
          var sheet = this.findSheet(address);
          if (!sheet) {
            return;
          }
          var row = this.findSheetRow(sheet, address);
          if (!row) {
            return;
          }
          delete row[address.col];
        } }, { key: "forEachInSheet", value: function forEachInSheet(sheetName, callback) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            sheet.forEach(function(row, rowNumber) {
              if (row) {
                row.forEach(function(cell, colNumber) {
                  if (cell) {
                    callback(cell, rowNumber, colNumber);
                  }
                });
              }
            });
          }
        } }, { key: "forEach", value: function forEach(callback) {
          var _this27 = this;
          _.each(this.sheets, function(sheet, sheetName) {
            _this27.forEachInSheet(sheetName, callback);
          });
        } }, { key: "map", value: function map(callback) {
          var results = [];
          this.forEach(function(cell) {
            results.push(callback(cell));
          });
          return results;
        } }, { key: "findSheet", value: function findSheet(address, create) {
          var name = address.sheetName;
          if (this.sheets[name]) {
            return this.sheets[name];
          }
          if (create) {
            return this.sheets[name] = [];
          }
          return void 0;
        } }, { key: "findSheetRow", value: function findSheetRow(sheet, address, create) {
          var row = address.row;
          if (sheet && sheet[row]) {
            return sheet[row];
          }
          if (create) {
            return sheet[row] = [];
          }
          return void 0;
        } }, { key: "findRowCell", value: function findRowCell(row, address, create) {
          var col = address.col;
          if (row && row[col]) {
            return row[col];
          }
          if (create) {
            return row[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
          }
          return void 0;
        } }, { key: "spliceRows", value: function spliceRows(sheetName, start, numDelete, numInsert) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            var inserts = [];
            for (var i = 0; i < numInsert; i++) {
              inserts.push([]);
            }
            sheet.splice.apply(sheet, [start, numDelete].concat(inserts));
          }
        } }, { key: "spliceColumns", value: function spliceColumns(sheetName, start, numDelete, numInsert) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            var inserts = [];
            for (var i = 0; i < numInsert; i++) {
              inserts.push(null);
            }
            _.each(sheet, function(row) {
              row.splice.apply(row, [start, numDelete].concat(inserts));
            });
          }
        } }]);
        return CellMatrix2;
      }();
      module2.exports = CellMatrix;
    }, { "./col-cache": 19, "./under-dash": 26 }], 19: [function(require2, module2, exports2) {
      var addressRegex = /^[A-Z]+\d+$/;
      var colCache = {
        _dictionary: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
        _l2nFill: 0,
        _l2n: {},
        _n2l: [],
        _level: function _level(n) {
          if (n <= 26) {
            return 1;
          }
          if (n <= 26 * 26) {
            return 2;
          }
          return 3;
        },
        _fill: function _fill(level) {
          var c;
          var v;
          var l1;
          var l2;
          var l3;
          var n = 1;
          if (level >= 4) {
            throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
          }
          if (this._l2nFill < 1 && level >= 1) {
            while (n <= 26) {
              c = this._dictionary[n - 1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 1;
          }
          if (this._l2nFill < 2 && level >= 2) {
            n = 27;
            while (n <= 26 + 26 * 26) {
              v = n - (26 + 1);
              l1 = v % 26;
              l2 = Math.floor(v / 26);
              c = this._dictionary[l2] + this._dictionary[l1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 2;
          }
          if (this._l2nFill < 3 && level >= 3) {
            n = 26 + 26 * 26 + 1;
            while (n <= 16384) {
              v = n - (26 * 26 + 26 + 1);
              l1 = v % 26;
              l2 = Math.floor(v / 26) % 26;
              l3 = Math.floor(v / (26 * 26));
              c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 3;
          }
        },
        l2n: function l2n(l) {
          if (!this._l2n[l]) {
            this._fill(l.length);
          }
          if (!this._l2n[l]) {
            throw new Error("Out of bounds. Invalid column letter: ".concat(l));
          }
          return this._l2n[l];
        },
        n2l: function n2l(n) {
          if (n < 1 || n > 16384) {
            throw new Error("".concat(n, " is out of bounds. Excel supports columns from 1 to 16384"));
          }
          if (!this._n2l[n]) {
            this._fill(this._level(n));
          }
          return this._n2l[n];
        },
        // =========================================================================
        // Address processing
        _hash: {},
        // check if value looks like an address
        validateAddress: function validateAddress(value) {
          if (!addressRegex.test(value)) {
            throw new Error("Invalid Address: ".concat(value));
          }
          return true;
        },
        // convert address string into structure
        decodeAddress: function decodeAddress(value) {
          var addr = value.length < 5 && this._hash[value];
          if (addr) {
            return addr;
          }
          var hasCol = false;
          var col = "";
          var colNumber = 0;
          var hasRow = false;
          var row = "";
          var rowNumber = 0;
          for (var i = 0, char; i < value.length; i++) {
            char = value.charCodeAt(i);
            if (!hasRow && char >= 65 && char <= 90) {
              hasCol = true;
              col += value[i];
              colNumber = colNumber * 26 + char - 64;
            } else if (char >= 48 && char <= 57) {
              hasRow = true;
              row += value[i];
              rowNumber = rowNumber * 10 + char - 48;
            } else if (hasRow && hasCol && char !== 36) {
              break;
            }
          }
          if (!hasCol) {
            colNumber = void 0;
          } else if (colNumber > 16384) {
            throw new Error("Out of bounds. Invalid column letter: ".concat(col));
          }
          if (!hasRow) {
            rowNumber = void 0;
          }
          value = col + row;
          var address = { address: value, col: colNumber, row: rowNumber, $col$row: "$".concat(col, "$").concat(row) };
          if (colNumber <= 100 && rowNumber <= 100) {
            this._hash[value] = address;
            this._hash[address.$col$row] = address;
          }
          return address;
        },
        // convert r,c into structure (if only 1 arg, assume r is address string)
        getAddress: function getAddress(r, c) {
          if (c) {
            var address = this.n2l(c) + r;
            return this.decodeAddress(address);
          }
          return this.decodeAddress(r);
        },
        // convert [address], [tl:br] into address structures
        decode: function decode(value) {
          var parts = value.split(":");
          if (parts.length === 2) {
            var tl = this.decodeAddress(parts[0]);
            var br = this.decodeAddress(parts[1]);
            var result = { top: Math.min(tl.row, br.row), left: Math.min(tl.col, br.col), bottom: Math.max(tl.row, br.row), right: Math.max(tl.col, br.col) };
            result.tl = this.n2l(result.left) + result.top;
            result.br = this.n2l(result.right) + result.bottom;
            result.dimensions = "".concat(result.tl, ":").concat(result.br);
            return result;
          }
          return this.decodeAddress(value);
        },
        // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
        decodeEx: function decodeEx(value) {
          var groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
          var sheetName = groups[1] || groups[2];
          var reference = groups[3];
          var parts = reference.split(":");
          if (parts.length > 1) {
            var tl = this.decodeAddress(parts[0]);
            var br = this.decodeAddress(parts[1]);
            var top = Math.min(tl.row, br.row);
            var left = Math.min(tl.col, br.col);
            var bottom = Math.max(tl.row, br.row);
            var right = Math.max(tl.col, br.col);
            tl = this.n2l(left) + top;
            br = this.n2l(right) + bottom;
            return { top, left, bottom, right, sheetName, tl: { address: tl, col: left, row: top, $col$row: "$".concat(this.n2l(left), "$").concat(top), sheetName }, br: { address: br, col: right, row: bottom, $col$row: "$".concat(this.n2l(right), "$").concat(bottom), sheetName }, dimensions: "".concat(tl, ":").concat(br) };
          }
          if (reference.startsWith("#")) {
            return sheetName ? { sheetName, error: reference } : { error: reference };
          }
          var address = this.decodeAddress(reference);
          return sheetName ? _objectSpread2({ sheetName }, address) : address;
        },
        // convert row,col into address string
        encodeAddress: function encodeAddress(row, col) {
          return colCache.n2l(col) + row;
        },
        // convert row,col into string address or t,l,b,r into range
        encode: function encode() {
          switch (arguments.length) {
            case 2:
              return colCache.encodeAddress(arguments[0], arguments[1]);
            case 4:
              return "".concat(colCache.encodeAddress(arguments[0], arguments[1]), ":").concat(colCache.encodeAddress(arguments[2], arguments[3]));
            default:
              throw new Error("Can only encode with 2 or 4 arguments");
          }
        },
        // return true if address is contained within range
        inRange: function inRange(range, address) {
          var _range = _slicedToArray(range, 5), left = _range[0], top = _range[1], right = _range[3], bottom = _range[4];
          var _address = _slicedToArray(address, 2), col = _address[0], row = _address[1];
          return col >= left && col <= right && row >= top && row <= bottom;
        }
      };
      module2.exports = colCache;
    }, {}], 20: [function(require2, module2, exports2) {
      var oneDepthCopy = function oneDepthCopy2(obj, nestKeys) {
        return _objectSpread2(_objectSpread2({}, obj), nestKeys.reduce(function(memo, key) {
          if (obj[key])
            memo[key] = _objectSpread2({}, obj[key]);
          return memo;
        }, {}));
      };
      var setIfExists = function setIfExists2(src, dst, key) {
        var nestKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
        if (src[key])
          dst[key] = oneDepthCopy(src[key], nestKeys);
      };
      var isEmptyObj = function isEmptyObj2(obj) {
        return Object.keys(obj).length === 0;
      };
      var copyStyle = function copyStyle2(style) {
        if (!style)
          return style;
        if (isEmptyObj(style))
          return {};
        var copied = _objectSpread2({}, style);
        setIfExists(style, copied, "font", ["color"]);
        setIfExists(style, copied, "alignment");
        setIfExists(style, copied, "protection");
        if (style.border) {
          setIfExists(style, copied, "border");
          setIfExists(style.border, copied.border, "top", ["color"]);
          setIfExists(style.border, copied.border, "left", ["color"]);
          setIfExists(style.border, copied.border, "bottom", ["color"]);
          setIfExists(style.border, copied.border, "right", ["color"]);
          setIfExists(style.border, copied.border, "diagonal", ["color"]);
        }
        if (style.fill) {
          setIfExists(style, copied, "fill", ["fgColor", "bgColor", "center"]);
          if (style.fill.stops) {
            copied.fill.stops = style.fill.stops.map(function(s) {
              return oneDepthCopy(s, ["color"]);
            });
          }
        }
        return copied;
      };
      exports2.copyStyle = copyStyle;
    }, {}], 21: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var crypto2 = require2("crypto");
          var Encryptor = {
            /**
            * Calculate a hash of the concatenated buffers with the given algorithm.
            * @param {string} algorithm - The hash algorithm.
            * @returns {Buffer} The hash
            */
            hash: function hash(algorithm) {
              var hash2 = crypto2.createHash(algorithm);
              for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                buffers[_key - 1] = arguments[_key];
              }
              hash2.update(Buffer2.concat(buffers));
              return hash2.digest();
            },
            /**
            * Convert a password into an encryption key
            * @param {string} password - The password
            * @param {string} hashAlgorithm - The hash algoritm
            * @param {string} saltValue - The salt value
            * @param {number} spinCount - The spin count
            * @param {number} keyBits - The length of the key in bits
            * @param {Buffer} blockKey - The block key
            * @returns {Buffer} The encryption key
            */
            convertPasswordToHash: function convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
              hashAlgorithm = hashAlgorithm.toLowerCase();
              var hashes = crypto2.getHashes();
              if (hashes.indexOf(hashAlgorithm) < 0) {
                throw new Error("Hash algorithm '".concat(hashAlgorithm, "' not supported!"));
              }
              var passwordBuffer = Buffer2.from(password, "utf16le");
              var key = this.hash(hashAlgorithm, Buffer2.from(saltValue, "base64"), passwordBuffer);
              for (var i = 0; i < spinCount; i++) {
                var iterator = Buffer2.alloc(4);
                iterator.writeUInt32LE(i, 0);
                key = this.hash(hashAlgorithm, key, iterator);
              }
              return key.toString("base64");
            },
            /**
            * Generates cryptographically strong pseudo-random data.
            * @param size The size argument is a number indicating the number of bytes to generate.
            */
            randomBytes: function randomBytes(size) {
              return crypto2.randomBytes(size);
            }
          };
          module2.exports = Encryptor;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 220, "crypto": 390 }], 22: [function(require2, module2, exports2) {
      var _require7 = require2("saxes"), SaxesParser = _require7.SaxesParser;
      var _require8 = require2("readable-stream"), PassThrough = _require8.PassThrough;
      var _require9 = require2("./browser-buffer-decode"), bufferToString = _require9.bufferToString;
      module2.exports = /* @__PURE__ */ function() {
        var _ref2 = _wrapAsyncGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee3(iterable) {
          var saxesParser, error, events, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1)
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
                    iterable = iterable.pipe(new PassThrough());
                  }
                  saxesParser = new SaxesParser();
                  saxesParser.on("error", function(err) {
                    error = err;
                  });
                  events = [];
                  saxesParser.on("opentag", function(value) {
                    return events.push({ eventType: "opentag", value });
                  });
                  saxesParser.on("text", function(value) {
                    return events.push({ eventType: "text", value });
                  });
                  saxesParser.on("closetag", function(value) {
                    return events.push({ eventType: "closetag", value });
                  });
                  _iteratorAbruptCompletion = false;
                  _didIteratorError = false;
                  _context3.prev = 9;
                  _iterator = _asyncIterator(iterable);
                case 11:
                  _context3.next = 13;
                  return _awaitAsyncGenerator(_iterator.next());
                case 13:
                  if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {
                    _context3.next = 24;
                    break;
                  }
                  chunk = _step.value;
                  saxesParser.write(bufferToString(chunk));
                  if (!error) {
                    _context3.next = 18;
                    break;
                  }
                  throw error;
                case 18:
                  _context3.next = 20;
                  return events;
                case 20:
                  events = [];
                case 21:
                  _iteratorAbruptCompletion = false;
                  _context3.next = 11;
                  break;
                case 24:
                  _context3.next = 30;
                  break;
                case 26:
                  _context3.prev = 26;
                  _context3.t0 = _context3["catch"](9);
                  _didIteratorError = true;
                  _iteratorError = _context3.t0;
                case 30:
                  _context3.prev = 30;
                  _context3.prev = 31;
                  if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                    _context3.next = 35;
                    break;
                  }
                  _context3.next = 35;
                  return _awaitAsyncGenerator(_iterator.return());
                case 35:
                  _context3.prev = 35;
                  if (!_didIteratorError) {
                    _context3.next = 38;
                    break;
                  }
                  throw _iteratorError;
                case 38:
                  return _context3.finish(35);
                case 39:
                  return _context3.finish(30);
                case 40:
                case "end":
                  return _context3.stop();
              }
          }, _callee3, null, [[9, 26, 30, 40], [31, , 35, 39]]);
        }));
        return function(_x) {
          return _ref2.apply(this, arguments);
        };
      }();
    }, { "./browser-buffer-decode": 16, "readable-stream": 491, "saxes": 496 }], 23: [function(require2, module2, exports2) {
      var colCache = require2("./col-cache");
      var replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
      var CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
      function slideFormula(formula, fromCell, toCell) {
        var offset = colCache.decode(fromCell);
        var to = colCache.decode(toCell);
        return formula.replace(replacementCandidateRx, function(refMatch, sheet, sheetMaybe, addrPart, trailingParen) {
          if (trailingParen) {
            return refMatch;
          }
          var match = CRrx.exec(addrPart);
          if (match) {
            var colDollar = match[1];
            var colStr = match[2].toUpperCase();
            var rowDollar = match[3];
            var rowStr = match[4];
            if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
              return refMatch;
            }
            var col = colCache.l2n(colStr);
            var row = parseInt(rowStr, 10);
            if (!colDollar) {
              col += to.col - offset.col;
            }
            if (!rowDollar) {
              row += to.row - offset.row;
            }
            var res = (sheet || "") + (colDollar || "") + colCache.n2l(col) + (rowDollar || "") + row;
            return res;
          }
          return refMatch;
        });
      }
      module2.exports = { slideFormula };
    }, { "./col-cache": 19 }], 24: [function(require2, module2, exports2) {
      (function(process2, Buffer2) {
        (function() {
          var Stream = require2("readable-stream");
          var utils = require2("./utils");
          var StringBuf = require2("./string-buf");
          var StringChunk = /* @__PURE__ */ function() {
            function StringChunk2(data, encoding) {
              _classCallCheck(this, StringChunk2);
              this._data = data;
              this._encoding = encoding;
            }
            _createClass(StringChunk2, [{
              key: "length",
              get: function get() {
                return this.toBuffer().length;
              }
              // copy to target buffer
            }, { key: "copy", value: function copy2(target, targetOffset, offset, length) {
              return this.toBuffer().copy(target, targetOffset, offset, length);
            } }, { key: "toBuffer", value: function toBuffer() {
              if (!this._buffer) {
                this._buffer = Buffer2.from(this._data, this._encoding);
              }
              return this._buffer;
            } }]);
            return StringChunk2;
          }();
          var StringBufChunk = /* @__PURE__ */ function() {
            function StringBufChunk2(data) {
              _classCallCheck(this, StringBufChunk2);
              this._data = data;
            }
            _createClass(StringBufChunk2, [{
              key: "length",
              get: function get() {
                return this._data.length;
              }
              // copy to target buffer
            }, { key: "copy", value: function copy2(target, targetOffset, offset, length) {
              return this._data._buf.copy(target, targetOffset, offset, length);
            } }, { key: "toBuffer", value: function toBuffer() {
              return this._data.toBuffer();
            } }]);
            return StringBufChunk2;
          }();
          var BufferChunk = /* @__PURE__ */ function() {
            function BufferChunk2(data) {
              _classCallCheck(this, BufferChunk2);
              this._data = data;
            }
            _createClass(BufferChunk2, [{
              key: "length",
              get: function get() {
                return this._data.length;
              }
              // copy to target buffer
            }, { key: "copy", value: function copy2(target, targetOffset, offset, length) {
              this._data.copy(target, targetOffset, offset, length);
            } }, { key: "toBuffer", value: function toBuffer() {
              return this._data;
            } }]);
            return BufferChunk2;
          }();
          var ReadWriteBuf = /* @__PURE__ */ function() {
            function ReadWriteBuf2(size) {
              _classCallCheck(this, ReadWriteBuf2);
              this.size = size;
              this.buffer = Buffer2.alloc(size);
              this.iRead = 0;
              this.iWrite = 0;
            }
            _createClass(ReadWriteBuf2, [{ key: "toBuffer", value: function toBuffer() {
              if (this.iRead === 0 && this.iWrite === this.size) {
                return this.buffer;
              }
              var buf = Buffer2.alloc(this.iWrite - this.iRead);
              this.buffer.copy(buf, 0, this.iRead, this.iWrite);
              return buf;
            } }, { key: "length", get: function get() {
              return this.iWrite - this.iRead;
            } }, { key: "eod", get: function get() {
              return this.iRead === this.iWrite;
            } }, { key: "full", get: function get() {
              return this.iWrite === this.size;
            } }, { key: "read", value: function read(size) {
              var buf;
              if (size === 0) {
                return null;
              }
              if (size === void 0 || size >= this.length) {
                buf = this.toBuffer();
                this.iRead = this.iWrite;
                return buf;
              }
              buf = Buffer2.alloc(size);
              this.buffer.copy(buf, 0, this.iRead, size);
              this.iRead += size;
              return buf;
            } }, { key: "write", value: function write(chunk, offset, length) {
              var size = Math.min(length, this.size - this.iWrite);
              chunk.copy(this.buffer, this.iWrite, offset, offset + size);
              this.iWrite += size;
              return size;
            } }]);
            return ReadWriteBuf2;
          }();
          var StreamBuf = function StreamBuf2(options) {
            options = options || {};
            this.bufSize = options.bufSize || 1024 * 1024;
            this.buffers = [];
            this.batch = options.batch || false;
            this.corked = false;
            this.inPos = 0;
            this.outPos = 0;
            this.pipes = [];
            this.paused = false;
            this.encoding = null;
          };
          utils.inherits(StreamBuf, Stream.Duplex, {
            toBuffer: function toBuffer() {
              switch (this.buffers.length) {
                case 0:
                  return null;
                case 1:
                  return this.buffers[0].toBuffer();
                default:
                  return Buffer2.concat(this.buffers.map(function(rwBuf) {
                    return rwBuf.toBuffer();
                  }));
              }
            },
            // writable
            // event drain - if write returns false (which it won't), indicates when safe to write again.
            // finish - end() has been called
            // pipe(src) - pipe() has been called on readable
            // unpipe(src) - unpipe() has been called on readable
            // error - duh
            _getWritableBuffer: function _getWritableBuffer() {
              if (this.buffers.length) {
                var last = this.buffers[this.buffers.length - 1];
                if (!last.full) {
                  return last;
                }
              }
              var buf = new ReadWriteBuf(this.bufSize);
              this.buffers.push(buf);
              return buf;
            },
            _pipe: function _pipe(chunk) {
              var _this28 = this;
              return _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee4() {
                var write;
                return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1)
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        write = function write2(pipe) {
                          return new Promise(function(resolve) {
                            pipe.write(chunk.toBuffer(), function() {
                              resolve();
                            });
                          });
                        };
                        _context4.next = 3;
                        return Promise.all(_this28.pipes.map(write));
                      case 3:
                      case "end":
                        return _context4.stop();
                    }
                }, _callee4);
              }))();
            },
            _writeToBuffers: function _writeToBuffers(chunk) {
              var inPos = 0;
              var inLen = chunk.length;
              while (inPos < inLen) {
                var buffer = this._getWritableBuffer();
                inPos += buffer.write(chunk, inPos, inLen - inPos);
              }
            },
            write: function write(data, encoding, callback) {
              var _this29 = this;
              return _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee5() {
                var chunk;
                return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1)
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (encoding instanceof Function) {
                          callback = encoding;
                          encoding = "utf8";
                        }
                        callback = callback || utils.nop;
                        if (!(data instanceof StringBuf)) {
                          _context5.next = 6;
                          break;
                        }
                        chunk = new StringBufChunk(data);
                        _context5.next = 15;
                        break;
                      case 6:
                        if (!(data instanceof Buffer2)) {
                          _context5.next = 10;
                          break;
                        }
                        chunk = new BufferChunk(data);
                        _context5.next = 15;
                        break;
                      case 10:
                        if (!(typeof data === "string" || data instanceof String || data instanceof ArrayBuffer)) {
                          _context5.next = 14;
                          break;
                        }
                        chunk = new StringChunk(data, encoding);
                        _context5.next = 15;
                        break;
                      case 14:
                        throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
                      case 15:
                        if (!_this29.pipes.length) {
                          _context5.next = 31;
                          break;
                        }
                        if (!_this29.batch) {
                          _context5.next = 21;
                          break;
                        }
                        _this29._writeToBuffers(chunk);
                        while (!_this29.corked && _this29.buffers.length > 1) {
                          _this29._pipe(_this29.buffers.shift());
                        }
                        _context5.next = 29;
                        break;
                      case 21:
                        if (_this29.corked) {
                          _context5.next = 27;
                          break;
                        }
                        _context5.next = 24;
                        return _this29._pipe(chunk);
                      case 24:
                        callback();
                        _context5.next = 29;
                        break;
                      case 27:
                        _this29._writeToBuffers(chunk);
                        process2.nextTick(callback);
                      case 29:
                        _context5.next = 34;
                        break;
                      case 31:
                        if (!_this29.paused) {
                          _this29.emit("data", chunk.toBuffer());
                        }
                        _this29._writeToBuffers(chunk);
                        _this29.emit("readable");
                      case 34:
                        return _context5.abrupt("return", true);
                      case 35:
                      case "end":
                        return _context5.stop();
                    }
                }, _callee5);
              }))();
            },
            cork: function cork() {
              this.corked = true;
            },
            _flush: function _flush() {
              if (this.pipes.length) {
                while (this.buffers.length) {
                  this._pipe(this.buffers.shift());
                }
              }
            },
            uncork: function uncork() {
              this.corked = false;
              this._flush();
            },
            end: function end(chunk, encoding, callback) {
              var _this30 = this;
              var writeComplete = function writeComplete2(error) {
                if (error) {
                  callback(error);
                } else {
                  _this30._flush();
                  _this30.pipes.forEach(function(pipe) {
                    pipe.end();
                  });
                  _this30.emit("finish");
                }
              };
              if (chunk) {
                this.write(chunk, encoding, writeComplete);
              } else {
                writeComplete();
              }
            },
            // readable
            // event readable - some data is now available
            // event data - switch to flowing mode - feeds chunks to handler
            // event end - no more data
            // event close - optional, indicates upstream close
            // event error - duh
            read: function read(size) {
              var buffers;
              if (size) {
                buffers = [];
                while (size && this.buffers.length && !this.buffers[0].eod) {
                  var first = this.buffers[0];
                  var buffer = first.read(size);
                  size -= buffer.length;
                  buffers.push(buffer);
                  if (first.eod && first.full) {
                    this.buffers.shift();
                  }
                }
                return Buffer2.concat(buffers);
              }
              buffers = this.buffers.map(function(buf) {
                return buf.toBuffer();
              }).filter(Boolean);
              this.buffers = [];
              return Buffer2.concat(buffers);
            },
            setEncoding: function setEncoding(encoding) {
              this.encoding = encoding;
            },
            pause: function pause() {
              this.paused = true;
            },
            resume: function resume() {
              this.paused = false;
            },
            isPaused: function isPaused() {
              return !!this.paused;
            },
            pipe: function pipe(destination) {
              this.pipes.push(destination);
              if (!this.paused && this.buffers.length) {
                this.end();
              }
            },
            unpipe: function unpipe(destination) {
              this.pipes = this.pipes.filter(function(pipe) {
                return pipe !== destination;
              });
            },
            unshift: function unshift() {
              throw new Error("Not Implemented");
            },
            wrap: function wrap() {
              throw new Error("Not Implemented");
            }
            /* stream */
          });
          module2.exports = StreamBuf;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./string-buf": 25, "./utils": 27, "_process": 467, "buffer": 220, "readable-stream": 491 }], 25: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var StringBuf = /* @__PURE__ */ function() {
            function StringBuf2(options) {
              _classCallCheck(this, StringBuf2);
              this._buf = Buffer2.alloc(options && options.size || 16384);
              this._encoding = options && options.encoding || "utf8";
              this._inPos = 0;
              this._buffer = void 0;
            }
            _createClass(StringBuf2, [{ key: "length", get: function get() {
              return this._inPos;
            } }, { key: "capacity", get: function get() {
              return this._buf.length;
            } }, { key: "buffer", get: function get() {
              return this._buf;
            } }, { key: "toBuffer", value: function toBuffer() {
              if (!this._buffer) {
                this._buffer = Buffer2.alloc(this.length);
                this._buf.copy(this._buffer, 0, 0, this.length);
              }
              return this._buffer;
            } }, { key: "reset", value: function reset(position) {
              position = position || 0;
              this._buffer = void 0;
              this._inPos = position;
            } }, { key: "_grow", value: function _grow(min) {
              var size = this._buf.length * 2;
              while (size < min) {
                size *= 2;
              }
              var buf = Buffer2.alloc(size);
              this._buf.copy(buf, 0);
              this._buf = buf;
            } }, { key: "addText", value: function addText(text) {
              this._buffer = void 0;
              var inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
              while (inPos >= this._buf.length - 4) {
                this._grow(this._inPos + text.length);
                inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
              }
              this._inPos = inPos;
            } }, { key: "addStringBuf", value: function addStringBuf(inBuf) {
              if (inBuf.length) {
                this._buffer = void 0;
                if (this.length + inBuf.length > this.capacity) {
                  this._grow(this.length + inBuf.length);
                }
                inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
                this._inPos += inBuf.length;
              }
            } }]);
            return StringBuf2;
          }();
          module2.exports = StringBuf;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 220 }], 26: [function(require2, module2, exports2) {
      var toString2 = Object.prototype.toString;
      var escapeHtmlRegex = /["&<>]/;
      var _ = { each: function each(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            obj.forEach(cb);
          } else {
            Object.keys(obj).forEach(function(key) {
              cb(obj[key], key);
            });
          }
        }
      }, some: function some(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.some(cb);
          }
          return Object.keys(obj).some(function(key) {
            return cb(obj[key], key);
          });
        }
        return false;
      }, every: function every(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.every(cb);
          }
          return Object.keys(obj).every(function(key) {
            return cb(obj[key], key);
          });
        }
        return true;
      }, map: function map(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.map(cb);
          }
          return Object.keys(obj).map(function(key) {
            return cb(obj[key], key);
          });
        }
        return [];
      }, keyBy: function keyBy(a, p) {
        return a.reduce(function(o, v) {
          o[v[p]] = v;
          return o;
        }, {});
      }, isEqual: function isEqual(a, b) {
        var aType = typeof a;
        var bType = typeof b;
        var aArray = Array.isArray(a);
        var bArray = Array.isArray(b);
        var keys2;
        if (aType !== bType) {
          return false;
        }
        switch (typeof a) {
          case "object":
            if (aArray || bArray) {
              if (aArray && bArray) {
                return a.length === b.length && a.every(function(aValue, index2) {
                  var bValue = b[index2];
                  return _.isEqual(aValue, bValue);
                });
              }
              return false;
            }
            if (a === null || b === null) {
              return a === b;
            }
            keys2 = Object.keys(a);
            if (Object.keys(b).length !== keys2.length) {
              return false;
            }
            var _iterator4 = _createForOfIteratorHelper$1(keys2), _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                var key = _step4.value;
                if (!b.hasOwnProperty(key)) {
                  return false;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            return _.every(a, function(aValue, key2) {
              var bValue = b[key2];
              return _.isEqual(aValue, bValue);
            });
          default:
            return a === b;
        }
      }, escapeHtml: function escapeHtml(html) {
        var regexResult = escapeHtmlRegex.exec(html);
        if (!regexResult)
          return html;
        var result = "";
        var escape = "";
        var lastIndex = 0;
        var i = regexResult.index;
        for (; i < html.length; i++) {
          switch (html.charAt(i)) {
            case '"':
              escape = "&quot;";
              break;
            case "&":
              escape = "&amp;";
              break;
            case "'":
              escape = "&apos;";
              break;
            case "<":
              escape = "&lt;";
              break;
            case ">":
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== i)
            result += html.substring(lastIndex, i);
          lastIndex = i + 1;
          result += escape;
        }
        if (lastIndex !== i)
          return result + html.substring(lastIndex, i);
        return result;
      }, strcmp: function strcmp(a, b) {
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      }, isUndefined: function isUndefined(val) {
        return toString2.call(val) === "[object Undefined]";
      }, isObject: function isObject(val) {
        return toString2.call(val) === "[object Object]";
      }, deepMerge: function deepMerge() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var src, clone2, copyIsArray;
        function assignValue(val, key) {
          src = target[key];
          copyIsArray = Array.isArray(val);
          if (_.isObject(val) || copyIsArray) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && Array.isArray(src) ? src : [];
            } else {
              clone2 = src && _.isObject(src) ? src : {};
            }
            target[key] = _.deepMerge(clone2, val);
          } else if (!_.isUndefined(val)) {
            target[key] = val;
          }
        }
        for (var i = 0; i < length; i++) {
          _.each(arguments[i], assignValue);
        }
        return target;
      } };
      module2.exports = _;
    }, {}], 27: [function(require2, module2, exports2) {
      (function(global2, setImmediate) {
        (function() {
          var fs = require2("fs");
          var inherits = function inherits2(cls, superCtor, statics, prototype) {
            cls.super_ = superCtor;
            if (!prototype) {
              prototype = statics;
              statics = null;
            }
            if (statics) {
              Object.keys(statics).forEach(function(i) {
                Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
              });
            }
            var properties = { constructor: { value: cls, enumerable: false, writable: false, configurable: true } };
            if (prototype) {
              Object.keys(prototype).forEach(function(i) {
                properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
              });
            }
            cls.prototype = Object.create(superCtor.prototype, properties);
          };
          var xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
          var utils = { nop: function nop() {
          }, promiseImmediate: function promiseImmediate(value) {
            return new Promise(function(resolve) {
              if (global2.setImmediate) {
                setImmediate(function() {
                  resolve(value);
                });
              } else {
                setTimeout(function() {
                  resolve(value);
                }, 1);
              }
            });
          }, inherits, dateToExcel: function dateToExcel(d, date1904) {
            return 25569 + d.getTime() / (24 * 3600 * 1e3) - (date1904 ? 1462 : 0);
          }, excelToDate: function excelToDate(v, date1904) {
            var millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1e3);
            return new Date(millisecondSinceEpoch);
          }, parsePath: function parsePath(filepath) {
            var last = filepath.lastIndexOf("/");
            return { path: filepath.substring(0, last), name: filepath.substring(last + 1) };
          }, getRelsPath: function getRelsPath(filepath) {
            var path = utils.parsePath(filepath);
            return "".concat(path.path, "/_rels/").concat(path.name, ".rels");
          }, xmlEncode: function xmlEncode(text) {
            var regexResult = xmlDecodeRegex.exec(text);
            if (!regexResult)
              return text;
            var result = "";
            var escape = "";
            var lastIndex = 0;
            var i = regexResult.index;
            for (; i < text.length; i++) {
              var charCode = text.charCodeAt(i);
              switch (charCode) {
                case 34:
                  escape = "&quot;";
                  break;
                case 38:
                  escape = "&amp;";
                  break;
                case 39:
                  escape = "&apos;";
                  break;
                case 60:
                  escape = "&lt;";
                  break;
                case 62:
                  escape = "&gt;";
                  break;
                case 127:
                  escape = "";
                  break;
                default: {
                  if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
                    escape = "";
                    break;
                  }
                  continue;
                }
              }
              if (lastIndex !== i)
                result += text.substring(lastIndex, i);
              lastIndex = i + 1;
              if (escape)
                result += escape;
            }
            if (lastIndex !== i)
              return result + text.substring(lastIndex, i);
            return result;
          }, xmlDecode: function xmlDecode(text) {
            return text.replace(/&([a-z]*);/g, function(c) {
              switch (c) {
                case "&lt;":
                  return "<";
                case "&gt;":
                  return ">";
                case "&amp;":
                  return "&";
                case "&apos;":
                  return "'";
                case "&quot;":
                  return '"';
                default:
                  return c;
              }
            });
          }, validInt: function validInt(value) {
            var i = parseInt(value, 10);
            return !Number.isNaN(i) ? i : 0;
          }, isDateFmt: function isDateFmt(fmt) {
            if (!fmt) {
              return false;
            }
            fmt = fmt.replace(/\[[^\]]*]/g, "");
            fmt = fmt.replace(/"[^"]*"/g, "");
            var result = fmt.match(/[ymdhMsb]+/) !== null;
            return result;
          }, fs: { exists: function exists(path) {
            return new Promise(function(resolve) {
              fs.access(path, fs.constants.F_OK, function(err) {
                resolve(!err);
              });
            });
          } }, toIsoDateString: function toIsoDateString(dt) {
            return dt.toIsoString().subsstr(0, 10);
          }, parseBoolean: function parseBoolean(value) {
            return value === true || value === "true" || value === 1 || value === "1";
          } };
          module2.exports = utils;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
    }, { "fs": 216, "timers": 523 }], 28: [function(require2, module2, exports2) {
      var _ = require2("./under-dash");
      var utils = require2("./utils");
      var OPEN_ANGLE = "<";
      var CLOSE_ANGLE = ">";
      var OPEN_ANGLE_SLASH = "</";
      var CLOSE_SLASH_ANGLE = "/>";
      function pushAttribute(xml, name, value) {
        xml.push(" ".concat(name, '="').concat(utils.xmlEncode(value.toString()), '"'));
      }
      function pushAttributes(xml, attributes) {
        if (attributes) {
          var tmp = [];
          _.each(attributes, function(value, name) {
            if (value !== void 0) {
              pushAttribute(tmp, name, value);
            }
          });
          xml.push(tmp.join(""));
        }
      }
      var XmlStream = /* @__PURE__ */ function() {
        function XmlStream2() {
          _classCallCheck(this, XmlStream2);
          this._xml = [];
          this._stack = [];
          this._rollbacks = [];
        }
        _createClass(XmlStream2, [{ key: "tos", get: function get() {
          return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
        } }, { key: "cursor", get: function get() {
          return this._xml.length;
        } }, { key: "openXml", value: function openXml(docAttributes) {
          var xml = this._xml;
          xml.push("<?xml");
          pushAttributes(xml, docAttributes);
          xml.push("?>\n");
        } }, { key: "openNode", value: function openNode(name, attributes) {
          var parent = this.tos;
          var xml = this._xml;
          if (parent && this.open) {
            xml.push(CLOSE_ANGLE);
          }
          this._stack.push(name);
          xml.push(OPEN_ANGLE);
          xml.push(name);
          pushAttributes(xml, attributes);
          this.leaf = true;
          this.open = true;
        } }, { key: "addAttribute", value: function addAttribute(name, value) {
          if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
          }
          if (value !== void 0) {
            pushAttribute(this._xml, name, value);
          }
        } }, { key: "addAttributes", value: function addAttributes(attrs) {
          if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
          }
          pushAttributes(this._xml, attrs);
        } }, { key: "writeText", value: function writeText(text) {
          var xml = this._xml;
          if (this.open) {
            xml.push(CLOSE_ANGLE);
            this.open = false;
          }
          this.leaf = false;
          xml.push(utils.xmlEncode(text.toString()));
        } }, { key: "writeXml", value: function writeXml(xml) {
          if (this.open) {
            this._xml.push(CLOSE_ANGLE);
            this.open = false;
          }
          this.leaf = false;
          this._xml.push(xml);
        } }, { key: "closeNode", value: function closeNode() {
          var node = this._stack.pop();
          var xml = this._xml;
          if (this.leaf) {
            xml.push(CLOSE_SLASH_ANGLE);
          } else {
            xml.push(OPEN_ANGLE_SLASH);
            xml.push(node);
            xml.push(CLOSE_ANGLE);
          }
          this.open = false;
          this.leaf = false;
        } }, { key: "leafNode", value: function leafNode(name, attributes, text) {
          this.openNode(name, attributes);
          if (text !== void 0) {
            this.writeText(text);
          }
          this.closeNode();
        } }, { key: "closeAll", value: function closeAll() {
          while (this._stack.length) {
            this.closeNode();
          }
        } }, { key: "addRollback", value: function addRollback() {
          this._rollbacks.push({ xml: this._xml.length, stack: this._stack.length, leaf: this.leaf, open: this.open });
          return this.cursor;
        } }, { key: "commit", value: function commit() {
          this._rollbacks.pop();
        } }, { key: "rollback", value: function rollback() {
          var r = this._rollbacks.pop();
          if (this._xml.length > r.xml) {
            this._xml.splice(r.xml, this._xml.length - r.xml);
          }
          if (this._stack.length > r.stack) {
            this._stack.splice(r.stack, this._stack.length - r.stack);
          }
          this.leaf = r.leaf;
          this.open = r.open;
        } }, { key: "xml", get: function get() {
          this.closeAll();
          return this._xml.join("");
        } }]);
        return XmlStream2;
      }();
      XmlStream.StdDocAttributes = { version: "1.0", encoding: "UTF-8", standalone: "yes" };
      module2.exports = XmlStream;
    }, { "./under-dash": 26, "./utils": 27 }], 29: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          var events = require2("events");
          var JSZip = require2("jszip");
          var StreamBuf = require2("./stream-buf");
          var _require10 = require2("./browser-buffer-encode"), stringToBuffer = _require10.stringToBuffer;
          var ZipWriter = /* @__PURE__ */ function(_events$EventEmitter) {
            _inherits(ZipWriter2, _events$EventEmitter);
            var _super = _createSuper(ZipWriter2);
            function ZipWriter2(options) {
              var _this31;
              _classCallCheck(this, ZipWriter2);
              _this31 = _super.call(this);
              _this31.options = Object.assign({ type: "nodebuffer", compression: "DEFLATE" }, options);
              _this31.zip = new JSZip();
              _this31.stream = new StreamBuf();
              return _this31;
            }
            _createClass(ZipWriter2, [{ key: "append", value: function append(data, options) {
              if (options.hasOwnProperty("base64") && options.base64) {
                this.zip.file(options.name, data, { base64: true });
              } else {
                if (process2.browser && typeof data === "string") {
                  data = stringToBuffer(data);
                }
                this.zip.file(options.name, data);
              }
            } }, {
              key: "finalize",
              value: function() {
                var _finalize = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee6() {
                  var content;
                  return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1)
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.next = 2;
                          return this.zip.generateAsync(this.options);
                        case 2:
                          content = _context6.sent;
                          this.stream.end(content);
                          this.emit("finish");
                        case 5:
                        case "end":
                          return _context6.stop();
                      }
                  }, _callee6, this);
                }));
                function finalize() {
                  return _finalize.apply(this, arguments);
                }
                return finalize;
              }()
              // ==========================================================================
              // Stream.Readable interface
            }, { key: "read", value: function read(size) {
              return this.stream.read(size);
            } }, { key: "setEncoding", value: function setEncoding(encoding) {
              return this.stream.setEncoding(encoding);
            } }, { key: "pause", value: function pause() {
              return this.stream.pause();
            } }, { key: "resume", value: function resume() {
              return this.stream.resume();
            } }, { key: "isPaused", value: function isPaused() {
              return this.stream.isPaused();
            } }, { key: "pipe", value: function pipe(destination, options) {
              return this.stream.pipe(destination, options);
            } }, { key: "unpipe", value: function unpipe(destination) {
              return this.stream.unpipe(destination);
            } }, { key: "unshift", value: function unshift(chunk) {
              return this.stream.unshift(chunk);
            } }, { key: "wrap", value: function wrap(stream) {
              return this.stream.wrap(stream);
            } }]);
            return ZipWriter2;
          }(events.EventEmitter);
          module2.exports = { ZipWriter };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./browser-buffer-encode": 17, "./stream-buf": 24, "_process": 467, "events": 422, "jszip": 441 }], 30: [function(require2, module2, exports2) {
      module2.exports = { 0: { f: "General" }, 1: { f: "0" }, 2: { f: "0.00" }, 3: { f: "#,##0" }, 4: { f: "#,##0.00" }, 9: { f: "0%" }, 10: { f: "0.00%" }, 11: { f: "0.00E+00" }, 12: { f: "# ?/?" }, 13: { f: "# ??/??" }, 14: { f: "mm-dd-yy" }, 15: { f: "d-mmm-yy" }, 16: { f: "d-mmm" }, 17: { f: "mmm-yy" }, 18: { f: "h:mm AM/PM" }, 19: { f: "h:mm:ss AM/PM" }, 20: { f: "h:mm" }, 21: { f: "h:mm:ss" }, 22: { f: 'm/d/yy "h":mm' }, 27: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 28: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 29: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" }, 31: { "zh-tw": 'yyyy""m""d""', "zh-cn": 'yyyy""m""d""', "ja-jp": 'yyyy""m""d""', "ko-kr": 'yyyy"" mm"" dd""' }, 32: { "zh-tw": 'hh""mm""', "zh-cn": 'h""mm""', "ja-jp": 'h""mm""', "ko-kr": 'h"" mm""' }, 33: { "zh-tw": 'hh""mm""ss""', "zh-cn": 'h""mm""ss""', "ja-jp": 'h""mm""ss""', "ko-kr": 'h"" mm"" ss""' }, 34: { "zh-tw": '/ hh""mm""', "zh-cn": '/ h""mm""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 35: { "zh-tw": '/ hh""mm""ss""', "zh-cn": '/ h""mm""ss""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 36: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 37: { f: "#,##0 ;(#,##0)" }, 38: { f: "#,##0 ;[Red](#,##0)" }, 39: { f: "#,##0.00 ;(#,##0.00)" }, 40: { f: "#,##0.00 ;[Red](#,##0.00)" }, 45: { f: "mm:ss" }, 46: { f: "[h]:mm:ss" }, 47: { f: "mmss.0" }, 48: { f: "##0.0E+0" }, 49: { f: "@" }, 50: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 51: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 52: { "zh-tw": '/ hh""mm""', "zh-cn": 'yyyy""m""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 53: { "zh-tw": '/ hh""mm""ss""', "zh-cn": 'm""d""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 54: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 55: { "zh-tw": '/ hh""mm""', "zh-cn": '/ h""mm""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 56: { "zh-tw": '/ hh""mm""ss""', "zh-cn": '/ h""mm""ss""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 57: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 58: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 59: { "th-th": "t0" }, 60: { "th-th": "t0.00" }, 61: { "th-th": "t#,##0" }, 62: { "th-th": "t#,##0.00" }, 67: { "th-th": "t0%" }, 68: { "th-th": "t0.00%" }, 69: { "th-th": "t# ?/?" }, 70: { "th-th": "t# ??/??" }, 81: { "th-th": "d/m/bb" } };
    }, {}], 31: [function(require2, module2, exports2) {
      module2.exports = { OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain", SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings", Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing", Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" };
    }, {}], 32: [function(require2, module2, exports2) {
      var parseSax = require2("../../utils/parse-sax");
      var XmlStream = require2("../../utils/xml-stream");
      var BaseXform = /* @__PURE__ */ function() {
        function BaseXform2() {
          _classCallCheck(this, BaseXform2);
        }
        _createClass(BaseXform2, [{ key: "prepare", value: (
          // constructor(/* model, name */) {}
          // ============================================================
          // Virtual Interface
          function prepare() {
          }
        ) }, { key: "render", value: function render13() {
        } }, { key: "parseOpen", value: function parseOpen(node) {
        } }, { key: "parseText", value: function parseText(text) {
        } }, { key: "parseClose", value: function parseClose(name) {
        } }, {
          key: "reconcile",
          value: function reconcile(model, options) {
          }
          // ============================================================
        }, { key: "reset", value: function reset() {
          this.model = null;
          if (this.map) {
            Object.values(this.map).forEach(function(xform) {
              if (xform instanceof BaseXform2) {
                xform.reset();
              } else if (xform.xform) {
                xform.xform.reset();
              }
            });
          }
        } }, { key: "mergeModel", value: function mergeModel(obj) {
          this.model = Object.assign(this.model || {}, obj);
        } }, { key: "parse", value: function() {
          var _parse2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee7(saxParser) {
            var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, events, _iterator5, _step5, _step5$value, eventType, value;
            return _regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1)
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _iteratorAbruptCompletion2 = false;
                    _didIteratorError2 = false;
                    _context7.prev = 2;
                    _iterator2 = _asyncIterator(saxParser);
                  case 4:
                    _context7.next = 6;
                    return _iterator2.next();
                  case 6:
                    if (!(_iteratorAbruptCompletion2 = !(_step2 = _context7.sent).done)) {
                      _context7.next = 37;
                      break;
                    }
                    events = _step2.value;
                    _iterator5 = _createForOfIteratorHelper$1(events);
                    _context7.prev = 9;
                    _iterator5.s();
                  case 11:
                    if ((_step5 = _iterator5.n()).done) {
                      _context7.next = 26;
                      break;
                    }
                    _step5$value = _step5.value, eventType = _step5$value.eventType, value = _step5$value.value;
                    if (!(eventType === "opentag")) {
                      _context7.next = 17;
                      break;
                    }
                    this.parseOpen(value);
                    _context7.next = 24;
                    break;
                  case 17:
                    if (!(eventType === "text")) {
                      _context7.next = 21;
                      break;
                    }
                    this.parseText(value);
                    _context7.next = 24;
                    break;
                  case 21:
                    if (!(eventType === "closetag")) {
                      _context7.next = 24;
                      break;
                    }
                    if (this.parseClose(value.name)) {
                      _context7.next = 24;
                      break;
                    }
                    return _context7.abrupt("return", this.model);
                  case 24:
                    _context7.next = 11;
                    break;
                  case 26:
                    _context7.next = 31;
                    break;
                  case 28:
                    _context7.prev = 28;
                    _context7.t0 = _context7["catch"](9);
                    _iterator5.e(_context7.t0);
                  case 31:
                    _context7.prev = 31;
                    _iterator5.f();
                    return _context7.finish(31);
                  case 34:
                    _iteratorAbruptCompletion2 = false;
                    _context7.next = 4;
                    break;
                  case 37:
                    _context7.next = 43;
                    break;
                  case 39:
                    _context7.prev = 39;
                    _context7.t1 = _context7["catch"](2);
                    _didIteratorError2 = true;
                    _iteratorError2 = _context7.t1;
                  case 43:
                    _context7.prev = 43;
                    _context7.prev = 44;
                    if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {
                      _context7.next = 48;
                      break;
                    }
                    _context7.next = 48;
                    return _iterator2.return();
                  case 48:
                    _context7.prev = 48;
                    if (!_didIteratorError2) {
                      _context7.next = 51;
                      break;
                    }
                    throw _iteratorError2;
                  case 51:
                    return _context7.finish(48);
                  case 52:
                    return _context7.finish(43);
                  case 53:
                    return _context7.abrupt("return", this.model);
                  case 54:
                  case "end":
                    return _context7.stop();
                }
            }, _callee7, this, [[2, 39, 43, 53], [9, 28, 31, 34], [44, , 48, 52]]);
          }));
          function parse(_x5) {
            return _parse2.apply(this, arguments);
          }
          return parse;
        }() }, { key: "parseStream", value: function() {
          var _parseStream = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee8(stream) {
            return _regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1)
                switch (_context8.prev = _context8.next) {
                  case 0:
                    return _context8.abrupt("return", this.parse(parseSax(stream)));
                  case 1:
                  case "end":
                    return _context8.stop();
                }
            }, _callee8, this);
          }));
          function parseStream(_x6) {
            return _parseStream.apply(this, arguments);
          }
          return parseStream;
        }() }, { key: "xml", get: function get() {
          return this.toXml(this.model);
        } }, {
          key: "toXml",
          value: function toXml(model) {
            var xmlStream = new XmlStream();
            this.render(xmlStream, model);
            return xmlStream.xml;
          }
          // ============================================================
          // Useful Utilities
        }], [{ key: "toAttribute", value: function toAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (value === void 0) {
            if (always) {
              return dflt;
            }
          } else if (always || value !== dflt) {
            return value.toString();
          }
          return void 0;
        } }, { key: "toStringAttribute", value: function toStringAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toStringValue", value: function toStringValue(attr, dflt) {
          return attr === void 0 ? dflt : attr;
        } }, { key: "toBoolAttribute", value: function toBoolAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (value === void 0) {
            if (always) {
              return dflt;
            }
          } else if (always || value !== dflt) {
            return value ? "1" : "0";
          }
          return void 0;
        } }, { key: "toBoolValue", value: function toBoolValue(attr, dflt) {
          return attr === void 0 ? dflt : attr === "1";
        } }, { key: "toIntAttribute", value: function toIntAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toIntValue", value: function toIntValue(attr, dflt) {
          return attr === void 0 ? dflt : parseInt(attr, 10);
        } }, { key: "toFloatAttribute", value: function toFloatAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toFloatValue", value: function toFloatValue(attr, dflt) {
          return attr === void 0 ? dflt : parseFloat(attr);
        } }]);
        return BaseXform2;
      }();
      module2.exports = BaseXform;
    }, { "../../utils/parse-sax": 22, "../../utils/xml-stream": 28 }], 33: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var colCache = require2("../../../utils/col-cache");
      var DefinedNamesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits(DefinedNamesXform2, _BaseXform);
        var _super2 = _createSuper(DefinedNamesXform2);
        function DefinedNamesXform2() {
          _classCallCheck(this, DefinedNamesXform2);
          return _super2.apply(this, arguments);
        }
        _createClass(DefinedNamesXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("definedName", { name: model.name, localSheetId: model.localSheetId });
          xmlStream.writeText(model.ranges.join(","));
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "definedName":
              this._parsedName = node.attributes.name;
              this._parsedLocalSheetId = node.attributes.localSheetId;
              this._parsedText = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this._parsedText.push(text);
        } }, { key: "parseClose", value: function parseClose() {
          this.model = { name: this._parsedName, ranges: extractRanges(this._parsedText.join("")) };
          if (this._parsedLocalSheetId !== void 0) {
            this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
          }
          return false;
        } }]);
        return DefinedNamesXform2;
      }(BaseXform);
      function isValidRange(range) {
        try {
          colCache.decodeEx(range);
          return true;
        } catch (err) {
          return false;
        }
      }
      function extractRanges(parsedText) {
        var ranges = [];
        var quotesOpened = false;
        var last = "";
        parsedText.split(",").forEach(function(item) {
          if (!item) {
            return;
          }
          var quotes = (item.match(/'/g) || []).length;
          if (!quotes) {
            if (quotesOpened) {
              last += "".concat(item, ",");
            } else if (isValidRange(item)) {
              ranges.push(item);
            }
            return;
          }
          var quotesEven = quotes % 2 === 0;
          if (!quotesOpened && quotesEven && isValidRange(item)) {
            ranges.push(item);
          } else if (quotesOpened && !quotesEven) {
            quotesOpened = false;
            if (isValidRange(last + item)) {
              ranges.push(last + item);
            }
            last = "";
          } else {
            quotesOpened = true;
            last += "".concat(item, ",");
          }
        });
        return ranges;
      }
      module2.exports = DefinedNamesXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 34: [function(require2, module2, exports2) {
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var WorksheetXform = /* @__PURE__ */ function(_BaseXform2) {
        _inherits(WorksheetXform2, _BaseXform2);
        var _super3 = _createSuper(WorksheetXform2);
        function WorksheetXform2() {
          _classCallCheck(this, WorksheetXform2);
          return _super3.apply(this, arguments);
        }
        _createClass(WorksheetXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("sheet", { sheetId: model.id, name: model.name, state: model.state, "r:id": model.rId });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "sheet") {
            this.model = { name: utils.xmlDecode(node.attributes.name), id: parseInt(node.attributes.sheetId, 10), state: node.attributes.state, rId: node.attributes["r:id"] };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorksheetXform2;
      }(BaseXform);
      module2.exports = WorksheetXform;
    }, { "../../../utils/utils": 27, "../base-xform": 32 }], 35: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var WorkbookCalcPropertiesXform = /* @__PURE__ */ function(_BaseXform3) {
        _inherits(WorkbookCalcPropertiesXform2, _BaseXform3);
        var _super4 = _createSuper(WorkbookCalcPropertiesXform2);
        function WorkbookCalcPropertiesXform2() {
          _classCallCheck(this, WorkbookCalcPropertiesXform2);
          return _super4.apply(this, arguments);
        }
        _createClass(WorkbookCalcPropertiesXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("calcPr", { calcId: 171027, fullCalcOnLoad: model.fullCalcOnLoad ? 1 : void 0 });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "calcPr") {
            this.model = {};
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorkbookCalcPropertiesXform2;
      }(BaseXform);
      module2.exports = WorkbookCalcPropertiesXform;
    }, { "../base-xform": 32 }], 36: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var WorksheetPropertiesXform = /* @__PURE__ */ function(_BaseXform4) {
        _inherits(WorksheetPropertiesXform2, _BaseXform4);
        var _super5 = _createSuper(WorksheetPropertiesXform2);
        function WorksheetPropertiesXform2() {
          _classCallCheck(this, WorksheetPropertiesXform2);
          return _super5.apply(this, arguments);
        }
        _createClass(WorksheetPropertiesXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("workbookPr", { date1904: model.date1904 ? 1 : void 0, defaultThemeVersion: 164011, filterPrivacy: 1 });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "workbookPr") {
            this.model = { date1904: node.attributes.date1904 === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorksheetPropertiesXform2;
      }(BaseXform);
      module2.exports = WorksheetPropertiesXform;
    }, { "../base-xform": 32 }], 37: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var WorkbookViewXform = /* @__PURE__ */ function(_BaseXform5) {
        _inherits(WorkbookViewXform2, _BaseXform5);
        var _super6 = _createSuper(WorkbookViewXform2);
        function WorkbookViewXform2() {
          _classCallCheck(this, WorkbookViewXform2);
          return _super6.apply(this, arguments);
        }
        _createClass(WorkbookViewXform2, [{ key: "render", value: function render13(xmlStream, model) {
          var attributes = { xWindow: model.x || 0, yWindow: model.y || 0, windowWidth: model.width || 12e3, windowHeight: model.height || 24e3, firstSheet: model.firstSheet, activeTab: model.activeTab };
          if (model.visibility && model.visibility !== "visible") {
            attributes.visibility = model.visibility;
          }
          xmlStream.leafNode("workbookView", attributes);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "workbookView") {
            var model = this.model = {};
            var addS = function addS2(name, value, dflt) {
              var s = value !== void 0 ? model[name] = value : dflt;
              if (s !== void 0) {
                model[name] = s;
              }
            };
            var addN = function addN2(name, value, dflt) {
              var n = value !== void 0 ? model[name] = parseInt(value, 10) : dflt;
              if (n !== void 0) {
                model[name] = n;
              }
            };
            addN("x", node.attributes.xWindow, 0);
            addN("y", node.attributes.yWindow, 0);
            addN("width", node.attributes.windowWidth, 25e3);
            addN("height", node.attributes.windowHeight, 1e4);
            addS("visibility", node.attributes.visibility, "visible");
            addN("activeTab", node.attributes.activeTab, void 0);
            addN("firstSheet", node.attributes.firstSheet, void 0);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorkbookViewXform2;
      }(BaseXform);
      module2.exports = WorkbookViewXform;
    }, { "../base-xform": 32 }], 38: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var ListXform = require2("../list-xform");
      var DefinedNameXform = require2("./defined-name-xform");
      var SheetXform = require2("./sheet-xform");
      var WorkbookViewXform = require2("./workbook-view-xform");
      var WorkbookPropertiesXform = require2("./workbook-properties-xform");
      var WorkbookCalcPropertiesXform = require2("./workbook-calc-properties-xform");
      var WorkbookXform = /* @__PURE__ */ function(_BaseXform6) {
        _inherits(WorkbookXform2, _BaseXform6);
        var _super7 = _createSuper(WorkbookXform2);
        function WorkbookXform2() {
          var _this32;
          _classCallCheck(this, WorkbookXform2);
          _this32 = _super7.call(this);
          _this32.map = { fileVersion: WorkbookXform2.STATIC_XFORMS.fileVersion, workbookPr: new WorkbookPropertiesXform(), bookViews: new ListXform({ tag: "bookViews", count: false, childXform: new WorkbookViewXform() }), sheets: new ListXform({ tag: "sheets", count: false, childXform: new SheetXform() }), definedNames: new ListXform({ tag: "definedNames", count: false, childXform: new DefinedNameXform() }), calcPr: new WorkbookCalcPropertiesXform() };
          return _this32;
        }
        _createClass(WorkbookXform2, [{ key: "prepare", value: function prepare(model) {
          model.sheets = model.worksheets;
          var printAreas = [];
          var index2 = 0;
          model.sheets.forEach(function(sheet) {
            if (sheet.pageSetup && sheet.pageSetup.printArea) {
              sheet.pageSetup.printArea.split("&&").forEach(function(printArea) {
                var printAreaComponents = printArea.split(":");
                var definedName2 = { name: "_xlnm.Print_Area", ranges: ["'".concat(sheet.name, "'!$").concat(printAreaComponents[0], ":$").concat(printAreaComponents[1])], localSheetId: index2 };
                printAreas.push(definedName2);
              });
            }
            if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
              var ranges = [];
              if (sheet.pageSetup.printTitlesColumn) {
                var titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
                ranges.push("'".concat(sheet.name, "'!$").concat(titlesColumns[0], ":$").concat(titlesColumns[1]));
              }
              if (sheet.pageSetup.printTitlesRow) {
                var titlesRows = sheet.pageSetup.printTitlesRow.split(":");
                ranges.push("'".concat(sheet.name, "'!$").concat(titlesRows[0], ":$").concat(titlesRows[1]));
              }
              var definedName = { name: "_xlnm.Print_Titles", ranges, localSheetId: index2 };
              printAreas.push(definedName);
            }
            index2++;
          });
          if (printAreas.length) {
            model.definedNames = model.definedNames.concat(printAreas);
          }
          (model.media || []).forEach(function(medium, i) {
            medium.name = medium.type + (i + 1);
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("workbook", WorkbookXform2.WORKBOOK_ATTRIBUTES);
          this.map.fileVersion.render(xmlStream);
          this.map.workbookPr.render(xmlStream, model.properties);
          this.map.bookViews.render(xmlStream, model.views);
          this.map.sheets.render(xmlStream, model.sheets);
          this.map.definedNames.render(xmlStream, model.definedNames);
          this.map.calcPr.render(xmlStream, model.calcProperties);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "workbook":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "workbook":
              this.model = { sheets: this.map.sheets.model, properties: this.map.workbookPr.model || {}, views: this.map.bookViews.model, calcProperties: {} };
              if (this.map.definedNames.model) {
                this.model.definedNames = this.map.definedNames.model;
              }
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model) {
          var rels = (model.workbookRels || []).reduce(function(map, rel) {
            map[rel.Id] = rel;
            return map;
          }, {});
          var worksheets = [];
          var worksheet;
          var index2 = 0;
          (model.sheets || []).forEach(function(sheet) {
            var rel = rels[sheet.rId];
            if (!rel) {
              return;
            }
            worksheet = model.worksheetHash["xl/".concat(rel.Target.replace(/^(\s|\/xl\/)+/, ""))];
            if (worksheet) {
              worksheet.name = sheet.name;
              worksheet.id = sheet.id;
              worksheet.state = sheet.state;
              worksheets[index2++] = worksheet;
            }
          });
          var definedNames = [];
          _.each(model.definedNames, function(definedName) {
            if (definedName.name === "_xlnm.Print_Area") {
              worksheet = worksheets[definedName.localSheetId];
              if (worksheet) {
                if (!worksheet.pageSetup) {
                  worksheet.pageSetup = {};
                }
                var range = colCache.decodeEx(definedName.ranges[0]);
                worksheet.pageSetup.printArea = worksheet.pageSetup.printArea ? "".concat(worksheet.pageSetup.printArea, "&&").concat(range.dimensions) : range.dimensions;
              }
            } else if (definedName.name === "_xlnm.Print_Titles") {
              worksheet = worksheets[definedName.localSheetId];
              if (worksheet) {
                if (!worksheet.pageSetup) {
                  worksheet.pageSetup = {};
                }
                var rangeString = definedName.ranges.join(",");
                var dollarRegex = /\$/g;
                var rowRangeRegex = /\$\d+:\$\d+/;
                var rowRangeMatches = rangeString.match(rowRangeRegex);
                if (rowRangeMatches && rowRangeMatches.length) {
                  var _range2 = rowRangeMatches[0];
                  worksheet.pageSetup.printTitlesRow = _range2.replace(dollarRegex, "");
                }
                var columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
                var columnRangeMatches = rangeString.match(columnRangeRegex);
                if (columnRangeMatches && columnRangeMatches.length) {
                  var _range3 = columnRangeMatches[0];
                  worksheet.pageSetup.printTitlesColumn = _range3.replace(dollarRegex, "");
                }
              }
            } else {
              definedNames.push(definedName);
            }
          });
          model.definedNames = definedNames;
          model.media.forEach(function(media, i) {
            media.index = i;
          });
        } }]);
        return WorkbookXform2;
      }(BaseXform);
      WorkbookXform.WORKBOOK_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x15", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" };
      WorkbookXform.STATIC_XFORMS = { fileVersion: new StaticXform({ tag: "fileVersion", $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 } }) };
      module2.exports = WorkbookXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "../static-xform": 120, "./defined-name-xform": 33, "./sheet-xform": 34, "./workbook-calc-properties-xform": 35, "./workbook-properties-xform": 36, "./workbook-view-xform": 37 }], 39: [function(require2, module2, exports2) {
      var RichTextXform = require2("../strings/rich-text-xform");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var CommentXform = module2.exports = function(model) {
        this.model = model;
      };
      utils.inherits(CommentXform, BaseXform, { get tag() {
        return "r";
      }, get richTextXform() {
        if (!this._richTextXform) {
          this._richTextXform = new RichTextXform();
        }
        return this._richTextXform;
      }, render: function render13(xmlStream, model) {
        var _this33 = this;
        model = model || this.model;
        xmlStream.openNode("comment", { ref: model.ref, authorId: 0 });
        xmlStream.openNode("text");
        if (model && model.note && model.note.texts) {
          model.note.texts.forEach(function(text) {
            _this33.richTextXform.render(xmlStream, text);
          });
        }
        xmlStream.closeNode();
        xmlStream.closeNode();
      }, parseOpen: function parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "comment":
            this.model = _objectSpread2({ type: "note", note: { texts: [] } }, node.attributes);
            return true;
          case "r":
            this.parser = this.richTextXform;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }, parseText: function parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }, parseClose: function parseClose(name) {
        switch (name) {
          case "comment":
            return false;
          case "r":
            this.model.note.texts.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      } });
    }, { "../../../utils/utils": 27, "../base-xform": 32, "../strings/rich-text-xform": 122 }], 40: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var CommentXform = require2("./comment-xform");
      var CommentsXform = module2.exports = function() {
        this.map = { comment: new CommentXform() };
      };
      utils.inherits(CommentsXform, BaseXform, { COMMENTS_ATTRIBUTES: { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main" } }, { render: function render13(xmlStream, model) {
        var _this34 = this;
        model = model || this.model;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("comments", CommentsXform.COMMENTS_ATTRIBUTES);
        xmlStream.openNode("authors");
        xmlStream.leafNode("author", null, "Author");
        xmlStream.closeNode();
        xmlStream.openNode("commentList");
        model.comments.forEach(function(comment) {
          _this34.map.comment.render(xmlStream, comment);
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
      }, parseOpen: function parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "commentList":
            this.model = { comments: [] };
            return true;
          case "comment":
            this.parser = this.map.comment;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }, parseText: function parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }, parseClose: function parseClose(name) {
        switch (name) {
          case "commentList":
            return false;
          case "comment":
            this.model.comments.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      } });
    }, { "../../../utils/utils": 27, "../../../utils/xml-stream": 28, "../base-xform": 32, "./comment-xform": 39 }], 41: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var VmlPositionXform = /* @__PURE__ */ function(_BaseXform7) {
        _inherits(VmlPositionXform2, _BaseXform7);
        var _super8 = _createSuper(VmlPositionXform2);
        function VmlPositionXform2(model) {
          var _this35;
          _classCallCheck(this, VmlPositionXform2);
          _this35 = _super8.call(this);
          _this35._model = model;
          return _this35;
        }
        _createClass(VmlPositionXform2, [{ key: "tag", get: function get() {
          return this._model && this._model.tag;
        } }, { key: "render", value: function render13(xmlStream, model, type) {
          if (model === type[2]) {
            xmlStream.leafNode(this.tag);
          } else if (this.tag === "x:SizeWithCells" && model === type[1]) {
            xmlStream.leafNode(this.tag);
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = {};
              this.model[this.tag] = true;
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return VmlPositionXform2;
      }(BaseXform);
      module2.exports = VmlPositionXform;
    }, { "../../base-xform": 32 }], 42: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var VmlProtectionXform = /* @__PURE__ */ function(_BaseXform8) {
        _inherits(VmlProtectionXform2, _BaseXform8);
        var _super9 = _createSuper(VmlProtectionXform2);
        function VmlProtectionXform2(model) {
          var _this36;
          _classCallCheck(this, VmlProtectionXform2);
          _this36 = _super9.call(this);
          _this36._model = model;
          return _this36;
        }
        _createClass(VmlProtectionXform2, [{ key: "tag", get: function get() {
          return this._model && this._model.tag;
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.text = "";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this.text = text;
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return VmlProtectionXform2;
      }(BaseXform);
      module2.exports = VmlProtectionXform;
    }, { "../../base-xform": 32 }], 43: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var VmlAnchorXform = /* @__PURE__ */ function(_BaseXform9) {
        _inherits(VmlAnchorXform2, _BaseXform9);
        var _super10 = _createSuper(VmlAnchorXform2);
        function VmlAnchorXform2() {
          _classCallCheck(this, VmlAnchorXform2);
          return _super10.apply(this, arguments);
        }
        _createClass(VmlAnchorXform2, [{ key: "tag", get: function get() {
          return "x:Anchor";
        } }, { key: "getAnchorRect", value: function getAnchorRect(anchor) {
          var l = Math.floor(anchor.left);
          var lf = Math.floor((anchor.left - l) * 68);
          var t2 = Math.floor(anchor.top);
          var tf2 = Math.floor((anchor.top - t2) * 18);
          var r = Math.floor(anchor.right);
          var rf = Math.floor((anchor.right - r) * 68);
          var b = Math.floor(anchor.bottom);
          var bf = Math.floor((anchor.bottom - b) * 18);
          return [l, lf, t2, tf2, r, rf, b, bf];
        } }, { key: "getDefaultRect", value: function getDefaultRect(ref2) {
          var l = ref2.col;
          var lf = 6;
          var t2 = Math.max(ref2.row - 2, 0);
          var tf2 = 14;
          var r = l + 2;
          var rf = 2;
          var b = t2 + 4;
          var bf = 16;
          return [l, lf, t2, tf2, r, rf, b, bf];
        } }, { key: "render", value: function render13(xmlStream, model) {
          var rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
          xmlStream.leafNode("x:Anchor", null, rect.join(", "));
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.text = "";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this.text = text;
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return VmlAnchorXform2;
      }(BaseXform);
      module2.exports = VmlAnchorXform;
    }, { "../base-xform": 32 }], 44: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var VmlAnchorXform = require2("./vml-anchor-xform");
      var VmlProtectionXform = require2("./style/vml-protection-xform");
      var VmlPositionXform = require2("./style/vml-position-xform");
      var POSITION_TYPE = ["twoCells", "oneCells", "absolute"];
      var VmlClientDataXform = /* @__PURE__ */ function(_BaseXform10) {
        _inherits(VmlClientDataXform2, _BaseXform10);
        var _super11 = _createSuper(VmlClientDataXform2);
        function VmlClientDataXform2() {
          var _this37;
          _classCallCheck(this, VmlClientDataXform2);
          _this37 = _super11.call(this);
          _this37.map = { "x:Anchor": new VmlAnchorXform(), "x:Locked": new VmlProtectionXform({ tag: "x:Locked" }), "x:LockText": new VmlProtectionXform({ tag: "x:LockText" }), "x:SizeWithCells": new VmlPositionXform({ tag: "x:SizeWithCells" }), "x:MoveWithCells": new VmlPositionXform({ tag: "x:MoveWithCells" }) };
          return _this37;
        }
        _createClass(VmlClientDataXform2, [{ key: "tag", get: function get() {
          return "x:ClientData";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _model$note = model.note, protection = _model$note.protection, editAs = _model$note.editAs;
          xmlStream.openNode(this.tag, { ObjectType: "Note" });
          this.map["x:MoveWithCells"].render(xmlStream, editAs, POSITION_TYPE);
          this.map["x:SizeWithCells"].render(xmlStream, editAs, POSITION_TYPE);
          this.map["x:Anchor"].render(xmlStream, model);
          this.map["x:Locked"].render(xmlStream, protection.locked);
          xmlStream.leafNode("x:AutoFill", null, "False");
          this.map["x:LockText"].render(xmlStream, protection.lockText);
          xmlStream.leafNode("x:Row", null, model.refAddress.row - 1);
          xmlStream.leafNode("x:Column", null, model.refAddress.col - 1);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { anchor: [], protection: {}, editAs: "" };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.normalizeModel();
              return false;
            default:
              return true;
          }
        } }, { key: "normalizeModel", value: function normalizeModel() {
          var position = Object.assign({}, this.map["x:MoveWithCells"].model, this.map["x:SizeWithCells"].model);
          var len = Object.keys(position).length;
          this.model.editAs = POSITION_TYPE[len];
          this.model.anchor = this.map["x:Anchor"].text;
          this.model.protection.locked = this.map["x:Locked"].text;
          this.model.protection.lockText = this.map["x:LockText"].text;
        } }]);
        return VmlClientDataXform2;
      }(BaseXform);
      module2.exports = VmlClientDataXform;
    }, { "../base-xform": 32, "./style/vml-position-xform": 41, "./style/vml-protection-xform": 42, "./vml-anchor-xform": 43 }], 45: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var VmlShapeXform = require2("./vml-shape-xform");
      var VmlNotesXform = /* @__PURE__ */ function(_BaseXform11) {
        _inherits(VmlNotesXform2, _BaseXform11);
        var _super12 = _createSuper(VmlNotesXform2);
        function VmlNotesXform2() {
          var _this38;
          _classCallCheck(this, VmlNotesXform2);
          _this38 = _super12.call(this);
          _this38.map = { "v:shape": new VmlShapeXform() };
          return _this38;
        }
        _createClass(VmlNotesXform2, [{ key: "tag", get: function get() {
          return "xml";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this39 = this;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, VmlNotesXform2.DRAWING_ATTRIBUTES);
          xmlStream.openNode("o:shapelayout", { "v:ext": "edit" });
          xmlStream.leafNode("o:idmap", { "v:ext": "edit", data: 1 });
          xmlStream.closeNode();
          xmlStream.openNode("v:shapetype", { id: "_x0000_t202", coordsize: "21600,21600", "o:spt": 202, path: "m,l,21600r21600,l21600,xe" });
          xmlStream.leafNode("v:stroke", { joinstyle: "miter" });
          xmlStream.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" });
          xmlStream.closeNode();
          model.comments.forEach(function(item, index2) {
            _this39.map["v:shape"].render(xmlStream, item, index2);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { comments: [] };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.comments.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var _this40 = this;
          model.anchors.forEach(function(anchor) {
            if (anchor.br) {
              _this40.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
              _this40.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
          });
        } }]);
        return VmlNotesXform2;
      }(BaseXform);
      VmlNotesXform.DRAWING_ATTRIBUTES = { "xmlns:v": "urn:schemas-microsoft-com:vml", "xmlns:o": "urn:schemas-microsoft-com:office:office", "xmlns:x": "urn:schemas-microsoft-com:office:excel" };
      module2.exports = VmlNotesXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./vml-shape-xform": 46 }], 46: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var VmlTextboxXform = require2("./vml-textbox-xform");
      var VmlClientDataXform = require2("./vml-client-data-xform");
      var VmlShapeXform = /* @__PURE__ */ function(_BaseXform12) {
        _inherits(VmlShapeXform2, _BaseXform12);
        var _super13 = _createSuper(VmlShapeXform2);
        function VmlShapeXform2() {
          var _this41;
          _classCallCheck(this, VmlShapeXform2);
          _this41 = _super13.call(this);
          _this41.map = { "v:textbox": new VmlTextboxXform(), "x:ClientData": new VmlClientDataXform() };
          return _this41;
        }
        _createClass(VmlShapeXform2, [{ key: "tag", get: function get() {
          return "v:shape";
        } }, { key: "render", value: function render13(xmlStream, model, index2) {
          xmlStream.openNode("v:shape", VmlShapeXform2.V_SHAPE_ATTRIBUTES(model, index2));
          xmlStream.leafNode("v:fill", { color2: "infoBackground [80]" });
          xmlStream.leafNode("v:shadow", { color: "none [81]", obscured: "t" });
          xmlStream.leafNode("v:path", { "o:connecttype": "none" });
          this.map["v:textbox"].render(xmlStream, model);
          this.map["x:ClientData"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { margins: { insetmode: node.attributes["o:insetmode"] }, anchor: "", editAs: "", protection: {} };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
              this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
              this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
              this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
              return false;
            default:
              return true;
          }
        } }]);
        return VmlShapeXform2;
      }(BaseXform);
      VmlShapeXform.V_SHAPE_ATTRIBUTES = function(model, index2) {
        return { id: "_x0000_s".concat(1025 + index2), type: "#_x0000_t202", style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden", fillcolor: "infoBackground [80]", strokecolor: "none [81]", "o:insetmode": model.note.margins && model.note.margins.insetmode };
      };
      module2.exports = VmlShapeXform;
    }, { "../base-xform": 32, "./vml-client-data-xform": 44, "./vml-textbox-xform": 47 }], 47: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var VmlTextboxXform = /* @__PURE__ */ function(_BaseXform13) {
        _inherits(VmlTextboxXform2, _BaseXform13);
        var _super14 = _createSuper(VmlTextboxXform2);
        function VmlTextboxXform2() {
          _classCallCheck(this, VmlTextboxXform2);
          return _super14.apply(this, arguments);
        }
        _createClass(VmlTextboxXform2, [{ key: "tag", get: function get() {
          return "v:textbox";
        } }, { key: "conversionUnit", value: function conversionUnit(value, multiple, unit) {
          return "".concat(parseFloat(value) * multiple.toFixed(2)).concat(unit);
        } }, { key: "reverseConversionUnit", value: function reverseConversionUnit(inset) {
          var _this42 = this;
          return (inset || "").split(",").map(function(margin) {
            return Number(parseFloat(_this42.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this43 = this;
          var attributes = { style: "mso-direction-alt:auto" };
          if (model && model.note) {
            var _ref3 = model.note && model.note.margins, inset = _ref3.inset;
            if (Array.isArray(inset)) {
              inset = inset.map(function(margin) {
                return _this43.conversionUnit(margin, 10, "mm");
              }).join(",");
            }
            if (inset) {
              attributes.inset = inset;
            }
          }
          xmlStream.openNode("v:textbox", attributes);
          xmlStream.leafNode("div", { style: "text-align:left" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { inset: this.reverseConversionUnit(node.attributes.inset) };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return VmlTextboxXform2;
      }(BaseXform);
      module2.exports = VmlTextboxXform;
    }, { "../base-xform": 32 }], 48: [function(require2, module2, exports2) {
      var BaseXform = require2("./base-xform");
      var CompositeXform = /* @__PURE__ */ function(_BaseXform14) {
        _inherits(CompositeXform2, _BaseXform14);
        var _super15 = _createSuper(CompositeXform2);
        function CompositeXform2() {
          _classCallCheck(this, CompositeXform2);
          return _super15.apply(this, arguments);
        }
        _createClass(CompositeXform2, [{ key: "createNewModel", value: function createNewModel(node) {
          return {};
        } }, { key: "parseOpen", value: function parseOpen(node) {
          this.parser = this.parser || this.map[node.name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === this.tag) {
            this.model = this.createNewModel(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name] = parser.model;
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.onParserClose(name, this.parser);
              this.parser = void 0;
            }
            return true;
          }
          return name !== this.tag;
        } }]);
        return CompositeXform2;
      }(BaseXform);
      module2.exports = CompositeXform;
    }, { "./base-xform": 32 }], 49: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var AppHeadingPairsXform = /* @__PURE__ */ function(_BaseXform15) {
        _inherits(AppHeadingPairsXform2, _BaseXform15);
        var _super16 = _createSuper(AppHeadingPairsXform2);
        function AppHeadingPairsXform2() {
          _classCallCheck(this, AppHeadingPairsXform2);
          return _super16.apply(this, arguments);
        }
        _createClass(AppHeadingPairsXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("HeadingPairs");
          xmlStream.openNode("vt:vector", { size: 2, baseType: "variant" });
          xmlStream.openNode("vt:variant");
          xmlStream.leafNode("vt:lpstr", void 0, "Worksheets");
          xmlStream.closeNode();
          xmlStream.openNode("vt:variant");
          xmlStream.leafNode("vt:i4", void 0, model.length);
          xmlStream.closeNode();
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          return node.name === "HeadingPairs";
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== "HeadingPairs";
        } }]);
        return AppHeadingPairsXform2;
      }(BaseXform);
      module2.exports = AppHeadingPairsXform;
    }, { "../base-xform": 32 }], 50: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var AppTitlesOfPartsXform = /* @__PURE__ */ function(_BaseXform16) {
        _inherits(AppTitlesOfPartsXform2, _BaseXform16);
        var _super17 = _createSuper(AppTitlesOfPartsXform2);
        function AppTitlesOfPartsXform2() {
          _classCallCheck(this, AppTitlesOfPartsXform2);
          return _super17.apply(this, arguments);
        }
        _createClass(AppTitlesOfPartsXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("TitlesOfParts");
          xmlStream.openNode("vt:vector", { size: model.length, baseType: "lpstr" });
          model.forEach(function(sheet) {
            xmlStream.leafNode("vt:lpstr", void 0, sheet.name);
          });
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          return node.name === "TitlesOfParts";
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== "TitlesOfParts";
        } }]);
        return AppTitlesOfPartsXform2;
      }(BaseXform);
      module2.exports = AppTitlesOfPartsXform;
    }, { "../base-xform": 32 }], 51: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StringXform = require2("../simple/string-xform");
      var AppHeadingPairsXform = require2("./app-heading-pairs-xform");
      var AppTitleOfPartsXform = require2("./app-titles-of-parts-xform");
      var AppXform = /* @__PURE__ */ function(_BaseXform17) {
        _inherits(AppXform2, _BaseXform17);
        var _super18 = _createSuper(AppXform2);
        function AppXform2() {
          var _this44;
          _classCallCheck(this, AppXform2);
          _this44 = _super18.call(this);
          _this44.map = { Company: new StringXform({ tag: "Company" }), Manager: new StringXform({ tag: "Manager" }), HeadingPairs: new AppHeadingPairsXform(), TitleOfParts: new AppTitleOfPartsXform() };
          return _this44;
        }
        _createClass(AppXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Properties", AppXform2.PROPERTY_ATTRIBUTES);
          xmlStream.leafNode("Application", void 0, "Microsoft Excel");
          xmlStream.leafNode("DocSecurity", void 0, "0");
          xmlStream.leafNode("ScaleCrop", void 0, "false");
          this.map.HeadingPairs.render(xmlStream, model.worksheets);
          this.map.TitleOfParts.render(xmlStream, model.worksheets);
          this.map.Company.render(xmlStream, model.company || "");
          this.map.Manager.render(xmlStream, model.manager);
          xmlStream.leafNode("LinksUpToDate", void 0, "false");
          xmlStream.leafNode("SharedDoc", void 0, "false");
          xmlStream.leafNode("HyperlinksChanged", void 0, "false");
          xmlStream.leafNode("AppVersion", void 0, "16.0300");
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "Properties":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "Properties":
              this.model = { worksheets: this.map.TitleOfParts.model, company: this.map.Company.model, manager: this.map.Manager.model };
              return false;
            default:
              return true;
          }
        } }]);
        return AppXform2;
      }(BaseXform);
      AppXform.DateFormat = function(dt) {
        return dt.toISOString().replace(/[.]\d{3,6}/, "");
      };
      AppXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
      AppXform.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties", "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes" };
      module2.exports = AppXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../simple/string-xform": 119, "./app-heading-pairs-xform": 49, "./app-titles-of-parts-xform": 50 }], 52: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var ContentTypesXform = /* @__PURE__ */ function(_BaseXform18) {
        _inherits(ContentTypesXform2, _BaseXform18);
        var _super19 = _createSuper(ContentTypesXform2);
        function ContentTypesXform2() {
          _classCallCheck(this, ContentTypesXform2);
          return _super19.apply(this, arguments);
        }
        _createClass(ContentTypesXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Types", ContentTypesXform2.PROPERTY_ATTRIBUTES);
          var mediaHash = {};
          (model.media || []).forEach(function(medium) {
            if (medium.type === "image") {
              var imageType = medium.extension;
              if (!mediaHash[imageType]) {
                mediaHash[imageType] = true;
                xmlStream.leafNode("Default", { Extension: imageType, ContentType: "image/".concat(imageType) });
              }
            }
          });
          xmlStream.leafNode("Default", { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" });
          xmlStream.leafNode("Default", { Extension: "xml", ContentType: "application/xml" });
          xmlStream.leafNode("Override", { PartName: "/xl/workbook.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" });
          model.worksheets.forEach(function(worksheet) {
            var name = "/xl/worksheets/sheet".concat(worksheet.id, ".xml");
            xmlStream.leafNode("Override", { PartName: name, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" });
          });
          xmlStream.leafNode("Override", { PartName: "/xl/theme/theme1.xml", ContentType: "application/vnd.openxmlformats-officedocument.theme+xml" });
          xmlStream.leafNode("Override", { PartName: "/xl/styles.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" });
          var hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
          if (hasSharedStrings) {
            xmlStream.leafNode("Override", { PartName: "/xl/sharedStrings.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" });
          }
          if (model.tables) {
            model.tables.forEach(function(table) {
              xmlStream.leafNode("Override", { PartName: "/xl/tables/".concat(table.target), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml" });
            });
          }
          if (model.drawings) {
            model.drawings.forEach(function(drawing) {
              xmlStream.leafNode("Override", { PartName: "/xl/drawings/".concat(drawing.name, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml" });
            });
          }
          if (model.commentRefs) {
            xmlStream.leafNode("Default", { Extension: "vml", ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing" });
            model.commentRefs.forEach(function(_ref) {
              var commentName = _ref.commentName;
              xmlStream.leafNode("Override", { PartName: "/xl/".concat(commentName, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml" });
            });
          }
          xmlStream.leafNode("Override", { PartName: "/docProps/core.xml", ContentType: "application/vnd.openxmlformats-package.core-properties+xml" });
          xmlStream.leafNode("Override", { PartName: "/docProps/app.xml", ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen() {
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ContentTypesXform2;
      }(BaseXform);
      ContentTypesXform.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/content-types" };
      module2.exports = ContentTypesXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32 }], 53: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var DateXform = require2("../simple/date-xform");
      var StringXform = require2("../simple/string-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var CoreXform = /* @__PURE__ */ function(_BaseXform19) {
        _inherits(CoreXform2, _BaseXform19);
        var _super20 = _createSuper(CoreXform2);
        function CoreXform2() {
          var _this45;
          _classCallCheck(this, CoreXform2);
          _this45 = _super20.call(this);
          _this45.map = { "dc:creator": new StringXform({ tag: "dc:creator" }), "dc:title": new StringXform({ tag: "dc:title" }), "dc:subject": new StringXform({ tag: "dc:subject" }), "dc:description": new StringXform({ tag: "dc:description" }), "dc:identifier": new StringXform({ tag: "dc:identifier" }), "dc:language": new StringXform({ tag: "dc:language" }), "cp:keywords": new StringXform({ tag: "cp:keywords" }), "cp:category": new StringXform({ tag: "cp:category" }), "cp:lastModifiedBy": new StringXform({ tag: "cp:lastModifiedBy" }), "cp:lastPrinted": new DateXform({ tag: "cp:lastPrinted", format: CoreXform2.DateFormat }), "cp:revision": new IntegerXform({ tag: "cp:revision" }), "cp:version": new StringXform({ tag: "cp:version" }), "cp:contentStatus": new StringXform({ tag: "cp:contentStatus" }), "cp:contentType": new StringXform({ tag: "cp:contentType" }), "dcterms:created": new DateXform({ tag: "dcterms:created", attrs: CoreXform2.DateAttrs, format: CoreXform2.DateFormat }), "dcterms:modified": new DateXform({ tag: "dcterms:modified", attrs: CoreXform2.DateAttrs, format: CoreXform2.DateFormat }) };
          return _this45;
        }
        _createClass(CoreXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("cp:coreProperties", CoreXform2.CORE_PROPERTY_ATTRIBUTES);
          this.map["dc:creator"].render(xmlStream, model.creator);
          this.map["dc:title"].render(xmlStream, model.title);
          this.map["dc:subject"].render(xmlStream, model.subject);
          this.map["dc:description"].render(xmlStream, model.description);
          this.map["dc:identifier"].render(xmlStream, model.identifier);
          this.map["dc:language"].render(xmlStream, model.language);
          this.map["cp:keywords"].render(xmlStream, model.keywords);
          this.map["cp:category"].render(xmlStream, model.category);
          this.map["cp:lastModifiedBy"].render(xmlStream, model.lastModifiedBy);
          this.map["cp:lastPrinted"].render(xmlStream, model.lastPrinted);
          this.map["cp:revision"].render(xmlStream, model.revision);
          this.map["cp:version"].render(xmlStream, model.version);
          this.map["cp:contentStatus"].render(xmlStream, model.contentStatus);
          this.map["cp:contentType"].render(xmlStream, model.contentType);
          this.map["dcterms:created"].render(xmlStream, model.created);
          this.map["dcterms:modified"].render(xmlStream, model.modified);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "cp:coreProperties":
            case "coreProperties":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "cp:coreProperties":
            case "coreProperties":
              this.model = { creator: this.map["dc:creator"].model, title: this.map["dc:title"].model, subject: this.map["dc:subject"].model, description: this.map["dc:description"].model, identifier: this.map["dc:identifier"].model, language: this.map["dc:language"].model, keywords: this.map["cp:keywords"].model, category: this.map["cp:category"].model, lastModifiedBy: this.map["cp:lastModifiedBy"].model, lastPrinted: this.map["cp:lastPrinted"].model, revision: this.map["cp:revision"].model, contentStatus: this.map["cp:contentStatus"].model, contentType: this.map["cp:contentType"].model, created: this.map["dcterms:created"].model, modified: this.map["dcterms:modified"].model };
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return CoreXform2;
      }(BaseXform);
      CoreXform.DateFormat = function(dt) {
        return dt.toISOString().replace(/[.]\d{3}/, "");
      };
      CoreXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
      CoreXform.CORE_PROPERTY_ATTRIBUTES = { "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties", "xmlns:dc": "http://purl.org/dc/elements/1.1/", "xmlns:dcterms": "http://purl.org/dc/terms/", "xmlns:dcmitype": "http://purl.org/dc/dcmitype/", "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance" };
      module2.exports = CoreXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../simple/date-xform": 117, "../simple/integer-xform": 118, "../simple/string-xform": 119 }], 54: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var RelationshipXform = /* @__PURE__ */ function(_BaseXform20) {
        _inherits(RelationshipXform2, _BaseXform20);
        var _super21 = _createSuper(RelationshipXform2);
        function RelationshipXform2() {
          _classCallCheck(this, RelationshipXform2);
          return _super21.apply(this, arguments);
        }
        _createClass(RelationshipXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("Relationship", model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "Relationship":
              this.model = node.attributes;
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return RelationshipXform2;
      }(BaseXform);
      module2.exports = RelationshipXform;
    }, { "../base-xform": 32 }], 55: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var RelationshipXform = require2("./relationship-xform");
      var RelationshipsXform = /* @__PURE__ */ function(_BaseXform21) {
        _inherits(RelationshipsXform2, _BaseXform21);
        var _super22 = _createSuper(RelationshipsXform2);
        function RelationshipsXform2() {
          var _this46;
          _classCallCheck(this, RelationshipsXform2);
          _this46 = _super22.call(this);
          _this46.map = { Relationship: new RelationshipXform() };
          return _this46;
        }
        _createClass(RelationshipsXform2, [{ key: "render", value: function render13(xmlStream, model) {
          var _this47 = this;
          model = model || this._values;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Relationships", RelationshipsXform2.RELATIONSHIPS_ATTRIBUTES);
          model.forEach(function(relationship) {
            _this47.map.Relationship.render(xmlStream, relationship);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "Relationships":
              this.model = [];
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "Relationships":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return RelationshipsXform2;
      }(BaseXform);
      RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/relationships" };
      module2.exports = RelationshipsXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./relationship-xform": 54 }], 56: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var BaseCellAnchorXform = /* @__PURE__ */ function(_BaseXform22) {
        _inherits(BaseCellAnchorXform2, _BaseXform22);
        var _super23 = _createSuper(BaseCellAnchorXform2);
        function BaseCellAnchorXform2() {
          _classCallCheck(this, BaseCellAnchorXform2);
          return _super23.apply(this, arguments);
        }
        _createClass(BaseCellAnchorXform2, [{ key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { range: { editAs: node.attributes.editAs || "oneCell" } };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "reconcilePicture", value: function reconcilePicture(model, options) {
          if (model && model.rId) {
            var rel = options.rels[model.rId];
            var match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
            if (match) {
              var name = match[1];
              var mediaId = options.mediaIndex[name];
              return options.media[mediaId];
            }
          }
          return void 0;
        } }]);
        return BaseCellAnchorXform2;
      }(BaseXform);
      module2.exports = BaseCellAnchorXform;
    }, { "../base-xform": 32 }], 57: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var BlipXform = require2("./blip-xform");
      var BlipFillXform = /* @__PURE__ */ function(_BaseXform23) {
        _inherits(BlipFillXform2, _BaseXform23);
        var _super24 = _createSuper(BlipFillXform2);
        function BlipFillXform2() {
          var _this48;
          _classCallCheck(this, BlipFillXform2);
          _this48 = _super24.call(this);
          _this48.map = { "a:blip": new BlipXform() };
          return _this48;
        }
        _createClass(BlipFillXform2, [{ key: "tag", get: function get() {
          return "xdr:blipFill";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["a:blip"].render(xmlStream, model);
          xmlStream.openNode("a:stretch");
          xmlStream.leafNode("a:fillRect");
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["a:blip"].model;
              return false;
            default:
              return true;
          }
        } }]);
        return BlipFillXform2;
      }(BaseXform);
      module2.exports = BlipFillXform;
    }, { "../base-xform": 32, "./blip-xform": 58 }], 58: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var BlipXform = /* @__PURE__ */ function(_BaseXform24) {
        _inherits(BlipXform2, _BaseXform24);
        var _super25 = _createSuper(BlipXform2);
        function BlipXform2() {
          _classCallCheck(this, BlipXform2);
          return _super25.apply(this, arguments);
        }
        _createClass(BlipXform2, [{ key: "tag", get: function get() {
          return "a:blip";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:embed": model.rId, cstate: "print" });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:embed"] };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return BlipXform2;
      }(BaseXform);
      module2.exports = BlipXform;
    }, { "../base-xform": 32 }], 59: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var CNvPicPrXform = /* @__PURE__ */ function(_BaseXform25) {
        _inherits(CNvPicPrXform2, _BaseXform25);
        var _super26 = _createSuper(CNvPicPrXform2);
        function CNvPicPrXform2() {
          _classCallCheck(this, CNvPicPrXform2);
          return _super26.apply(this, arguments);
        }
        _createClass(CNvPicPrXform2, [{ key: "tag", get: function get() {
          return "xdr:cNvPicPr";
        } }, { key: "render", value: function render13(xmlStream) {
          xmlStream.openNode(this.tag);
          xmlStream.leafNode("a:picLocks", { noChangeAspect: "1" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return CNvPicPrXform2;
      }(BaseXform);
      module2.exports = CNvPicPrXform;
    }, { "../base-xform": 32 }], 60: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var HlickClickXform = require2("./hlink-click-xform");
      var ExtLstXform = require2("./ext-lst-xform");
      var CNvPrXform = /* @__PURE__ */ function(_BaseXform26) {
        _inherits(CNvPrXform2, _BaseXform26);
        var _super27 = _createSuper(CNvPrXform2);
        function CNvPrXform2() {
          var _this49;
          _classCallCheck(this, CNvPrXform2);
          _this49 = _super27.call(this);
          _this49.map = { "a:hlinkClick": new HlickClickXform(), "a:extLst": new ExtLstXform() };
          return _this49;
        }
        _createClass(CNvPrXform2, [{ key: "tag", get: function get() {
          return "xdr:cNvPr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { id: model.index, name: "Picture ".concat(model.index) });
          this.map["a:hlinkClick"].render(xmlStream, model);
          this.map["a:extLst"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["a:hlinkClick"].model;
              return false;
            default:
              return true;
          }
        } }]);
        return CNvPrXform2;
      }(BaseXform);
      module2.exports = CNvPrXform;
    }, { "../base-xform": 32, "./ext-lst-xform": 63, "./hlink-click-xform": 65 }], 61: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var CellPositionXform = /* @__PURE__ */ function(_BaseXform27) {
        _inherits(CellPositionXform2, _BaseXform27);
        var _super28 = _createSuper(CellPositionXform2);
        function CellPositionXform2(options) {
          var _this50;
          _classCallCheck(this, CellPositionXform2);
          _this50 = _super28.call(this);
          _this50.tag = options.tag;
          _this50.map = { "xdr:col": new IntegerXform({ tag: "xdr:col", zero: true }), "xdr:colOff": new IntegerXform({ tag: "xdr:colOff", zero: true }), "xdr:row": new IntegerXform({ tag: "xdr:row", zero: true }), "xdr:rowOff": new IntegerXform({ tag: "xdr:rowOff", zero: true }) };
          return _this50;
        }
        _createClass(CellPositionXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:col"].render(xmlStream, model.nativeCol);
          this.map["xdr:colOff"].render(xmlStream, model.nativeColOff);
          this.map["xdr:row"].render(xmlStream, model.nativeRow);
          this.map["xdr:rowOff"].render(xmlStream, model.nativeRowOff);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = { nativeCol: this.map["xdr:col"].model, nativeColOff: this.map["xdr:colOff"].model, nativeRow: this.map["xdr:row"].model, nativeRowOff: this.map["xdr:rowOff"].model };
              return false;
            default:
              return true;
          }
        } }]);
        return CellPositionXform2;
      }(BaseXform);
      module2.exports = CellPositionXform;
    }, { "../base-xform": 32, "../simple/integer-xform": 118 }], 62: [function(require2, module2, exports2) {
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var TwoCellAnchorXform = require2("./two-cell-anchor-xform");
      var OneCellAnchorXform = require2("./one-cell-anchor-xform");
      function getAnchorType(model) {
        var range = typeof model.range === "string" ? colCache.decode(model.range) : model.range;
        return range.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
      }
      var DrawingXform = /* @__PURE__ */ function(_BaseXform28) {
        _inherits(DrawingXform2, _BaseXform28);
        var _super29 = _createSuper(DrawingXform2);
        function DrawingXform2() {
          var _this51;
          _classCallCheck(this, DrawingXform2);
          _this51 = _super29.call(this);
          _this51.map = { "xdr:twoCellAnchor": new TwoCellAnchorXform(), "xdr:oneCellAnchor": new OneCellAnchorXform() };
          return _this51;
        }
        _createClass(DrawingXform2, [{ key: "prepare", value: function prepare(model) {
          var _this52 = this;
          model.anchors.forEach(function(item, index2) {
            item.anchorType = getAnchorType(item);
            var anchor = _this52.map[item.anchorType];
            anchor.prepare(item, { index: index2 });
          });
        } }, { key: "tag", get: function get() {
          return "xdr:wsDr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this53 = this;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, DrawingXform2.DRAWING_ATTRIBUTES);
          model.anchors.forEach(function(item) {
            var anchor = _this53.map[item.anchorType];
            anchor.render(xmlStream, item);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { anchors: [] };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.anchors.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var _this54 = this;
          model.anchors.forEach(function(anchor) {
            if (anchor.br) {
              _this54.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
              _this54.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
          });
        } }]);
        return DrawingXform2;
      }(BaseXform);
      DrawingXform.DRAWING_ATTRIBUTES = { "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing", "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main" };
      module2.exports = DrawingXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/xml-stream": 28, "../base-xform": 32, "./one-cell-anchor-xform": 67, "./two-cell-anchor-xform": 70 }], 63: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var ExtLstXform = /* @__PURE__ */ function(_BaseXform29) {
        _inherits(ExtLstXform2, _BaseXform29);
        var _super30 = _createSuper(ExtLstXform2);
        function ExtLstXform2() {
          _classCallCheck(this, ExtLstXform2);
          return _super30.apply(this, arguments);
        }
        _createClass(ExtLstXform2, [{ key: "tag", get: function get() {
          return "a:extLst";
        } }, { key: "render", value: function render13(xmlStream) {
          xmlStream.openNode(this.tag);
          xmlStream.openNode("a:ext", { uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}" });
          xmlStream.leafNode("a16:creationId", { "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main", id: "{00000000-0008-0000-0000-000002000000}" });
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return ExtLstXform2;
      }(BaseXform);
      module2.exports = ExtLstXform;
    }, { "../base-xform": 32 }], 64: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var EMU_PER_PIXEL_AT_96_DPI = 9525;
      var ExtXform = /* @__PURE__ */ function(_BaseXform30) {
        _inherits(ExtXform2, _BaseXform30);
        var _super31 = _createSuper(ExtXform2);
        function ExtXform2(options) {
          var _this55;
          _classCallCheck(this, ExtXform2);
          _this55 = _super31.call(this);
          _this55.tag = options.tag;
          _this55.map = {};
          return _this55;
        }
        _createClass(ExtXform2, [{ key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          var width2 = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
          var height2 = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
          xmlStream.addAttribute("cx", width2);
          xmlStream.addAttribute("cy", height2);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { width: parseInt(node.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI, height: parseInt(node.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ExtXform2;
      }(BaseXform);
      module2.exports = ExtXform;
    }, { "../base-xform": 32 }], 65: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var HLinkClickXform = /* @__PURE__ */ function(_BaseXform31) {
        _inherits(HLinkClickXform2, _BaseXform31);
        var _super32 = _createSuper(HLinkClickXform2);
        function HLinkClickXform2() {
          _classCallCheck(this, HLinkClickXform2);
          return _super32.apply(this, arguments);
        }
        _createClass(HLinkClickXform2, [{ key: "tag", get: function get() {
          return "a:hlinkClick";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (!(model.hyperlinks && model.hyperlinks.rId)) {
            return;
          }
          xmlStream.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:id": model.hyperlinks.rId, tooltip: model.hyperlinks.tooltip });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { hyperlinks: { rId: node.attributes["r:id"], tooltip: node.attributes.tooltip } };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return HLinkClickXform2;
      }(BaseXform);
      module2.exports = HLinkClickXform;
    }, { "../base-xform": 32 }], 66: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var CNvPrXform = require2("./c-nv-pr-xform");
      var CNvPicPrXform = require2("./c-nv-pic-pr-xform");
      var NvPicPrXform = /* @__PURE__ */ function(_BaseXform32) {
        _inherits(NvPicPrXform2, _BaseXform32);
        var _super33 = _createSuper(NvPicPrXform2);
        function NvPicPrXform2() {
          var _this56;
          _classCallCheck(this, NvPicPrXform2);
          _this56 = _super33.call(this);
          _this56.map = { "xdr:cNvPr": new CNvPrXform(), "xdr:cNvPicPr": new CNvPicPrXform() };
          return _this56;
        }
        _createClass(NvPicPrXform2, [{ key: "tag", get: function get() {
          return "xdr:nvPicPr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:cNvPr"].render(xmlStream, model);
          this.map["xdr:cNvPicPr"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["xdr:cNvPr"].model;
              return false;
            default:
              return true;
          }
        } }]);
        return NvPicPrXform2;
      }(BaseXform);
      module2.exports = NvPicPrXform;
    }, { "../base-xform": 32, "./c-nv-pic-pr-xform": 59, "./c-nv-pr-xform": 60 }], 67: [function(require2, module2, exports2) {
      var BaseCellAnchorXform = require2("./base-cell-anchor-xform");
      var StaticXform = require2("../static-xform");
      var CellPositionXform = require2("./cell-position-xform");
      var ExtXform = require2("./ext-xform");
      var PicXform = require2("./pic-xform");
      var OneCellAnchorXform = /* @__PURE__ */ function(_BaseCellAnchorXform) {
        _inherits(OneCellAnchorXform2, _BaseCellAnchorXform);
        var _super34 = _createSuper(OneCellAnchorXform2);
        function OneCellAnchorXform2() {
          var _this57;
          _classCallCheck(this, OneCellAnchorXform2);
          _this57 = _super34.call(this);
          _this57.map = { "xdr:from": new CellPositionXform({ tag: "xdr:from" }), "xdr:ext": new ExtXform({ tag: "xdr:ext" }), "xdr:pic": new PicXform(), "xdr:clientData": new StaticXform({ tag: "xdr:clientData" }) };
          return _this57;
        }
        _createClass(OneCellAnchorXform2, [{ key: "tag", get: function get() {
          return "xdr:oneCellAnchor";
        } }, { key: "prepare", value: function prepare(model, options) {
          this.map["xdr:pic"].prepare(model.picture, options);
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
          this.map["xdr:from"].render(xmlStream, model.range.tl);
          this.map["xdr:ext"].render(xmlStream, model.range.ext);
          this.map["xdr:pic"].render(xmlStream, model.picture);
          this.map["xdr:clientData"].render(xmlStream, {});
          xmlStream.closeNode();
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.range.tl = this.map["xdr:from"].model;
              this.model.range.ext = this.map["xdr:ext"].model;
              this.model.picture = this.map["xdr:pic"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.medium = this.reconcilePicture(model.picture, options);
        } }]);
        return OneCellAnchorXform2;
      }(BaseCellAnchorXform);
      module2.exports = OneCellAnchorXform;
    }, { "../static-xform": 120, "./base-cell-anchor-xform": 56, "./cell-position-xform": 61, "./ext-xform": 64, "./pic-xform": 68 }], 68: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var BlipFillXform = require2("./blip-fill-xform");
      var NvPicPrXform = require2("./nv-pic-pr-xform");
      var spPrJSON = require2("./sp-pr");
      var PicXform = /* @__PURE__ */ function(_BaseXform33) {
        _inherits(PicXform2, _BaseXform33);
        var _super35 = _createSuper(PicXform2);
        function PicXform2() {
          var _this58;
          _classCallCheck(this, PicXform2);
          _this58 = _super35.call(this);
          _this58.map = { "xdr:nvPicPr": new NvPicPrXform(), "xdr:blipFill": new BlipFillXform(), "xdr:spPr": new StaticXform(spPrJSON) };
          return _this58;
        }
        _createClass(PicXform2, [{ key: "tag", get: function get() {
          return "xdr:pic";
        } }, { key: "prepare", value: function prepare(model, options) {
          model.index = options.index + 1;
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:nvPicPr"].render(xmlStream, model);
          this.map["xdr:blipFill"].render(xmlStream, model);
          this.map["xdr:spPr"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.mergeModel(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return PicXform2;
      }(BaseXform);
      module2.exports = PicXform;
    }, { "../base-xform": 32, "../static-xform": 120, "./blip-fill-xform": 57, "./nv-pic-pr-xform": 66, "./sp-pr": 69 }], 69: [function(require2, module2, exports2) {
      module2.exports = { tag: "xdr:spPr", c: [{ tag: "a:xfrm", c: [{ tag: "a:off", $: { x: "0", y: "0" } }, { tag: "a:ext", $: { cx: "0", cy: "0" } }] }, { tag: "a:prstGeom", $: { prst: "rect" }, c: [{ tag: "a:avLst" }] }] };
    }, {}], 70: [function(require2, module2, exports2) {
      var BaseCellAnchorXform = require2("./base-cell-anchor-xform");
      var StaticXform = require2("../static-xform");
      var CellPositionXform = require2("./cell-position-xform");
      var PicXform = require2("./pic-xform");
      var TwoCellAnchorXform = /* @__PURE__ */ function(_BaseCellAnchorXform2) {
        _inherits(TwoCellAnchorXform2, _BaseCellAnchorXform2);
        var _super36 = _createSuper(TwoCellAnchorXform2);
        function TwoCellAnchorXform2() {
          var _this59;
          _classCallCheck(this, TwoCellAnchorXform2);
          _this59 = _super36.call(this);
          _this59.map = { "xdr:from": new CellPositionXform({ tag: "xdr:from" }), "xdr:to": new CellPositionXform({ tag: "xdr:to" }), "xdr:pic": new PicXform(), "xdr:clientData": new StaticXform({ tag: "xdr:clientData" }) };
          return _this59;
        }
        _createClass(TwoCellAnchorXform2, [{ key: "tag", get: function get() {
          return "xdr:twoCellAnchor";
        } }, { key: "prepare", value: function prepare(model, options) {
          this.map["xdr:pic"].prepare(model.picture, options);
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
          this.map["xdr:from"].render(xmlStream, model.range.tl);
          this.map["xdr:to"].render(xmlStream, model.range.br);
          this.map["xdr:pic"].render(xmlStream, model.picture);
          this.map["xdr:clientData"].render(xmlStream, {});
          xmlStream.closeNode();
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.range.tl = this.map["xdr:from"].model;
              this.model.range.br = this.map["xdr:to"].model;
              this.model.picture = this.map["xdr:pic"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.medium = this.reconcilePicture(model.picture, options);
        } }]);
        return TwoCellAnchorXform2;
      }(BaseCellAnchorXform);
      module2.exports = TwoCellAnchorXform;
    }, { "../static-xform": 120, "./base-cell-anchor-xform": 56, "./cell-position-xform": 61, "./pic-xform": 68 }], 71: [function(require2, module2, exports2) {
      var BaseXform = require2("./base-xform");
      var ListXform = /* @__PURE__ */ function(_BaseXform34) {
        _inherits(ListXform2, _BaseXform34);
        var _super37 = _createSuper(ListXform2);
        function ListXform2(options) {
          var _this60;
          _classCallCheck(this, ListXform2);
          _this60 = _super37.call(this);
          _this60.tag = options.tag;
          _this60.always = !!options.always;
          _this60.count = options.count;
          _this60.empty = options.empty;
          _this60.$count = options.$count || "count";
          _this60.$ = options.$;
          _this60.childXform = options.childXform;
          _this60.maxItems = options.maxItems;
          return _this60;
        }
        _createClass(ListXform2, [{ key: "prepare", value: function prepare(model, options) {
          var childXform = this.childXform;
          if (model) {
            model.forEach(function(childModel, index2) {
              options.index = index2;
              childXform.prepare(childModel, options);
            });
          }
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (this.always || model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
              xmlStream.addAttribute(this.$count, model && model.length || 0);
            }
            var childXform = this.childXform;
            (model || []).forEach(function(childModel, index2) {
              childXform.render(xmlStream, childModel, index2);
            });
            xmlStream.closeNode();
          } else if (this.empty) {
            xmlStream.leafNode(this.tag);
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.model = [];
              return true;
            default:
              if (this.childXform.parseOpen(node)) {
                this.parser = this.childXform;
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
              if (this.maxItems && this.model.length > this.maxItems) {
                throw new Error("Max ".concat(this.childXform.tag, " count (").concat(this.maxItems, ") exceeded"));
              }
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          if (model) {
            var childXform = this.childXform;
            model.forEach(function(childModel) {
              childXform.reconcile(childModel, options);
            });
          }
        } }]);
        return ListXform2;
      }(BaseXform);
      module2.exports = ListXform;
    }, { "./base-xform": 32 }], 72: [function(require2, module2, exports2) {
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var AutoFilterXform = /* @__PURE__ */ function(_BaseXform35) {
        _inherits(AutoFilterXform2, _BaseXform35);
        var _super38 = _createSuper(AutoFilterXform2);
        function AutoFilterXform2() {
          _classCallCheck(this, AutoFilterXform2);
          return _super38.apply(this, arguments);
        }
        _createClass(AutoFilterXform2, [{ key: "tag", get: function get() {
          return "autoFilter";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            if (typeof model === "string") {
              xmlStream.leafNode("autoFilter", { ref: model });
            } else {
              var getAddress = function getAddress2(addr) {
                if (typeof addr === "string") {
                  return addr;
                }
                return colCache.getAddress(addr.row, addr.column).address;
              };
              var firstAddress = getAddress(model.from);
              var secondAddress = getAddress(model.to);
              if (firstAddress && secondAddress) {
                xmlStream.leafNode("autoFilter", { ref: "".concat(firstAddress, ":").concat(secondAddress) });
              }
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "autoFilter") {
            this.model = node.attributes.ref;
          }
        } }]);
        return AutoFilterXform2;
      }(BaseXform);
      module2.exports = AutoFilterXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 73: [function(require2, module2, exports2) {
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var Range = require2("../../../doc/range");
      var Enums = require2("../../../doc/enums");
      var RichTextXform = require2("../strings/rich-text-xform");
      function getValueType(v) {
        if (v === null || v === void 0) {
          return Enums.ValueType.Null;
        }
        if (v instanceof String || typeof v === "string") {
          return Enums.ValueType.String;
        }
        if (typeof v === "number") {
          return Enums.ValueType.Number;
        }
        if (typeof v === "boolean") {
          return Enums.ValueType.Boolean;
        }
        if (v instanceof Date) {
          return Enums.ValueType.Date;
        }
        if (v.text && v.hyperlink) {
          return Enums.ValueType.Hyperlink;
        }
        if (v.formula) {
          return Enums.ValueType.Formula;
        }
        if (v.error) {
          return Enums.ValueType.Error;
        }
        throw new Error("I could not understand type of value");
      }
      function getEffectiveCellType(cell) {
        switch (cell.type) {
          case Enums.ValueType.Formula:
            return getValueType(cell.result);
          default:
            return cell.type;
        }
      }
      var CellXform = /* @__PURE__ */ function(_BaseXform36) {
        _inherits(CellXform2, _BaseXform36);
        var _super39 = _createSuper(CellXform2);
        function CellXform2() {
          var _this61;
          _classCallCheck(this, CellXform2);
          _this61 = _super39.call(this);
          _this61.richTextXForm = new RichTextXform();
          return _this61;
        }
        _createClass(CellXform2, [{ key: "tag", get: function get() {
          return "c";
        } }, { key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
          if (styleId) {
            model.styleId = styleId;
          }
          if (model.comment) {
            options.comments.push(_objectSpread2(_objectSpread2({}, model.comment), {}, { ref: model.address }));
          }
          switch (model.type) {
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
              if (options.sharedStrings) {
                model.ssId = options.sharedStrings.add(model.value);
              }
              break;
            case Enums.ValueType.Date:
              if (options.date1904) {
                model.date1904 = true;
              }
              break;
            case Enums.ValueType.Hyperlink:
              if (options.sharedStrings && model.text !== void 0 && model.text !== null) {
                model.ssId = options.sharedStrings.add(model.text);
              }
              options.hyperlinks.push({ address: model.address, target: model.hyperlink, tooltip: model.tooltip });
              break;
            case Enums.ValueType.Merge:
              options.merges.add(model);
              break;
            case Enums.ValueType.Formula:
              if (options.date1904) {
                model.date1904 = true;
              }
              if (model.shareType === "shared") {
                model.si = options.siFormulae++;
              }
              if (model.formula) {
                options.formulae[model.address] = model;
              } else if (model.sharedFormula) {
                var master = options.formulae[model.sharedFormula];
                if (!master) {
                  throw new Error("Shared Formula master must exist above and or left of clone for cell ".concat(model.address));
                }
                if (master.si === void 0) {
                  master.shareType = "shared";
                  master.si = options.siFormulae++;
                  master.range = new Range(master.address, model.address);
                } else if (master.range) {
                  master.range.expandToAddress(model.address);
                }
                model.si = master.si;
              }
              break;
          }
        } }, { key: "renderFormula", value: function renderFormula(xmlStream, model) {
          var attrs = null;
          switch (model.shareType) {
            case "shared":
              attrs = { t: "shared", ref: model.ref || model.range.range, si: model.si };
              break;
            case "array":
              attrs = { t: "array", ref: model.ref };
              break;
            default:
              if (model.si !== void 0) {
                attrs = { t: "shared", si: model.si };
              }
              break;
          }
          switch (getValueType(model.result)) {
            case Enums.ValueType.Null:
              xmlStream.leafNode("f", attrs, model.formula);
              break;
            case Enums.ValueType.String:
              xmlStream.addAttribute("t", "str");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result);
              break;
            case Enums.ValueType.Number:
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result);
              break;
            case Enums.ValueType.Boolean:
              xmlStream.addAttribute("t", "b");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result ? 1 : 0);
              break;
            case Enums.ValueType.Error:
              xmlStream.addAttribute("t", "e");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result.error);
              break;
            case Enums.ValueType.Date:
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, utils.dateToExcel(model.result, model.date1904));
              break;
            default:
              throw new Error("I could not understand type of value");
          }
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this62 = this;
          if (model.type === Enums.ValueType.Null && !model.styleId) {
            return;
          }
          xmlStream.openNode("c");
          xmlStream.addAttribute("r", model.address);
          if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
          }
          switch (model.type) {
            case Enums.ValueType.Null:
              break;
            case Enums.ValueType.Number:
              xmlStream.leafNode("v", null, model.value);
              break;
            case Enums.ValueType.Boolean:
              xmlStream.addAttribute("t", "b");
              xmlStream.leafNode("v", null, model.value ? "1" : "0");
              break;
            case Enums.ValueType.Error:
              xmlStream.addAttribute("t", "e");
              xmlStream.leafNode("v", null, model.value.error);
              break;
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
              if (model.ssId !== void 0) {
                xmlStream.addAttribute("t", "s");
                xmlStream.leafNode("v", null, model.ssId);
              } else if (model.value && model.value.richText) {
                xmlStream.addAttribute("t", "inlineStr");
                xmlStream.openNode("is");
                model.value.richText.forEach(function(text) {
                  _this62.richTextXForm.render(xmlStream, text);
                });
                xmlStream.closeNode("is");
              } else {
                xmlStream.addAttribute("t", "str");
                xmlStream.leafNode("v", null, model.value);
              }
              break;
            case Enums.ValueType.Date:
              xmlStream.leafNode("v", null, utils.dateToExcel(model.value, model.date1904));
              break;
            case Enums.ValueType.Hyperlink:
              if (model.ssId !== void 0) {
                xmlStream.addAttribute("t", "s");
                xmlStream.leafNode("v", null, model.ssId);
              } else {
                xmlStream.addAttribute("t", "str");
                xmlStream.leafNode("v", null, model.text);
              }
              break;
            case Enums.ValueType.Formula:
              this.renderFormula(xmlStream, model);
              break;
            case Enums.ValueType.Merge:
              break;
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "c":
              this.model = { address: node.attributes.r };
              this.t = node.attributes.t;
              if (node.attributes.s) {
                this.model.styleId = parseInt(node.attributes.s, 10);
              }
              return true;
            case "f":
              this.currentNode = "f";
              this.model.si = node.attributes.si;
              this.model.shareType = node.attributes.t;
              this.model.ref = node.attributes.ref;
              return true;
            case "v":
              this.currentNode = "v";
              return true;
            case "t":
              this.currentNode = "t";
              return true;
            case "r":
              this.parser = this.richTextXForm;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
            return;
          }
          switch (this.currentNode) {
            case "f":
              this.model.formula = this.model.formula ? this.model.formula + text : text;
              break;
            case "v":
            case "t":
              if (this.model.value && this.model.value.richText) {
                this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
              } else {
                this.model.value = this.model.value ? this.model.value + text : text;
              }
              break;
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case "c": {
              var model = this.model;
              if (model.formula || model.shareType) {
                model.type = Enums.ValueType.Formula;
                if (model.value) {
                  if (this.t === "str") {
                    model.result = utils.xmlDecode(model.value);
                  } else if (this.t === "b") {
                    model.result = parseInt(model.value, 10) !== 0;
                  } else if (this.t === "e") {
                    model.result = { error: model.value };
                  } else {
                    model.result = parseFloat(model.value);
                  }
                  model.value = void 0;
                }
              } else if (model.value !== void 0) {
                switch (this.t) {
                  case "s":
                    model.type = Enums.ValueType.String;
                    model.value = parseInt(model.value, 10);
                    break;
                  case "str":
                    model.type = Enums.ValueType.String;
                    model.value = utils.xmlDecode(model.value);
                    break;
                  case "inlineStr":
                    model.type = Enums.ValueType.String;
                    break;
                  case "b":
                    model.type = Enums.ValueType.Boolean;
                    model.value = parseInt(model.value, 10) !== 0;
                    break;
                  case "e":
                    model.type = Enums.ValueType.Error;
                    model.value = { error: model.value };
                    break;
                  default:
                    model.type = Enums.ValueType.Number;
                    model.value = parseFloat(model.value);
                    break;
                }
              } else if (model.styleId) {
                model.type = Enums.ValueType.Null;
              } else {
                model.type = Enums.ValueType.Merge;
              }
              return false;
            }
            case "f":
            case "v":
            case "is":
              this.currentNode = void 0;
              return true;
            case "t":
              if (this.parser) {
                this.parser.parseClose(name);
                return true;
              }
              this.currentNode = void 0;
              return true;
            case "r":
              this.model.value = this.model.value || {};
              this.model.value.richText = this.model.value.richText || [];
              this.model.value.richText.push(this.parser.model);
              this.parser = void 0;
              this.currentNode = void 0;
              return true;
            default:
              if (this.parser) {
                this.parser.parseClose(name);
                return true;
              }
              return false;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
          if (style) {
            model.style = style;
          }
          if (model.styleId !== void 0) {
            model.styleId = void 0;
          }
          switch (model.type) {
            case Enums.ValueType.String:
              if (typeof model.value === "number") {
                if (options.sharedStrings) {
                  model.value = options.sharedStrings.getString(model.value);
                }
              }
              if (model.value.richText) {
                model.type = Enums.ValueType.RichText;
              }
              break;
            case Enums.ValueType.Number:
              if (style && utils.isDateFmt(style.numFmt)) {
                model.type = Enums.ValueType.Date;
                model.value = utils.excelToDate(model.value, options.date1904);
              }
              break;
            case Enums.ValueType.Formula:
              if (model.result !== void 0 && style && utils.isDateFmt(style.numFmt)) {
                model.result = utils.excelToDate(model.result, options.date1904);
              }
              if (model.shareType === "shared") {
                if (model.ref) {
                  options.formulae[model.si] = model.address;
                } else {
                  model.sharedFormula = options.formulae[model.si];
                  delete model.shareType;
                }
                delete model.si;
              }
              break;
          }
          var hyperlink = options.hyperlinkMap[model.address];
          if (hyperlink) {
            if (model.type === Enums.ValueType.Formula) {
              model.text = model.result;
              model.result = void 0;
            } else {
              model.text = model.value;
              model.value = void 0;
            }
            model.type = Enums.ValueType.Hyperlink;
            model.hyperlink = hyperlink;
          }
          var comment = options.commentsMap && options.commentsMap[model.address];
          if (comment) {
            model.comment = comment;
          }
        } }]);
        return CellXform2;
      }(BaseXform);
      module2.exports = CellXform;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/utils": 27, "../base-xform": 32, "../strings/rich-text-xform": 122 }], 74: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CfIconExtXform = /* @__PURE__ */ function(_BaseXform37) {
        _inherits(CfIconExtXform2, _BaseXform37);
        var _super40 = _createSuper(CfIconExtXform2);
        function CfIconExtXform2() {
          _classCallCheck(this, CfIconExtXform2);
          return _super40.apply(this, arguments);
        }
        _createClass(CfIconExtXform2, [{ key: "tag", get: function get() {
          return "x14:cfIcon";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { iconSet: model.iconSet, iconId: model.iconId });
        } }, { key: "parseOpen", value: function parseOpen(_ref) {
          var attributes = _ref.attributes;
          this.model = { iconSet: attributes.iconSet, iconId: BaseXform.toIntValue(attributes.iconId) };
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return CfIconExtXform2;
      }(BaseXform);
      module2.exports = CfIconExtXform;
    }, { "../../base-xform": 32 }], 75: [function(require2, module2, exports2) {
      var _require11 = require2("uuid"), uuidv4 = _require11.v4;
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var DatabarExtXform = require2("./databar-ext-xform");
      var IconSetExtXform = require2("./icon-set-ext-xform");
      var extIcons = { "3Triangles": true, "3Stars": true, "5Boxes": true };
      var CfRuleExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits(CfRuleExtXform2, _CompositeXform);
        var _super41 = _createSuper(CfRuleExtXform2);
        function CfRuleExtXform2() {
          var _this63;
          _classCallCheck(this, CfRuleExtXform2);
          _this63 = _super41.call(this);
          _this63.map = { "x14:dataBar": _this63.databarXform = new DatabarExtXform(), "x14:iconSet": _this63.iconSetXform = new IconSetExtXform() };
          return _this63;
        }
        _createClass(CfRuleExtXform2, [{ key: "tag", get: function get() {
          return "x14:cfRule";
        } }, { key: "prepare", value: function prepare(model) {
          if (CfRuleExtXform2.isExt(model)) {
            model.x14Id = "{".concat(uuidv4(), "}").toUpperCase();
          }
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (!CfRuleExtXform2.isExt(model)) {
            return;
          }
          switch (model.type) {
            case "dataBar":
              this.renderDataBar(xmlStream, model);
              break;
            case "iconSet":
              this.renderIconSet(xmlStream, model);
              break;
          }
        } }, { key: "renderDataBar", value: function renderDataBar(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "dataBar", id: model.x14Id });
          this.databarXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderIconSet", value: function renderIconSet(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "iconSet", priority: model.priority, id: model.x14Id || "{".concat(uuidv4(), "}") });
          this.iconSetXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { type: attributes.type, x14Id: attributes.id, priority: BaseXform.toIntValue(attributes.priority) };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }], [{ key: "isExt", value: function isExt(rule) {
          if (rule.type === "dataBar") {
            return DatabarExtXform.isExt(rule);
          }
          if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
              return true;
            }
          }
          return false;
        } }]);
        return CfRuleExtXform2;
      }(CompositeXform);
      module2.exports = CfRuleExtXform;
    }, { "../../base-xform": 32, "../../composite-xform": 48, "./databar-ext-xform": 79, "./icon-set-ext-xform": 81, "uuid": 528 }], 76: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var FExtXform = require2("./f-ext-xform");
      var CfvoExtXform = /* @__PURE__ */ function(_CompositeXform2) {
        _inherits(CfvoExtXform2, _CompositeXform2);
        var _super42 = _createSuper(CfvoExtXform2);
        function CfvoExtXform2() {
          var _this64;
          _classCallCheck(this, CfvoExtXform2);
          _this64 = _super42.call(this);
          _this64.map = { "xm:f": _this64.fExtXform = new FExtXform() };
          return _this64;
        }
        _createClass(CfvoExtXform2, [{ key: "tag", get: function get() {
          return "x14:cfvo";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: model.type });
          if (model.value !== void 0) {
            this.fExtXform.render(xmlStream, model.value);
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(node) {
          return { type: node.attributes.type };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "xm:f":
              this.model.value = parser.model ? parseFloat(parser.model) : 0;
              break;
          }
        } }]);
        return CfvoExtXform2;
      }(CompositeXform);
      module2.exports = CfvoExtXform;
    }, { "../../composite-xform": 48, "./f-ext-xform": 80 }], 77: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var SqRefExtXform = require2("./sqref-ext-xform");
      var CfRuleExtXform = require2("./cf-rule-ext-xform");
      var ConditionalFormattingExtXform = /* @__PURE__ */ function(_CompositeXform3) {
        _inherits(ConditionalFormattingExtXform2, _CompositeXform3);
        var _super43 = _createSuper(ConditionalFormattingExtXform2);
        function ConditionalFormattingExtXform2() {
          var _this65;
          _classCallCheck(this, ConditionalFormattingExtXform2);
          _this65 = _super43.call(this);
          _this65.map = { "xm:sqref": _this65.sqRef = new SqRefExtXform(), "x14:cfRule": _this65.cfRule = new CfRuleExtXform() };
          return _this65;
        }
        _createClass(ConditionalFormattingExtXform2, [{ key: "tag", get: function get() {
          return "x14:conditionalFormatting";
        } }, { key: "prepare", value: function prepare(model, options) {
          var _this66 = this;
          model.rules.forEach(function(rule) {
            _this66.cfRule.prepare(rule, options);
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this67 = this;
          if (!model.rules.some(CfRuleExtXform.isExt)) {
            return;
          }
          xmlStream.openNode(this.tag, { "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main" });
          model.rules.filter(CfRuleExtXform.isExt).forEach(function(rule) {
            return _this67.cfRule.render(xmlStream, rule);
          });
          this.sqRef.render(xmlStream, model.ref);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return { rules: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "xm:sqref":
              this.model.ref = parser.model;
              break;
            case "x14:cfRule":
              this.model.rules.push(parser.model);
              break;
          }
        } }]);
        return ConditionalFormattingExtXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingExtXform;
    }, { "../../composite-xform": 48, "./cf-rule-ext-xform": 75, "./sqref-ext-xform": 82 }], 78: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var CfRuleExtXform = require2("./cf-rule-ext-xform");
      var ConditionalFormattingExtXform = require2("./conditional-formatting-ext-xform");
      var ConditionalFormattingsExtXform = /* @__PURE__ */ function(_CompositeXform4) {
        _inherits(ConditionalFormattingsExtXform2, _CompositeXform4);
        var _super44 = _createSuper(ConditionalFormattingsExtXform2);
        function ConditionalFormattingsExtXform2() {
          var _this68;
          _classCallCheck(this, ConditionalFormattingsExtXform2);
          _this68 = _super44.call(this);
          _this68.map = { "x14:conditionalFormatting": _this68.cfXform = new ConditionalFormattingExtXform() };
          return _this68;
        }
        _createClass(ConditionalFormattingsExtXform2, [{ key: "tag", get: function get() {
          return "x14:conditionalFormattings";
        } }, { key: "hasContent", value: function hasContent(model) {
          if (model.hasExtContent === void 0) {
            model.hasExtContent = model.some(function(cf) {
              return cf.rules.some(CfRuleExtXform.isExt);
            });
          }
          return model.hasExtContent;
        } }, { key: "prepare", value: function prepare(model, options) {
          var _this69 = this;
          model.forEach(function(cf) {
            _this69.cfXform.prepare(cf, options);
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this70 = this;
          if (this.hasContent(model)) {
            xmlStream.openNode(this.tag);
            model.forEach(function(cf) {
              return _this70.cfXform.render(xmlStream, cf);
            });
            xmlStream.closeNode();
          }
        } }, { key: "createNewModel", value: function createNewModel() {
          return [];
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.push(parser.model);
        } }]);
        return ConditionalFormattingsExtXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingsExtXform;
    }, { "../../composite-xform": 48, "./cf-rule-ext-xform": 75, "./conditional-formatting-ext-xform": 77 }], 79: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoExtXform = require2("./cfvo-ext-xform");
      var DatabarExtXform = /* @__PURE__ */ function(_CompositeXform5) {
        _inherits(DatabarExtXform2, _CompositeXform5);
        var _super45 = _createSuper(DatabarExtXform2);
        function DatabarExtXform2() {
          var _this71;
          _classCallCheck(this, DatabarExtXform2);
          _this71 = _super45.call(this);
          _this71.map = { "x14:cfvo": _this71.cfvoXform = new CfvoExtXform(), "x14:borderColor": _this71.borderColorXform = new ColorXform("x14:borderColor"), "x14:negativeBorderColor": _this71.negativeBorderColorXform = new ColorXform("x14:negativeBorderColor"), "x14:negativeFillColor": _this71.negativeFillColorXform = new ColorXform("x14:negativeFillColor"), "x14:axisColor": _this71.axisColorXform = new ColorXform("x14:axisColor") };
          return _this71;
        }
        _createClass(DatabarExtXform2, [{ key: "tag", get: function get() {
          return "x14:dataBar";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this72 = this;
          xmlStream.openNode(this.tag, { minLength: BaseXform.toIntAttribute(model.minLength, 0, true), maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true), border: BaseXform.toBoolAttribute(model.border, false), gradient: BaseXform.toBoolAttribute(model.gradient, true), negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarBorderColorSameAsPositive, true), axisPosition: BaseXform.toAttribute(model.axisPosition, "auto"), direction: BaseXform.toAttribute(model.direction, "leftToRight") });
          model.cfvo.forEach(function(cfvo) {
            _this72.cfvoXform.render(xmlStream, cfvo);
          });
          this.borderColorXform.render(xmlStream, model.borderColor);
          this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);
          this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);
          this.axisColorXform.render(xmlStream, model.axisColor);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { cfvo: [], minLength: BaseXform.toIntValue(attributes.minLength, 0), maxLength: BaseXform.toIntValue(attributes.maxLength, 100), border: BaseXform.toBoolValue(attributes.border, false), gradient: BaseXform.toBoolValue(attributes.gradient, true), negativeBarColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarBorderColorSameAsPositive, true), axisPosition: BaseXform.toStringValue(attributes.axisPosition, "auto"), direction: BaseXform.toStringValue(attributes.direction, "leftToRight") };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          var _name$split = name.split(":"), _name$split2 = _slicedToArray(_name$split, 2), prop = _name$split2[1];
          switch (prop) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            default:
              this.model[prop] = parser.model;
              break;
          }
        } }], [{ key: "isExt", value: function isExt(rule) {
          return !rule.gradient;
        } }]);
        return DatabarExtXform2;
      }(CompositeXform);
      module2.exports = DatabarExtXform;
    }, { "../../base-xform": 32, "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-ext-xform": 76 }], 80: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var FExtXform = /* @__PURE__ */ function(_BaseXform38) {
        _inherits(FExtXform2, _BaseXform38);
        var _super46 = _createSuper(FExtXform2);
        function FExtXform2() {
          _classCallCheck(this, FExtXform2);
          return _super46.apply(this, arguments);
        }
        _createClass(FExtXform2, [{ key: "tag", get: function get() {
          return "xm:f";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return FExtXform2;
      }(BaseXform);
      module2.exports = FExtXform;
    }, { "../../base-xform": 32 }], 81: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var CfvoExtXform = require2("./cfvo-ext-xform");
      var CfIconExtXform = require2("./cf-icon-ext-xform");
      var IconSetExtXform = /* @__PURE__ */ function(_CompositeXform6) {
        _inherits(IconSetExtXform2, _CompositeXform6);
        var _super47 = _createSuper(IconSetExtXform2);
        function IconSetExtXform2() {
          var _this73;
          _classCallCheck(this, IconSetExtXform2);
          _this73 = _super47.call(this);
          _this73.map = { "x14:cfvo": _this73.cfvoXform = new CfvoExtXform(), "x14:cfIcon": _this73.cfIconXform = new CfIconExtXform() };
          return _this73;
        }
        _createClass(IconSetExtXform2, [{ key: "tag", get: function get() {
          return "x14:iconSet";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this74 = this;
          xmlStream.openNode(this.tag, { iconSet: BaseXform.toStringAttribute(model.iconSet), reverse: BaseXform.toBoolAttribute(model.reverse, false), showValue: BaseXform.toBoolAttribute(model.showValue, true), custom: BaseXform.toBoolAttribute(model.icons, false) });
          model.cfvo.forEach(function(cfvo) {
            _this74.cfvoXform.render(xmlStream, cfvo);
          });
          if (model.icons) {
            model.icons.forEach(function(icon, i) {
              icon.iconId = i;
              _this74.cfIconXform.render(xmlStream, icon);
            });
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { cfvo: [], iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolValue(attributes.reverse, false), showValue: BaseXform.toBoolValue(attributes.showValue, true) };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          var _name$split3 = name.split(":"), _name$split4 = _slicedToArray(_name$split3, 2), prop = _name$split4[1];
          switch (prop) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            case "cfIcon":
              if (!this.model.icons) {
                this.model.icons = [];
              }
              this.model.icons.push(parser.model);
              break;
            default:
              this.model[prop] = parser.model;
              break;
          }
        } }]);
        return IconSetExtXform2;
      }(CompositeXform);
      module2.exports = IconSetExtXform;
    }, { "../../base-xform": 32, "../../composite-xform": 48, "./cf-icon-ext-xform": 74, "./cfvo-ext-xform": 76 }], 82: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var SqrefExtXform = /* @__PURE__ */ function(_BaseXform39) {
        _inherits(SqrefExtXform2, _BaseXform39);
        var _super48 = _createSuper(SqrefExtXform2);
        function SqrefExtXform2() {
          _classCallCheck(this, SqrefExtXform2);
          return _super48.apply(this, arguments);
        }
        _createClass(SqrefExtXform2, [{ key: "tag", get: function get() {
          return "xm:sqref";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return SqrefExtXform2;
      }(BaseXform);
      module2.exports = SqrefExtXform;
    }, { "../../base-xform": 32 }], 83: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var Range = require2("../../../../doc/range");
      var DatabarXform = require2("./databar-xform");
      var ExtLstRefXform = require2("./ext-lst-ref-xform");
      var FormulaXform = require2("./formula-xform");
      var ColorScaleXform = require2("./color-scale-xform");
      var IconSetXform = require2("./icon-set-xform");
      var extIcons = { "3Triangles": true, "3Stars": true, "5Boxes": true };
      var getTextFormula = function getTextFormula2(model) {
        if (model.formulae && model.formulae[0]) {
          return model.formulae[0];
        }
        var range = new Range(model.ref);
        var tl = range.tl;
        switch (model.operator) {
          case "containsText":
            return 'NOT(ISERROR(SEARCH("'.concat(model.text, '",').concat(tl, ")))");
          case "containsBlanks":
            return "LEN(TRIM(".concat(tl, "))=0");
          case "notContainsBlanks":
            return "LEN(TRIM(".concat(tl, "))>0");
          case "containsErrors":
            return "ISERROR(".concat(tl, ")");
          case "notContainsErrors":
            return "NOT(ISERROR(".concat(tl, "))");
          default:
            return void 0;
        }
      };
      var getTimePeriodFormula = function getTimePeriodFormula2(model) {
        if (model.formulae && model.formulae[0]) {
          return model.formulae[0];
        }
        var range = new Range(model.ref);
        var tl = range.tl;
        switch (model.timePeriod) {
          case "thisWeek":
            return "AND(TODAY()-ROUNDDOWN(".concat(tl, ",0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(").concat(tl, ",0)-TODAY()<=7-WEEKDAY(TODAY()))");
          case "lastWeek":
            return "AND(TODAY()-ROUNDDOWN(".concat(tl, ",0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(").concat(tl, ",0)<(WEEKDAY(TODAY())+7))");
          case "nextWeek":
            return "AND(ROUNDDOWN(".concat(tl, ",0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(").concat(tl, ",0)-TODAY()<(15-WEEKDAY(TODAY())))");
          case "yesterday":
            return "FLOOR(".concat(tl, ",1)=TODAY()-1");
          case "today":
            return "FLOOR(".concat(tl, ",1)=TODAY()");
          case "tomorrow":
            return "FLOOR(".concat(tl, ",1)=TODAY()+1");
          case "last7Days":
            return "AND(TODAY()-FLOOR(".concat(tl, ",1)<=6,FLOOR(").concat(tl, ",1)<=TODAY())");
          case "lastMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(EDATE(TODAY(),0-1)),YEAR(").concat(tl, ")=YEAR(EDATE(TODAY(),0-1)))");
          case "thisMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(TODAY()),YEAR(").concat(tl, ")=YEAR(TODAY()))");
          case "nextMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(EDATE(TODAY(),0+1)),YEAR(").concat(tl, ")=YEAR(EDATE(TODAY(),0+1)))");
          default:
            return void 0;
        }
      };
      var opType = function opType2(attributes) {
        var type = attributes.type, operator = attributes.operator;
        switch (type) {
          case "containsText":
          case "containsBlanks":
          case "notContainsBlanks":
          case "containsErrors":
          case "notContainsErrors":
            return { type: "containsText", operator: type };
          default:
            return { type, operator };
        }
      };
      var CfRuleXform = /* @__PURE__ */ function(_CompositeXform7) {
        _inherits(CfRuleXform2, _CompositeXform7);
        var _super49 = _createSuper(CfRuleXform2);
        function CfRuleXform2() {
          var _this75;
          _classCallCheck(this, CfRuleXform2);
          _this75 = _super49.call(this);
          _this75.map = { dataBar: _this75.databarXform = new DatabarXform(), extLst: _this75.extLstRefXform = new ExtLstRefXform(), formula: _this75.formulaXform = new FormulaXform(), colorScale: _this75.colorScaleXform = new ColorScaleXform(), iconSet: _this75.iconSetXform = new IconSetXform() };
          return _this75;
        }
        _createClass(CfRuleXform2, [{ key: "tag", get: function get() {
          return "cfRule";
        } }, { key: "render", value: function render13(xmlStream, model) {
          switch (model.type) {
            case "expression":
              this.renderExpression(xmlStream, model);
              break;
            case "cellIs":
              this.renderCellIs(xmlStream, model);
              break;
            case "top10":
              this.renderTop10(xmlStream, model);
              break;
            case "aboveAverage":
              this.renderAboveAverage(xmlStream, model);
              break;
            case "dataBar":
              this.renderDataBar(xmlStream, model);
              break;
            case "colorScale":
              this.renderColorScale(xmlStream, model);
              break;
            case "iconSet":
              this.renderIconSet(xmlStream, model);
              break;
            case "containsText":
              this.renderText(xmlStream, model);
              break;
            case "timePeriod":
              this.renderTimePeriod(xmlStream, model);
              break;
          }
        } }, { key: "renderExpression", value: function renderExpression(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "expression", dxfId: model.dxfId, priority: model.priority });
          this.formulaXform.render(xmlStream, model.formulae[0]);
          xmlStream.closeNode();
        } }, { key: "renderCellIs", value: function renderCellIs(xmlStream, model) {
          var _this76 = this;
          xmlStream.openNode(this.tag, { type: "cellIs", dxfId: model.dxfId, priority: model.priority, operator: model.operator });
          model.formulae.forEach(function(formula) {
            _this76.formulaXform.render(xmlStream, formula);
          });
          xmlStream.closeNode();
        } }, { key: "renderTop10", value: function renderTop10(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: "top10", dxfId: model.dxfId, priority: model.priority, percent: BaseXform.toBoolAttribute(model.percent, false), bottom: BaseXform.toBoolAttribute(model.bottom, false), rank: BaseXform.toIntValue(model.rank, 10, true) });
        } }, { key: "renderAboveAverage", value: function renderAboveAverage(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: "aboveAverage", dxfId: model.dxfId, priority: model.priority, aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true) });
        } }, { key: "renderDataBar", value: function renderDataBar(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "dataBar", priority: model.priority });
          this.databarXform.render(xmlStream, model);
          this.extLstRefXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderColorScale", value: function renderColorScale(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "colorScale", priority: model.priority });
          this.colorScaleXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderIconSet", value: function renderIconSet(xmlStream, model) {
          if (!CfRuleXform2.isPrimitive(model)) {
            return;
          }
          xmlStream.openNode(this.tag, { type: "iconSet", priority: model.priority });
          this.iconSetXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderText", value: function renderText(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: model.operator, dxfId: model.dxfId, priority: model.priority, operator: BaseXform.toStringAttribute(model.operator, "containsText") });
          var formula = getTextFormula(model);
          if (formula) {
            this.formulaXform.render(xmlStream, formula);
          }
          xmlStream.closeNode();
        } }, { key: "renderTimePeriod", value: function renderTimePeriod(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "timePeriod", dxfId: model.dxfId, priority: model.priority, timePeriod: model.timePeriod });
          var formula = getTimePeriodFormula(model);
          if (formula) {
            this.formulaXform.render(xmlStream, formula);
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return _objectSpread2(_objectSpread2({}, opType(attributes)), {}, { dxfId: BaseXform.toIntValue(attributes.dxfId), priority: BaseXform.toIntValue(attributes.priority), timePeriod: attributes.timePeriod, percent: BaseXform.toBoolValue(attributes.percent), bottom: BaseXform.toBoolValue(attributes.bottom), rank: BaseXform.toIntValue(attributes.rank), aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage) });
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "dataBar":
            case "extLst":
            case "colorScale":
            case "iconSet":
              Object.assign(this.model, parser.model);
              break;
            case "formula":
              this.model.formulae = this.model.formulae || [];
              this.model.formulae.push(parser.model);
              break;
          }
        } }], [{ key: "isPrimitive", value: function isPrimitive(rule) {
          if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
              return false;
            }
          }
          return true;
        } }]);
        return CfRuleXform2;
      }(CompositeXform);
      module2.exports = CfRuleXform;
    }, { "../../../../doc/range": 10, "../../base-xform": 32, "../../composite-xform": 48, "./color-scale-xform": 85, "./databar-xform": 88, "./ext-lst-ref-xform": 89, "./formula-xform": 90, "./icon-set-xform": 91 }], 84: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CfvoXform = /* @__PURE__ */ function(_BaseXform40) {
        _inherits(CfvoXform2, _BaseXform40);
        var _super50 = _createSuper(CfvoXform2);
        function CfvoXform2() {
          _classCallCheck(this, CfvoXform2);
          return _super50.apply(this, arguments);
        }
        _createClass(CfvoXform2, [{ key: "tag", get: function get() {
          return "cfvo";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: model.type, val: model.value });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          this.model = { type: node.attributes.type, value: BaseXform.toFloatValue(node.attributes.val) };
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return CfvoXform2;
      }(BaseXform);
      module2.exports = CfvoXform;
    }, { "../../base-xform": 32 }], 85: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoXform = require2("./cfvo-xform");
      var ColorScaleXform = /* @__PURE__ */ function(_CompositeXform8) {
        _inherits(ColorScaleXform2, _CompositeXform8);
        var _super51 = _createSuper(ColorScaleXform2);
        function ColorScaleXform2() {
          var _this77;
          _classCallCheck(this, ColorScaleXform2);
          _this77 = _super51.call(this);
          _this77.map = { cfvo: _this77.cfvoXform = new CfvoXform(), color: _this77.colorXform = new ColorXform() };
          return _this77;
        }
        _createClass(ColorScaleXform2, [{ key: "tag", get: function get() {
          return "colorScale";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this78 = this;
          xmlStream.openNode(this.tag);
          model.cfvo.forEach(function(cfvo) {
            _this78.cfvoXform.render(xmlStream, cfvo);
          });
          model.color.forEach(function(color) {
            _this78.colorXform.render(xmlStream, color);
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(node) {
          return { cfvo: [], color: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name].push(parser.model);
        } }]);
        return ColorScaleXform2;
      }(CompositeXform);
      module2.exports = ColorScaleXform;
    }, { "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-xform": 84 }], 86: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var CfRuleXform = require2("./cf-rule-xform");
      var ConditionalFormattingXform = /* @__PURE__ */ function(_CompositeXform9) {
        _inherits(ConditionalFormattingXform2, _CompositeXform9);
        var _super52 = _createSuper(ConditionalFormattingXform2);
        function ConditionalFormattingXform2() {
          var _this79;
          _classCallCheck(this, ConditionalFormattingXform2);
          _this79 = _super52.call(this);
          _this79.map = { cfRule: new CfRuleXform() };
          return _this79;
        }
        _createClass(ConditionalFormattingXform2, [{ key: "tag", get: function get() {
          return "conditionalFormatting";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this80 = this;
          if (!model.rules.some(CfRuleXform.isPrimitive)) {
            return;
          }
          xmlStream.openNode(this.tag, { sqref: model.ref });
          model.rules.forEach(function(rule) {
            if (CfRuleXform.isPrimitive(rule)) {
              rule.ref = model.ref;
              _this80.map.cfRule.render(xmlStream, rule);
            }
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { ref: attributes.sqref, rules: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.rules.push(parser.model);
        } }]);
        return ConditionalFormattingXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingXform;
    }, { "../../composite-xform": 48, "./cf-rule-xform": 83 }], 87: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var ConditionalFormattingXform = require2("./conditional-formatting-xform");
      var ConditionalFormattingsXform = /* @__PURE__ */ function(_BaseXform41) {
        _inherits(ConditionalFormattingsXform2, _BaseXform41);
        var _super53 = _createSuper(ConditionalFormattingsXform2);
        function ConditionalFormattingsXform2() {
          var _this81;
          _classCallCheck(this, ConditionalFormattingsXform2);
          _this81 = _super53.call(this);
          _this81.cfXform = new ConditionalFormattingXform();
          return _this81;
        }
        _createClass(ConditionalFormattingsXform2, [{ key: "tag", get: function get() {
          return "conditionalFormatting";
        } }, { key: "reset", value: function reset() {
          this.model = [];
        } }, { key: "prepare", value: function prepare(model, options) {
          var nextPriority = model.reduce(function(p, cf) {
            return Math.max.apply(Math, [p].concat(_toConsumableArray(cf.rules.map(function(rule) {
              return rule.priority || 0;
            }))));
          }, 1);
          model.forEach(function(cf) {
            cf.rules.forEach(function(rule) {
              if (!rule.priority) {
                rule.priority = nextPriority++;
              }
              if (rule.style) {
                rule.dxfId = options.styles.addDxfStyle(rule.style);
              }
            });
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this82 = this;
          model.forEach(function(cf) {
            _this82.cfXform.render(xmlStream, cf);
          });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "conditionalFormatting":
              this.parser = this.cfXform;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
              return false;
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.forEach(function(cf) {
            cf.rules.forEach(function(rule) {
              if (rule.dxfId !== void 0) {
                rule.style = options.styles.getDxfStyle(rule.dxfId);
                delete rule.dxfId;
              }
            });
          });
        } }]);
        return ConditionalFormattingsXform2;
      }(BaseXform);
      module2.exports = ConditionalFormattingsXform;
    }, { "../../base-xform": 32, "./conditional-formatting-xform": 86 }], 88: [function(require2, module2, exports2) {
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoXform = require2("./cfvo-xform");
      var DatabarXform = /* @__PURE__ */ function(_CompositeXform10) {
        _inherits(DatabarXform2, _CompositeXform10);
        var _super54 = _createSuper(DatabarXform2);
        function DatabarXform2() {
          var _this83;
          _classCallCheck(this, DatabarXform2);
          _this83 = _super54.call(this);
          _this83.map = { cfvo: _this83.cfvoXform = new CfvoXform(), color: _this83.colorXform = new ColorXform() };
          return _this83;
        }
        _createClass(DatabarXform2, [{ key: "tag", get: function get() {
          return "dataBar";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this84 = this;
          xmlStream.openNode(this.tag);
          model.cfvo.forEach(function(cfvo) {
            _this84.cfvoXform.render(xmlStream, cfvo);
          });
          this.colorXform.render(xmlStream, model.color);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return { cfvo: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            case "color":
              this.model.color = parser.model;
              break;
          }
        } }]);
        return DatabarXform2;
      }(CompositeXform);
      module2.exports = DatabarXform;
    }, { "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-xform": 84 }], 89: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var X14IdXform = /* @__PURE__ */ function(_BaseXform42) {
        _inherits(X14IdXform2, _BaseXform42);
        var _super55 = _createSuper(X14IdXform2);
        function X14IdXform2() {
          _classCallCheck(this, X14IdXform2);
          return _super55.apply(this, arguments);
        }
        _createClass(X14IdXform2, [{ key: "tag", get: function get() {
          return "x14:id";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return X14IdXform2;
      }(BaseXform);
      var ExtXform = /* @__PURE__ */ function(_CompositeXform11) {
        _inherits(ExtXform2, _CompositeXform11);
        var _super56 = _createSuper(ExtXform2);
        function ExtXform2() {
          var _this85;
          _classCallCheck(this, ExtXform2);
          _this85 = _super56.call(this);
          _this85.map = { "x14:id": _this85.idXform = new X14IdXform() };
          return _this85;
        }
        _createClass(ExtXform2, [{ key: "tag", get: function get() {
          return "ext";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" });
          this.idXform.render(xmlStream, model.x14Id);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.x14Id = parser.model;
        } }]);
        return ExtXform2;
      }(CompositeXform);
      var ExtLstRefXform = /* @__PURE__ */ function(_CompositeXform12) {
        _inherits(ExtLstRefXform2, _CompositeXform12);
        var _super57 = _createSuper(ExtLstRefXform2);
        function ExtLstRefXform2() {
          var _this86;
          _classCallCheck(this, ExtLstRefXform2);
          _this86 = _super57.call(this);
          _this86.map = { ext: new ExtXform() };
          return _this86;
        }
        _createClass(ExtLstRefXform2, [{ key: "tag", get: function get() {
          return "extLst";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map.ext.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }]);
        return ExtLstRefXform2;
      }(CompositeXform);
      module2.exports = ExtLstRefXform;
    }, { "../../base-xform": 32, "../../composite-xform": 48 }], 90: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var FormulaXform = /* @__PURE__ */ function(_BaseXform43) {
        _inherits(FormulaXform2, _BaseXform43);
        var _super58 = _createSuper(FormulaXform2);
        function FormulaXform2() {
          _classCallCheck(this, FormulaXform2);
          return _super58.apply(this, arguments);
        }
        _createClass(FormulaXform2, [{ key: "tag", get: function get() {
          return "formula";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }]);
        return FormulaXform2;
      }(BaseXform);
      module2.exports = FormulaXform;
    }, { "../../base-xform": 32 }], 91: [function(require2, module2, exports2) {
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var CfvoXform = require2("./cfvo-xform");
      var IconSetXform = /* @__PURE__ */ function(_CompositeXform13) {
        _inherits(IconSetXform2, _CompositeXform13);
        var _super59 = _createSuper(IconSetXform2);
        function IconSetXform2() {
          var _this87;
          _classCallCheck(this, IconSetXform2);
          _this87 = _super59.call(this);
          _this87.map = { cfvo: _this87.cfvoXform = new CfvoXform() };
          return _this87;
        }
        _createClass(IconSetXform2, [{ key: "tag", get: function get() {
          return "iconSet";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this88 = this;
          xmlStream.openNode(this.tag, { iconSet: BaseXform.toStringAttribute(model.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolAttribute(model.reverse, false), showValue: BaseXform.toBoolAttribute(model.showValue, true) });
          model.cfvo.forEach(function(cfvo) {
            _this88.cfvoXform.render(xmlStream, cfvo);
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolValue(attributes.reverse), showValue: BaseXform.toBoolValue(attributes.showValue), cfvo: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name].push(parser.model);
        } }]);
        return IconSetXform2;
      }(CompositeXform);
      module2.exports = IconSetXform;
    }, { "../../base-xform": 32, "../../composite-xform": 48, "./cfvo-xform": 84 }], 92: [function(require2, module2, exports2) {
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var ColXform = /* @__PURE__ */ function(_BaseXform44) {
        _inherits(ColXform2, _BaseXform44);
        var _super60 = _createSuper(ColXform2);
        function ColXform2() {
          _classCallCheck(this, ColXform2);
          return _super60.apply(this, arguments);
        }
        _createClass(ColXform2, [{ key: "tag", get: function get() {
          return "col";
        } }, { key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style || {});
          if (styleId) {
            model.styleId = styleId;
          }
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("col");
          xmlStream.addAttribute("min", model.min);
          xmlStream.addAttribute("max", model.max);
          if (model.width) {
            xmlStream.addAttribute("width", model.width);
          }
          if (model.styleId) {
            xmlStream.addAttribute("style", model.styleId);
          }
          if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
          }
          if (model.bestFit) {
            xmlStream.addAttribute("bestFit", "1");
          }
          if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
          }
          if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
          }
          xmlStream.addAttribute("customWidth", "1");
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "col") {
            var model = this.model = { min: parseInt(node.attributes.min || "0", 10), max: parseInt(node.attributes.max || "0", 10), width: node.attributes.width === void 0 ? void 0 : parseFloat(node.attributes.width || "0") };
            if (node.attributes.style) {
              model.styleId = parseInt(node.attributes.style, 10);
            }
            if (utils.parseBoolean(node.attributes.hidden)) {
              model.hidden = true;
            }
            if (utils.parseBoolean(node.attributes.bestFit)) {
              model.bestFit = true;
            }
            if (node.attributes.outlineLevel) {
              model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (utils.parseBoolean(node.attributes.collapsed)) {
              model.collapsed = true;
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          if (model.styleId) {
            model.style = options.styles.getStyleModel(model.styleId);
          }
        } }]);
        return ColXform2;
      }(BaseXform);
      module2.exports = ColXform;
    }, { "../../../utils/utils": 27, "../base-xform": 32 }], 93: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var utils = require2("../../../utils/utils");
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var Range = require2("../../../doc/range");
      function assign(definedName, attributes, name, defaultValue) {
        var value = attributes[name];
        if (value !== void 0) {
          definedName[name] = value;
        } else if (defaultValue !== void 0) {
          definedName[name] = defaultValue;
        }
      }
      function assignBool(definedName, attributes, name, defaultValue) {
        var value = attributes[name];
        if (value !== void 0) {
          definedName[name] = utils.parseBoolean(value);
        } else if (defaultValue !== void 0) {
          definedName[name] = defaultValue;
        }
      }
      function optimiseDataValidations(model) {
        var dvList = _.map(model, function(dataValidation, address) {
          return { address, dataValidation, marked: false };
        }).sort(function(a, b) {
          return _.strcmp(a.address, b.address);
        });
        var dvMap = _.keyBy(dvList, "address");
        var matchCol = function matchCol2(addr, height2, col) {
          for (var i = 0; i < height2; i++) {
            var otherAddress = colCache.encodeAddress(addr.row + i, col);
            if (!model[otherAddress] || !_.isEqual(model[addr.address], model[otherAddress])) {
              return false;
            }
          }
          return true;
        };
        return dvList.map(function(dv) {
          if (!dv.marked) {
            var addr = colCache.decodeEx(dv.address);
            if (addr.dimensions) {
              dvMap[addr.dimensions].marked = true;
              return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: dv.address });
            }
            var height2 = 1;
            var otherAddress = colCache.encodeAddress(addr.row + height2, addr.col);
            while (model[otherAddress] && _.isEqual(dv.dataValidation, model[otherAddress])) {
              height2++;
              otherAddress = colCache.encodeAddress(addr.row + height2, addr.col);
            }
            var width2 = 1;
            while (matchCol(addr, height2, addr.col + width2)) {
              width2++;
            }
            for (var i = 0; i < height2; i++) {
              for (var j = 0; j < width2; j++) {
                otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);
                dvMap[otherAddress].marked = true;
              }
            }
            if (height2 > 1 || width2 > 1) {
              var bottom = addr.row + (height2 - 1);
              var right = addr.col + (width2 - 1);
              return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: "".concat(dv.address, ":").concat(colCache.encodeAddress(bottom, right)) });
            }
            return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: dv.address });
          }
          return null;
        }).filter(Boolean);
      }
      var DataValidationsXform = /* @__PURE__ */ function(_BaseXform45) {
        _inherits(DataValidationsXform2, _BaseXform45);
        var _super61 = _createSuper(DataValidationsXform2);
        function DataValidationsXform2() {
          _classCallCheck(this, DataValidationsXform2);
          return _super61.apply(this, arguments);
        }
        _createClass(DataValidationsXform2, [{ key: "tag", get: function get() {
          return "dataValidations";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var optimizedModel = optimiseDataValidations(model);
          if (optimizedModel.length) {
            xmlStream.openNode("dataValidations", { count: optimizedModel.length });
            optimizedModel.forEach(function(value) {
              xmlStream.openNode("dataValidation");
              if (value.type !== "any") {
                xmlStream.addAttribute("type", value.type);
                if (value.operator && value.type !== "list" && value.operator !== "between") {
                  xmlStream.addAttribute("operator", value.operator);
                }
                if (value.allowBlank) {
                  xmlStream.addAttribute("allowBlank", "1");
                }
              }
              if (value.showInputMessage) {
                xmlStream.addAttribute("showInputMessage", "1");
              }
              if (value.promptTitle) {
                xmlStream.addAttribute("promptTitle", value.promptTitle);
              }
              if (value.prompt) {
                xmlStream.addAttribute("prompt", value.prompt);
              }
              if (value.showErrorMessage) {
                xmlStream.addAttribute("showErrorMessage", "1");
              }
              if (value.errorStyle) {
                xmlStream.addAttribute("errorStyle", value.errorStyle);
              }
              if (value.errorTitle) {
                xmlStream.addAttribute("errorTitle", value.errorTitle);
              }
              if (value.error) {
                xmlStream.addAttribute("error", value.error);
              }
              xmlStream.addAttribute("sqref", value.sqref);
              (value.formulae || []).forEach(function(formula, index2) {
                xmlStream.openNode("formula".concat(index2 + 1));
                if (value.type === "date") {
                  xmlStream.writeText(utils.dateToExcel(new Date(formula)));
                } else {
                  xmlStream.writeText(formula);
                }
                xmlStream.closeNode();
              });
              xmlStream.closeNode();
            });
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "dataValidations":
              this.model = {};
              return true;
            case "dataValidation": {
              this._address = node.attributes.sqref;
              var dataValidation = { type: node.attributes.type || "any", formulae: [] };
              if (node.attributes.type) {
                assignBool(dataValidation, node.attributes, "allowBlank");
              }
              assignBool(dataValidation, node.attributes, "showInputMessage");
              assignBool(dataValidation, node.attributes, "showErrorMessage");
              switch (dataValidation.type) {
                case "any":
                case "list":
                case "custom":
                  break;
                default:
                  assign(dataValidation, node.attributes, "operator", "between");
                  break;
              }
              assign(dataValidation, node.attributes, "promptTitle");
              assign(dataValidation, node.attributes, "prompt");
              assign(dataValidation, node.attributes, "errorStyle");
              assign(dataValidation, node.attributes, "errorTitle");
              assign(dataValidation, node.attributes, "error");
              this._dataValidation = dataValidation;
              return true;
            }
            case "formula1":
            case "formula2":
              this._formula = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this._formula) {
            this._formula.push(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          var _this89 = this;
          switch (name) {
            case "dataValidations":
              return false;
            case "dataValidation": {
              if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
                delete this._dataValidation.formulae;
                delete this._dataValidation.operator;
              }
              var list = this._address.split(/\s+/g) || [];
              list.forEach(function(addr) {
                if (addr.includes(":")) {
                  var range = new Range(addr);
                  range.forEachAddress(function(address) {
                    _this89.model[address] = _this89._dataValidation;
                  });
                } else {
                  _this89.model[addr] = _this89._dataValidation;
                }
              });
              return true;
            }
            case "formula1":
            case "formula2": {
              var formula = this._formula.join("");
              switch (this._dataValidation.type) {
                case "whole":
                case "textLength":
                  formula = parseInt(formula, 10);
                  break;
                case "decimal":
                  formula = parseFloat(formula);
                  break;
                case "date":
                  formula = utils.excelToDate(parseFloat(formula));
                  break;
              }
              this._dataValidation.formulae.push(formula);
              this._formula = void 0;
              return true;
            }
            default:
              return true;
          }
        } }]);
        return DataValidationsXform2;
      }(BaseXform);
      module2.exports = DataValidationsXform;
    }, { "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/utils": 27, "../base-xform": 32 }], 94: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var DimensionXform = /* @__PURE__ */ function(_BaseXform46) {
        _inherits(DimensionXform2, _BaseXform46);
        var _super62 = _createSuper(DimensionXform2);
        function DimensionXform2() {
          _classCallCheck(this, DimensionXform2);
          return _super62.apply(this, arguments);
        }
        _createClass(DimensionXform2, [{ key: "tag", get: function get() {
          return "dimension";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.leafNode("dimension", { ref: model });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "dimension") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return DimensionXform2;
      }(BaseXform);
      module2.exports = DimensionXform;
    }, { "../base-xform": 32 }], 95: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var DrawingXform = /* @__PURE__ */ function(_BaseXform47) {
        _inherits(DrawingXform2, _BaseXform47);
        var _super63 = _createSuper(DrawingXform2);
        function DrawingXform2() {
          _classCallCheck(this, DrawingXform2);
          return _super63.apply(this, arguments);
        }
        _createClass(DrawingXform2, [{ key: "tag", get: function get() {
          return "drawing";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return DrawingXform2;
      }(BaseXform);
      module2.exports = DrawingXform;
    }, { "../base-xform": 32 }], 96: [function(require2, module2, exports2) {
      var CompositeXform = require2("../composite-xform");
      var ConditionalFormattingsExt = require2("./cf-ext/conditional-formattings-ext-xform");
      var ExtXform = /* @__PURE__ */ function(_CompositeXform14) {
        _inherits(ExtXform2, _CompositeXform14);
        var _super64 = _createSuper(ExtXform2);
        function ExtXform2() {
          var _this90;
          _classCallCheck(this, ExtXform2);
          _this90 = _super64.call(this);
          _this90.map = { "x14:conditionalFormattings": _this90.conditionalFormattings = new ConditionalFormattingsExt() };
          return _this90;
        }
        _createClass(ExtXform2, [{ key: "tag", get: function get() {
          return "ext";
        } }, { key: "hasContent", value: function hasContent(model) {
          return this.conditionalFormattings.hasContent(model.conditionalFormattings);
        } }, { key: "prepare", value: function prepare(model, options) {
          this.conditionalFormattings.prepare(model.conditionalFormattings, options);
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("ext", { uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" });
          this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name] = parser.model;
        } }]);
        return ExtXform2;
      }(CompositeXform);
      var ExtLstXform = /* @__PURE__ */ function(_CompositeXform15) {
        _inherits(ExtLstXform2, _CompositeXform15);
        var _super65 = _createSuper(ExtLstXform2);
        function ExtLstXform2() {
          var _this91;
          _classCallCheck(this, ExtLstXform2);
          _this91 = _super65.call(this);
          _this91.map = { ext: _this91.ext = new ExtXform() };
          return _this91;
        }
        _createClass(ExtLstXform2, [{ key: "tag", get: function get() {
          return "extLst";
        } }, { key: "prepare", value: function prepare(model, options) {
          this.ext.prepare(model, options);
        } }, { key: "hasContent", value: function hasContent(model) {
          return this.ext.hasContent(model);
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (!this.hasContent(model)) {
            return;
          }
          xmlStream.openNode("extLst");
          this.ext.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }]);
        return ExtLstXform2;
      }(CompositeXform);
      module2.exports = ExtLstXform;
    }, { "../composite-xform": 48, "./cf-ext/conditional-formattings-ext-xform": 78 }], 97: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var HeaderFooterXform = /* @__PURE__ */ function(_BaseXform48) {
        _inherits(HeaderFooterXform2, _BaseXform48);
        var _super66 = _createSuper(HeaderFooterXform2);
        function HeaderFooterXform2() {
          _classCallCheck(this, HeaderFooterXform2);
          return _super66.apply(this, arguments);
        }
        _createClass(HeaderFooterXform2, [{ key: "tag", get: function get() {
          return "headerFooter";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.addRollback();
            var createTag = false;
            xmlStream.openNode("headerFooter");
            if (model.differentFirst) {
              xmlStream.addAttribute("differentFirst", "1");
              createTag = true;
            }
            if (model.differentOddEven) {
              xmlStream.addAttribute("differentOddEven", "1");
              createTag = true;
            }
            if (model.oddHeader && typeof model.oddHeader === "string") {
              xmlStream.leafNode("oddHeader", null, model.oddHeader);
              createTag = true;
            }
            if (model.oddFooter && typeof model.oddFooter === "string") {
              xmlStream.leafNode("oddFooter", null, model.oddFooter);
              createTag = true;
            }
            if (model.evenHeader && typeof model.evenHeader === "string") {
              xmlStream.leafNode("evenHeader", null, model.evenHeader);
              createTag = true;
            }
            if (model.evenFooter && typeof model.evenFooter === "string") {
              xmlStream.leafNode("evenFooter", null, model.evenFooter);
              createTag = true;
            }
            if (model.firstHeader && typeof model.firstHeader === "string") {
              xmlStream.leafNode("firstHeader", null, model.firstHeader);
              createTag = true;
            }
            if (model.firstFooter && typeof model.firstFooter === "string") {
              xmlStream.leafNode("firstFooter", null, model.firstFooter);
              createTag = true;
            }
            if (createTag) {
              xmlStream.closeNode();
              xmlStream.commit();
            } else {
              xmlStream.rollback();
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "headerFooter":
              this.model = {};
              if (node.attributes.differentFirst) {
                this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;
              }
              if (node.attributes.differentOddEven) {
                this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;
              }
              return true;
            case "oddHeader":
              this.currentNode = "oddHeader";
              return true;
            case "oddFooter":
              this.currentNode = "oddFooter";
              return true;
            case "evenHeader":
              this.currentNode = "evenHeader";
              return true;
            case "evenFooter":
              this.currentNode = "evenFooter";
              return true;
            case "firstHeader":
              this.currentNode = "firstHeader";
              return true;
            case "firstFooter":
              this.currentNode = "firstFooter";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          switch (this.currentNode) {
            case "oddHeader":
              this.model.oddHeader = text;
              break;
            case "oddFooter":
              this.model.oddFooter = text;
              break;
            case "evenHeader":
              this.model.evenHeader = text;
              break;
            case "evenFooter":
              this.model.evenFooter = text;
              break;
            case "firstHeader":
              this.model.firstHeader = text;
              break;
            case "firstFooter":
              this.model.firstFooter = text;
              break;
          }
        } }, { key: "parseClose", value: function parseClose() {
          switch (this.currentNode) {
            case "oddHeader":
            case "oddFooter":
            case "evenHeader":
            case "evenFooter":
            case "firstHeader":
            case "firstFooter":
              this.currentNode = void 0;
              return true;
            default:
              return false;
          }
        } }]);
        return HeaderFooterXform2;
      }(BaseXform);
      module2.exports = HeaderFooterXform;
    }, { "../base-xform": 32 }], 98: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var HyperlinkXform = /* @__PURE__ */ function(_BaseXform49) {
        _inherits(HyperlinkXform2, _BaseXform49);
        var _super67 = _createSuper(HyperlinkXform2);
        function HyperlinkXform2() {
          _classCallCheck(this, HyperlinkXform2);
          return _super67.apply(this, arguments);
        }
        _createClass(HyperlinkXform2, [{ key: "tag", get: function get() {
          return "hyperlink";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (this.isInternalLink(model)) {
            xmlStream.leafNode("hyperlink", { ref: model.address, "r:id": model.rId, tooltip: model.tooltip, location: model.target });
          } else {
            xmlStream.leafNode("hyperlink", { ref: model.address, "r:id": model.rId, tooltip: model.tooltip });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "hyperlink") {
            this.model = { address: node.attributes.ref, rId: node.attributes["r:id"], tooltip: node.attributes.tooltip };
            if (node.attributes.location) {
              this.model.target = node.attributes.location;
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "isInternalLink", value: function isInternalLink(model) {
          return model.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(model.target);
        } }]);
        return HyperlinkXform2;
      }(BaseXform);
      module2.exports = HyperlinkXform;
    }, { "../base-xform": 32 }], 99: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var MergeCellXform = /* @__PURE__ */ function(_BaseXform50) {
        _inherits(MergeCellXform2, _BaseXform50);
        var _super68 = _createSuper(MergeCellXform2);
        function MergeCellXform2() {
          _classCallCheck(this, MergeCellXform2);
          return _super68.apply(this, arguments);
        }
        _createClass(MergeCellXform2, [{ key: "tag", get: function get() {
          return "mergeCell";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("mergeCell", { ref: model });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "mergeCell") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return MergeCellXform2;
      }(BaseXform);
      module2.exports = MergeCellXform;
    }, { "../base-xform": 32 }], 100: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var Range = require2("../../../doc/range");
      var colCache = require2("../../../utils/col-cache");
      var Enums = require2("../../../doc/enums");
      var Merges2 = /* @__PURE__ */ function() {
        function Merges3() {
          _classCallCheck(this, Merges3);
          this.merges = {};
        }
        _createClass(Merges3, [{ key: "add", value: function add(merge2) {
          if (this.merges[merge2.master]) {
            this.merges[merge2.master].expandToAddress(merge2.address);
          } else {
            var range = "".concat(merge2.master, ":").concat(merge2.address);
            this.merges[merge2.master] = new Range(range);
          }
        } }, { key: "mergeCells", get: function get() {
          return _.map(this.merges, function(merge2) {
            return merge2.range;
          });
        } }, { key: "reconcile", value: function reconcile(mergeCells, rows) {
          _.each(mergeCells, function(merge2) {
            var dimensions = colCache.decode(merge2);
            for (var i = dimensions.top; i <= dimensions.bottom; i++) {
              var row = rows[i - 1];
              for (var j = dimensions.left; j <= dimensions.right; j++) {
                var cell = row.cells[j - 1];
                if (!cell) {
                  row.cells[j] = { type: Enums.ValueType.Null, address: colCache.encodeAddress(i, j) };
                } else if (cell.type === Enums.ValueType.Merge) {
                  cell.master = dimensions.tl;
                }
              }
            }
          });
        } }, { key: "getMasterAddress", value: function getMasterAddress(address) {
          var range = this.hash[address];
          return range && range.tl;
        } }]);
        return Merges3;
      }();
      module2.exports = Merges2;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 26 }], 101: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var isDefined = function isDefined2(attr) {
        return typeof attr !== "undefined";
      };
      var OutlinePropertiesXform = /* @__PURE__ */ function(_BaseXform51) {
        _inherits(OutlinePropertiesXform2, _BaseXform51);
        var _super69 = _createSuper(OutlinePropertiesXform2);
        function OutlinePropertiesXform2() {
          _classCallCheck(this, OutlinePropertiesXform2);
          return _super69.apply(this, arguments);
        }
        _createClass(OutlinePropertiesXform2, [{ key: "tag", get: function get() {
          return "outlinePr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
            xmlStream.leafNode(this.tag, { summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : void 0, summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : void 0 });
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { summaryBelow: isDefined(node.attributes.summaryBelow) ? Boolean(Number(node.attributes.summaryBelow)) : void 0, summaryRight: isDefined(node.attributes.summaryRight) ? Boolean(Number(node.attributes.summaryRight)) : void 0 };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return OutlinePropertiesXform2;
      }(BaseXform);
      module2.exports = OutlinePropertiesXform;
    }, { "../base-xform": 32 }], 102: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var PageBreaksXform = /* @__PURE__ */ function(_BaseXform52) {
        _inherits(PageBreaksXform2, _BaseXform52);
        var _super70 = _createSuper(PageBreaksXform2);
        function PageBreaksXform2() {
          _classCallCheck(this, PageBreaksXform2);
          return _super70.apply(this, arguments);
        }
        _createClass(PageBreaksXform2, [{ key: "tag", get: function get() {
          return "brk";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("brk", model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "brk") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PageBreaksXform2;
      }(BaseXform);
      module2.exports = PageBreaksXform;
    }, { "../base-xform": 32 }], 103: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var PageMarginsXform = /* @__PURE__ */ function(_BaseXform53) {
        _inherits(PageMarginsXform2, _BaseXform53);
        var _super71 = _createSuper(PageMarginsXform2);
        function PageMarginsXform2() {
          _classCallCheck(this, PageMarginsXform2);
          return _super71.apply(this, arguments);
        }
        _createClass(PageMarginsXform2, [{ key: "tag", get: function get() {
          return "pageMargins";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            var attributes = { left: model.left, right: model.right, top: model.top, bottom: model.bottom, header: model.header, footer: model.footer };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { left: parseFloat(node.attributes.left || 0.7), right: parseFloat(node.attributes.right || 0.7), top: parseFloat(node.attributes.top || 0.75), bottom: parseFloat(node.attributes.bottom || 0.75), header: parseFloat(node.attributes.header || 0.3), footer: parseFloat(node.attributes.footer || 0.3) };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PageMarginsXform2;
      }(BaseXform);
      module2.exports = PageMarginsXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 104: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var PageSetupPropertiesXform = /* @__PURE__ */ function(_BaseXform54) {
        _inherits(PageSetupPropertiesXform2, _BaseXform54);
        var _super72 = _createSuper(PageSetupPropertiesXform2);
        function PageSetupPropertiesXform2() {
          _classCallCheck(this, PageSetupPropertiesXform2);
          return _super72.apply(this, arguments);
        }
        _createClass(PageSetupPropertiesXform2, [{ key: "tag", get: function get() {
          return "pageSetUpPr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model && model.fitToPage) {
            xmlStream.leafNode(this.tag, { fitToPage: model.fitToPage ? "1" : void 0 });
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { fitToPage: node.attributes.fitToPage === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PageSetupPropertiesXform2;
      }(BaseXform);
      module2.exports = PageSetupPropertiesXform;
    }, { "../base-xform": 32 }], 105: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model) {
        return model ? "1" : void 0;
      }
      function pageOrderToXml(model) {
        switch (model) {
          case "overThenDown":
            return model;
          default:
            return void 0;
        }
      }
      function cellCommentsToXml(model) {
        switch (model) {
          case "atEnd":
          case "asDisplyed":
            return model;
          default:
            return void 0;
        }
      }
      function errorsToXml(model) {
        switch (model) {
          case "dash":
          case "blank":
          case "NA":
            return model;
          default:
            return void 0;
        }
      }
      function pageSizeToModel(value) {
        return value !== void 0 ? parseInt(value, 10) : void 0;
      }
      var PageSetupXform = /* @__PURE__ */ function(_BaseXform55) {
        _inherits(PageSetupXform2, _BaseXform55);
        var _super73 = _createSuper(PageSetupXform2);
        function PageSetupXform2() {
          _classCallCheck(this, PageSetupXform2);
          return _super73.apply(this, arguments);
        }
        _createClass(PageSetupXform2, [{ key: "tag", get: function get() {
          return "pageSetup";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            var attributes = { paperSize: model.paperSize, orientation: model.orientation, horizontalDpi: model.horizontalDpi, verticalDpi: model.verticalDpi, pageOrder: pageOrderToXml(model.pageOrder), blackAndWhite: booleanToXml(model.blackAndWhite), draft: booleanToXml(model.draft), cellComments: cellCommentsToXml(model.cellComments), errors: errorsToXml(model.errors), scale: model.scale, fitToWidth: model.fitToWidth, fitToHeight: model.fitToHeight, firstPageNumber: model.firstPageNumber, useFirstPageNumber: booleanToXml(model.firstPageNumber), usePrinterDefaults: booleanToXml(model.usePrinterDefaults), copies: model.copies };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { paperSize: pageSizeToModel(node.attributes.paperSize), orientation: node.attributes.orientation || "portrait", horizontalDpi: parseInt(node.attributes.horizontalDpi || "4294967295", 10), verticalDpi: parseInt(node.attributes.verticalDpi || "4294967295", 10), pageOrder: node.attributes.pageOrder || "downThenOver", blackAndWhite: node.attributes.blackAndWhite === "1", draft: node.attributes.draft === "1", cellComments: node.attributes.cellComments || "None", errors: node.attributes.errors || "displayed", scale: parseInt(node.attributes.scale || "100", 10), fitToWidth: parseInt(node.attributes.fitToWidth || "1", 10), fitToHeight: parseInt(node.attributes.fitToHeight || "1", 10), firstPageNumber: parseInt(node.attributes.firstPageNumber || "1", 10), useFirstPageNumber: node.attributes.useFirstPageNumber === "1", usePrinterDefaults: node.attributes.usePrinterDefaults === "1", copies: parseInt(node.attributes.copies || "1", 10) };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PageSetupXform2;
      }(BaseXform);
      module2.exports = PageSetupXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 106: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var PictureXform = /* @__PURE__ */ function(_BaseXform56) {
        _inherits(PictureXform2, _BaseXform56);
        var _super74 = _createSuper(PictureXform2);
        function PictureXform2() {
          _classCallCheck(this, PictureXform2);
          return _super74.apply(this, arguments);
        }
        _createClass(PictureXform2, [{ key: "tag", get: function get() {
          return "picture";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PictureXform2;
      }(BaseXform);
      module2.exports = PictureXform;
    }, { "../base-xform": 32 }], 107: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model) {
        return model ? "1" : void 0;
      }
      var PrintOptionsXform = /* @__PURE__ */ function(_BaseXform57) {
        _inherits(PrintOptionsXform2, _BaseXform57);
        var _super75 = _createSuper(PrintOptionsXform2);
        function PrintOptionsXform2() {
          _classCallCheck(this, PrintOptionsXform2);
          return _super75.apply(this, arguments);
        }
        _createClass(PrintOptionsXform2, [{ key: "tag", get: function get() {
          return "printOptions";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            var attributes = { headings: booleanToXml(model.showRowColHeaders), gridLines: booleanToXml(model.showGridLines), horizontalCentered: booleanToXml(model.horizontalCentered), verticalCentered: booleanToXml(model.verticalCentered) };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { showRowColHeaders: node.attributes.headings === "1", showGridLines: node.attributes.gridLines === "1", horizontalCentered: node.attributes.horizontalCentered === "1", verticalCentered: node.attributes.verticalCentered === "1" };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return PrintOptionsXform2;
      }(BaseXform);
      module2.exports = PrintOptionsXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 108: [function(require2, module2, exports2) {
      var PageBreaksXform = require2("./page-breaks-xform");
      var ListXform = require2("../list-xform");
      var RowBreaksXform = /* @__PURE__ */ function(_ListXform) {
        _inherits(RowBreaksXform2, _ListXform);
        var _super76 = _createSuper(RowBreaksXform2);
        function RowBreaksXform2() {
          _classCallCheck(this, RowBreaksXform2);
          var options = { tag: "rowBreaks", count: true, childXform: new PageBreaksXform() };
          return _super76.call(this, options);
        }
        _createClass(RowBreaksXform2, [{ key: "render", value: function render13(xmlStream, model) {
          if (model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
              xmlStream.addAttribute(this.$count, model.length);
              xmlStream.addAttribute("manualBreakCount", model.length);
            }
            var childXform = this.childXform;
            model.forEach(function(childModel) {
              childXform.render(xmlStream, childModel);
            });
            xmlStream.closeNode();
          } else if (this.empty) {
            xmlStream.leafNode(this.tag);
          }
        } }]);
        return RowBreaksXform2;
      }(ListXform);
      module2.exports = RowBreaksXform;
    }, { "../list-xform": 71, "./page-breaks-xform": 102 }], 109: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var utils = require2("../../../utils/utils");
      var CellXform = require2("./cell-xform");
      var RowXform = /* @__PURE__ */ function(_BaseXform58) {
        _inherits(RowXform2, _BaseXform58);
        var _super77 = _createSuper(RowXform2);
        function RowXform2(options) {
          var _this92;
          _classCallCheck(this, RowXform2);
          _this92 = _super77.call(this);
          _this92.maxItems = options && options.maxItems;
          _this92.map = { c: new CellXform() };
          return _this92;
        }
        _createClass(RowXform2, [{ key: "tag", get: function get() {
          return "row";
        } }, { key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style);
          if (styleId) {
            model.styleId = styleId;
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.prepare(cellModel, options);
          });
        } }, { key: "render", value: function render13(xmlStream, model, options) {
          xmlStream.openNode("row");
          xmlStream.addAttribute("r", model.number);
          if (model.height) {
            xmlStream.addAttribute("ht", model.height);
            xmlStream.addAttribute("customHeight", "1");
          }
          if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
          }
          if (model.min > 0 && model.max > 0 && model.min <= model.max) {
            xmlStream.addAttribute("spans", "".concat(model.min, ":").concat(model.max));
          }
          if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
            xmlStream.addAttribute("customFormat", "1");
          }
          xmlStream.addAttribute("x14ac:dyDescent", "0.25");
          if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
          }
          if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.render(xmlStream, cellModel, options);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === "row") {
            this.numRowsSeen += 1;
            var spans = node.attributes.spans ? node.attributes.spans.split(":").map(function(span) {
              return parseInt(span, 10);
            }) : [void 0, void 0];
            var model = this.model = { number: parseInt(node.attributes.r, 10), min: spans[0], max: spans[1], cells: [] };
            if (node.attributes.s) {
              model.styleId = parseInt(node.attributes.s, 10);
            }
            if (utils.parseBoolean(node.attributes.hidden)) {
              model.hidden = true;
            }
            if (utils.parseBoolean(node.attributes.bestFit)) {
              model.bestFit = true;
            }
            if (node.attributes.ht) {
              model.height = parseFloat(node.attributes.ht);
            }
            if (node.attributes.outlineLevel) {
              model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (utils.parseBoolean(node.attributes.collapsed)) {
              model.collapsed = true;
            }
            return true;
          }
          this.parser = this.map[node.name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.cells.push(this.parser.model);
              if (this.maxItems && this.model.cells.length > this.maxItems) {
                throw new Error("Max column count (".concat(this.maxItems, ") exceeded"));
              }
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
          if (model.styleId !== void 0) {
            model.styleId = void 0;
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.reconcile(cellModel, options);
          });
        } }]);
        return RowXform2;
      }(BaseXform);
      module2.exports = RowXform;
    }, { "../../../utils/utils": 27, "../base-xform": 32, "./cell-xform": 73 }], 110: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var SheetFormatPropertiesXform = /* @__PURE__ */ function(_BaseXform59) {
        _inherits(SheetFormatPropertiesXform2, _BaseXform59);
        var _super78 = _createSuper(SheetFormatPropertiesXform2);
        function SheetFormatPropertiesXform2() {
          _classCallCheck(this, SheetFormatPropertiesXform2);
          return _super78.apply(this, arguments);
        }
        _createClass(SheetFormatPropertiesXform2, [{ key: "tag", get: function get() {
          return "sheetFormatPr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            var attributes = { defaultRowHeight: model.defaultRowHeight, outlineLevelRow: model.outlineLevelRow, outlineLevelCol: model.outlineLevelCol, "x14ac:dyDescent": model.dyDescent };
            if (model.defaultColWidth) {
              attributes.defaultColWidth = model.defaultColWidth;
            }
            if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
              attributes.customHeight = "1";
            }
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode("sheetFormatPr", attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "sheetFormatPr") {
            this.model = { defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || "0"), dyDescent: parseFloat(node.attributes["x14ac:dyDescent"] || "0"), outlineLevelRow: parseInt(node.attributes.outlineLevelRow || "0", 10), outlineLevelCol: parseInt(node.attributes.outlineLevelCol || "0", 10) };
            if (node.attributes.defaultColWidth) {
              this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return SheetFormatPropertiesXform2;
      }(BaseXform);
      module2.exports = SheetFormatPropertiesXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 111: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var ColorXform = require2("../style/color-xform");
      var PageSetupPropertiesXform = require2("./page-setup-properties-xform");
      var OutlinePropertiesXform = require2("./outline-properties-xform");
      var SheetPropertiesXform = /* @__PURE__ */ function(_BaseXform60) {
        _inherits(SheetPropertiesXform2, _BaseXform60);
        var _super79 = _createSuper(SheetPropertiesXform2);
        function SheetPropertiesXform2() {
          var _this93;
          _classCallCheck(this, SheetPropertiesXform2);
          _this93 = _super79.call(this);
          _this93.map = { tabColor: new ColorXform("tabColor"), pageSetUpPr: new PageSetupPropertiesXform(), outlinePr: new OutlinePropertiesXform() };
          return _this93;
        }
        _createClass(SheetPropertiesXform2, [{ key: "tag", get: function get() {
          return "sheetPr";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.addRollback();
            xmlStream.openNode("sheetPr");
            var inner = false;
            inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;
            inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;
            inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;
            if (inner) {
              xmlStream.closeNode();
              xmlStream.commit();
            } else {
              xmlStream.rollback();
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === this.tag) {
            this.reset();
            return true;
          }
          if (this.map[node.name]) {
            this.parser = this.map[node.name];
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
            return true;
          }
          return false;
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
            this.model = {};
            if (this.map.tabColor.model) {
              this.model.tabColor = this.map.tabColor.model;
            }
            if (this.map.pageSetUpPr.model) {
              this.model.pageSetup = this.map.pageSetUpPr.model;
            }
            if (this.map.outlinePr.model) {
              this.model.outlineProperties = this.map.outlinePr.model;
            }
          } else {
            this.model = null;
          }
          return false;
        } }]);
        return SheetPropertiesXform2;
      }(BaseXform);
      module2.exports = SheetPropertiesXform;
    }, { "../base-xform": 32, "../style/color-xform": 128, "./outline-properties-xform": 101, "./page-setup-properties-xform": 104 }], 112: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model, value) {
        return model ? value : void 0;
      }
      function xmlToBoolean(value, equals2) {
        return value === equals2 ? true : void 0;
      }
      var SheetProtectionXform = /* @__PURE__ */ function(_BaseXform61) {
        _inherits(SheetProtectionXform2, _BaseXform61);
        var _super80 = _createSuper(SheetProtectionXform2);
        function SheetProtectionXform2() {
          _classCallCheck(this, SheetProtectionXform2);
          return _super80.apply(this, arguments);
        }
        _createClass(SheetProtectionXform2, [{ key: "tag", get: function get() {
          return "sheetProtection";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            var attributes = { sheet: booleanToXml(model.sheet, "1"), selectLockedCells: model.selectLockedCells === false ? "1" : void 0, selectUnlockedCells: model.selectUnlockedCells === false ? "1" : void 0, formatCells: booleanToXml(model.formatCells, "0"), formatColumns: booleanToXml(model.formatColumns, "0"), formatRows: booleanToXml(model.formatRows, "0"), insertColumns: booleanToXml(model.insertColumns, "0"), insertRows: booleanToXml(model.insertRows, "0"), insertHyperlinks: booleanToXml(model.insertHyperlinks, "0"), deleteColumns: booleanToXml(model.deleteColumns, "0"), deleteRows: booleanToXml(model.deleteRows, "0"), sort: booleanToXml(model.sort, "0"), autoFilter: booleanToXml(model.autoFilter, "0"), pivotTables: booleanToXml(model.pivotTables, "0") };
            if (model.sheet) {
              attributes.algorithmName = model.algorithmName;
              attributes.hashValue = model.hashValue;
              attributes.saltValue = model.saltValue;
              attributes.spinCount = model.spinCount;
              attributes.objects = booleanToXml(model.objects === false, "1");
              attributes.scenarios = booleanToXml(model.scenarios === false, "1");
            }
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { sheet: xmlToBoolean(node.attributes.sheet, "1"), objects: node.attributes.objects === "1" ? false : void 0, scenarios: node.attributes.scenarios === "1" ? false : void 0, selectLockedCells: node.attributes.selectLockedCells === "1" ? false : void 0, selectUnlockedCells: node.attributes.selectUnlockedCells === "1" ? false : void 0, formatCells: xmlToBoolean(node.attributes.formatCells, "0"), formatColumns: xmlToBoolean(node.attributes.formatColumns, "0"), formatRows: xmlToBoolean(node.attributes.formatRows, "0"), insertColumns: xmlToBoolean(node.attributes.insertColumns, "0"), insertRows: xmlToBoolean(node.attributes.insertRows, "0"), insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, "0"), deleteColumns: xmlToBoolean(node.attributes.deleteColumns, "0"), deleteRows: xmlToBoolean(node.attributes.deleteRows, "0"), sort: xmlToBoolean(node.attributes.sort, "0"), autoFilter: xmlToBoolean(node.attributes.autoFilter, "0"), pivotTables: xmlToBoolean(node.attributes.pivotTables, "0") };
              if (node.attributes.algorithmName) {
                this.model.algorithmName = node.attributes.algorithmName;
                this.model.hashValue = node.attributes.hashValue;
                this.model.saltValue = node.attributes.saltValue;
                this.model.spinCount = parseInt(node.attributes.spinCount, 10);
              }
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return SheetProtectionXform2;
      }(BaseXform);
      module2.exports = SheetProtectionXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 113: [function(require2, module2, exports2) {
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var VIEW_STATES = { frozen: "frozen", frozenSplit: "frozen", split: "split" };
      var SheetViewXform = /* @__PURE__ */ function(_BaseXform62) {
        _inherits(SheetViewXform2, _BaseXform62);
        var _super81 = _createSuper(SheetViewXform2);
        function SheetViewXform2() {
          _classCallCheck(this, SheetViewXform2);
          return _super81.apply(this, arguments);
        }
        _createClass(SheetViewXform2, [{ key: "tag", get: function get() {
          return "sheetView";
        } }, { key: "prepare", value: function prepare(model) {
          switch (model.state) {
            case "frozen":
            case "split":
              break;
            default:
              model.state = "normal";
              break;
          }
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("sheetView", { workbookViewId: model.workbookViewId || 0 });
          var add = function add2(name, value, included) {
            if (included) {
              xmlStream.addAttribute(name, value);
            }
          };
          add("rightToLeft", "1", model.rightToLeft === true);
          add("tabSelected", "1", model.tabSelected);
          add("showRuler", "0", model.showRuler === false);
          add("showRowColHeaders", "0", model.showRowColHeaders === false);
          add("showGridLines", "0", model.showGridLines === false);
          add("zoomScale", model.zoomScale, model.zoomScale);
          add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
          add("view", model.style, model.style);
          var topLeftCell;
          var xSplit;
          var ySplit;
          var activePane;
          switch (model.state) {
            case "frozen":
              xSplit = model.xSplit || 0;
              ySplit = model.ySplit || 0;
              topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;
              activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
              xmlStream.leafNode("pane", { xSplit: model.xSplit || void 0, ySplit: model.ySplit || void 0, topLeftCell, activePane, state: "frozen" });
              xmlStream.leafNode("selection", { pane: activePane, activeCell: model.activeCell, sqref: model.activeCell });
              break;
            case "split":
              if (model.activePane === "topLeft") {
                model.activePane = void 0;
              }
              xmlStream.leafNode("pane", { xSplit: model.xSplit || void 0, ySplit: model.ySplit || void 0, topLeftCell: model.topLeftCell, activePane: model.activePane });
              xmlStream.leafNode("selection", { pane: model.activePane, activeCell: model.activeCell, sqref: model.activeCell });
              break;
            case "normal":
              if (model.activeCell) {
                xmlStream.leafNode("selection", { activeCell: model.activeCell, sqref: model.activeCell });
              }
              break;
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "sheetView":
              this.sheetView = { workbookViewId: parseInt(node.attributes.workbookViewId, 10), rightToLeft: node.attributes.rightToLeft === "1", tabSelected: node.attributes.tabSelected === "1", showRuler: !(node.attributes.showRuler === "0"), showRowColHeaders: !(node.attributes.showRowColHeaders === "0"), showGridLines: !(node.attributes.showGridLines === "0"), zoomScale: parseInt(node.attributes.zoomScale || "100", 10), zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || "100", 10), style: node.attributes.view };
              this.pane = void 0;
              this.selections = {};
              return true;
            case "pane":
              this.pane = { xSplit: parseInt(node.attributes.xSplit || "0", 10), ySplit: parseInt(node.attributes.ySplit || "0", 10), topLeftCell: node.attributes.topLeftCell, activePane: node.attributes.activePane || "topLeft", state: node.attributes.state };
              return true;
            case "selection": {
              var name = node.attributes.pane || "topLeft";
              this.selections[name] = { pane: name, activeCell: node.attributes.activeCell };
              return true;
            }
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          var model;
          var selection;
          switch (name) {
            case "sheetView":
              if (this.sheetView && this.pane) {
                model = this.model = {
                  workbookViewId: this.sheetView.workbookViewId,
                  rightToLeft: this.sheetView.rightToLeft,
                  state: VIEW_STATES[this.pane.state] || "split",
                  // split is default
                  xSplit: this.pane.xSplit,
                  ySplit: this.pane.ySplit,
                  topLeftCell: this.pane.topLeftCell,
                  showRuler: this.sheetView.showRuler,
                  showRowColHeaders: this.sheetView.showRowColHeaders,
                  showGridLines: this.sheetView.showGridLines,
                  zoomScale: this.sheetView.zoomScale,
                  zoomScaleNormal: this.sheetView.zoomScaleNormal
                };
                if (this.model.state === "split") {
                  model.activePane = this.pane.activePane;
                }
                selection = this.selections[this.pane.activePane];
                if (selection && selection.activeCell) {
                  model.activeCell = selection.activeCell;
                }
                if (this.sheetView.style) {
                  model.style = this.sheetView.style;
                }
              } else {
                model = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: "normal", showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal };
                selection = this.selections.topLeft;
                if (selection && selection.activeCell) {
                  model.activeCell = selection.activeCell;
                }
                if (this.sheetView.style) {
                  model.style = this.sheetView.style;
                }
              }
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile() {
        } }]);
        return SheetViewXform2;
      }(BaseXform);
      module2.exports = SheetViewXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 114: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var TablePartXform = /* @__PURE__ */ function(_BaseXform63) {
        _inherits(TablePartXform2, _BaseXform63);
        var _super82 = _createSuper(TablePartXform2);
        function TablePartXform2() {
          _classCallCheck(this, TablePartXform2);
          return _super82.apply(this, arguments);
        }
        _createClass(TablePartXform2, [{ key: "tag", get: function get() {
          return "tablePart";
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return TablePartXform2;
      }(BaseXform);
      module2.exports = TablePartXform;
    }, { "../base-xform": 32 }], 115: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var RelType = require2("../../rel-type");
      var Merges2 = require2("./merges");
      var BaseXform = require2("../base-xform");
      var ListXform = require2("../list-xform");
      var RowXform = require2("./row-xform");
      var ColXform = require2("./col-xform");
      var DimensionXform = require2("./dimension-xform");
      var HyperlinkXform = require2("./hyperlink-xform");
      var MergeCellXform = require2("./merge-cell-xform");
      var DataValidationsXform = require2("./data-validations-xform");
      var SheetPropertiesXform = require2("./sheet-properties-xform");
      var SheetFormatPropertiesXform = require2("./sheet-format-properties-xform");
      var SheetViewXform = require2("./sheet-view-xform");
      var SheetProtectionXform = require2("./sheet-protection-xform");
      var PageMarginsXform = require2("./page-margins-xform");
      var PageSetupXform = require2("./page-setup-xform");
      var PrintOptionsXform = require2("./print-options-xform");
      var AutoFilterXform = require2("./auto-filter-xform");
      var PictureXform = require2("./picture-xform");
      var DrawingXform = require2("./drawing-xform");
      var TablePartXform = require2("./table-part-xform");
      var RowBreaksXform = require2("./row-breaks-xform");
      var HeaderFooterXform = require2("./header-footer-xform");
      var ConditionalFormattingsXform = require2("./cf/conditional-formattings-xform");
      var ExtListXform = require2("./ext-lst-xform");
      var mergeRule = function mergeRule2(rule, extRule) {
        Object.keys(extRule).forEach(function(key) {
          var value = rule[key];
          var extValue = extRule[key];
          if (value === void 0 && extValue !== void 0) {
            rule[key] = extValue;
          }
        });
      };
      var mergeConditionalFormattings = function mergeConditionalFormattings2(model, extModel) {
        if (!extModel || !extModel.length) {
          return model;
        }
        if (!model || !model.length) {
          return extModel;
        }
        var cfMap = {};
        var ruleMap = {};
        model.forEach(function(cf) {
          cfMap[cf.ref] = cf;
          cf.rules.forEach(function(rule) {
            var x14Id = rule.x14Id;
            if (x14Id) {
              ruleMap[x14Id] = rule;
            }
          });
        });
        extModel.forEach(function(extCf) {
          extCf.rules.forEach(function(extRule) {
            var rule = ruleMap[extRule.x14Id];
            if (rule) {
              mergeRule(rule, extRule);
            } else if (cfMap[extCf.ref]) {
              cfMap[extCf.ref].rules.push(extRule);
            } else {
              model.push({ ref: extCf.ref, rules: [extRule] });
            }
          });
        });
        return model;
      };
      var WorkSheetXform = /* @__PURE__ */ function(_BaseXform64) {
        _inherits(WorkSheetXform2, _BaseXform64);
        var _super83 = _createSuper(WorkSheetXform2);
        function WorkSheetXform2(options) {
          var _this94;
          _classCallCheck(this, WorkSheetXform2);
          _this94 = _super83.call(this);
          var _ref4 = options || {}, maxRows = _ref4.maxRows, maxCols = _ref4.maxCols, ignoreNodes = _ref4.ignoreNodes;
          _this94.ignoreNodes = ignoreNodes || [];
          _this94.map = { sheetPr: new SheetPropertiesXform(), dimension: new DimensionXform(), sheetViews: new ListXform({ tag: "sheetViews", count: false, childXform: new SheetViewXform() }), sheetFormatPr: new SheetFormatPropertiesXform(), cols: new ListXform({ tag: "cols", count: false, childXform: new ColXform() }), sheetData: new ListXform({ tag: "sheetData", count: false, empty: true, childXform: new RowXform({ maxItems: maxCols }), maxItems: maxRows }), autoFilter: new AutoFilterXform(), mergeCells: new ListXform({ tag: "mergeCells", count: true, childXform: new MergeCellXform() }), rowBreaks: new RowBreaksXform(), hyperlinks: new ListXform({ tag: "hyperlinks", count: false, childXform: new HyperlinkXform() }), pageMargins: new PageMarginsXform(), dataValidations: new DataValidationsXform(), pageSetup: new PageSetupXform(), headerFooter: new HeaderFooterXform(), printOptions: new PrintOptionsXform(), picture: new PictureXform(), drawing: new DrawingXform(), sheetProtection: new SheetProtectionXform(), tableParts: new ListXform({ tag: "tableParts", count: true, childXform: new TablePartXform() }), conditionalFormatting: new ConditionalFormattingsXform(), extLst: new ExtListXform() };
          return _this94;
        }
        _createClass(WorkSheetXform2, [{ key: "prepare", value: function prepare(model, options) {
          var _this95 = this;
          options.merges = new Merges2();
          model.hyperlinks = options.hyperlinks = [];
          model.comments = options.comments = [];
          options.formulae = {};
          options.siFormulae = 0;
          this.map.cols.prepare(model.cols, options);
          this.map.sheetData.prepare(model.rows, options);
          this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
          model.mergeCells = options.merges.mergeCells;
          var rels = model.rels = [];
          function nextRid(r) {
            return "rId".concat(r.length + 1);
          }
          model.hyperlinks.forEach(function(hyperlink) {
            var rId = nextRid(rels);
            hyperlink.rId = rId;
            rels.push({ Id: rId, Type: RelType.Hyperlink, Target: hyperlink.target, TargetMode: "External" });
          });
          if (model.comments.length > 0) {
            var comment = { Id: nextRid(rels), Type: RelType.Comments, Target: "../comments".concat(model.id, ".xml") };
            rels.push(comment);
            var vmlDrawing = { Id: nextRid(rels), Type: RelType.VmlDrawing, Target: "../drawings/vmlDrawing".concat(model.id, ".vml") };
            rels.push(vmlDrawing);
            model.comments.forEach(function(item) {
              item.refAddress = colCache.decodeAddress(item.ref);
            });
            options.commentRefs.push({ commentName: "comments".concat(model.id), vmlDrawing: "vmlDrawing".concat(model.id) });
          }
          var drawingRelsHash = [];
          var bookImage;
          model.media.forEach(function(medium) {
            if (medium.type === "background") {
              var rId = nextRid(rels);
              bookImage = options.media[medium.imageId];
              rels.push({ Id: rId, Type: RelType.Image, Target: "../media/".concat(bookImage.name, ".").concat(bookImage.extension) });
              model.background = { rId };
              model.image = options.media[medium.imageId];
            } else if (medium.type === "image") {
              var drawing = model.drawing;
              bookImage = options.media[medium.imageId];
              if (!drawing) {
                drawing = model.drawing = { rId: nextRid(rels), name: "drawing".concat(++options.drawingsCount), anchors: [], rels: [] };
                options.drawings.push(drawing);
                rels.push({ Id: drawing.rId, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing", Target: "../drawings/".concat(drawing.name, ".xml") });
              }
              var rIdImage = _this95.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
              if (!rIdImage) {
                rIdImage = nextRid(drawing.rels);
                drawingRelsHash[drawing.rels.length] = rIdImage;
                drawing.rels.push({ Id: rIdImage, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", Target: "../media/".concat(bookImage.name, ".").concat(bookImage.extension) });
              }
              var anchor = { picture: { rId: rIdImage }, range: medium.range };
              if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
                var rIdHyperLink = nextRid(drawing.rels);
                drawingRelsHash[drawing.rels.length] = rIdHyperLink;
                anchor.picture.hyperlinks = { tooltip: medium.hyperlinks.tooltip, rId: rIdHyperLink };
                drawing.rels.push({ Id: rIdHyperLink, Type: RelType.Hyperlink, Target: medium.hyperlinks.hyperlink, TargetMode: "External" });
              }
              _this95.preImageId = medium.imageId;
              drawing.anchors.push(anchor);
            }
          });
          model.tables.forEach(function(table) {
            var rId = nextRid(rels);
            table.rId = rId;
            rels.push({ Id: rId, Type: RelType.Table, Target: "../tables/".concat(table.target) });
            table.columns.forEach(function(column) {
              var style = column.style;
              if (style) {
                column.dxfId = options.styles.addDxfStyle(style);
              }
            });
          });
          this.map.extLst.prepare(model, options);
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("worksheet", WorkSheetXform2.WORKSHEET_ATTRIBUTES);
          var sheetFormatPropertiesModel = model.properties ? { defaultRowHeight: model.properties.defaultRowHeight, dyDescent: model.properties.dyDescent, outlineLevelCol: model.properties.outlineLevelCol, outlineLevelRow: model.properties.outlineLevelRow } : void 0;
          if (model.properties && model.properties.defaultColWidth) {
            sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
          }
          var sheetPropertiesModel = { outlineProperties: model.properties && model.properties.outlineProperties, tabColor: model.properties && model.properties.tabColor, pageSetup: model.pageSetup && model.pageSetup.fitToPage ? { fitToPage: model.pageSetup.fitToPage } : void 0 };
          var pageMarginsModel = model.pageSetup && model.pageSetup.margins;
          var printOptionsModel = { showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders, showGridLines: model.pageSetup && model.pageSetup.showGridLines, horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered, verticalCentered: model.pageSetup && model.pageSetup.verticalCentered };
          var sheetProtectionModel = model.sheetProtection;
          this.map.sheetPr.render(xmlStream, sheetPropertiesModel);
          this.map.dimension.render(xmlStream, model.dimensions);
          this.map.sheetViews.render(xmlStream, model.views);
          this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);
          this.map.cols.render(xmlStream, model.cols);
          this.map.sheetData.render(xmlStream, model.rows);
          this.map.sheetProtection.render(xmlStream, sheetProtectionModel);
          this.map.autoFilter.render(xmlStream, model.autoFilter);
          this.map.mergeCells.render(xmlStream, model.mergeCells);
          this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings);
          this.map.dataValidations.render(xmlStream, model.dataValidations);
          this.map.hyperlinks.render(xmlStream, model.hyperlinks);
          this.map.printOptions.render(xmlStream, printOptionsModel);
          this.map.pageMargins.render(xmlStream, pageMarginsModel);
          this.map.pageSetup.render(xmlStream, model.pageSetup);
          this.map.headerFooter.render(xmlStream, model.headerFooter);
          this.map.rowBreaks.render(xmlStream, model.rowBreaks);
          this.map.drawing.render(xmlStream, model.drawing);
          this.map.picture.render(xmlStream, model.background);
          this.map.tableParts.render(xmlStream, model.tables);
          this.map.extLst.render(xmlStream, model);
          if (model.rels) {
            model.rels.forEach(function(rel) {
              if (rel.Type === RelType.VmlDrawing) {
                xmlStream.leafNode("legacyDrawing", { "r:id": rel.Id });
              }
            });
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === "worksheet") {
            _.each(this.map, function(xform) {
              xform.reset();
            });
            return true;
          }
          if (this.map[node.name] && !this.ignoreNodes.includes(node.name)) {
            this.parser = this.map[node.name];
            this.parser.parseOpen(node);
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "worksheet": {
              var properties = this.map.sheetFormatPr.model || {};
              if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
                properties.tabColor = this.map.sheetPr.model.tabColor;
              }
              if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
                properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
              }
              var sheetProperties = { fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false, margins: this.map.pageMargins.model };
              var pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
              var conditionalFormattings = mergeConditionalFormattings(this.map.conditionalFormatting.model, this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]);
              this.model = { dimensions: this.map.dimension.model, cols: this.map.cols.model, rows: this.map.sheetData.model, mergeCells: this.map.mergeCells.model, hyperlinks: this.map.hyperlinks.model, dataValidations: this.map.dataValidations.model, properties, views: this.map.sheetViews.model, pageSetup, headerFooter: this.map.headerFooter.model, background: this.map.picture.model, drawing: this.map.drawing.model, tables: this.map.tableParts.model, conditionalFormattings };
              if (this.map.autoFilter.model) {
                this.model.autoFilter = this.map.autoFilter.model;
              }
              if (this.map.sheetProtection.model) {
                this.model.sheetProtection = this.map.sheetProtection.model;
              }
              return false;
            }
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var rels = (model.relationships || []).reduce(function(h3, rel) {
            h3[rel.Id] = rel;
            if (rel.Type === RelType.Comments) {
              model.comments = options.comments[rel.Target].comments;
            }
            if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {
              var vmlComment = options.vmlDrawings[rel.Target].comments;
              model.comments.forEach(function(comment, index2) {
                comment.note = Object.assign({}, comment.note, vmlComment[index2]);
              });
            }
            return h3;
          }, {});
          options.commentsMap = (model.comments || []).reduce(function(h3, comment) {
            if (comment.ref) {
              h3[comment.ref] = comment;
            }
            return h3;
          }, {});
          options.hyperlinkMap = (model.hyperlinks || []).reduce(function(h3, hyperlink) {
            if (hyperlink.rId) {
              h3[hyperlink.address] = rels[hyperlink.rId].Target;
            }
            return h3;
          }, {});
          options.formulae = {};
          model.rows = model.rows && model.rows.filter(Boolean) || [];
          model.rows.forEach(function(row) {
            row.cells = row.cells && row.cells.filter(Boolean) || [];
          });
          this.map.cols.reconcile(model.cols, options);
          this.map.sheetData.reconcile(model.rows, options);
          this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
          model.media = [];
          if (model.drawing) {
            var drawingRel = rels[model.drawing.rId];
            var match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
            if (match) {
              var drawingName = match[1];
              var drawing = options.drawings[drawingName];
              drawing.anchors.forEach(function(anchor) {
                if (anchor.medium) {
                  var image = { type: "image", imageId: anchor.medium.index, range: anchor.range, hyperlinks: anchor.picture.hyperlinks };
                  model.media.push(image);
                }
              });
            }
          }
          var backgroundRel = model.background && rels[model.background.rId];
          if (backgroundRel) {
            var target = backgroundRel.Target.split("/media/")[1];
            var imageId = options.mediaIndex && options.mediaIndex[target];
            if (imageId !== void 0) {
              model.media.push({ type: "background", imageId });
            }
          }
          model.tables = (model.tables || []).map(function(tablePart) {
            var rel = rels[tablePart.rId];
            return options.tables[rel.Target];
          });
          delete model.relationships;
          delete model.hyperlinks;
          delete model.comments;
        } }]);
        return WorkSheetXform2;
      }(BaseXform);
      WorkSheetXform.WORKSHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" };
      module2.exports = WorkSheetXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/xml-stream": 28, "../../rel-type": 31, "../base-xform": 32, "../list-xform": 71, "./auto-filter-xform": 72, "./cf/conditional-formattings-xform": 87, "./col-xform": 92, "./data-validations-xform": 93, "./dimension-xform": 94, "./drawing-xform": 95, "./ext-lst-xform": 96, "./header-footer-xform": 97, "./hyperlink-xform": 98, "./merge-cell-xform": 99, "./merges": 100, "./page-margins-xform": 103, "./page-setup-xform": 105, "./picture-xform": 106, "./print-options-xform": 107, "./row-breaks-xform": 108, "./row-xform": 109, "./sheet-format-properties-xform": 110, "./sheet-properties-xform": 111, "./sheet-protection-xform": 112, "./sheet-view-xform": 113, "./table-part-xform": 114 }], 116: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var BooleanXform = /* @__PURE__ */ function(_BaseXform65) {
        _inherits(BooleanXform2, _BaseXform65);
        var _super84 = _createSuper(BooleanXform2);
        function BooleanXform2(options) {
          var _this96;
          _classCallCheck(this, BooleanXform2);
          _this96 = _super84.call(this);
          _this96.tag = options.tag;
          _this96.attr = options.attr;
          return _this96;
        }
        _createClass(BooleanXform2, [{ key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.tag);
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return BooleanXform2;
      }(BaseXform);
      module2.exports = BooleanXform;
    }, { "../base-xform": 32 }], 117: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var DateXform = /* @__PURE__ */ function(_BaseXform66) {
        _inherits(DateXform2, _BaseXform66);
        var _super85 = _createSuper(DateXform2);
        function DateXform2(options) {
          var _this97;
          _classCallCheck(this, DateXform2);
          _this97 = _super85.call(this);
          _this97.tag = options.tag;
          _this97.attr = options.attr;
          _this97.attrs = options.attrs;
          _this97._format = options.format || function(dt) {
            try {
              if (Number.isNaN(dt.getTime()))
                return "";
              return dt.toISOString();
            } catch (e) {
              return "";
            }
          };
          _this97._parse = options.parse || function(str) {
            return new Date(str);
          };
          return _this97;
        }
        _createClass(DateXform2, [{ key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, this._format(model));
            } else {
              xmlStream.writeText(this._format(model));
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = this._parse(node.attributes[this.attr]);
            } else {
              this.text = [];
            }
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = this._parse(this.text.join(""));
          }
          return false;
        } }]);
        return DateXform2;
      }(BaseXform);
      module2.exports = DateXform;
    }, { "../base-xform": 32 }], 118: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var IntegerXform = /* @__PURE__ */ function(_BaseXform67) {
        _inherits(IntegerXform2, _BaseXform67);
        var _super86 = _createSuper(IntegerXform2);
        function IntegerXform2(options) {
          var _this98;
          _classCallCheck(this, IntegerXform2);
          _this98 = _super86.call(this);
          _this98.tag = options.tag;
          _this98.attr = options.attr;
          _this98.attrs = options.attrs;
          _this98.zero = options.zero;
          return _this98;
        }
        _createClass(IntegerXform2, [{ key: "render", value: function render13(xmlStream, model) {
          if (model || this.zero) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, model);
            } else {
              xmlStream.writeText(model);
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = parseInt(node.attributes[this.attr], 10);
            } else {
              this.text = [];
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = parseInt(this.text.join("") || 0, 10);
          }
          return false;
        } }]);
        return IntegerXform2;
      }(BaseXform);
      module2.exports = IntegerXform;
    }, { "../base-xform": 32 }], 119: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var StringXform = /* @__PURE__ */ function(_BaseXform68) {
        _inherits(StringXform2, _BaseXform68);
        var _super87 = _createSuper(StringXform2);
        function StringXform2(options) {
          var _this99;
          _classCallCheck(this, StringXform2);
          _this99 = _super87.call(this);
          _this99.tag = options.tag;
          _this99.attr = options.attr;
          _this99.attrs = options.attrs;
          return _this99;
        }
        _createClass(StringXform2, [{ key: "render", value: function render13(xmlStream, model) {
          if (model !== void 0) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, model);
            } else {
              xmlStream.writeText(model);
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = node.attributes[this.attr];
            } else {
              this.text = [];
            }
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = this.text.join("");
          }
          return false;
        } }]);
        return StringXform2;
      }(BaseXform);
      module2.exports = StringXform;
    }, { "../base-xform": 32 }], 120: [function(require2, module2, exports2) {
      var BaseXform = require2("./base-xform");
      var XmlStream = require2("../../utils/xml-stream");
      function build(xmlStream, model) {
        xmlStream.openNode(model.tag, model.$);
        if (model.c) {
          model.c.forEach(function(child) {
            build(xmlStream, child);
          });
        }
        if (model.t) {
          xmlStream.writeText(model.t);
        }
        xmlStream.closeNode();
      }
      var StaticXform = /* @__PURE__ */ function(_BaseXform69) {
        _inherits(StaticXform2, _BaseXform69);
        var _super88 = _createSuper(StaticXform2);
        function StaticXform2(model) {
          var _this100;
          _classCallCheck(this, StaticXform2);
          _this100 = _super88.call(this);
          _this100._model = model;
          return _this100;
        }
        _createClass(StaticXform2, [{ key: "render", value: function render13(xmlStream) {
          if (!this._xml) {
            var stream = new XmlStream();
            build(stream, this._model);
            this._xml = stream.xml;
          }
          xmlStream.writeXml(this._xml);
        } }, { key: "parseOpen", value: function parseOpen() {
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this._model.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return StaticXform2;
      }(BaseXform);
      module2.exports = StaticXform;
    }, { "../../utils/xml-stream": 28, "./base-xform": 32 }], 121: [function(require2, module2, exports2) {
      var TextXform = require2("./text-xform");
      var RichTextXform = require2("./rich-text-xform");
      var BaseXform = require2("../base-xform");
      var PhoneticTextXform = /* @__PURE__ */ function(_BaseXform70) {
        _inherits(PhoneticTextXform2, _BaseXform70);
        var _super89 = _createSuper(PhoneticTextXform2);
        function PhoneticTextXform2() {
          var _this101;
          _classCallCheck(this, PhoneticTextXform2);
          _this101 = _super89.call(this);
          _this101.map = { r: new RichTextXform(), t: new TextXform() };
          return _this101;
        }
        _createClass(PhoneticTextXform2, [{ key: "tag", get: function get() {
          return "rPh";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag, { sb: model.sb || 0, eb: model.eb || 0 });
          if (model && model.hasOwnProperty("richText") && model.richText) {
            var r = this.map.r;
            model.richText.forEach(function(text) {
              r.render(xmlStream, text);
            });
          } else if (model) {
            this.map.t.render(xmlStream, model.text);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var name = node.name;
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (name === this.tag) {
            this.model = { sb: parseInt(node.attributes.sb, 10), eb: parseInt(node.attributes.eb, 10) };
            return true;
          }
          this.parser = this.map[name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              switch (name) {
                case "r": {
                  var rt = this.model.richText;
                  if (!rt) {
                    rt = this.model.richText = [];
                  }
                  rt.push(this.parser.model);
                  break;
                }
                case "t":
                  this.model.text = this.parser.model;
                  break;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return PhoneticTextXform2;
      }(BaseXform);
      module2.exports = PhoneticTextXform;
    }, { "../base-xform": 32, "./rich-text-xform": 122, "./text-xform": 125 }], 122: [function(require2, module2, exports2) {
      var TextXform = require2("./text-xform");
      var FontXform = require2("../style/font-xform");
      var BaseXform = require2("../base-xform");
      var RichTextXform = /* @__PURE__ */ function(_BaseXform71) {
        _inherits(RichTextXform2, _BaseXform71);
        var _super90 = _createSuper(RichTextXform2);
        function RichTextXform2(model) {
          var _this102;
          _classCallCheck(this, RichTextXform2);
          _this102 = _super90.call(this);
          _this102.model = model;
          return _this102;
        }
        _createClass(RichTextXform2, [{ key: "tag", get: function get() {
          return "r";
        } }, { key: "textXform", get: function get() {
          return this._textXform || (this._textXform = new TextXform());
        } }, { key: "fontXform", get: function get() {
          return this._fontXform || (this._fontXform = new FontXform(RichTextXform2.FONT_OPTIONS));
        } }, { key: "render", value: function render13(xmlStream, model) {
          model = model || this.model;
          xmlStream.openNode("r");
          if (model.font) {
            this.fontXform.render(xmlStream, model.font);
          }
          this.textXform.render(xmlStream, model.text);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "r":
              this.model = {};
              return true;
            case "t":
              this.parser = this.textXform;
              this.parser.parseOpen(node);
              return true;
            case "rPr":
              this.parser = this.fontXform;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case "r":
              return false;
            case "t":
              this.model.text = this.parser.model;
              this.parser = void 0;
              return true;
            case "rPr":
              this.model.font = this.parser.model;
              this.parser = void 0;
              return true;
            default:
              if (this.parser) {
                this.parser.parseClose(name);
              }
              return true;
          }
        } }]);
        return RichTextXform2;
      }(BaseXform);
      RichTextXform.FONT_OPTIONS = { tagName: "rPr", fontNameTag: "rFont" };
      module2.exports = RichTextXform;
    }, { "../base-xform": 32, "../style/font-xform": 131, "./text-xform": 125 }], 123: [function(require2, module2, exports2) {
      var TextXform = require2("./text-xform");
      var RichTextXform = require2("./rich-text-xform");
      var PhoneticTextXform = require2("./phonetic-text-xform");
      var BaseXform = require2("../base-xform");
      var SharedStringXform = /* @__PURE__ */ function(_BaseXform72) {
        _inherits(SharedStringXform2, _BaseXform72);
        var _super91 = _createSuper(SharedStringXform2);
        function SharedStringXform2(model) {
          var _this103;
          _classCallCheck(this, SharedStringXform2);
          _this103 = _super91.call(this);
          _this103.model = model;
          _this103.map = { r: new RichTextXform(), t: new TextXform(), rPh: new PhoneticTextXform() };
          return _this103;
        }
        _createClass(SharedStringXform2, [{ key: "tag", get: function get() {
          return "si";
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this104 = this;
          xmlStream.openNode(this.tag);
          if (model && model.hasOwnProperty("richText") && model.richText) {
            if (model.richText.length) {
              model.richText.forEach(function(text) {
                _this104.map.r.render(xmlStream, text);
              });
            } else {
              this.map.t.render(xmlStream, "");
            }
          } else if (model !== void 0 && model !== null) {
            this.map.t.render(xmlStream, model);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var name = node.name;
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (name === this.tag) {
            this.model = {};
            return true;
          }
          this.parser = this.map[name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              switch (name) {
                case "r": {
                  var rt = this.model.richText;
                  if (!rt) {
                    rt = this.model.richText = [];
                  }
                  rt.push(this.parser.model);
                  break;
                }
                case "t":
                  this.model = this.parser.model;
                  break;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return SharedStringXform2;
      }(BaseXform);
      module2.exports = SharedStringXform;
    }, { "../base-xform": 32, "./phonetic-text-xform": 121, "./rich-text-xform": 122, "./text-xform": 125 }], 124: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var SharedStringXform = require2("./shared-string-xform");
      var SharedStringsXform = /* @__PURE__ */ function(_BaseXform73) {
        _inherits(SharedStringsXform2, _BaseXform73);
        var _super92 = _createSuper(SharedStringsXform2);
        function SharedStringsXform2(model) {
          var _this105;
          _classCallCheck(this, SharedStringsXform2);
          _this105 = _super92.call(this);
          _this105.model = model || { values: [], count: 0 };
          _this105.hash = /* @__PURE__ */ Object.create(null);
          _this105.rich = /* @__PURE__ */ Object.create(null);
          return _this105;
        }
        _createClass(SharedStringsXform2, [{ key: "sharedStringXform", get: function get() {
          return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());
        } }, { key: "values", get: function get() {
          return this.model.values;
        } }, { key: "uniqueCount", get: function get() {
          return this.model.values.length;
        } }, { key: "count", get: function get() {
          return this.model.count;
        } }, { key: "getString", value: function getString(index2) {
          return this.model.values[index2];
        } }, { key: "add", value: function add(value) {
          return value.richText ? this.addRichText(value) : this.addText(value);
        } }, { key: "addText", value: function addText(value) {
          var index2 = this.hash[value];
          if (index2 === void 0) {
            index2 = this.hash[value] = this.model.values.length;
            this.model.values.push(value);
          }
          this.model.count++;
          return index2;
        } }, {
          key: "addRichText",
          value: function addRichText(value) {
            var xml = this.sharedStringXform.toXml(value);
            var index2 = this.rich[xml];
            if (index2 === void 0) {
              index2 = this.rich[xml] = this.model.values.length;
              this.model.values.push(value);
            }
            this.model.count++;
            return index2;
          }
          // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
          // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
          //   <si><t><%=text%></t></si>
          //   <si><r><rPr></rPr><t></t></r></si>
          // </sst>
        }, { key: "render", value: function render13(xmlStream, model) {
          model = model || this._values;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("sst", { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", count: model.count, uniqueCount: model.values.length });
          var sx = this.sharedStringXform;
          model.values.forEach(function(sharedString) {
            sx.render(xmlStream, sharedString);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "sst":
              return true;
            case "si":
              this.parser = this.sharedStringXform;
              this.parser.parseOpen(node);
              return true;
            default:
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.values.push(this.parser.model);
              this.model.count++;
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "sst":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return SharedStringsXform2;
      }(BaseXform);
      module2.exports = SharedStringsXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./shared-string-xform": 123 }], 125: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var TextXform = /* @__PURE__ */ function(_BaseXform74) {
        _inherits(TextXform2, _BaseXform74);
        var _super93 = _createSuper(TextXform2);
        function TextXform2() {
          _classCallCheck(this, TextXform2);
          return _super93.apply(this, arguments);
        }
        _createClass(TextXform2, [{ key: "tag", get: function get() {
          return "t";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("t");
          if (/^\s|\n|\s$/.test(model)) {
            xmlStream.addAttribute("xml:space", "preserve");
          }
          xmlStream.writeText(model);
          xmlStream.closeNode();
        } }, { key: "model", get: function get() {
          return this._text.join("").replace(/_x([0-9A-F]{4})_/g, function($0, $1) {
            return String.fromCharCode(parseInt($1, 16));
          });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "t":
              this._text = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this._text.push(text);
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return TextXform2;
      }(BaseXform);
      module2.exports = TextXform;
    }, { "../base-xform": 32 }], 126: [function(require2, module2, exports2) {
      var Enums = require2("../../../doc/enums");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var validation = { horizontalValues: ["left", "center", "right", "fill", "centerContinuous", "distributed", "justify"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {}), horizontal: function horizontal(value) {
        return this.horizontalValues[value] ? value : void 0;
      }, verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {}), vertical: function vertical(value) {
        if (value === "middle")
          return "center";
        return this.verticalValues[value] ? value : void 0;
      }, wrapText: function wrapText(value) {
        return value ? true : void 0;
      }, shrinkToFit: function shrinkToFit(value) {
        return value ? true : void 0;
      }, textRotation: function textRotation(value) {
        switch (value) {
          case "vertical":
            return value;
          default:
            value = utils.validInt(value);
            return value >= -90 && value <= 90 ? value : void 0;
        }
      }, indent: function indent(value) {
        value = utils.validInt(value);
        return Math.max(0, value);
      }, readingOrder: function readingOrder(value) {
        switch (value) {
          case "ltr":
            return Enums.ReadingOrder.LeftToRight;
          case "rtl":
            return Enums.ReadingOrder.RightToLeft;
          default:
            return void 0;
        }
      } };
      var textRotationXform = { toXml: function toXml(textRotation) {
        textRotation = validation.textRotation(textRotation);
        if (textRotation) {
          if (textRotation === "vertical") {
            return 255;
          }
          var tr = Math.round(textRotation);
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr < 0 && tr >= -90) {
            return 90 - tr;
          }
        }
        return void 0;
      }, toModel: function toModel(textRotation) {
        var tr = utils.validInt(textRotation);
        if (tr !== void 0) {
          if (tr === 255) {
            return "vertical";
          }
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr > 90 && tr <= 180) {
            return 90 - tr;
          }
        }
        return void 0;
      } };
      var AlignmentXform = /* @__PURE__ */ function(_BaseXform75) {
        _inherits(AlignmentXform2, _BaseXform75);
        var _super94 = _createSuper(AlignmentXform2);
        function AlignmentXform2() {
          _classCallCheck(this, AlignmentXform2);
          return _super94.apply(this, arguments);
        }
        _createClass(AlignmentXform2, [{ key: "tag", get: function get() {
          return "alignment";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("alignment");
          var isValid2 = false;
          function add(name, value) {
            if (value) {
              xmlStream.addAttribute(name, value);
              isValid2 = true;
            }
          }
          add("horizontal", validation.horizontal(model.horizontal));
          add("vertical", validation.vertical(model.vertical));
          add("wrapText", validation.wrapText(model.wrapText) ? "1" : false);
          add("shrinkToFit", validation.shrinkToFit(model.shrinkToFit) ? "1" : false);
          add("indent", validation.indent(model.indent));
          add("textRotation", textRotationXform.toXml(model.textRotation));
          add("readingOrder", validation.readingOrder(model.readingOrder));
          xmlStream.closeNode();
          if (isValid2) {
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var model = {};
          var valid = false;
          function add(truthy, name, value) {
            if (truthy) {
              model[name] = value;
              valid = true;
            }
          }
          add(node.attributes.horizontal, "horizontal", node.attributes.horizontal);
          add(node.attributes.vertical, "vertical", node.attributes.vertical === "center" ? "middle" : node.attributes.vertical);
          add(node.attributes.wrapText, "wrapText", utils.parseBoolean(node.attributes.wrapText));
          add(node.attributes.shrinkToFit, "shrinkToFit", utils.parseBoolean(node.attributes.shrinkToFit));
          add(node.attributes.indent, "indent", parseInt(node.attributes.indent, 10));
          add(node.attributes.textRotation, "textRotation", textRotationXform.toModel(node.attributes.textRotation));
          add(node.attributes.readingOrder, "readingOrder", node.attributes.readingOrder === "2" ? "rtl" : "ltr");
          this.model = valid ? model : null;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return AlignmentXform2;
      }(BaseXform);
      module2.exports = AlignmentXform;
    }, { "../../../doc/enums": 7, "../../../utils/utils": 27, "../base-xform": 32 }], 127: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var utils = require2("../../../utils/utils");
      var ColorXform = require2("./color-xform");
      var EdgeXform = /* @__PURE__ */ function(_BaseXform76) {
        _inherits(EdgeXform2, _BaseXform76);
        var _super95 = _createSuper(EdgeXform2);
        function EdgeXform2(name) {
          var _this106;
          _classCallCheck(this, EdgeXform2);
          _this106 = _super95.call(this);
          _this106.name = name;
          _this106.map = { color: new ColorXform() };
          return _this106;
        }
        _createClass(EdgeXform2, [{ key: "tag", get: function get() {
          return this.name;
        } }, { key: "render", value: function render13(xmlStream, model, defaultColor) {
          var color = model && model.color || defaultColor || this.defaultColor;
          xmlStream.openNode(this.name);
          if (model && model.style) {
            xmlStream.addAttribute("style", model.style);
            if (color) {
              this.map.color.render(xmlStream, color);
            }
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.name: {
              var style = node.attributes.style;
              if (style) {
                this.model = { style };
              } else {
                this.model = void 0;
              }
              return true;
            }
            case "color":
              this.parser = this.map.color;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === this.name) {
            if (this.map.color.model) {
              if (!this.model) {
                this.model = {};
              }
              this.model.color = this.map.color.model;
            }
          }
          return false;
        } }, { key: "validStyle", value: function validStyle(value) {
          return EdgeXform2.validStyleValues[value];
        } }]);
        return EdgeXform2;
      }(BaseXform);
      EdgeXform.validStyleValues = ["thin", "dashed", "dotted", "dashDot", "hair", "dashDotDot", "slantDashDot", "mediumDashed", "mediumDashDotDot", "mediumDashDot", "medium", "double", "thick"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {});
      var BorderXform = /* @__PURE__ */ function(_BaseXform77) {
        _inherits(BorderXform2, _BaseXform77);
        var _super96 = _createSuper(BorderXform2);
        function BorderXform2() {
          var _this107;
          _classCallCheck(this, BorderXform2);
          _this107 = _super96.call(this);
          _this107.map = { top: new EdgeXform("top"), left: new EdgeXform("left"), bottom: new EdgeXform("bottom"), right: new EdgeXform("right"), diagonal: new EdgeXform("diagonal") };
          return _this107;
        }
        _createClass(BorderXform2, [{ key: "render", value: function render13(xmlStream, model) {
          var color = model.color;
          xmlStream.openNode("border");
          if (model.diagonal && model.diagonal.style) {
            if (model.diagonal.up) {
              xmlStream.addAttribute("diagonalUp", "1");
            }
            if (model.diagonal.down) {
              xmlStream.addAttribute("diagonalDown", "1");
            }
          }
          function add(edgeModel, edgeXform) {
            if (edgeModel && !edgeModel.color && model.color) {
              edgeModel = _objectSpread2(_objectSpread2({}, edgeModel), {}, { color: model.color });
            }
            edgeXform.render(xmlStream, edgeModel, color);
          }
          add(model.left, this.map.left);
          add(model.right, this.map.right);
          add(model.top, this.map.top);
          add(model.bottom, this.map.bottom);
          add(model.diagonal, this.map.diagonal);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "border":
              this.reset();
              this.diagonalUp = utils.parseBoolean(node.attributes.diagonalUp);
              this.diagonalDown = utils.parseBoolean(node.attributes.diagonalDown);
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === "border") {
            var model = this.model = {};
            var add = function add2(key, edgeModel, extensions) {
              if (edgeModel) {
                if (extensions) {
                  Object.assign(edgeModel, extensions);
                }
                model[key] = edgeModel;
              }
            };
            add("left", this.map.left.model);
            add("right", this.map.right.model);
            add("top", this.map.top.model);
            add("bottom", this.map.bottom.model);
            add("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
          }
          return false;
        } }]);
        return BorderXform2;
      }(BaseXform);
      module2.exports = BorderXform;
    }, { "../../../utils/utils": 27, "../base-xform": 32, "./color-xform": 128 }], 128: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var ColorXform = /* @__PURE__ */ function(_BaseXform78) {
        _inherits(ColorXform2, _BaseXform78);
        var _super97 = _createSuper(ColorXform2);
        function ColorXform2(name) {
          var _this108;
          _classCallCheck(this, ColorXform2);
          _this108 = _super97.call(this);
          _this108.name = name || "color";
          return _this108;
        }
        _createClass(ColorXform2, [{ key: "tag", get: function get() {
          return this.name;
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.name);
            if (model.argb) {
              xmlStream.addAttribute("rgb", model.argb);
            } else if (model.theme !== void 0) {
              xmlStream.addAttribute("theme", model.theme);
              if (model.tint !== void 0) {
                xmlStream.addAttribute("tint", model.tint);
              }
            } else if (model.indexed !== void 0) {
              xmlStream.addAttribute("indexed", model.indexed);
            } else {
              xmlStream.addAttribute("auto", "1");
            }
            xmlStream.closeNode();
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.name) {
            if (node.attributes.rgb) {
              this.model = { argb: node.attributes.rgb };
            } else if (node.attributes.theme) {
              this.model = { theme: parseInt(node.attributes.theme, 10) };
              if (node.attributes.tint) {
                this.model.tint = parseFloat(node.attributes.tint);
              }
            } else if (node.attributes.indexed) {
              this.model = { indexed: parseInt(node.attributes.indexed, 10) };
            } else {
              this.model = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ColorXform2;
      }(BaseXform);
      module2.exports = ColorXform;
    }, { "../base-xform": 32 }], 129: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var AlignmentXform = require2("./alignment-xform");
      var BorderXform = require2("./border-xform");
      var FillXform = require2("./fill-xform");
      var FontXform = require2("./font-xform");
      var NumFmtXform = require2("./numfmt-xform");
      var ProtectionXform = require2("./protection-xform");
      var DxfXform = /* @__PURE__ */ function(_BaseXform79) {
        _inherits(DxfXform2, _BaseXform79);
        var _super98 = _createSuper(DxfXform2);
        function DxfXform2() {
          var _this109;
          _classCallCheck(this, DxfXform2);
          _this109 = _super98.call(this);
          _this109.map = { alignment: new AlignmentXform(), border: new BorderXform(), fill: new FillXform(), font: new FontXform(), numFmt: new NumFmtXform(), protection: new ProtectionXform() };
          return _this109;
        }
        _createClass(DxfXform2, [{
          key: "tag",
          get: function get() {
            return "dxf";
          }
          // how do we generate dxfid?
        }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode(this.tag);
          if (model.font) {
            this.map.font.render(xmlStream, model.font);
          }
          if (model.numFmt && model.numFmtId) {
            var numFmtModel = { id: model.numFmtId, formatCode: model.numFmt };
            this.map.numFmt.render(xmlStream, numFmtModel);
          }
          if (model.fill) {
            this.map.fill.render(xmlStream, model.fill);
          }
          if (model.alignment) {
            this.map.alignment.render(xmlStream, model.alignment);
          }
          if (model.border) {
            this.map.border.render(xmlStream, model.border);
          }
          if (model.protection) {
            this.map.protection.render(xmlStream, model.protection);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === this.tag) {
            this.model = { alignment: this.map.alignment.model, border: this.map.border.model, fill: this.map.fill.model, font: this.map.font.model, numFmt: this.map.numFmt.model, protection: this.map.protection.model };
            return false;
          }
          return true;
        } }]);
        return DxfXform2;
      }(BaseXform);
      module2.exports = DxfXform;
    }, { "../base-xform": 32, "./alignment-xform": 126, "./border-xform": 127, "./fill-xform": 130, "./font-xform": 131, "./numfmt-xform": 132, "./protection-xform": 133 }], 130: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var ColorXform = require2("./color-xform");
      var StopXform = /* @__PURE__ */ function(_BaseXform80) {
        _inherits(StopXform2, _BaseXform80);
        var _super99 = _createSuper(StopXform2);
        function StopXform2() {
          var _this110;
          _classCallCheck(this, StopXform2);
          _this110 = _super99.call(this);
          _this110.map = { color: new ColorXform() };
          return _this110;
        }
        _createClass(StopXform2, [{ key: "tag", get: function get() {
          return "stop";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("stop");
          xmlStream.addAttribute("position", model.position);
          this.map.color.render(xmlStream, model.color);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "stop":
              this.model = { position: parseFloat(node.attributes.position) };
              return true;
            case "color":
              this.parser = this.map.color;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.color = this.parser.model;
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }]);
        return StopXform2;
      }(BaseXform);
      var PatternFillXform = /* @__PURE__ */ function(_BaseXform81) {
        _inherits(PatternFillXform2, _BaseXform81);
        var _super100 = _createSuper(PatternFillXform2);
        function PatternFillXform2() {
          var _this111;
          _classCallCheck(this, PatternFillXform2);
          _this111 = _super100.call(this);
          _this111.map = { fgColor: new ColorXform("fgColor"), bgColor: new ColorXform("bgColor") };
          return _this111;
        }
        _createClass(PatternFillXform2, [{ key: "name", get: function get() {
          return "pattern";
        } }, { key: "tag", get: function get() {
          return "patternFill";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("patternFill");
          xmlStream.addAttribute("patternType", model.pattern);
          if (model.fgColor) {
            this.map.fgColor.render(xmlStream, model.fgColor);
          }
          if (model.bgColor) {
            this.map.bgColor.render(xmlStream, model.bgColor);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "patternFill":
              this.model = { type: "pattern", pattern: node.attributes.patternType };
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              if (this.parser.model) {
                this.model[name] = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }]);
        return PatternFillXform2;
      }(BaseXform);
      var GradientFillXform = /* @__PURE__ */ function(_BaseXform82) {
        _inherits(GradientFillXform2, _BaseXform82);
        var _super101 = _createSuper(GradientFillXform2);
        function GradientFillXform2() {
          var _this112;
          _classCallCheck(this, GradientFillXform2);
          _this112 = _super101.call(this);
          _this112.map = { stop: new StopXform() };
          return _this112;
        }
        _createClass(GradientFillXform2, [{ key: "name", get: function get() {
          return "gradient";
        } }, { key: "tag", get: function get() {
          return "gradientFill";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("gradientFill");
          switch (model.gradient) {
            case "angle":
              xmlStream.addAttribute("degree", model.degree);
              break;
            case "path":
              xmlStream.addAttribute("type", "path");
              if (model.center.left) {
                xmlStream.addAttribute("left", model.center.left);
                if (model.center.right === void 0) {
                  xmlStream.addAttribute("right", model.center.left);
                }
              }
              if (model.center.right) {
                xmlStream.addAttribute("right", model.center.right);
              }
              if (model.center.top) {
                xmlStream.addAttribute("top", model.center.top);
                if (model.center.bottom === void 0) {
                  xmlStream.addAttribute("bottom", model.center.top);
                }
              }
              if (model.center.bottom) {
                xmlStream.addAttribute("bottom", model.center.bottom);
              }
              break;
          }
          var stopXform = this.map.stop;
          model.stops.forEach(function(stopModel) {
            stopXform.render(xmlStream, stopModel);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "gradientFill": {
              var model = this.model = { stops: [] };
              if (node.attributes.degree) {
                model.gradient = "angle";
                model.degree = parseInt(node.attributes.degree, 10);
              } else if (node.attributes.type === "path") {
                model.gradient = "path";
                model.center = { left: node.attributes.left ? parseFloat(node.attributes.left) : 0, top: node.attributes.top ? parseFloat(node.attributes.top) : 0 };
                if (node.attributes.right !== node.attributes.left) {
                  model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;
                }
                if (node.attributes.bottom !== node.attributes.top) {
                  model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;
                }
              }
              return true;
            }
            case "stop":
              this.parser = this.map.stop;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.stops.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }]);
        return GradientFillXform2;
      }(BaseXform);
      var FillXform = /* @__PURE__ */ function(_BaseXform83) {
        _inherits(FillXform2, _BaseXform83);
        var _super102 = _createSuper(FillXform2);
        function FillXform2() {
          var _this113;
          _classCallCheck(this, FillXform2);
          _this113 = _super102.call(this);
          _this113.map = { patternFill: new PatternFillXform(), gradientFill: new GradientFillXform() };
          return _this113;
        }
        _createClass(FillXform2, [{ key: "tag", get: function get() {
          return "fill";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("fill");
          switch (model.type) {
            case "pattern":
              this.map.patternFill.render(xmlStream, model);
              break;
            case "gradient":
              this.map.gradientFill.render(xmlStream, model);
              break;
            default:
              xmlStream.rollback();
              return;
          }
          xmlStream.closeNode();
          xmlStream.commit();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "fill":
              this.model = {};
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model = this.parser.model;
              this.model.type = this.parser.name;
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "validStyle", value: function validStyle(value) {
          return FillXform2.validPatternValues[value];
        } }]);
        return FillXform2;
      }(BaseXform);
      FillXform.validPatternValues = ["none", "solid", "darkVertical", "darkGray", "mediumGray", "lightGray", "gray125", "gray0625", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "lightGrid"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {});
      FillXform.StopXform = StopXform;
      FillXform.PatternFillXform = PatternFillXform;
      FillXform.GradientFillXform = GradientFillXform;
      module2.exports = FillXform;
    }, { "../base-xform": 32, "./color-xform": 128 }], 131: [function(require2, module2, exports2) {
      var ColorXform = require2("./color-xform");
      var BooleanXform = require2("../simple/boolean-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var StringXform = require2("../simple/string-xform");
      var UnderlineXform = require2("./underline-xform");
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var FontXform = /* @__PURE__ */ function(_BaseXform84) {
        _inherits(FontXform2, _BaseXform84);
        var _super103 = _createSuper(FontXform2);
        function FontXform2(options) {
          var _this114;
          _classCallCheck(this, FontXform2);
          _this114 = _super103.call(this);
          _this114.options = options || FontXform2.OPTIONS;
          _this114.map = { b: { prop: "bold", xform: new BooleanXform({ tag: "b", attr: "val" }) }, i: { prop: "italic", xform: new BooleanXform({ tag: "i", attr: "val" }) }, u: { prop: "underline", xform: new UnderlineXform() }, charset: { prop: "charset", xform: new IntegerXform({ tag: "charset", attr: "val" }) }, color: { prop: "color", xform: new ColorXform() }, condense: { prop: "condense", xform: new BooleanXform({ tag: "condense", attr: "val" }) }, extend: { prop: "extend", xform: new BooleanXform({ tag: "extend", attr: "val" }) }, family: { prop: "family", xform: new IntegerXform({ tag: "family", attr: "val" }) }, outline: { prop: "outline", xform: new BooleanXform({ tag: "outline", attr: "val" }) }, vertAlign: { prop: "vertAlign", xform: new StringXform({ tag: "vertAlign", attr: "val" }) }, scheme: { prop: "scheme", xform: new StringXform({ tag: "scheme", attr: "val" }) }, shadow: { prop: "shadow", xform: new BooleanXform({ tag: "shadow", attr: "val" }) }, strike: { prop: "strike", xform: new BooleanXform({ tag: "strike", attr: "val" }) }, sz: { prop: "size", xform: new IntegerXform({ tag: "sz", attr: "val" }) } };
          _this114.map[_this114.options.fontNameTag] = { prop: "name", xform: new StringXform({ tag: _this114.options.fontNameTag, attr: "val" }) };
          return _this114;
        }
        _createClass(FontXform2, [{ key: "tag", get: function get() {
          return this.options.tagName;
        } }, { key: "render", value: function render13(xmlStream, model) {
          var map = this.map;
          xmlStream.openNode(this.options.tagName);
          _.each(this.map, function(defn, tag) {
            map[tag].xform.render(xmlStream, model[defn.prop]);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (this.map[node.name]) {
            this.parser = this.map[node.name].xform;
            return this.parser.parseOpen(node);
          }
          switch (node.name) {
            case this.options.tagName:
              this.model = {};
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser && !this.parser.parseClose(name)) {
            var item = this.map[name];
            if (this.parser.model) {
              this.model[item.prop] = this.parser.model;
            }
            this.parser = void 0;
            return true;
          }
          switch (name) {
            case this.options.tagName:
              return false;
            default:
              return true;
          }
        } }]);
        return FontXform2;
      }(BaseXform);
      FontXform.OPTIONS = { tagName: "font", fontNameTag: "name" };
      module2.exports = FontXform;
    }, { "../../../utils/under-dash": 26, "../base-xform": 32, "../simple/boolean-xform": 116, "../simple/integer-xform": 118, "../simple/string-xform": 119, "./color-xform": 128, "./underline-xform": 136 }], 132: [function(require2, module2, exports2) {
      var _ = require2("../../../utils/under-dash");
      var defaultNumFormats = require2("../../defaultnumformats");
      var BaseXform = require2("../base-xform");
      function hashDefaultFormats() {
        var hash = {};
        _.each(defaultNumFormats, function(dnf, id) {
          if (dnf.f) {
            hash[dnf.f] = parseInt(id, 10);
          }
        });
        return hash;
      }
      var defaultFmtHash = hashDefaultFormats();
      var NumFmtXform = /* @__PURE__ */ function(_BaseXform85) {
        _inherits(NumFmtXform2, _BaseXform85);
        var _super104 = _createSuper(NumFmtXform2);
        function NumFmtXform2(id, formatCode) {
          var _this115;
          _classCallCheck(this, NumFmtXform2);
          _this115 = _super104.call(this);
          _this115.id = id;
          _this115.formatCode = formatCode;
          return _this115;
        }
        _createClass(NumFmtXform2, [{ key: "tag", get: function get() {
          return "numFmt";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode("numFmt", { numFmtId: model.id, formatCode: model.formatCode });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "numFmt":
              this.model = { id: parseInt(node.attributes.numFmtId, 10), formatCode: node.attributes.formatCode.replace(/[\\](.)/g, "$1") };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return NumFmtXform2;
      }(BaseXform);
      NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
        return defaultFmtHash[formatCode];
      };
      NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
        return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
      };
      module2.exports = NumFmtXform;
    }, { "../../../utils/under-dash": 26, "../../defaultnumformats": 30, "../base-xform": 32 }], 133: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var validation = { boolean: function boolean(value, dflt) {
        if (value === void 0) {
          return dflt;
        }
        return value;
      } };
      var ProtectionXform = /* @__PURE__ */ function(_BaseXform86) {
        _inherits(ProtectionXform2, _BaseXform86);
        var _super105 = _createSuper(ProtectionXform2);
        function ProtectionXform2() {
          _classCallCheck(this, ProtectionXform2);
          return _super105.apply(this, arguments);
        }
        _createClass(ProtectionXform2, [{ key: "tag", get: function get() {
          return "protection";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("protection");
          var isValid2 = false;
          function add(name, value) {
            if (value !== void 0) {
              xmlStream.addAttribute(name, value);
              isValid2 = true;
            }
          }
          add("locked", validation.boolean(model.locked, true) ? void 0 : "0");
          add("hidden", validation.boolean(model.hidden, false) ? "1" : void 0);
          xmlStream.closeNode();
          if (isValid2) {
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var model = { locked: !(node.attributes.locked === "0"), hidden: node.attributes.hidden === "1" };
          var isSignificant = !model.locked || model.hidden;
          this.model = isSignificant ? model : null;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ProtectionXform2;
      }(BaseXform);
      module2.exports = ProtectionXform;
    }, { "../base-xform": 32 }], 134: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var AlignmentXform = require2("./alignment-xform");
      var ProtectionXform = require2("./protection-xform");
      var StyleXform = /* @__PURE__ */ function(_BaseXform87) {
        _inherits(StyleXform2, _BaseXform87);
        var _super106 = _createSuper(StyleXform2);
        function StyleXform2(options) {
          var _this116;
          _classCallCheck(this, StyleXform2);
          _this116 = _super106.call(this);
          _this116.xfId = !!(options && options.xfId);
          _this116.map = { alignment: new AlignmentXform(), protection: new ProtectionXform() };
          return _this116;
        }
        _createClass(StyleXform2, [{ key: "tag", get: function get() {
          return "xf";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openNode("xf", { numFmtId: model.numFmtId || 0, fontId: model.fontId || 0, fillId: model.fillId || 0, borderId: model.borderId || 0 });
          if (this.xfId) {
            xmlStream.addAttribute("xfId", model.xfId || 0);
          }
          if (model.numFmtId) {
            xmlStream.addAttribute("applyNumberFormat", "1");
          }
          if (model.fontId) {
            xmlStream.addAttribute("applyFont", "1");
          }
          if (model.fillId) {
            xmlStream.addAttribute("applyFill", "1");
          }
          if (model.borderId) {
            xmlStream.addAttribute("applyBorder", "1");
          }
          if (model.alignment) {
            xmlStream.addAttribute("applyAlignment", "1");
          }
          if (model.protection) {
            xmlStream.addAttribute("applyProtection", "1");
          }
          if (model.alignment) {
            this.map.alignment.render(xmlStream, model.alignment);
          }
          if (model.protection) {
            this.map.protection.render(xmlStream, model.protection);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "xf":
              this.model = { numFmtId: parseInt(node.attributes.numFmtId, 10), fontId: parseInt(node.attributes.fontId, 10), fillId: parseInt(node.attributes.fillId, 10), borderId: parseInt(node.attributes.borderId, 10) };
              if (this.xfId) {
                this.model.xfId = parseInt(node.attributes.xfId, 10);
              }
              return true;
            case "alignment":
              this.parser = this.map.alignment;
              this.parser.parseOpen(node);
              return true;
            case "protection":
              this.parser = this.map.protection;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              if (this.map.protection === this.parser) {
                this.model.protection = this.parser.model;
              } else {
                this.model.alignment = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          return name !== "xf";
        } }]);
        return StyleXform2;
      }(BaseXform);
      module2.exports = StyleXform;
    }, { "../base-xform": 32, "./alignment-xform": 126, "./protection-xform": 133 }], 135: [function(require2, module2, exports2) {
      var Enums = require2("../../../doc/enums");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var ListXform = require2("../list-xform");
      var FontXform = require2("./font-xform");
      var FillXform = require2("./fill-xform");
      var BorderXform = require2("./border-xform");
      var NumFmtXform = require2("./numfmt-xform");
      var StyleXform = require2("./style-xform");
      var DxfXform = require2("./dxf-xform");
      var NUMFMT_BASE = 164;
      var StylesXform = /* @__PURE__ */ function(_BaseXform88) {
        _inherits(StylesXform2, _BaseXform88);
        var _super107 = _createSuper(StylesXform2);
        function StylesXform2(initialise) {
          var _this117;
          _classCallCheck(this, StylesXform2);
          _this117 = _super107.call(this);
          _this117.map = {
            numFmts: new ListXform({ tag: "numFmts", count: true, childXform: new NumFmtXform() }),
            fonts: new ListXform({ tag: "fonts", count: true, childXform: new FontXform(), $: { "x14ac:knownFonts": 1 } }),
            fills: new ListXform({ tag: "fills", count: true, childXform: new FillXform() }),
            borders: new ListXform({ tag: "borders", count: true, childXform: new BorderXform() }),
            cellStyleXfs: new ListXform({ tag: "cellStyleXfs", count: true, childXform: new StyleXform() }),
            cellXfs: new ListXform({ tag: "cellXfs", count: true, childXform: new StyleXform({ xfId: true }) }),
            dxfs: new ListXform({ tag: "dxfs", always: true, count: true, childXform: new DxfXform() }),
            // for style manager
            numFmt: new NumFmtXform(),
            font: new FontXform(),
            fill: new FillXform(),
            border: new BorderXform(),
            style: new StyleXform({ xfId: true }),
            cellStyles: StylesXform2.STATIC_XFORMS.cellStyles,
            tableStyles: StylesXform2.STATIC_XFORMS.tableStyles,
            extLst: StylesXform2.STATIC_XFORMS.extLst
          };
          if (initialise) {
            _this117.init();
          }
          return _this117;
        }
        _createClass(StylesXform2, [{ key: "initIndex", value: function initIndex() {
          this.index = {
            style: {},
            numFmt: {},
            numFmtNextId: 164,
            // start custom format ids here
            font: {},
            border: {},
            fill: {}
          };
        } }, { key: "init", value: function init() {
          this.model = { styles: [], numFmts: [], fonts: [], borders: [], fills: [], dxfs: [] };
          this.initIndex();
          this._addBorder({});
          this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 });
          this._addFill({ type: "pattern", pattern: "none" });
          this._addFill({ type: "pattern", pattern: "gray125" });
          this.weakMap = /* @__PURE__ */ new WeakMap();
        } }, { key: "render", value: function render13(xmlStream, model) {
          model = model || this.model;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("styleSheet", StylesXform2.STYLESHEET_ATTRIBUTES);
          if (this.index) {
            if (model.numFmts && model.numFmts.length) {
              xmlStream.openNode("numFmts", { count: model.numFmts.length });
              model.numFmts.forEach(function(numFmtXml) {
                xmlStream.writeXml(numFmtXml);
              });
              xmlStream.closeNode();
            }
            if (!model.fonts.length) {
              this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
            }
            xmlStream.openNode("fonts", { count: model.fonts.length, "x14ac:knownFonts": 1 });
            model.fonts.forEach(function(fontXml) {
              xmlStream.writeXml(fontXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("fills", { count: model.fills.length });
            model.fills.forEach(function(fillXml) {
              xmlStream.writeXml(fillXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("borders", { count: model.borders.length });
            model.borders.forEach(function(borderXml) {
              xmlStream.writeXml(borderXml);
            });
            xmlStream.closeNode();
            this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
            xmlStream.openNode("cellXfs", { count: model.styles.length });
            model.styles.forEach(function(styleXml) {
              xmlStream.writeXml(styleXml);
            });
            xmlStream.closeNode();
          } else {
            this.map.numFmts.render(xmlStream, model.numFmts);
            this.map.fonts.render(xmlStream, model.fonts);
            this.map.fills.render(xmlStream, model.fills);
            this.map.borders.render(xmlStream, model.borders);
            this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
            this.map.cellXfs.render(xmlStream, model.styles);
          }
          StylesXform2.STATIC_XFORMS.cellStyles.render(xmlStream);
          this.map.dxfs.render(xmlStream, model.dxfs);
          StylesXform2.STATIC_XFORMS.tableStyles.render(xmlStream);
          StylesXform2.STATIC_XFORMS.extLst.render(xmlStream);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "styleSheet":
              this.initIndex();
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, {
          key: "parseClose",
          value: function parseClose(name) {
            var _this118 = this;
            if (this.parser) {
              if (!this.parser.parseClose(name)) {
                this.parser = void 0;
              }
              return true;
            }
            switch (name) {
              case "styleSheet": {
                this.model = {};
                var add = function add2(propName, xform) {
                  if (xform.model && xform.model.length) {
                    _this118.model[propName] = xform.model;
                  }
                };
                add("numFmts", this.map.numFmts);
                add("fonts", this.map.fonts);
                add("fills", this.map.fills);
                add("borders", this.map.borders);
                add("styles", this.map.cellXfs);
                add("dxfs", this.map.dxfs);
                this.index = { model: [], numFmt: [] };
                if (this.model.numFmts) {
                  var numFmtIndex = this.index.numFmt;
                  this.model.numFmts.forEach(function(numFmt) {
                    numFmtIndex[numFmt.id] = numFmt.formatCode;
                  });
                }
                return false;
              }
              default:
                return true;
            }
          }
          // add a cell's style model to the collection
          // each style property is processed and cross-referenced, etc.
          // the styleId is returned. Note: cellType is used when numFmt not defined
        }, {
          key: "addStyleModel",
          value: function addStyleModel(model, cellType) {
            if (!model) {
              return 0;
            }
            if (!this.model.fonts.length) {
              this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
            }
            if (this.weakMap && this.weakMap.has(model)) {
              return this.weakMap.get(model);
            }
            var style = {};
            cellType = cellType || Enums.ValueType.Number;
            if (model.numFmt) {
              style.numFmtId = this._addNumFmtStr(model.numFmt);
            } else {
              switch (cellType) {
                case Enums.ValueType.Number:
                  style.numFmtId = this._addNumFmtStr("General");
                  break;
                case Enums.ValueType.Date:
                  style.numFmtId = this._addNumFmtStr("mm-dd-yy");
                  break;
              }
            }
            if (model.font) {
              style.fontId = this._addFont(model.font);
            }
            if (model.border) {
              style.borderId = this._addBorder(model.border);
            }
            if (model.fill) {
              style.fillId = this._addFill(model.fill);
            }
            if (model.alignment) {
              style.alignment = model.alignment;
            }
            if (model.protection) {
              style.protection = model.protection;
            }
            var styleId = this._addStyle(style);
            if (this.weakMap) {
              this.weakMap.set(model, styleId);
            }
            return styleId;
          }
          // given a styleId (i.e. s="n"), get the cell's style model
          // objects are shared where possible.
        }, { key: "getStyleModel", value: function getStyleModel(id) {
          var style = this.model.styles[id];
          if (!style)
            return null;
          var model = this.index.model[id];
          if (model)
            return model;
          model = this.index.model[id] = {};
          if (style.numFmtId) {
            var numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);
            if (numFmt) {
              model.numFmt = numFmt;
            }
          }
          function addStyle(name, group, styleId) {
            if (styleId || styleId === 0) {
              var part = group[styleId];
              if (part) {
                model[name] = part;
              }
            }
          }
          addStyle("font", this.model.fonts, style.fontId);
          addStyle("border", this.model.borders, style.borderId);
          addStyle("fill", this.model.fills, style.fillId);
          if (style.alignment) {
            model.alignment = style.alignment;
          }
          if (style.protection) {
            model.protection = style.protection;
          }
          return model;
        } }, { key: "addDxfStyle", value: function addDxfStyle(style) {
          if (style.numFmt) {
            style.numFmtId = this._addNumFmtStr(style.numFmt);
          }
          this.model.dxfs.push(style);
          return this.model.dxfs.length - 1;
        } }, {
          key: "getDxfStyle",
          value: function getDxfStyle(id) {
            return this.model.dxfs[id];
          }
          // =========================================================================
          // Private Interface
        }, {
          key: "_addStyle",
          value: function _addStyle(style) {
            var xml = this.map.style.toXml(style);
            var index2 = this.index.style[xml];
            if (index2 === void 0) {
              index2 = this.index.style[xml] = this.model.styles.length;
              this.model.styles.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Number Formats
        }, {
          key: "_addNumFmtStr",
          value: function _addNumFmtStr(formatCode) {
            var index2 = NumFmtXform.getDefaultFmtId(formatCode);
            if (index2 !== void 0)
              return index2;
            index2 = this.index.numFmt[formatCode];
            if (index2 !== void 0)
              return index2;
            index2 = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
            var xml = this.map.numFmt.toXml({ id: index2, formatCode });
            this.model.numFmts.push(xml);
            return index2;
          }
          // =========================================================================
          // Fonts
        }, {
          key: "_addFont",
          value: function _addFont(font) {
            var xml = this.map.font.toXml(font);
            var index2 = this.index.font[xml];
            if (index2 === void 0) {
              index2 = this.index.font[xml] = this.model.fonts.length;
              this.model.fonts.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Borders
        }, {
          key: "_addBorder",
          value: function _addBorder(border) {
            var xml = this.map.border.toXml(border);
            var index2 = this.index.border[xml];
            if (index2 === void 0) {
              index2 = this.index.border[xml] = this.model.borders.length;
              this.model.borders.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Fills
        }, {
          key: "_addFill",
          value: function _addFill(fill2) {
            var xml = this.map.fill.toXml(fill2);
            var index2 = this.index.fill[xml];
            if (index2 === void 0) {
              index2 = this.index.fill[xml] = this.model.fills.length;
              this.model.fills.push(xml);
            }
            return index2;
          }
          // =========================================================================
        }]);
        return StylesXform2;
      }(BaseXform);
      StylesXform.STYLESHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac x16r2", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac", "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" };
      StylesXform.STATIC_XFORMS = { cellStyles: new StaticXform({ tag: "cellStyles", $: { count: 1 }, c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }] }), dxfs: new StaticXform({ tag: "dxfs", $: { count: 0 } }), tableStyles: new StaticXform({ tag: "tableStyles", $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" } }), extLst: new StaticXform({ tag: "extLst", c: [{ tag: "ext", $: { uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }, c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }] }, { tag: "ext", $: { uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }] }] }) };
      var StylesXformMock = /* @__PURE__ */ function(_StylesXform) {
        _inherits(StylesXformMock2, _StylesXform);
        var _super108 = _createSuper(StylesXformMock2);
        function StylesXformMock2() {
          var _this119;
          _classCallCheck(this, StylesXformMock2);
          _this119 = _super108.call(this);
          _this119.model = { styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }], numFmts: [], fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }], borders: [{}], fills: [{ type: "pattern", pattern: "none" }, { type: "pattern", pattern: "gray125" }] };
          return _this119;
        }
        _createClass(StylesXformMock2, [{
          key: "parseStream",
          value: function parseStream(stream) {
            stream.autodrain();
            return Promise.resolve();
          }
          // add a cell's style model to the collection
          // each style property is processed and cross-referenced, etc.
          // the styleId is returned. Note: cellType is used when numFmt not defined
        }, { key: "addStyleModel", value: function addStyleModel(model, cellType) {
          switch (cellType) {
            case Enums.ValueType.Date:
              return this.dateStyleId;
            default:
              return 0;
          }
        } }, {
          key: "dateStyleId",
          get: function get() {
            if (!this._dateStyleId) {
              var dateStyle = { numFmtId: NumFmtXform.getDefaultFmtId("mm-dd-yy") };
              this._dateStyleId = this.model.styles.length;
              this.model.styles.push(dateStyle);
            }
            return this._dateStyleId;
          }
          // given a styleId (i.e. s="n"), get the cell's style model
          // objects are shared where possible.
        }, { key: "getStyleModel", value: function getStyleModel() {
          return {};
        } }]);
        return StylesXformMock2;
      }(StylesXform);
      StylesXform.Mock = StylesXformMock;
      module2.exports = StylesXform;
    }, { "../../../doc/enums": 7, "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "../static-xform": 120, "./border-xform": 127, "./dxf-xform": 129, "./fill-xform": 130, "./font-xform": 131, "./numfmt-xform": 132, "./style-xform": 134 }], 136: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var UnderlineXform = /* @__PURE__ */ function(_BaseXform89) {
        _inherits(UnderlineXform2, _BaseXform89);
        var _super109 = _createSuper(UnderlineXform2);
        function UnderlineXform2(model) {
          var _this120;
          _classCallCheck(this, UnderlineXform2);
          _this120 = _super109.call(this);
          _this120.model = model;
          return _this120;
        }
        _createClass(UnderlineXform2, [{ key: "tag", get: function get() {
          return "u";
        } }, { key: "render", value: function render13(xmlStream, model) {
          model = model || this.model;
          if (model === true) {
            xmlStream.leafNode("u");
          } else {
            var attr = UnderlineXform2.Attributes[model];
            if (attr) {
              xmlStream.leafNode("u", attr);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "u") {
            this.model = node.attributes.val || true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return UnderlineXform2;
      }(BaseXform);
      UnderlineXform.Attributes = { single: {}, double: { val: "double" }, singleAccounting: { val: "singleAccounting" }, doubleAccounting: { val: "doubleAccounting" } };
      module2.exports = UnderlineXform;
    }, { "../base-xform": 32 }], 137: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var FilterColumnXform = require2("./filter-column-xform");
      var AutoFilterXform = /* @__PURE__ */ function(_BaseXform90) {
        _inherits(AutoFilterXform2, _BaseXform90);
        var _super110 = _createSuper(AutoFilterXform2);
        function AutoFilterXform2() {
          var _this121;
          _classCallCheck(this, AutoFilterXform2);
          _this121 = _super110.call(this);
          _this121.map = { filterColumn: new FilterColumnXform() };
          return _this121;
        }
        _createClass(AutoFilterXform2, [{ key: "tag", get: function get() {
          return "autoFilter";
        } }, { key: "prepare", value: function prepare(model) {
          var _this122 = this;
          model.columns.forEach(function(column, index2) {
            _this122.map.filterColumn.prepare(column, { index: index2 });
          });
        } }, { key: "render", value: function render13(xmlStream, model) {
          var _this123 = this;
          xmlStream.openNode(this.tag, { ref: model.autoFilterRef });
          model.columns.forEach(function(column) {
            _this123.map.filterColumn.render(xmlStream, column);
          });
          xmlStream.closeNode();
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.model = { autoFilterRef: node.attributes.ref, columns: [] };
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.columns.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return AutoFilterXform2;
      }(BaseXform);
      module2.exports = AutoFilterXform;
    }, { "../base-xform": 32, "./filter-column-xform": 139 }], 138: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var CustomFilterXform = /* @__PURE__ */ function(_BaseXform91) {
        _inherits(CustomFilterXform2, _BaseXform91);
        var _super111 = _createSuper(CustomFilterXform2);
        function CustomFilterXform2() {
          _classCallCheck(this, CustomFilterXform2);
          return _super111.apply(this, arguments);
        }
        _createClass(CustomFilterXform2, [{ key: "tag", get: function get() {
          return "customFilter";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { val: model.val, operator: model.operator });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { val: node.attributes.val, operator: node.attributes.operator };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return CustomFilterXform2;
      }(BaseXform);
      module2.exports = CustomFilterXform;
    }, { "../base-xform": 32 }], 139: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var ListXform = require2("../list-xform");
      var CustomFilterXform = require2("./custom-filter-xform");
      var FilterXform = require2("./filter-xform");
      var FilterColumnXform = /* @__PURE__ */ function(_BaseXform92) {
        _inherits(FilterColumnXform2, _BaseXform92);
        var _super112 = _createSuper(FilterColumnXform2);
        function FilterColumnXform2() {
          var _this124;
          _classCallCheck(this, FilterColumnXform2);
          _this124 = _super112.call(this);
          _this124.map = { customFilters: new ListXform({ tag: "customFilters", count: false, empty: true, childXform: new CustomFilterXform() }), filters: new ListXform({ tag: "filters", count: false, empty: true, childXform: new FilterXform() }) };
          return _this124;
        }
        _createClass(FilterColumnXform2, [{ key: "tag", get: function get() {
          return "filterColumn";
        } }, { key: "prepare", value: function prepare(model, options) {
          model.colId = options.index.toString();
        } }, { key: "render", value: function render13(xmlStream, model) {
          if (model.customFilters) {
            xmlStream.openNode(this.tag, { colId: model.colId, hiddenButton: model.filterButton ? "0" : "1" });
            this.map.customFilters.render(xmlStream, model.customFilters);
            xmlStream.closeNode();
            return true;
          }
          xmlStream.leafNode(this.tag, { colId: model.colId, hiddenButton: model.filterButton ? "0" : "1" });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          var attributes = node.attributes;
          switch (node.name) {
            case this.tag:
              this.model = { filterButton: attributes.hiddenButton === "0" };
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.customFilters = this.map.customFilters.model;
              return false;
            default:
              return true;
          }
        } }]);
        return FilterColumnXform2;
      }(BaseXform);
      module2.exports = FilterColumnXform;
    }, { "../base-xform": 32, "../list-xform": 71, "./custom-filter-xform": 138, "./filter-xform": 140 }], 140: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var FilterXform = /* @__PURE__ */ function(_BaseXform93) {
        _inherits(FilterXform2, _BaseXform93);
        var _super113 = _createSuper(FilterXform2);
        function FilterXform2() {
          _classCallCheck(this, FilterXform2);
          return _super113.apply(this, arguments);
        }
        _createClass(FilterXform2, [{ key: "tag", get: function get() {
          return "filter";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { val: model.val });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { val: node.attributes.val };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return FilterXform2;
      }(BaseXform);
      module2.exports = FilterXform;
    }, { "../base-xform": 32 }], 141: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var TableColumnXform = /* @__PURE__ */ function(_BaseXform94) {
        _inherits(TableColumnXform2, _BaseXform94);
        var _super114 = _createSuper(TableColumnXform2);
        function TableColumnXform2() {
          _classCallCheck(this, TableColumnXform2);
          return _super114.apply(this, arguments);
        }
        _createClass(TableColumnXform2, [{ key: "tag", get: function get() {
          return "tableColumn";
        } }, { key: "prepare", value: function prepare(model, options) {
          model.id = options.index + 1;
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { id: model.id.toString(), name: model.name, totalsRowLabel: model.totalsRowLabel, totalsRowFunction: model.totalsRowFunction, dxfId: model.dxfId });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            var attributes = node.attributes;
            this.model = { name: attributes.name, totalsRowLabel: attributes.totalsRowLabel, totalsRowFunction: attributes.totalsRowFunction, dxfId: attributes.dxfId };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return TableColumnXform2;
      }(BaseXform);
      module2.exports = TableColumnXform;
    }, { "../base-xform": 32 }], 142: [function(require2, module2, exports2) {
      var BaseXform = require2("../base-xform");
      var TableStyleInfoXform = /* @__PURE__ */ function(_BaseXform95) {
        _inherits(TableStyleInfoXform2, _BaseXform95);
        var _super115 = _createSuper(TableStyleInfoXform2);
        function TableStyleInfoXform2() {
          _classCallCheck(this, TableStyleInfoXform2);
          return _super115.apply(this, arguments);
        }
        _createClass(TableStyleInfoXform2, [{ key: "tag", get: function get() {
          return "tableStyleInfo";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.leafNode(this.tag, { name: model.theme ? model.theme : void 0, showFirstColumn: model.showFirstColumn ? "1" : "0", showLastColumn: model.showLastColumn ? "1" : "0", showRowStripes: model.showRowStripes ? "1" : "0", showColumnStripes: model.showColumnStripes ? "1" : "0" });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            var attributes = node.attributes;
            this.model = { theme: attributes.name ? attributes.name : null, showFirstColumn: attributes.showFirstColumn === "1", showLastColumn: attributes.showLastColumn === "1", showRowStripes: attributes.showRowStripes === "1", showColumnStripes: attributes.showColumnStripes === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return TableStyleInfoXform2;
      }(BaseXform);
      module2.exports = TableStyleInfoXform;
    }, { "../base-xform": 32 }], 143: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var ListXform = require2("../list-xform");
      var AutoFilterXform = require2("./auto-filter-xform");
      var TableColumnXform = require2("./table-column-xform");
      var TableStyleInfoXform = require2("./table-style-info-xform");
      var TableXform = /* @__PURE__ */ function(_BaseXform96) {
        _inherits(TableXform2, _BaseXform96);
        var _super116 = _createSuper(TableXform2);
        function TableXform2() {
          var _this125;
          _classCallCheck(this, TableXform2);
          _this125 = _super116.call(this);
          _this125.map = { autoFilter: new AutoFilterXform(), tableColumns: new ListXform({ tag: "tableColumns", count: true, empty: true, childXform: new TableColumnXform() }), tableStyleInfo: new TableStyleInfoXform() };
          return _this125;
        }
        _createClass(TableXform2, [{ key: "prepare", value: function prepare(model, options) {
          this.map.autoFilter.prepare(model);
          this.map.tableColumns.prepare(model.columns, options);
        } }, { key: "tag", get: function get() {
          return "table";
        } }, { key: "render", value: function render13(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, _objectSpread2(_objectSpread2({}, TableXform2.TABLE_ATTRIBUTES), {}, { id: model.id, name: model.name, displayName: model.displayName || model.name, ref: model.tableRef, totalsRowCount: model.totalsRow ? "1" : void 0, totalsRowShown: model.totalsRow ? void 0 : "1", headerRowCount: model.headerRow ? "1" : "0" }));
          this.map.autoFilter.render(xmlStream, model);
          this.map.tableColumns.render(xmlStream, model.columns);
          this.map.tableStyleInfo.render(xmlStream, model.style);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          var name = node.name, attributes = node.attributes;
          switch (name) {
            case this.tag:
              this.reset();
              this.model = { name: attributes.name, displayName: attributes.displayName || attributes.name, tableRef: attributes.ref, totalsRow: attributes.totalsRowCount === "1", headerRow: attributes.headerRowCount === "1" };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          var _this126 = this;
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.columns = this.map.tableColumns.model;
              if (this.map.autoFilter.model) {
                this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
                this.map.autoFilter.model.columns.forEach(function(column, index2) {
                  _this126.model.columns[index2].filterButton = column.filterButton;
                });
              }
              this.model.style = this.map.tableStyleInfo.model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.columns.forEach(function(column) {
            if (column.dxfId !== void 0) {
              column.style = options.styles.getDxfStyle(column.dxfId);
            }
          });
        } }]);
        return TableXform2;
      }(BaseXform);
      TableXform.TABLE_ATTRIBUTES = {
        xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "mc:Ignorable": "xr xr3",
        "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
        "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
        // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
      };
      module2.exports = TableXform;
    }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "./auto-filter-xform": 137, "./table-column-xform": 141, "./table-style-info-xform": 142 }], 144: [function(require2, module2, exports2) {
      (function(process2, Buffer2) {
        (function() {
          var fs = require2("fs");
          var JSZip = require2("jszip");
          var _require12 = require2("readable-stream"), PassThrough = _require12.PassThrough;
          var ZipStream = require2("../utils/zip-stream");
          var StreamBuf = require2("../utils/stream-buf");
          var utils = require2("../utils/utils");
          var XmlStream = require2("../utils/xml-stream");
          var _require13 = require2("../utils/browser-buffer-decode"), bufferToString = _require13.bufferToString;
          var StylesXform = require2("./xform/style/styles-xform");
          var CoreXform = require2("./xform/core/core-xform");
          var SharedStringsXform = require2("./xform/strings/shared-strings-xform");
          var RelationshipsXform = require2("./xform/core/relationships-xform");
          var ContentTypesXform = require2("./xform/core/content-types-xform");
          var AppXform = require2("./xform/core/app-xform");
          var WorkbookXform = require2("./xform/book/workbook-xform");
          var WorksheetXform = require2("./xform/sheet/worksheet-xform");
          var DrawingXform = require2("./xform/drawing/drawing-xform");
          var TableXform = require2("./xform/table/table-xform");
          var CommentsXform = require2("./xform/comment/comments-xform");
          var VmlNotesXform = require2("./xform/comment/vml-notes-xform");
          var theme1Xml = require2("./xml/theme1");
          function fsReadFileAsync(filename, options) {
            return new Promise(function(resolve, reject) {
              fs.readFile(filename, options, function(error, data) {
                if (error) {
                  reject(error);
                } else {
                  resolve(data);
                }
              });
            });
          }
          var XLSX2 = /* @__PURE__ */ function() {
            function XLSX3(workbook) {
              _classCallCheck(this, XLSX3);
              this.workbook = workbook;
            }
            _createClass(XLSX3, [{ key: "readFile", value: function() {
              var _readFile2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee9(filename, options) {
                var stream, workbook;
                return _regeneratorRuntime.wrap(function _callee9$(_context9) {
                  while (1)
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.next = 2;
                        return utils.fs.exists(filename);
                      case 2:
                        if (_context9.sent) {
                          _context9.next = 4;
                          break;
                        }
                        throw new Error("File not found: ".concat(filename));
                      case 4:
                        stream = fs.createReadStream(filename);
                        _context9.prev = 5;
                        _context9.next = 8;
                        return this.read(stream, options);
                      case 8:
                        workbook = _context9.sent;
                        stream.close();
                        return _context9.abrupt("return", workbook);
                      case 13:
                        _context9.prev = 13;
                        _context9.t0 = _context9["catch"](5);
                        stream.close();
                        throw _context9.t0;
                      case 17:
                      case "end":
                        return _context9.stop();
                    }
                }, _callee9, this, [[5, 13]]);
              }));
              function readFile(_x7, _x8) {
                return _readFile2.apply(this, arguments);
              }
              return readFile;
            }() }, { key: "parseRels", value: function parseRels(stream) {
              var xform = new RelationshipsXform();
              return xform.parseStream(stream);
            } }, { key: "parseWorkbook", value: function parseWorkbook(stream) {
              var xform = new WorkbookXform();
              return xform.parseStream(stream);
            } }, { key: "parseSharedStrings", value: function parseSharedStrings(stream) {
              var xform = new SharedStringsXform();
              return xform.parseStream(stream);
            } }, { key: "reconcile", value: function reconcile(model, options) {
              var workbookXform = new WorkbookXform();
              var worksheetXform = new WorksheetXform(options);
              var drawingXform = new DrawingXform();
              var tableXform = new TableXform();
              workbookXform.reconcile(model);
              var drawingOptions = { media: model.media, mediaIndex: model.mediaIndex };
              Object.keys(model.drawings).forEach(function(name) {
                var drawing = model.drawings[name];
                var drawingRel = model.drawingRels[name];
                if (drawingRel) {
                  drawingOptions.rels = drawingRel.reduce(function(o, rel) {
                    o[rel.Id] = rel;
                    return o;
                  }, {});
                  (drawing.anchors || []).forEach(function(anchor) {
                    var hyperlinks = anchor.picture && anchor.picture.hyperlinks;
                    if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
                      hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
                      delete hyperlinks.rId;
                    }
                  });
                  drawingXform.reconcile(drawing, drawingOptions);
                }
              });
              var tableOptions = { styles: model.styles };
              Object.values(model.tables).forEach(function(table) {
                tableXform.reconcile(table, tableOptions);
              });
              var sheetOptions = { styles: model.styles, sharedStrings: model.sharedStrings, media: model.media, mediaIndex: model.mediaIndex, date1904: model.properties && model.properties.date1904, drawings: model.drawings, comments: model.comments, tables: model.tables, vmlDrawings: model.vmlDrawings };
              model.worksheets.forEach(function(worksheet) {
                worksheet.relationships = model.worksheetRels[worksheet.sheetNo];
                worksheetXform.reconcile(worksheet, sheetOptions);
              });
              delete model.worksheetHash;
              delete model.worksheetRels;
              delete model.globalRels;
              delete model.sharedStrings;
              delete model.workbookRels;
              delete model.sheetDefs;
              delete model.styles;
              delete model.mediaIndex;
              delete model.drawings;
              delete model.drawingRels;
              delete model.vmlDrawings;
            } }, { key: "_processWorksheetEntry", value: function() {
              var _processWorksheetEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee10(stream, model, sheetNo, options, path) {
                var xform, worksheet;
                return _regeneratorRuntime.wrap(function _callee10$(_context10) {
                  while (1)
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        xform = new WorksheetXform(options);
                        _context10.next = 3;
                        return xform.parseStream(stream);
                      case 3:
                        worksheet = _context10.sent;
                        worksheet.sheetNo = sheetNo;
                        model.worksheetHash[path] = worksheet;
                        model.worksheets.push(worksheet);
                      case 7:
                      case "end":
                        return _context10.stop();
                    }
                }, _callee10);
              }));
              function _processWorksheetEntry(_x9, _x10, _x11, _x12, _x13) {
                return _processWorksheetEntry2.apply(this, arguments);
              }
              return _processWorksheetEntry;
            }() }, { key: "_processCommentEntry", value: function() {
              var _processCommentEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee11(stream, model, name) {
                var xform, comments;
                return _regeneratorRuntime.wrap(function _callee11$(_context11) {
                  while (1)
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        xform = new CommentsXform();
                        _context11.next = 3;
                        return xform.parseStream(stream);
                      case 3:
                        comments = _context11.sent;
                        model.comments["../".concat(name, ".xml")] = comments;
                      case 5:
                      case "end":
                        return _context11.stop();
                    }
                }, _callee11);
              }));
              function _processCommentEntry(_x14, _x15, _x16) {
                return _processCommentEntry2.apply(this, arguments);
              }
              return _processCommentEntry;
            }() }, { key: "_processTableEntry", value: function() {
              var _processTableEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee12(stream, model, name) {
                var xform, table;
                return _regeneratorRuntime.wrap(function _callee12$(_context12) {
                  while (1)
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        xform = new TableXform();
                        _context12.next = 3;
                        return xform.parseStream(stream);
                      case 3:
                        table = _context12.sent;
                        model.tables["../tables/".concat(name, ".xml")] = table;
                      case 5:
                      case "end":
                        return _context12.stop();
                    }
                }, _callee12);
              }));
              function _processTableEntry(_x17, _x18, _x19) {
                return _processTableEntry2.apply(this, arguments);
              }
              return _processTableEntry;
            }() }, { key: "_processWorksheetRelsEntry", value: function() {
              var _processWorksheetRelsEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee13(stream, model, sheetNo) {
                var xform, relationships;
                return _regeneratorRuntime.wrap(function _callee13$(_context13) {
                  while (1)
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        xform = new RelationshipsXform();
                        _context13.next = 3;
                        return xform.parseStream(stream);
                      case 3:
                        relationships = _context13.sent;
                        model.worksheetRels[sheetNo] = relationships;
                      case 5:
                      case "end":
                        return _context13.stop();
                    }
                }, _callee13);
              }));
              function _processWorksheetRelsEntry(_x20, _x21, _x22) {
                return _processWorksheetRelsEntry2.apply(this, arguments);
              }
              return _processWorksheetRelsEntry;
            }() }, { key: "_processMediaEntry", value: function() {
              var _processMediaEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee14(entry, model, filename) {
                var lastDot, extension, name;
                return _regeneratorRuntime.wrap(function _callee14$(_context14) {
                  while (1)
                    switch (_context14.prev = _context14.next) {
                      case 0:
                        lastDot = filename.lastIndexOf(".");
                        if (!(lastDot >= 1)) {
                          _context14.next = 6;
                          break;
                        }
                        extension = filename.substr(lastDot + 1);
                        name = filename.substr(0, lastDot);
                        _context14.next = 6;
                        return new Promise(function(resolve, reject) {
                          var streamBuf = new StreamBuf();
                          streamBuf.on("finish", function() {
                            model.mediaIndex[filename] = model.media.length;
                            model.mediaIndex[name] = model.media.length;
                            var medium = { type: "image", name, extension, buffer: streamBuf.toBuffer() };
                            model.media.push(medium);
                            resolve();
                          });
                          entry.on("error", function(error) {
                            reject(error);
                          });
                          entry.pipe(streamBuf);
                        });
                      case 6:
                      case "end":
                        return _context14.stop();
                    }
                }, _callee14);
              }));
              function _processMediaEntry(_x23, _x24, _x25) {
                return _processMediaEntry2.apply(this, arguments);
              }
              return _processMediaEntry;
            }() }, { key: "_processDrawingEntry", value: function() {
              var _processDrawingEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee15(entry, model, name) {
                var xform, drawing;
                return _regeneratorRuntime.wrap(function _callee15$(_context15) {
                  while (1)
                    switch (_context15.prev = _context15.next) {
                      case 0:
                        xform = new DrawingXform();
                        _context15.next = 3;
                        return xform.parseStream(entry);
                      case 3:
                        drawing = _context15.sent;
                        model.drawings[name] = drawing;
                      case 5:
                      case "end":
                        return _context15.stop();
                    }
                }, _callee15);
              }));
              function _processDrawingEntry(_x26, _x27, _x28) {
                return _processDrawingEntry2.apply(this, arguments);
              }
              return _processDrawingEntry;
            }() }, { key: "_processDrawingRelsEntry", value: function() {
              var _processDrawingRelsEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee16(entry, model, name) {
                var xform, relationships;
                return _regeneratorRuntime.wrap(function _callee16$(_context16) {
                  while (1)
                    switch (_context16.prev = _context16.next) {
                      case 0:
                        xform = new RelationshipsXform();
                        _context16.next = 3;
                        return xform.parseStream(entry);
                      case 3:
                        relationships = _context16.sent;
                        model.drawingRels[name] = relationships;
                      case 5:
                      case "end":
                        return _context16.stop();
                    }
                }, _callee16);
              }));
              function _processDrawingRelsEntry(_x29, _x30, _x31) {
                return _processDrawingRelsEntry2.apply(this, arguments);
              }
              return _processDrawingRelsEntry;
            }() }, { key: "_processVmlDrawingEntry", value: function() {
              var _processVmlDrawingEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee17(entry, model, name) {
                var xform, vmlDrawing;
                return _regeneratorRuntime.wrap(function _callee17$(_context17) {
                  while (1)
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        xform = new VmlNotesXform();
                        _context17.next = 3;
                        return xform.parseStream(entry);
                      case 3:
                        vmlDrawing = _context17.sent;
                        model.vmlDrawings["../drawings/".concat(name, ".vml")] = vmlDrawing;
                      case 5:
                      case "end":
                        return _context17.stop();
                    }
                }, _callee17);
              }));
              function _processVmlDrawingEntry(_x32, _x33, _x34) {
                return _processVmlDrawingEntry2.apply(this, arguments);
              }
              return _processVmlDrawingEntry;
            }() }, {
              key: "_processThemeEntry",
              value: function() {
                var _processThemeEntry2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee18(entry, model, name) {
                  return _regeneratorRuntime.wrap(function _callee18$(_context18) {
                    while (1)
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _context18.next = 2;
                          return new Promise(function(resolve, reject) {
                            var stream = new StreamBuf();
                            entry.on("error", reject);
                            stream.on("error", reject);
                            stream.on("finish", function() {
                              model.themes[name] = stream.read().toString();
                              resolve();
                            });
                            entry.pipe(stream);
                          });
                        case 2:
                        case "end":
                          return _context18.stop();
                      }
                  }, _callee18);
                }));
                function _processThemeEntry(_x35, _x36, _x37) {
                  return _processThemeEntry2.apply(this, arguments);
                }
                return _processThemeEntry;
              }()
              /**
              * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
              */
            }, { key: "createInputStream", value: function createInputStream() {
              throw new Error("`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
            } }, { key: "read", value: function() {
              var _read = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee19(stream, options) {
                var chunks, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, chunk;
                return _regeneratorRuntime.wrap(function _callee19$(_context19) {
                  while (1)
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        if (!stream[Symbol.asyncIterator] && stream.pipe) {
                          stream = stream.pipe(new PassThrough());
                        }
                        chunks = [];
                        _iteratorAbruptCompletion3 = false;
                        _didIteratorError3 = false;
                        _context19.prev = 4;
                        _iterator3 = _asyncIterator(stream);
                      case 6:
                        _context19.next = 8;
                        return _iterator3.next();
                      case 8:
                        if (!(_iteratorAbruptCompletion3 = !(_step3 = _context19.sent).done)) {
                          _context19.next = 14;
                          break;
                        }
                        chunk = _step3.value;
                        chunks.push(chunk);
                      case 11:
                        _iteratorAbruptCompletion3 = false;
                        _context19.next = 6;
                        break;
                      case 14:
                        _context19.next = 20;
                        break;
                      case 16:
                        _context19.prev = 16;
                        _context19.t0 = _context19["catch"](4);
                        _didIteratorError3 = true;
                        _iteratorError3 = _context19.t0;
                      case 20:
                        _context19.prev = 20;
                        _context19.prev = 21;
                        if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {
                          _context19.next = 25;
                          break;
                        }
                        _context19.next = 25;
                        return _iterator3.return();
                      case 25:
                        _context19.prev = 25;
                        if (!_didIteratorError3) {
                          _context19.next = 28;
                          break;
                        }
                        throw _iteratorError3;
                      case 28:
                        return _context19.finish(25);
                      case 29:
                        return _context19.finish(20);
                      case 30:
                        return _context19.abrupt("return", this.load(Buffer2.concat(chunks), options));
                      case 31:
                      case "end":
                        return _context19.stop();
                    }
                }, _callee19, this, [[4, 16, 20, 30], [21, , 25, 29]]);
              }));
              function read(_x38, _x39) {
                return _read.apply(this, arguments);
              }
              return read;
            }() }, {
              key: "load",
              value: function() {
                var _load = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee20(data, options) {
                  var buffer, model, zip, _i6, _Object$values, entry, entryName, stream, content, chunkSize, i, workbook, appXform, appProperties, coreXform, coreProperties, match;
                  return _regeneratorRuntime.wrap(function _callee20$(_context20) {
                    while (1)
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          if (options && options.base64) {
                            buffer = Buffer2.from(data.toString(), "base64");
                          } else {
                            buffer = data;
                          }
                          model = { worksheets: [], worksheetHash: {}, worksheetRels: [], themes: {}, media: [], mediaIndex: {}, drawings: {}, drawingRels: {}, comments: {}, tables: {}, vmlDrawings: {} };
                          _context20.next = 4;
                          return JSZip.loadAsync(buffer);
                        case 4:
                          zip = _context20.sent;
                          _i6 = 0, _Object$values = Object.values(zip.files);
                        case 6:
                          if (!(_i6 < _Object$values.length)) {
                            _context20.next = 126;
                            break;
                          }
                          entry = _Object$values[_i6];
                          if (entry.dir) {
                            _context20.next = 123;
                            break;
                          }
                          entryName = entry.name;
                          if (entryName[0] === "/") {
                            entryName = entryName.substr(1);
                          }
                          stream = void 0;
                          if (!(entryName.match(/xl\/media\//) || // themes are not parsed as stream
                          entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/))) {
                            _context20.next = 21;
                            break;
                          }
                          stream = new PassThrough();
                          _context20.t0 = stream;
                          _context20.next = 17;
                          return entry.async("nodebuffer");
                        case 17:
                          _context20.t1 = _context20.sent;
                          _context20.t0.write.call(_context20.t0, _context20.t1);
                          _context20.next = 36;
                          break;
                        case 21:
                          stream = new PassThrough({ writableObjectMode: true, readableObjectMode: true });
                          content = void 0;
                          if (!process2.browser) {
                            _context20.next = 31;
                            break;
                          }
                          _context20.t2 = bufferToString;
                          _context20.next = 27;
                          return entry.async("nodebuffer");
                        case 27:
                          _context20.t3 = _context20.sent;
                          content = (0, _context20.t2)(_context20.t3);
                          _context20.next = 34;
                          break;
                        case 31:
                          _context20.next = 33;
                          return entry.async("string");
                        case 33:
                          content = _context20.sent;
                        case 34:
                          chunkSize = 16 * 1024;
                          for (i = 0; i < content.length; i += chunkSize) {
                            stream.write(content.substring(i, i + chunkSize));
                          }
                        case 36:
                          stream.end();
                          _context20.t4 = entryName;
                          _context20.next = _context20.t4 === "_rels/.rels" ? 40 : _context20.t4 === "xl/workbook.xml" ? 44 : _context20.t4 === "xl/_rels/workbook.xml.rels" ? 53 : _context20.t4 === "xl/sharedStrings.xml" ? 57 : _context20.t4 === "xl/styles.xml" ? 61 : _context20.t4 === "docProps/app.xml" ? 65 : _context20.t4 === "docProps/core.xml" ? 72 : 78;
                          break;
                        case 40:
                          _context20.next = 42;
                          return this.parseRels(stream);
                        case 42:
                          model.globalRels = _context20.sent;
                          return _context20.abrupt("break", 123);
                        case 44:
                          _context20.next = 46;
                          return this.parseWorkbook(stream);
                        case 46:
                          workbook = _context20.sent;
                          model.sheets = workbook.sheets;
                          model.definedNames = workbook.definedNames;
                          model.views = workbook.views;
                          model.properties = workbook.properties;
                          model.calcProperties = workbook.calcProperties;
                          return _context20.abrupt("break", 123);
                        case 53:
                          _context20.next = 55;
                          return this.parseRels(stream);
                        case 55:
                          model.workbookRels = _context20.sent;
                          return _context20.abrupt("break", 123);
                        case 57:
                          model.sharedStrings = new SharedStringsXform();
                          _context20.next = 60;
                          return model.sharedStrings.parseStream(stream);
                        case 60:
                          return _context20.abrupt("break", 123);
                        case 61:
                          model.styles = new StylesXform();
                          _context20.next = 64;
                          return model.styles.parseStream(stream);
                        case 64:
                          return _context20.abrupt("break", 123);
                        case 65:
                          appXform = new AppXform();
                          _context20.next = 68;
                          return appXform.parseStream(stream);
                        case 68:
                          appProperties = _context20.sent;
                          model.company = appProperties.company;
                          model.manager = appProperties.manager;
                          return _context20.abrupt("break", 123);
                        case 72:
                          coreXform = new CoreXform();
                          _context20.next = 75;
                          return coreXform.parseStream(stream);
                        case 75:
                          coreProperties = _context20.sent;
                          Object.assign(model, coreProperties);
                          return _context20.abrupt("break", 123);
                        case 78:
                          match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                          if (!match) {
                            _context20.next = 83;
                            break;
                          }
                          _context20.next = 82;
                          return this._processWorksheetEntry(stream, model, match[1], options, entryName);
                        case 82:
                          return _context20.abrupt("break", 123);
                        case 83:
                          match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                          if (!match) {
                            _context20.next = 88;
                            break;
                          }
                          _context20.next = 87;
                          return this._processWorksheetRelsEntry(stream, model, match[1]);
                        case 87:
                          return _context20.abrupt("break", 123);
                        case 88:
                          match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
                          if (!match) {
                            _context20.next = 93;
                            break;
                          }
                          _context20.next = 92;
                          return this._processThemeEntry(stream, model, match[1]);
                        case 92:
                          return _context20.abrupt("break", 123);
                        case 93:
                          match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
                          if (!match) {
                            _context20.next = 98;
                            break;
                          }
                          _context20.next = 97;
                          return this._processMediaEntry(stream, model, match[1]);
                        case 97:
                          return _context20.abrupt("break", 123);
                        case 98:
                          match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
                          if (!match) {
                            _context20.next = 103;
                            break;
                          }
                          _context20.next = 102;
                          return this._processDrawingEntry(stream, model, match[1]);
                        case 102:
                          return _context20.abrupt("break", 123);
                        case 103:
                          match = entryName.match(/xl\/(comments\d+)[.]xml/);
                          if (!match) {
                            _context20.next = 108;
                            break;
                          }
                          _context20.next = 107;
                          return this._processCommentEntry(stream, model, match[1]);
                        case 107:
                          return _context20.abrupt("break", 123);
                        case 108:
                          match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
                          if (!match) {
                            _context20.next = 113;
                            break;
                          }
                          _context20.next = 112;
                          return this._processTableEntry(stream, model, match[1]);
                        case 112:
                          return _context20.abrupt("break", 123);
                        case 113:
                          match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
                          if (!match) {
                            _context20.next = 118;
                            break;
                          }
                          _context20.next = 117;
                          return this._processDrawingRelsEntry(stream, model, match[1]);
                        case 117:
                          return _context20.abrupt("break", 123);
                        case 118:
                          match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
                          if (!match) {
                            _context20.next = 123;
                            break;
                          }
                          _context20.next = 122;
                          return this._processVmlDrawingEntry(stream, model, match[1]);
                        case 122:
                          return _context20.abrupt("break", 123);
                        case 123:
                          _i6++;
                          _context20.next = 6;
                          break;
                        case 126:
                          this.reconcile(model, options);
                          this.workbook.model = model;
                          return _context20.abrupt("return", this.workbook);
                        case 129:
                        case "end":
                          return _context20.stop();
                      }
                  }, _callee20, this);
                }));
                function load(_x40, _x41) {
                  return _load.apply(this, arguments);
                }
                return load;
              }()
              // =========================================================================
              // Write
            }, { key: "addMedia", value: function() {
              var _addMedia = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee22(zip, model) {
                return _regeneratorRuntime.wrap(function _callee22$(_context22) {
                  while (1)
                    switch (_context22.prev = _context22.next) {
                      case 0:
                        _context22.next = 2;
                        return Promise.all(model.media.map(/* @__PURE__ */ function() {
                          var _ref5 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee21(medium) {
                            var filename, data, dataimg64, content;
                            return _regeneratorRuntime.wrap(function _callee21$(_context21) {
                              while (1)
                                switch (_context21.prev = _context21.next) {
                                  case 0:
                                    if (!(medium.type === "image")) {
                                      _context21.next = 13;
                                      break;
                                    }
                                    filename = "xl/media/".concat(medium.name, ".").concat(medium.extension);
                                    if (!medium.filename) {
                                      _context21.next = 7;
                                      break;
                                    }
                                    _context21.next = 5;
                                    return fsReadFileAsync(medium.filename);
                                  case 5:
                                    data = _context21.sent;
                                    return _context21.abrupt("return", zip.append(data, { name: filename }));
                                  case 7:
                                    if (!medium.buffer) {
                                      _context21.next = 9;
                                      break;
                                    }
                                    return _context21.abrupt("return", zip.append(medium.buffer, { name: filename }));
                                  case 9:
                                    if (!medium.base64) {
                                      _context21.next = 13;
                                      break;
                                    }
                                    dataimg64 = medium.base64;
                                    content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                                    return _context21.abrupt("return", zip.append(content, { name: filename, base64: true }));
                                  case 13:
                                    throw new Error("Unsupported media");
                                  case 14:
                                  case "end":
                                    return _context21.stop();
                                }
                            }, _callee21);
                          }));
                          return function(_x44) {
                            return _ref5.apply(this, arguments);
                          };
                        }()));
                      case 2:
                      case "end":
                        return _context22.stop();
                    }
                }, _callee22);
              }));
              function addMedia(_x42, _x43) {
                return _addMedia.apply(this, arguments);
              }
              return addMedia;
            }() }, { key: "addDrawings", value: function addDrawings(zip, model) {
              var drawingXform = new DrawingXform();
              var relsXform = new RelationshipsXform();
              model.worksheets.forEach(function(worksheet) {
                var drawing = worksheet.drawing;
                if (drawing) {
                  drawingXform.prepare(drawing, {});
                  var xml = drawingXform.toXml(drawing);
                  zip.append(xml, { name: "xl/drawings/".concat(drawing.name, ".xml") });
                  xml = relsXform.toXml(drawing.rels);
                  zip.append(xml, { name: "xl/drawings/_rels/".concat(drawing.name, ".xml.rels") });
                }
              });
            } }, { key: "addTables", value: function addTables(zip, model) {
              var tableXform = new TableXform();
              model.worksheets.forEach(function(worksheet) {
                var tables = worksheet.tables;
                tables.forEach(function(table) {
                  tableXform.prepare(table, {});
                  var tableXml = tableXform.toXml(table);
                  zip.append(tableXml, { name: "xl/tables/".concat(table.target) });
                });
              });
            } }, { key: "addContentTypes", value: function() {
              var _addContentTypes = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee23(zip, model) {
                var xform, xml;
                return _regeneratorRuntime.wrap(function _callee23$(_context23) {
                  while (1)
                    switch (_context23.prev = _context23.next) {
                      case 0:
                        xform = new ContentTypesXform();
                        xml = xform.toXml(model);
                        zip.append(xml, { name: "[Content_Types].xml" });
                      case 3:
                      case "end":
                        return _context23.stop();
                    }
                }, _callee23);
              }));
              function addContentTypes(_x45, _x46) {
                return _addContentTypes.apply(this, arguments);
              }
              return addContentTypes;
            }() }, { key: "addApp", value: function() {
              var _addApp = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee24(zip, model) {
                var xform, xml;
                return _regeneratorRuntime.wrap(function _callee24$(_context24) {
                  while (1)
                    switch (_context24.prev = _context24.next) {
                      case 0:
                        xform = new AppXform();
                        xml = xform.toXml(model);
                        zip.append(xml, { name: "docProps/app.xml" });
                      case 3:
                      case "end":
                        return _context24.stop();
                    }
                }, _callee24);
              }));
              function addApp(_x47, _x48) {
                return _addApp.apply(this, arguments);
              }
              return addApp;
            }() }, { key: "addCore", value: function() {
              var _addCore = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee25(zip, model) {
                var coreXform;
                return _regeneratorRuntime.wrap(function _callee25$(_context25) {
                  while (1)
                    switch (_context25.prev = _context25.next) {
                      case 0:
                        coreXform = new CoreXform();
                        zip.append(coreXform.toXml(model), { name: "docProps/core.xml" });
                      case 2:
                      case "end":
                        return _context25.stop();
                    }
                }, _callee25);
              }));
              function addCore(_x49, _x50) {
                return _addCore.apply(this, arguments);
              }
              return addCore;
            }() }, { key: "addThemes", value: function() {
              var _addThemes = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee26(zip, model) {
                var themes;
                return _regeneratorRuntime.wrap(function _callee26$(_context26) {
                  while (1)
                    switch (_context26.prev = _context26.next) {
                      case 0:
                        themes = model.themes || { theme1: theme1Xml };
                        Object.keys(themes).forEach(function(name) {
                          var xml = themes[name];
                          var path = "xl/theme/".concat(name, ".xml");
                          zip.append(xml, { name: path });
                        });
                      case 2:
                      case "end":
                        return _context26.stop();
                    }
                }, _callee26);
              }));
              function addThemes(_x51, _x52) {
                return _addThemes.apply(this, arguments);
              }
              return addThemes;
            }() }, { key: "addOfficeRels", value: function() {
              var _addOfficeRels = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee27(zip) {
                var xform, xml;
                return _regeneratorRuntime.wrap(function _callee27$(_context27) {
                  while (1)
                    switch (_context27.prev = _context27.next) {
                      case 0:
                        xform = new RelationshipsXform();
                        xml = xform.toXml([{ Id: "rId1", Type: XLSX3.RelType.OfficeDocument, Target: "xl/workbook.xml" }, { Id: "rId2", Type: XLSX3.RelType.CoreProperties, Target: "docProps/core.xml" }, { Id: "rId3", Type: XLSX3.RelType.ExtenderProperties, Target: "docProps/app.xml" }]);
                        zip.append(xml, { name: "_rels/.rels" });
                      case 3:
                      case "end":
                        return _context27.stop();
                    }
                }, _callee27);
              }));
              function addOfficeRels(_x53) {
                return _addOfficeRels.apply(this, arguments);
              }
              return addOfficeRels;
            }() }, { key: "addWorkbookRels", value: function() {
              var _addWorkbookRels = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee28(zip, model) {
                var count, relationships, xform, xml;
                return _regeneratorRuntime.wrap(function _callee28$(_context28) {
                  while (1)
                    switch (_context28.prev = _context28.next) {
                      case 0:
                        count = 1;
                        relationships = [{ Id: "rId".concat(count++), Type: XLSX3.RelType.Styles, Target: "styles.xml" }, { Id: "rId".concat(count++), Type: XLSX3.RelType.Theme, Target: "theme/theme1.xml" }];
                        if (model.sharedStrings.count) {
                          relationships.push({ Id: "rId".concat(count++), Type: XLSX3.RelType.SharedStrings, Target: "sharedStrings.xml" });
                        }
                        model.worksheets.forEach(function(worksheet) {
                          worksheet.rId = "rId".concat(count++);
                          relationships.push({ Id: worksheet.rId, Type: XLSX3.RelType.Worksheet, Target: "worksheets/sheet".concat(worksheet.id, ".xml") });
                        });
                        xform = new RelationshipsXform();
                        xml = xform.toXml(relationships);
                        zip.append(xml, { name: "xl/_rels/workbook.xml.rels" });
                      case 7:
                      case "end":
                        return _context28.stop();
                    }
                }, _callee28);
              }));
              function addWorkbookRels(_x54, _x55) {
                return _addWorkbookRels.apply(this, arguments);
              }
              return addWorkbookRels;
            }() }, { key: "addSharedStrings", value: function() {
              var _addSharedStrings = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee29(zip, model) {
                return _regeneratorRuntime.wrap(function _callee29$(_context29) {
                  while (1)
                    switch (_context29.prev = _context29.next) {
                      case 0:
                        if (model.sharedStrings && model.sharedStrings.count) {
                          zip.append(model.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
                        }
                      case 1:
                      case "end":
                        return _context29.stop();
                    }
                }, _callee29);
              }));
              function addSharedStrings(_x56, _x57) {
                return _addSharedStrings.apply(this, arguments);
              }
              return addSharedStrings;
            }() }, { key: "addStyles", value: function() {
              var _addStyles = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee30(zip, model) {
                var xml;
                return _regeneratorRuntime.wrap(function _callee30$(_context30) {
                  while (1)
                    switch (_context30.prev = _context30.next) {
                      case 0:
                        xml = model.styles.xml;
                        if (xml) {
                          zip.append(xml, { name: "xl/styles.xml" });
                        }
                      case 2:
                      case "end":
                        return _context30.stop();
                    }
                }, _callee30);
              }));
              function addStyles(_x58, _x59) {
                return _addStyles.apply(this, arguments);
              }
              return addStyles;
            }() }, { key: "addWorkbook", value: function() {
              var _addWorkbook = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee31(zip, model) {
                var xform;
                return _regeneratorRuntime.wrap(function _callee31$(_context31) {
                  while (1)
                    switch (_context31.prev = _context31.next) {
                      case 0:
                        xform = new WorkbookXform();
                        zip.append(xform.toXml(model), { name: "xl/workbook.xml" });
                      case 2:
                      case "end":
                        return _context31.stop();
                    }
                }, _callee31);
              }));
              function addWorkbook(_x60, _x61) {
                return _addWorkbook.apply(this, arguments);
              }
              return addWorkbook;
            }() }, { key: "addWorksheets", value: function() {
              var _addWorksheets = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee32(zip, model) {
                var worksheetXform, relationshipsXform, commentsXform, vmlNotesXform;
                return _regeneratorRuntime.wrap(function _callee32$(_context32) {
                  while (1)
                    switch (_context32.prev = _context32.next) {
                      case 0:
                        worksheetXform = new WorksheetXform();
                        relationshipsXform = new RelationshipsXform();
                        commentsXform = new CommentsXform();
                        vmlNotesXform = new VmlNotesXform();
                        model.worksheets.forEach(function(worksheet) {
                          var xmlStream = new XmlStream();
                          worksheetXform.render(xmlStream, worksheet);
                          zip.append(xmlStream.xml, { name: "xl/worksheets/sheet".concat(worksheet.id, ".xml") });
                          if (worksheet.rels && worksheet.rels.length) {
                            xmlStream = new XmlStream();
                            relationshipsXform.render(xmlStream, worksheet.rels);
                            zip.append(xmlStream.xml, { name: "xl/worksheets/_rels/sheet".concat(worksheet.id, ".xml.rels") });
                          }
                          if (worksheet.comments.length > 0) {
                            xmlStream = new XmlStream();
                            commentsXform.render(xmlStream, worksheet);
                            zip.append(xmlStream.xml, { name: "xl/comments".concat(worksheet.id, ".xml") });
                            xmlStream = new XmlStream();
                            vmlNotesXform.render(xmlStream, worksheet);
                            zip.append(xmlStream.xml, { name: "xl/drawings/vmlDrawing".concat(worksheet.id, ".vml") });
                          }
                        });
                      case 5:
                      case "end":
                        return _context32.stop();
                    }
                }, _callee32);
              }));
              function addWorksheets(_x62, _x63) {
                return _addWorksheets.apply(this, arguments);
              }
              return addWorksheets;
            }() }, { key: "_finalize", value: function _finalize(zip) {
              var _this127 = this;
              return new Promise(function(resolve, reject) {
                zip.on("finish", function() {
                  resolve(_this127);
                });
                zip.on("error", reject);
                zip.finalize();
              });
            } }, { key: "prepareModel", value: function prepareModel(model, options) {
              model.creator = model.creator || "ExcelJS";
              model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
              model.created = model.created || /* @__PURE__ */ new Date();
              model.modified = model.modified || /* @__PURE__ */ new Date();
              model.useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : true;
              model.useStyles = options.useStyles !== void 0 ? options.useStyles : true;
              model.sharedStrings = new SharedStringsXform();
              model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();
              var workbookXform = new WorkbookXform();
              var worksheetXform = new WorksheetXform();
              workbookXform.prepare(model);
              var worksheetOptions = { sharedStrings: model.sharedStrings, styles: model.styles, date1904: model.properties.date1904, drawingsCount: 0, media: model.media };
              worksheetOptions.drawings = model.drawings = [];
              worksheetOptions.commentRefs = model.commentRefs = [];
              var tableCount = 0;
              model.tables = [];
              model.worksheets.forEach(function(worksheet) {
                worksheet.tables.forEach(function(table) {
                  tableCount++;
                  table.target = "table".concat(tableCount, ".xml");
                  table.id = tableCount;
                  model.tables.push(table);
                });
                worksheetXform.prepare(worksheet, worksheetOptions);
              });
            } }, { key: "write", value: function() {
              var _write2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee33(stream, options) {
                var model, zip;
                return _regeneratorRuntime.wrap(function _callee33$(_context33) {
                  while (1)
                    switch (_context33.prev = _context33.next) {
                      case 0:
                        options = options || {};
                        model = this.workbook.model;
                        zip = new ZipStream.ZipWriter(options.zip);
                        zip.pipe(stream);
                        this.prepareModel(model, options);
                        _context33.next = 7;
                        return this.addContentTypes(zip, model);
                      case 7:
                        _context33.next = 9;
                        return this.addOfficeRels(zip, model);
                      case 9:
                        _context33.next = 11;
                        return this.addWorkbookRels(zip, model);
                      case 11:
                        _context33.next = 13;
                        return this.addWorksheets(zip, model);
                      case 13:
                        _context33.next = 15;
                        return this.addSharedStrings(zip, model);
                      case 15:
                        _context33.next = 17;
                        return this.addDrawings(zip, model);
                      case 17:
                        _context33.next = 19;
                        return this.addTables(zip, model);
                      case 19:
                        _context33.next = 21;
                        return Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);
                      case 21:
                        _context33.next = 23;
                        return this.addMedia(zip, model);
                      case 23:
                        _context33.next = 25;
                        return Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);
                      case 25:
                        _context33.next = 27;
                        return this.addWorkbook(zip, model);
                      case 27:
                        return _context33.abrupt("return", this._finalize(zip));
                      case 28:
                      case "end":
                        return _context33.stop();
                    }
                }, _callee33, this);
              }));
              function write(_x64, _x65) {
                return _write2.apply(this, arguments);
              }
              return write;
            }() }, { key: "writeFile", value: function writeFile(filename, options) {
              var _this128 = this;
              var stream = fs.createWriteStream(filename);
              return new Promise(function(resolve, reject) {
                stream.on("finish", function() {
                  resolve();
                });
                stream.on("error", function(error) {
                  reject(error);
                });
                _this128.write(stream, options).then(function() {
                  stream.end();
                }).catch(function(err) {
                  reject(err);
                });
              });
            } }, { key: "writeBuffer", value: function() {
              var _writeBuffer2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee34(options) {
                var stream;
                return _regeneratorRuntime.wrap(function _callee34$(_context34) {
                  while (1)
                    switch (_context34.prev = _context34.next) {
                      case 0:
                        stream = new StreamBuf();
                        _context34.next = 3;
                        return this.write(stream, options);
                      case 3:
                        return _context34.abrupt("return", stream.read());
                      case 4:
                      case "end":
                        return _context34.stop();
                    }
                }, _callee34, this);
              }));
              function writeBuffer(_x66) {
                return _writeBuffer2.apply(this, arguments);
              }
              return writeBuffer;
            }() }]);
            return XLSX3;
          }();
          XLSX2.RelType = require2("./rel-type");
          module2.exports = XLSX2;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "../utils/browser-buffer-decode": 16, "../utils/stream-buf": 24, "../utils/utils": 27, "../utils/xml-stream": 28, "../utils/zip-stream": 29, "./rel-type": 31, "./xform/book/workbook-xform": 38, "./xform/comment/comments-xform": 40, "./xform/comment/vml-notes-xform": 45, "./xform/core/app-xform": 51, "./xform/core/content-types-xform": 52, "./xform/core/core-xform": 53, "./xform/core/relationships-xform": 55, "./xform/drawing/drawing-xform": 62, "./xform/sheet/worksheet-xform": 115, "./xform/strings/shared-strings-xform": 124, "./xform/style/styles-xform": 135, "./xform/table/table-xform": 143, "./xml/theme1": 145, "_process": 467, "buffer": 220, "fs": 216, "jszip": 441, "readable-stream": 491 }], 145: [function(require2, module2, exports2) {
      module2.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
    }, {}], 146: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CsvFormatterStream = void 0;
          var stream_1 = require2("stream");
          var formatter_1 = require2("./formatter");
          var CsvFormatterStream = /* @__PURE__ */ function(_stream_1$Transform) {
            _inherits(CsvFormatterStream2, _stream_1$Transform);
            var _super117 = _createSuper(CsvFormatterStream2);
            function CsvFormatterStream2(formatterOptions) {
              var _this129;
              _classCallCheck(this, CsvFormatterStream2);
              _this129 = _super117.call(this, { writableObjectMode: formatterOptions.objectMode });
              _this129.hasWrittenBOM = false;
              _this129.formatterOptions = formatterOptions;
              _this129.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
              _this129.hasWrittenBOM = !formatterOptions.writeBOM;
              return _this129;
            }
            _createClass(CsvFormatterStream2, [{ key: "transform", value: function transform(transformFunction) {
              this.rowFormatter.rowTransform = transformFunction;
              return this;
            } }, { key: "_transform", value: function _transform(row, encoding, cb) {
              var _this130 = this;
              var cbCalled = false;
              try {
                if (!this.hasWrittenBOM) {
                  this.push(this.formatterOptions.BOM);
                  this.hasWrittenBOM = true;
                }
                this.rowFormatter.format(row, function(err, rows) {
                  if (err) {
                    cbCalled = true;
                    return cb(err);
                  }
                  if (rows) {
                    rows.forEach(function(r) {
                      _this130.push(Buffer2.from(r, "utf8"));
                    });
                  }
                  cbCalled = true;
                  return cb();
                });
              } catch (e) {
                if (cbCalled) {
                  throw e;
                }
                cb(e);
              }
            } }, { key: "_flush", value: function _flush(cb) {
              var _this131 = this;
              this.rowFormatter.finish(function(err, rows) {
                if (err) {
                  return cb(err);
                }
                if (rows) {
                  rows.forEach(function(r) {
                    _this131.push(Buffer2.from(r, "utf8"));
                  });
                }
                return cb();
              });
            } }]);
            return CsvFormatterStream2;
          }(stream_1.Transform);
          exports2.CsvFormatterStream = CsvFormatterStream;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./formatter": 150, "buffer": 220, "stream": 505 }], 147: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FormatterOptions = void 0;
      var FormatterOptions = /* @__PURE__ */ _createClass(function FormatterOptions2() {
        _classCallCheck(this, FormatterOptions2);
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.rowDelimiter = "\n";
        this.quote = '"';
        this.escape = this.quote;
        this.quoteColumns = false;
        this.quoteHeaders = this.quoteColumns;
        this.headers = null;
        this.includeEndRowDelimiter = false;
        this.writeBOM = false;
        this.BOM = "\uFEFF";
        this.alwaysWriteHeaders = false;
        Object.assign(this, opts || {});
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
          this.quoteHeaders = this.quoteColumns;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
          this.quote = '"';
        } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
          this.quote = "";
        }
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
          this.escape = this.quote;
        }
        this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
        this.headers = Array.isArray(this.headers) ? this.headers : null;
        this.escapedQuote = "".concat(this.escape).concat(this.quote);
      });
      exports2.FormatterOptions = FormatterOptions;
    }, {}], 148: [function(require2, module2, exports2) {
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FieldFormatter = void 0;
      var lodash_isboolean_1 = __importDefault(require2("lodash.isboolean"));
      var lodash_isnil_1 = __importDefault(require2("lodash.isnil"));
      var lodash_escaperegexp_1 = __importDefault(require2("lodash.escaperegexp"));
      var FieldFormatter = /* @__PURE__ */ function() {
        function FieldFormatter2(formatterOptions) {
          _classCallCheck(this, FieldFormatter2);
          this._headers = null;
          this.formatterOptions = formatterOptions;
          if (formatterOptions.headers !== null) {
            this.headers = formatterOptions.headers;
          }
          this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
          var escapePattern = "[".concat(formatterOptions.delimiter).concat(lodash_escaperegexp_1.default(formatterOptions.rowDelimiter), "|\r|\n]");
          this.ESCAPE_REGEXP = new RegExp(escapePattern);
        }
        _createClass(FieldFormatter2, [{ key: "headers", set: function set(headers) {
          this._headers = headers;
        } }, { key: "shouldQuote", value: function shouldQuote(fieldIndex, isHeader) {
          var quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
          if (lodash_isboolean_1.default(quoteConfig)) {
            return quoteConfig;
          }
          if (Array.isArray(quoteConfig)) {
            return quoteConfig[fieldIndex];
          }
          if (this._headers !== null) {
            return quoteConfig[this._headers[fieldIndex]];
          }
          return false;
        } }, { key: "format", value: function format(field, fieldIndex, isHeader) {
          var preparedField = "".concat(lodash_isnil_1.default(field) ? "" : field).replace(/\0/g, "");
          var formatterOptions = this.formatterOptions;
          if (formatterOptions.quote !== "") {
            var shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
            if (shouldEscape) {
              return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
            }
          }
          var hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
          if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
            return this.quoteField(preparedField);
          }
          return preparedField;
        } }, { key: "quoteField", value: function quoteField(field) {
          var quote = this.formatterOptions.quote;
          return "".concat(quote).concat(field).concat(quote);
        } }]);
        return FieldFormatter2;
      }();
      exports2.FieldFormatter = FieldFormatter;
    }, { "lodash.escaperegexp": 442, "lodash.isboolean": 444, "lodash.isnil": 447 }], 149: [function(require2, module2, exports2) {
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowFormatter = void 0;
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var lodash_isequal_1 = __importDefault(require2("lodash.isequal"));
      var FieldFormatter_1 = require2("./FieldFormatter");
      var types_1 = require2("../types");
      var RowFormatter = /* @__PURE__ */ function() {
        function RowFormatter2(formatterOptions) {
          _classCallCheck(this, RowFormatter2);
          this.rowCount = 0;
          this.formatterOptions = formatterOptions;
          this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
          this.headers = formatterOptions.headers;
          this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
          this.hasWrittenHeaders = false;
          if (this.headers !== null) {
            this.fieldFormatter.headers = this.headers;
          }
          if (formatterOptions.transform) {
            this.rowTransform = formatterOptions.transform;
          }
        }
        _createClass(RowFormatter2, [{ key: "rowTransform", set: function set(transformFunction) {
          if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
          }
          this._rowTransform = RowFormatter2.createTransform(transformFunction);
        } }, { key: "format", value: function format(row, cb) {
          var _this132 = this;
          this.callTransformer(row, function(err, transformedRow) {
            if (err) {
              return cb(err);
            }
            if (!row) {
              return cb(null);
            }
            var rows = [];
            if (transformedRow) {
              var _this132$checkHeaders = _this132.checkHeaders(transformedRow), shouldFormatColumns = _this132$checkHeaders.shouldFormatColumns, headers = _this132$checkHeaders.headers;
              if (_this132.shouldWriteHeaders && headers && !_this132.hasWrittenHeaders) {
                rows.push(_this132.formatColumns(headers, true));
                _this132.hasWrittenHeaders = true;
              }
              if (shouldFormatColumns) {
                var columns = _this132.gatherColumns(transformedRow);
                rows.push(_this132.formatColumns(columns, false));
              }
            }
            return cb(null, rows);
          });
        } }, {
          key: "finish",
          value: function finish(cb) {
            var rows = [];
            if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
              if (!this.headers) {
                return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
              }
              rows.push(this.formatColumns(this.headers, true));
            }
            if (this.formatterOptions.includeEndRowDelimiter) {
              rows.push(this.formatterOptions.rowDelimiter);
            }
            return cb(null, rows);
          }
          // check if we need to write header return true if we should also write a row
          // could be false if headers is true and the header row(first item) is passed in
        }, {
          key: "checkHeaders",
          value: function checkHeaders(row) {
            if (this.headers) {
              return { shouldFormatColumns: true, headers: this.headers };
            }
            var headers = RowFormatter2.gatherHeaders(row);
            this.headers = headers;
            this.fieldFormatter.headers = headers;
            if (!this.shouldWriteHeaders) {
              return { shouldFormatColumns: true, headers: null };
            }
            return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };
          }
          // todo change this method to unknown[]
        }, { key: "gatherColumns", value: function gatherColumns(row) {
          if (this.headers === null) {
            throw new Error("Headers is currently null");
          }
          if (!Array.isArray(row)) {
            return this.headers.map(function(header) {
              return row[header];
            });
          }
          if (RowFormatter2.isRowHashArray(row)) {
            return this.headers.map(function(header, i) {
              var col = row[i];
              if (col) {
                return col[1];
              }
              return "";
            });
          }
          if (RowFormatter2.isRowArray(row) && !this.shouldWriteHeaders) {
            return row;
          }
          return this.headers.map(function(header, i) {
            return row[i];
          });
        } }, { key: "callTransformer", value: function callTransformer(row, cb) {
          if (!this._rowTransform) {
            return cb(null, row);
          }
          return this._rowTransform(row, cb);
        } }, { key: "formatColumns", value: function formatColumns(columns, isHeadersRow) {
          var _this133 = this;
          var formattedCols = columns.map(function(field, i) {
            return _this133.fieldFormatter.format(field, i, isHeadersRow);
          }).join(this.formatterOptions.delimiter);
          var rowCount = this.rowCount;
          this.rowCount += 1;
          if (rowCount) {
            return [this.formatterOptions.rowDelimiter, formattedCols].join("");
          }
          return formattedCols;
        } }], [{ key: "isRowHashArray", value: function isRowHashArray(row) {
          if (Array.isArray(row)) {
            return Array.isArray(row[0]) && row[0].length === 2;
          }
          return false;
        } }, {
          key: "isRowArray",
          value: function isRowArray(row) {
            return Array.isArray(row) && !this.isRowHashArray(row);
          }
          // get headers from a row item
        }, {
          key: "gatherHeaders",
          value: function gatherHeaders(row) {
            if (RowFormatter2.isRowHashArray(row)) {
              return row.map(function(it) {
                return it[0];
              });
            }
            if (Array.isArray(row)) {
              return row;
            }
            return Object.keys(row);
          }
          // eslint-disable-next-line @typescript-eslint/no-shadow
        }, { key: "createTransform", value: function createTransform(transformFunction) {
          if (types_1.isSyncTransform(transformFunction)) {
            return function(row, cb) {
              var transformedRow = null;
              try {
                transformedRow = transformFunction(row);
              } catch (e) {
                return cb(e);
              }
              return cb(null, transformedRow);
            };
          }
          return function(row, cb) {
            transformFunction(row, cb);
          };
        } }]);
        return RowFormatter2;
      }();
      exports2.RowFormatter = RowFormatter;
    }, { "../types": 152, "./FieldFormatter": 148, "lodash.isequal": 445, "lodash.isfunction": 446 }], 150: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FieldFormatter = exports2.RowFormatter = void 0;
      var RowFormatter_1 = require2("./RowFormatter");
      Object.defineProperty(exports2, "RowFormatter", { enumerable: true, get: function get() {
        return RowFormatter_1.RowFormatter;
      } });
      var FieldFormatter_1 = require2("./FieldFormatter");
      Object.defineProperty(exports2, "FieldFormatter", { enumerable: true, get: function get() {
        return FieldFormatter_1.FieldFormatter;
      } });
    }, { "./FieldFormatter": 148, "./RowFormatter": 149 }], 151: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var __createBinding = Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            Object.defineProperty(o, k2, { enumerable: true, get: function get() {
              return m[k];
            } });
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          };
          var __setModuleDefault = Object.create ? function(o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          } : function(o, v) {
            o["default"] = v;
          };
          var __importStar = function(mod) {
            if (mod && mod.__esModule)
              return mod;
            var result = {};
            if (mod != null) {
              for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                  __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
          };
          var __exportStar = function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.writeToPath = exports2.writeToString = exports2.writeToBuffer = exports2.writeToStream = exports2.write = exports2.format = exports2.FormatterOptions = exports2.CsvFormatterStream = void 0;
          var util_1 = require2("util");
          var stream_1 = require2("stream");
          var fs = __importStar(require2("fs"));
          var FormatterOptions_1 = require2("./FormatterOptions");
          var CsvFormatterStream_1 = require2("./CsvFormatterStream");
          __exportStar(require2("./types"), exports2);
          var CsvFormatterStream_2 = require2("./CsvFormatterStream");
          Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function get() {
            return CsvFormatterStream_2.CsvFormatterStream;
          } });
          var FormatterOptions_2 = require2("./FormatterOptions");
          Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function get() {
            return FormatterOptions_2.FormatterOptions;
          } });
          exports2.format = function(options) {
            return new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
          };
          exports2.write = function(rows, options) {
            var csvStream = exports2.format(options);
            var promiseWrite = util_1.promisify(function(row, cb) {
              csvStream.write(row, void 0, cb);
            });
            rows.reduce(function(prev, row) {
              return prev.then(function() {
                return promiseWrite(row);
              });
            }, Promise.resolve()).then(function() {
              return csvStream.end();
            }).catch(function(err) {
              csvStream.emit("error", err);
            });
            return csvStream;
          };
          exports2.writeToStream = function(ws, rows, options) {
            return exports2.write(rows, options).pipe(ws);
          };
          exports2.writeToBuffer = function(rows) {
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var buffers = [];
            var ws = new stream_1.Writable({ write: function write(data, enc, writeCb) {
              buffers.push(data);
              writeCb();
            } });
            return new Promise(function(res, rej) {
              ws.on("error", rej).on("finish", function() {
                return res(Buffer2.concat(buffers));
              });
              exports2.write(rows, opts).pipe(ws);
            });
          };
          exports2.writeToString = function(rows, options) {
            return exports2.writeToBuffer(rows, options).then(function(buffer) {
              return buffer.toString();
            });
          };
          exports2.writeToPath = function(path, rows, options) {
            var stream = fs.createWriteStream(path, { encoding: "utf8" });
            return exports2.write(rows, options).pipe(stream);
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./CsvFormatterStream": 146, "./FormatterOptions": 147, "./types": 152, "buffer": 220, "fs": 216, "stream": 505, "util": 527 }], 152: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSyncTransform = void 0;
      exports2.isSyncTransform = function(transform) {
        return transform.length === 1;
      };
    }, {}], 153: [function(require2, module2, exports2) {
      (function(setImmediate) {
        (function() {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CsvParserStream = void 0;
          var string_decoder_1 = require2("string_decoder");
          var stream_1 = require2("stream");
          var transforms_1 = require2("./transforms");
          var parser_1 = require2("./parser");
          var CsvParserStream = /* @__PURE__ */ function(_stream_1$Transform2) {
            _inherits(CsvParserStream2, _stream_1$Transform2);
            var _super118 = _createSuper(CsvParserStream2);
            function CsvParserStream2(parserOptions) {
              var _this134;
              _classCallCheck(this, CsvParserStream2);
              _this134 = _super118.call(this, { objectMode: parserOptions.objectMode });
              _this134.lines = "";
              _this134.rowCount = 0;
              _this134.parsedRowCount = 0;
              _this134.parsedLineCount = 0;
              _this134.endEmitted = false;
              _this134.headersEmitted = false;
              _this134.parserOptions = parserOptions;
              _this134.parser = new parser_1.Parser(parserOptions);
              _this134.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
              _this134.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
              _this134.rowTransformerValidator = new transforms_1.RowTransformerValidator();
              return _this134;
            }
            _createClass(CsvParserStream2, [{ key: "hasHitRowLimit", get: function get() {
              return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
            } }, { key: "shouldEmitRows", get: function get() {
              return this.parsedRowCount > this.parserOptions.skipRows;
            } }, { key: "shouldSkipLine", get: function get() {
              return this.parsedLineCount <= this.parserOptions.skipLines;
            } }, { key: "transform", value: function transform(transformFunction) {
              this.rowTransformerValidator.rowTransform = transformFunction;
              return this;
            } }, {
              key: "validate",
              value: function validate(validateFunction) {
                this.rowTransformerValidator.rowValidator = validateFunction;
                return this;
              }
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }, { key: "emit", value: function emit(event) {
              var _get2;
              if (event === "end") {
                if (!this.endEmitted) {
                  this.endEmitted = true;
                  _get(_getPrototypeOf(CsvParserStream2.prototype), "emit", this).call(this, "end", this.rowCount);
                }
                return false;
              }
              for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                rest[_key - 1] = arguments[_key];
              }
              return (_get2 = _get(_getPrototypeOf(CsvParserStream2.prototype), "emit", this)).call.apply(_get2, [this, event].concat(rest));
            } }, { key: "_transform", value: function _transform(data, encoding, done) {
              if (this.hasHitRowLimit) {
                return done();
              }
              var wrappedCallback = CsvParserStream2.wrapDoneCallback(done);
              try {
                var lines = this.lines;
                var newLine = lines + this.decoder.write(data);
                var rows = this.parse(newLine, true);
                return this.processRows(rows, wrappedCallback);
              } catch (e) {
                return wrappedCallback(e);
              }
            } }, { key: "_flush", value: function _flush(done) {
              var wrappedCallback = CsvParserStream2.wrapDoneCallback(done);
              if (this.hasHitRowLimit) {
                return wrappedCallback();
              }
              try {
                var newLine = this.lines + this.decoder.end();
                var rows = this.parse(newLine, false);
                return this.processRows(rows, wrappedCallback);
              } catch (e) {
                return wrappedCallback(e);
              }
            } }, { key: "parse", value: function parse(data, hasMoreData) {
              if (!data) {
                return [];
              }
              var _this$parser$parse = this.parser.parse(data, hasMoreData), line = _this$parser$parse.line, rows = _this$parser$parse.rows;
              this.lines = line;
              return rows;
            } }, { key: "processRows", value: function processRows(rows, cb) {
              var _this135 = this;
              var rowsLength = rows.length;
              var iterate = function iterate2(i) {
                var callNext = function callNext2(err) {
                  if (err) {
                    return cb(err);
                  }
                  if (i % 100 === 0) {
                    setImmediate(function() {
                      return iterate2(i + 1);
                    });
                    return void 0;
                  }
                  return iterate2(i + 1);
                };
                _this135.checkAndEmitHeaders();
                if (i >= rowsLength || _this135.hasHitRowLimit) {
                  return cb();
                }
                _this135.parsedLineCount += 1;
                if (_this135.shouldSkipLine) {
                  return callNext();
                }
                var row = rows[i];
                _this135.rowCount += 1;
                _this135.parsedRowCount += 1;
                var nextRowCount = _this135.rowCount;
                return _this135.transformRow(row, function(err, transformResult) {
                  if (err) {
                    _this135.rowCount -= 1;
                    return callNext(err);
                  }
                  if (!transformResult) {
                    return callNext(new Error("expected transform result"));
                  }
                  if (!transformResult.isValid) {
                    _this135.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
                  } else if (transformResult.row) {
                    return _this135.pushRow(transformResult.row, callNext);
                  }
                  return callNext();
                });
              };
              iterate(0);
            } }, { key: "transformRow", value: function transformRow(parsedRow, cb) {
              var _this136 = this;
              try {
                this.headerTransformer.transform(parsedRow, function(err, withHeaders) {
                  if (err) {
                    return cb(err);
                  }
                  if (!withHeaders) {
                    return cb(new Error("Expected result from header transform"));
                  }
                  if (!withHeaders.isValid) {
                    if (_this136.shouldEmitRows) {
                      return cb(null, { isValid: false, row: parsedRow });
                    }
                    return _this136.skipRow(cb);
                  }
                  if (withHeaders.row) {
                    if (_this136.shouldEmitRows) {
                      return _this136.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
                    }
                    return _this136.skipRow(cb);
                  }
                  _this136.rowCount -= 1;
                  _this136.parsedRowCount -= 1;
                  return cb(null, { row: null, isValid: true });
                });
              } catch (e) {
                cb(e);
              }
            } }, { key: "checkAndEmitHeaders", value: function checkAndEmitHeaders() {
              if (!this.headersEmitted && this.headerTransformer.headers) {
                this.headersEmitted = true;
                this.emit("headers", this.headerTransformer.headers);
              }
            } }, { key: "skipRow", value: function skipRow(cb) {
              this.rowCount -= 1;
              return cb(null, { row: null, isValid: true });
            } }, { key: "pushRow", value: function pushRow(row, cb) {
              try {
                if (!this.parserOptions.objectMode) {
                  this.push(JSON.stringify(row));
                } else {
                  this.push(row);
                }
                cb();
              } catch (e) {
                cb(e);
              }
            } }], [{ key: "wrapDoneCallback", value: function wrapDoneCallback(done) {
              var errorCalled = false;
              return function(err) {
                if (err) {
                  if (errorCalled) {
                    throw err;
                  }
                  errorCalled = true;
                  done(err);
                  return;
                }
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                done.apply(void 0, args);
              };
            } }]);
            return CsvParserStream2;
          }(stream_1.Transform);
          exports2.CsvParserStream = CsvParserStream;
        }).call(this);
      }).call(this, require2("timers").setImmediate);
    }, { "./parser": 165, "./transforms": 168, "stream": 505, "string_decoder": 218, "timers": 523 }], 154: [function(require2, module2, exports2) {
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ParserOptions = void 0;
      var lodash_escaperegexp_1 = __importDefault(require2("lodash.escaperegexp"));
      var lodash_isnil_1 = __importDefault(require2("lodash.isnil"));
      var ParserOptions = /* @__PURE__ */ _createClass(function ParserOptions2(opts) {
        _classCallCheck(this, ParserOptions2);
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.ignoreEmpty = false;
        this.quote = '"';
        this.escape = null;
        this.escapeChar = this.quote;
        this.comment = null;
        this.supportsComments = false;
        this.ltrim = false;
        this.rtrim = false;
        this.trim = false;
        this.headers = null;
        this.renameHeaders = false;
        this.strictColumnHandling = false;
        this.discardUnmappedColumns = false;
        this.carriageReturn = "\r";
        this.encoding = "utf8";
        this.limitRows = false;
        this.maxRows = 0;
        this.skipLines = 0;
        this.skipRows = 0;
        Object.assign(this, opts || {});
        if (this.delimiter.length > 1) {
          throw new Error("delimiter option must be one character long");
        }
        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
        this.supportsComments = !lodash_isnil_1.default(this.comment);
        this.NEXT_TOKEN_REGEXP = new RegExp("([^\\s]|\\r\\n|\\n|\\r|".concat(this.escapedDelimiter, ")"));
        if (this.maxRows > 0) {
          this.limitRows = true;
        }
      });
      exports2.ParserOptions = ParserOptions;
    }, { "lodash.escaperegexp": 442, "lodash.isnil": 447 }], 155: [function(require2, module2, exports2) {
      var __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function get() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      var __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseString = exports2.parseFile = exports2.parseStream = exports2.parse = exports2.ParserOptions = exports2.CsvParserStream = void 0;
      var fs = __importStar(require2("fs"));
      var stream_1 = require2("stream");
      var ParserOptions_1 = require2("./ParserOptions");
      var CsvParserStream_1 = require2("./CsvParserStream");
      __exportStar(require2("./types"), exports2);
      var CsvParserStream_2 = require2("./CsvParserStream");
      Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function get() {
        return CsvParserStream_2.CsvParserStream;
      } });
      var ParserOptions_2 = require2("./ParserOptions");
      Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function get() {
        return ParserOptions_2.ParserOptions;
      } });
      exports2.parse = function(args) {
        return new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
      };
      exports2.parseStream = function(stream, options) {
        return stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
      exports2.parseFile = function(location) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
      exports2.parseString = function(string, options) {
        var rs = new stream_1.Readable();
        rs.push(string);
        rs.push(null);
        return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
    }, { "./CsvParserStream": 153, "./ParserOptions": 154, "./types": 169, "fs": 216, "stream": 505 }], 156: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = void 0;
      var Scanner_1 = require2("./Scanner");
      var RowParser_1 = require2("./RowParser");
      var Token_1 = require2("./Token");
      var Parser = /* @__PURE__ */ function() {
        function Parser2(parserOptions) {
          _classCallCheck(this, Parser2);
          this.parserOptions = parserOptions;
          this.rowParser = new RowParser_1.RowParser(this.parserOptions);
        }
        _createClass(Parser2, [{ key: "parse", value: function parse(line, hasMoreData) {
          var scanner = new Scanner_1.Scanner({ line: Parser2.removeBOM(line), parserOptions: this.parserOptions, hasMoreData });
          if (this.parserOptions.supportsComments) {
            return this.parseWithComments(scanner);
          }
          return this.parseWithoutComments(scanner);
        } }, { key: "parseWithoutComments", value: function parseWithoutComments(scanner) {
          var rows = [];
          var shouldContinue = true;
          while (shouldContinue) {
            shouldContinue = this.parseRow(scanner, rows);
          }
          return { line: scanner.line, rows };
        } }, { key: "parseWithComments", value: function parseWithComments(scanner) {
          var parserOptions = this.parserOptions;
          var rows = [];
          for (var nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
              var cursor = scanner.advancePastLine();
              if (cursor === null) {
                return { line: scanner.lineFromCursor, rows };
              }
              if (!scanner.hasMoreCharacters) {
                return { line: scanner.lineFromCursor, rows };
              }
              scanner.truncateToCursor();
            } else if (!this.parseRow(scanner, rows)) {
              break;
            }
          }
          return { line: scanner.line, rows };
        } }, { key: "parseRow", value: function parseRow(scanner, rows) {
          var nextToken = scanner.nextNonSpaceToken;
          if (!nextToken) {
            return false;
          }
          var row = this.rowParser.parse(scanner);
          if (row === null) {
            return false;
          }
          if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {
            return true;
          }
          rows.push(row);
          return true;
        } }], [{ key: "removeBOM", value: function removeBOM(line) {
          if (line && line.charCodeAt(0) === 65279) {
            return line.slice(1);
          }
          return line;
        } }]);
        return Parser2;
      }();
      exports2.Parser = Parser;
    }, { "./RowParser": 157, "./Scanner": 158, "./Token": 159 }], 157: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowParser = void 0;
      var column_1 = require2("./column");
      var Token_1 = require2("./Token");
      var EMPTY_STRING = "";
      var RowParser = /* @__PURE__ */ function() {
        function RowParser2(parserOptions) {
          _classCallCheck(this, RowParser2);
          this.parserOptions = parserOptions;
          this.columnParser = new column_1.ColumnParser(parserOptions);
        }
        _createClass(RowParser2, [{ key: "parse", value: function parse(scanner) {
          var parserOptions = this.parserOptions;
          var hasMoreData = scanner.hasMoreData;
          var currentScanner = scanner;
          var columns = [];
          var currentToken = this.getStartToken(currentScanner, columns);
          while (currentToken) {
            if (Token_1.Token.isTokenRowDelimiter(currentToken)) {
              currentScanner.advancePastToken(currentToken);
              if (!currentScanner.hasMoreCharacters && Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
                return null;
              }
              currentScanner.truncateToCursor();
              return columns;
            }
            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
              var item = this.columnParser.parse(currentScanner);
              if (item === null) {
                return null;
              }
              columns.push(item);
            }
            currentToken = currentScanner.nextNonSpaceToken;
          }
          if (!hasMoreData) {
            currentScanner.truncateToCursor();
            return columns;
          }
          return null;
        } }, { key: "getStartToken", value: function getStartToken(scanner, columns) {
          var currentToken = scanner.nextNonSpaceToken;
          if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
            columns.push("");
            return scanner.nextNonSpaceToken;
          }
          return currentToken;
        } }, { key: "shouldSkipColumnParse", value: function shouldSkipColumnParse(scanner, currentToken, columns) {
          var parserOptions = this.parserOptions;
          if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {
            scanner.advancePastToken(currentToken);
            var nextToken = scanner.nextCharacterToken;
            if (!scanner.hasMoreCharacters || nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken)) {
              columns.push("");
              return true;
            }
            if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {
              columns.push("");
              return true;
            }
          }
          return false;
        } }], [{ key: "isEmptyRow", value: function isEmptyRow(row) {
          return row.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
        } }]);
        return RowParser2;
      }();
      exports2.RowParser = RowParser;
    }, { "./Token": 159, "./column": 164 }], 158: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Scanner = void 0;
      var Token_1 = require2("./Token");
      var ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
      var Scanner = /* @__PURE__ */ function() {
        function Scanner2(args) {
          _classCallCheck(this, Scanner2);
          this.cursor = 0;
          this.line = args.line;
          this.lineLength = this.line.length;
          this.parserOptions = args.parserOptions;
          this.hasMoreData = args.hasMoreData;
          this.cursor = args.cursor || 0;
        }
        _createClass(Scanner2, [{ key: "hasMoreCharacters", get: function get() {
          return this.lineLength > this.cursor;
        } }, { key: "nextNonSpaceToken", get: function get() {
          var lineFromCursor = this.lineFromCursor;
          var regex = this.parserOptions.NEXT_TOKEN_REGEXP;
          if (lineFromCursor.search(regex) === -1) {
            return null;
          }
          var match = regex.exec(lineFromCursor);
          if (match == null) {
            return null;
          }
          var token = match[1];
          var startCursor = this.cursor + (match.index || 0);
          return new Token_1.Token({ token, startCursor, endCursor: startCursor + token.length - 1 });
        } }, { key: "nextCharacterToken", get: function get() {
          var cursor = this.cursor, lineLength = this.lineLength;
          if (lineLength <= cursor) {
            return null;
          }
          return new Token_1.Token({ token: this.line[cursor], startCursor: cursor, endCursor: cursor });
        } }, { key: "lineFromCursor", get: function get() {
          return this.line.substr(this.cursor);
        } }, { key: "advancePastLine", value: function advancePastLine() {
          var match = ROW_DELIMITER.exec(this.lineFromCursor);
          if (!match) {
            if (this.hasMoreData) {
              return null;
            }
            this.cursor = this.lineLength;
            return this;
          }
          this.cursor += (match.index || 0) + match[0].length;
          return this;
        } }, { key: "advanceTo", value: function advanceTo(cursor) {
          this.cursor = cursor;
          return this;
        } }, { key: "advanceToToken", value: function advanceToToken(token) {
          this.cursor = token.startCursor;
          return this;
        } }, { key: "advancePastToken", value: function advancePastToken(token) {
          this.cursor = token.endCursor + 1;
          return this;
        } }, { key: "truncateToCursor", value: function truncateToCursor() {
          this.line = this.lineFromCursor;
          this.lineLength = this.line.length;
          this.cursor = 0;
          return this;
        } }]);
        return Scanner2;
      }();
      exports2.Scanner = Scanner;
    }, { "./Token": 159 }], 159: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Token = void 0;
      var Token = /* @__PURE__ */ function() {
        function Token2(tokenArgs) {
          _classCallCheck(this, Token2);
          this.token = tokenArgs.token;
          this.startCursor = tokenArgs.startCursor;
          this.endCursor = tokenArgs.endCursor;
        }
        _createClass(Token2, null, [{ key: "isTokenRowDelimiter", value: function isTokenRowDelimiter(token) {
          var content = token.token;
          return content === "\r" || content === "\n" || content === "\r\n";
        } }, { key: "isTokenCarriageReturn", value: function isTokenCarriageReturn(token, parserOptions) {
          return token.token === parserOptions.carriageReturn;
        } }, { key: "isTokenComment", value: function isTokenComment(token, parserOptions) {
          return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
        } }, { key: "isTokenEscapeCharacter", value: function isTokenEscapeCharacter(token, parserOptions) {
          return token.token === parserOptions.escapeChar;
        } }, { key: "isTokenQuote", value: function isTokenQuote(token, parserOptions) {
          return token.token === parserOptions.quote;
        } }, { key: "isTokenDelimiter", value: function isTokenDelimiter(token, parserOptions) {
          return token.token === parserOptions.delimiter;
        } }]);
        return Token2;
      }();
      exports2.Token = Token;
    }, {}], 160: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColumnFormatter = void 0;
      var ColumnFormatter = /* @__PURE__ */ _createClass(function ColumnFormatter2(parserOptions) {
        _classCallCheck(this, ColumnFormatter2);
        if (parserOptions.trim) {
          this.format = function(col) {
            return col.trim();
          };
        } else if (parserOptions.ltrim) {
          this.format = function(col) {
            return col.trimLeft();
          };
        } else if (parserOptions.rtrim) {
          this.format = function(col) {
            return col.trimRight();
          };
        } else {
          this.format = function(col) {
            return col;
          };
        }
      });
      exports2.ColumnFormatter = ColumnFormatter;
    }, {}], 161: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColumnParser = void 0;
      var NonQuotedColumnParser_1 = require2("./NonQuotedColumnParser");
      var QuotedColumnParser_1 = require2("./QuotedColumnParser");
      var Token_1 = require2("../Token");
      var ColumnParser = /* @__PURE__ */ function() {
        function ColumnParser2(parserOptions) {
          _classCallCheck(this, ColumnParser2);
          this.parserOptions = parserOptions;
          this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
          this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
        }
        _createClass(ColumnParser2, [{ key: "parse", value: function parse(scanner) {
          var nextNonSpaceToken = scanner.nextNonSpaceToken;
          if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
            scanner.advanceToToken(nextNonSpaceToken);
            return this.quotedColumnParser.parse(scanner);
          }
          return this.nonQuotedColumnParser.parse(scanner);
        } }]);
        return ColumnParser2;
      }();
      exports2.ColumnParser = ColumnParser;
    }, { "../Token": 159, "./NonQuotedColumnParser": 162, "./QuotedColumnParser": 163 }], 162: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NonQuotedColumnParser = void 0;
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      var Token_1 = require2("../Token");
      var NonQuotedColumnParser = /* @__PURE__ */ function() {
        function NonQuotedColumnParser2(parserOptions) {
          _classCallCheck(this, NonQuotedColumnParser2);
          this.parserOptions = parserOptions;
          this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
        }
        _createClass(NonQuotedColumnParser2, [{ key: "parse", value: function parse(scanner) {
          if (!scanner.hasMoreCharacters) {
            return null;
          }
          var parserOptions = this.parserOptions;
          var characters = [];
          var nextToken = scanner.nextCharacterToken;
          for (; nextToken; nextToken = scanner.nextCharacterToken) {
            if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {
              break;
            }
            characters.push(nextToken.token);
            scanner.advancePastToken(nextToken);
          }
          return this.columnFormatter.format(characters.join(""));
        } }]);
        return NonQuotedColumnParser2;
      }();
      exports2.NonQuotedColumnParser = NonQuotedColumnParser;
    }, { "../Token": 159, "./ColumnFormatter": 160 }], 163: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.QuotedColumnParser = void 0;
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      var Token_1 = require2("../Token");
      var QuotedColumnParser = /* @__PURE__ */ function() {
        function QuotedColumnParser2(parserOptions) {
          _classCallCheck(this, QuotedColumnParser2);
          this.parserOptions = parserOptions;
          this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
        }
        _createClass(QuotedColumnParser2, [{ key: "parse", value: function parse(scanner) {
          if (!scanner.hasMoreCharacters) {
            return null;
          }
          var originalCursor = scanner.cursor;
          var _this$gatherDataBetwe = this.gatherDataBetweenQuotes(scanner), foundClosingQuote = _this$gatherDataBetwe.foundClosingQuote, col = _this$gatherDataBetwe.col;
          if (!foundClosingQuote) {
            scanner.advanceTo(originalCursor);
            if (!scanner.hasMoreData) {
              throw new Error("Parse Error: missing closing: '".concat(this.parserOptions.quote || "", "' in line: at '").concat(scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'"), "'"));
            }
            return null;
          }
          this.checkForMalformedColumn(scanner);
          return col;
        } }, { key: "gatherDataBetweenQuotes", value: function gatherDataBetweenQuotes(scanner) {
          var parserOptions = this.parserOptions;
          var foundStartingQuote = false;
          var foundClosingQuote = false;
          var characters = [];
          var nextToken = scanner.nextCharacterToken;
          for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
            var isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);
            if (!foundStartingQuote && isQuote) {
              foundStartingQuote = true;
            } else if (foundStartingQuote) {
              if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
                scanner.advancePastToken(nextToken);
                var tokenFollowingEscape = scanner.nextCharacterToken;
                if (tokenFollowingEscape !== null && (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
                  characters.push(tokenFollowingEscape.token);
                  nextToken = tokenFollowingEscape;
                } else if (isQuote) {
                  foundClosingQuote = true;
                } else {
                  characters.push(nextToken.token);
                }
              } else if (isQuote) {
                foundClosingQuote = true;
              } else {
                characters.push(nextToken.token);
              }
            }
            scanner.advancePastToken(nextToken);
          }
          return { col: this.columnFormatter.format(characters.join("")), foundClosingQuote };
        } }, { key: "checkForMalformedColumn", value: function checkForMalformedColumn(scanner) {
          var parserOptions = this.parserOptions;
          var nextNonSpaceToken = scanner.nextNonSpaceToken;
          if (nextNonSpaceToken) {
            var isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
            var isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);
            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
              var linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
              throw new Error("Parse Error: expected: '".concat(parserOptions.escapedDelimiter, "' OR new line got: '").concat(nextNonSpaceToken.token, "'. at '").concat(linePreview));
            }
            scanner.advanceToToken(nextNonSpaceToken);
          } else if (!scanner.hasMoreData) {
            scanner.advancePastLine();
          }
        } }]);
        return QuotedColumnParser2;
      }();
      exports2.QuotedColumnParser = QuotedColumnParser;
    }, { "../Token": 159, "./ColumnFormatter": 160 }], 164: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColumnFormatter = exports2.QuotedColumnParser = exports2.NonQuotedColumnParser = exports2.ColumnParser = void 0;
      var ColumnParser_1 = require2("./ColumnParser");
      Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function get() {
        return ColumnParser_1.ColumnParser;
      } });
      var NonQuotedColumnParser_1 = require2("./NonQuotedColumnParser");
      Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function get() {
        return NonQuotedColumnParser_1.NonQuotedColumnParser;
      } });
      var QuotedColumnParser_1 = require2("./QuotedColumnParser");
      Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function get() {
        return QuotedColumnParser_1.QuotedColumnParser;
      } });
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      Object.defineProperty(exports2, "ColumnFormatter", { enumerable: true, get: function get() {
        return ColumnFormatter_1.ColumnFormatter;
      } });
    }, { "./ColumnFormatter": 160, "./ColumnParser": 161, "./NonQuotedColumnParser": 162, "./QuotedColumnParser": 163 }], 165: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.QuotedColumnParser = exports2.NonQuotedColumnParser = exports2.ColumnParser = exports2.Token = exports2.Scanner = exports2.RowParser = exports2.Parser = void 0;
      var Parser_1 = require2("./Parser");
      Object.defineProperty(exports2, "Parser", { enumerable: true, get: function get() {
        return Parser_1.Parser;
      } });
      var RowParser_1 = require2("./RowParser");
      Object.defineProperty(exports2, "RowParser", { enumerable: true, get: function get() {
        return RowParser_1.RowParser;
      } });
      var Scanner_1 = require2("./Scanner");
      Object.defineProperty(exports2, "Scanner", { enumerable: true, get: function get() {
        return Scanner_1.Scanner;
      } });
      var Token_1 = require2("./Token");
      Object.defineProperty(exports2, "Token", { enumerable: true, get: function get() {
        return Token_1.Token;
      } });
      var column_1 = require2("./column");
      Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function get() {
        return column_1.ColumnParser;
      } });
      Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function get() {
        return column_1.NonQuotedColumnParser;
      } });
      Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function get() {
        return column_1.QuotedColumnParser;
      } });
    }, { "./Parser": 156, "./RowParser": 157, "./Scanner": 158, "./Token": 159, "./column": 164 }], 166: [function(require2, module2, exports2) {
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HeaderTransformer = void 0;
      var lodash_isundefined_1 = __importDefault(require2("lodash.isundefined"));
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var lodash_uniq_1 = __importDefault(require2("lodash.uniq"));
      var lodash_groupby_1 = __importDefault(require2("lodash.groupby"));
      var HeaderTransformer = /* @__PURE__ */ function() {
        function HeaderTransformer2(parserOptions) {
          _classCallCheck(this, HeaderTransformer2);
          this.headers = null;
          this.receivedHeaders = false;
          this.shouldUseFirstRow = false;
          this.processedFirstRow = false;
          this.headersLength = 0;
          this.parserOptions = parserOptions;
          if (parserOptions.headers === true) {
            this.shouldUseFirstRow = true;
          } else if (Array.isArray(parserOptions.headers)) {
            this.setHeaders(parserOptions.headers);
          } else if (lodash_isfunction_1.default(parserOptions.headers)) {
            this.headersTransform = parserOptions.headers;
          }
        }
        _createClass(HeaderTransformer2, [{ key: "transform", value: function transform(row, cb) {
          if (!this.shouldMapRow(row)) {
            return cb(null, { row: null, isValid: true });
          }
          return cb(null, this.processRow(row));
        } }, { key: "shouldMapRow", value: function shouldMapRow(row) {
          var parserOptions = this.parserOptions;
          if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
            if (!this.receivedHeaders) {
              throw new Error("Error renaming headers: new headers must be provided in an array");
            }
            this.processedFirstRow = true;
            return false;
          }
          if (!this.receivedHeaders && Array.isArray(row)) {
            if (this.headersTransform) {
              this.setHeaders(this.headersTransform(row));
            } else if (this.shouldUseFirstRow) {
              this.setHeaders(row);
            } else {
              return true;
            }
            return false;
          }
          return true;
        } }, { key: "processRow", value: function processRow(row) {
          if (!this.headers) {
            return { row, isValid: true };
          }
          var parserOptions = this.parserOptions;
          if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {
            if (!parserOptions.strictColumnHandling) {
              throw new Error("Unexpected Error: column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length));
            }
            return { row, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length) };
          }
          if (parserOptions.strictColumnHandling && row.length < this.headersLength) {
            return { row, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length) };
          }
          return { row: this.mapHeaders(row), isValid: true };
        } }, { key: "mapHeaders", value: function mapHeaders(row) {
          var rowMap = {};
          var headers = this.headers, headersLength = this.headersLength;
          for (var i = 0; i < headersLength; i += 1) {
            var header = headers[i];
            if (!lodash_isundefined_1.default(header)) {
              var val = row[i];
              if (lodash_isundefined_1.default(val)) {
                rowMap[header] = "";
              } else {
                rowMap[header] = val;
              }
            }
          }
          return rowMap;
        } }, { key: "setHeaders", value: function setHeaders(headers) {
          var _a;
          var filteredHeaders = headers.filter(function(h3) {
            return !!h3;
          });
          if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
            var grouped = lodash_groupby_1.default(filteredHeaders);
            var duplicates = Object.keys(grouped).filter(function(dup2) {
              return grouped[dup2].length > 1;
            });
            throw new Error("Duplicate headers found ".concat(JSON.stringify(duplicates)));
          }
          this.headers = headers;
          this.receivedHeaders = true;
          this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
        } }]);
        return HeaderTransformer2;
      }();
      exports2.HeaderTransformer = HeaderTransformer;
    }, { "lodash.groupby": 443, "lodash.isfunction": 446, "lodash.isundefined": 448, "lodash.uniq": 449 }], 167: [function(require2, module2, exports2) {
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowTransformerValidator = void 0;
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var types_1 = require2("../types");
      var RowTransformerValidator = /* @__PURE__ */ function() {
        function RowTransformerValidator2() {
          _classCallCheck(this, RowTransformerValidator2);
          this._rowTransform = null;
          this._rowValidator = null;
        }
        _createClass(RowTransformerValidator2, [{ key: "rowTransform", set: function set(transformFunction) {
          if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
          }
          this._rowTransform = RowTransformerValidator2.createTransform(transformFunction);
        } }, { key: "rowValidator", set: function set(validateFunction) {
          if (!lodash_isfunction_1.default(validateFunction)) {
            throw new TypeError("The validate should be a function");
          }
          this._rowValidator = RowTransformerValidator2.createValidator(validateFunction);
        } }, { key: "transformAndValidate", value: function transformAndValidate(row, cb) {
          var _this137 = this;
          return this.callTransformer(row, function(transformErr, transformedRow) {
            if (transformErr) {
              return cb(transformErr);
            }
            if (!transformedRow) {
              return cb(null, { row: null, isValid: true });
            }
            return _this137.callValidator(transformedRow, function(validateErr, validationResult) {
              if (validateErr) {
                return cb(validateErr);
              }
              if (validationResult && !validationResult.isValid) {
                return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
              }
              return cb(null, { row: transformedRow, isValid: true });
            });
          });
        } }, { key: "callTransformer", value: function callTransformer(row, cb) {
          if (!this._rowTransform) {
            return cb(null, row);
          }
          return this._rowTransform(row, cb);
        } }, { key: "callValidator", value: function callValidator(row, cb) {
          if (!this._rowValidator) {
            return cb(null, { row, isValid: true });
          }
          return this._rowValidator(row, cb);
        } }], [{ key: "createTransform", value: function createTransform(transformFunction) {
          if (types_1.isSyncTransform(transformFunction)) {
            return function(row, cb) {
              var transformed = null;
              try {
                transformed = transformFunction(row);
              } catch (e) {
                return cb(e);
              }
              return cb(null, transformed);
            };
          }
          return transformFunction;
        } }, { key: "createValidator", value: function createValidator(validateFunction) {
          if (types_1.isSyncValidate(validateFunction)) {
            return function(row, cb) {
              cb(null, { row, isValid: validateFunction(row) });
            };
          }
          return function(row, cb) {
            validateFunction(row, function(err, isValid2, reason) {
              if (err) {
                return cb(err);
              }
              if (isValid2) {
                return cb(null, { row, isValid: isValid2, reason });
              }
              return cb(null, { row, isValid: false, reason });
            });
          };
        } }]);
        return RowTransformerValidator2;
      }();
      exports2.RowTransformerValidator = RowTransformerValidator;
    }, { "../types": 169, "lodash.isfunction": 446 }], 168: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HeaderTransformer = exports2.RowTransformerValidator = void 0;
      var RowTransformerValidator_1 = require2("./RowTransformerValidator");
      Object.defineProperty(exports2, "RowTransformerValidator", { enumerable: true, get: function get() {
        return RowTransformerValidator_1.RowTransformerValidator;
      } });
      var HeaderTransformer_1 = require2("./HeaderTransformer");
      Object.defineProperty(exports2, "HeaderTransformer", { enumerable: true, get: function get() {
        return HeaderTransformer_1.HeaderTransformer;
      } });
    }, { "./HeaderTransformer": 166, "./RowTransformerValidator": 167 }], 169: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSyncValidate = exports2.isSyncTransform = void 0;
      exports2.isSyncTransform = function(transform) {
        return transform.length === 1;
      };
      exports2.isSyncValidate = function(validate) {
        return validate.length === 1;
      };
    }, {}], 170: [function(require2, module2, exports2) {
      var asn1 = exports2;
      asn1.bignum = require2("bn.js");
      asn1.define = require2("./asn1/api").define;
      asn1.base = require2("./asn1/base");
      asn1.constants = require2("./asn1/constants");
      asn1.decoders = require2("./asn1/decoders");
      asn1.encoders = require2("./asn1/encoders");
    }, { "./asn1/api": 171, "./asn1/base": 173, "./asn1/constants": 177, "./asn1/decoders": 179, "./asn1/encoders": 182, "bn.js": 184 }], 171: [function(require2, module2, exports2) {
      var encoders = require2("./encoders");
      var decoders = require2("./decoders");
      var inherits = require2("inherits");
      var api = exports2;
      api.define = function define(name, body) {
        return new Entity(name, body);
      };
      function Entity(name, body) {
        this.name = name;
        this.body = body;
        this.decoders = {};
        this.encoders = {};
      }
      Entity.prototype._createNamed = function createNamed(Base) {
        var name = this.name;
        function Generated(entity) {
          this._initNamed(entity, name);
        }
        inherits(Generated, Base);
        Generated.prototype._initNamed = function _initNamed(entity, name2) {
          Base.call(this, entity, name2);
        };
        return new Generated(this);
      };
      Entity.prototype._getDecoder = function _getDecoder(enc) {
        enc = enc || "der";
        if (!this.decoders.hasOwnProperty(enc))
          this.decoders[enc] = this._createNamed(decoders[enc]);
        return this.decoders[enc];
      };
      Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
      };
      Entity.prototype._getEncoder = function _getEncoder(enc) {
        enc = enc || "der";
        if (!this.encoders.hasOwnProperty(enc))
          this.encoders[enc] = this._createNamed(encoders[enc]);
        return this.encoders[enc];
      };
      Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
      };
    }, { "./decoders": 179, "./encoders": 182, "inherits": 440 }], 172: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Reporter = require2("../base/reporter").Reporter;
      var Buffer2 = require2("safer-buffer").Buffer;
      function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer2.isBuffer(base)) {
          this.error("Input not Buffer");
          return;
        }
        this.base = base;
        this.offset = 0;
        this.length = base.length;
      }
      inherits(DecoderBuffer, Reporter);
      exports2.DecoderBuffer = DecoderBuffer;
      DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
        if (data instanceof DecoderBuffer) {
          return true;
        }
        var isCompatible = typeof data === "object" && Buffer2.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
        return isCompatible;
      };
      DecoderBuffer.prototype.save = function save() {
        return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
      };
      DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;
        this.offset = save.offset;
        Reporter.prototype.restore.call(this, save.reporter);
        return res;
      };
      DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
      };
      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length)
          return this.base.readUInt8(this.offset++, true);
        else
          return this.error(fail || "DecoderBuffer overrun");
      };
      DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length))
          return this.error(fail || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
      };
      DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
      };
      function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
          this.length = 0;
          this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item))
              item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
          }, this);
        } else if (typeof value === "number") {
          if (!(0 <= value && value <= 255))
            return reporter.error("non-byte EncoderBuffer value");
          this.value = value;
          this.length = 1;
        } else if (typeof value === "string") {
          this.value = value;
          this.length = Buffer2.byteLength(value);
        } else if (Buffer2.isBuffer(value)) {
          this.value = value;
          this.length = value.length;
        } else {
          return reporter.error("Unsupported type: " + typeof value);
        }
      }
      exports2.EncoderBuffer = EncoderBuffer;
      EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
        if (data instanceof EncoderBuffer) {
          return true;
        }
        var isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
        return isCompatible;
      };
      EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
          out = Buffer2.alloc(this.length);
        if (!offset)
          offset = 0;
        if (this.length === 0)
          return out;
        if (Array.isArray(this.value)) {
          this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
          });
        } else {
          if (typeof this.value === "number")
            out[offset] = this.value;
          else if (typeof this.value === "string")
            out.write(this.value, offset);
          else if (Buffer2.isBuffer(this.value))
            this.value.copy(out, offset);
          offset += this.length;
        }
        return out;
      };
    }, { "../base/reporter": 175, "inherits": 440, "safer-buffer": 495 }], 173: [function(require2, module2, exports2) {
      var base = exports2;
      base.Reporter = require2("./reporter").Reporter;
      base.DecoderBuffer = require2("./buffer").DecoderBuffer;
      base.EncoderBuffer = require2("./buffer").EncoderBuffer;
      base.Node = require2("./node");
    }, { "./buffer": 172, "./node": 174, "./reporter": 175 }], 174: [function(require2, module2, exports2) {
      var Reporter = require2("../base/reporter").Reporter;
      var EncoderBuffer = require2("../base/buffer").EncoderBuffer;
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var assert = require2("minimalistic-assert");
      var tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"];
      var methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags);
      var overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
      function Node(enc, parent, name) {
        var state = {};
        this._baseState = state;
        state.name = name;
        state.enc = enc;
        state.parent = parent || null;
        state.children = null;
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state["default"] = null;
        state.explicit = null;
        state.implicit = null;
        state.contains = null;
        if (!state.parent) {
          state.children = [];
          this._wrap();
        }
      }
      module2.exports = Node;
      var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      Node.prototype.clone = function clone2() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
          cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
      };
      Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
          this[method] = function _wrappedMethod() {
            var clone2 = new this.constructor(this);
            state.children.push(clone2);
            return clone2[method].apply(clone2, arguments);
          };
        }, this);
      };
      Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null);
        body.call(this);
        state.children = state.children.filter(function(child) {
          return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, "Root node can have only one child");
      };
      Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;
        var children = args.filter(function(arg) {
          return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
          return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
          assert(state.children === null);
          state.children = children;
          children.forEach(function(child) {
            child._baseState.parent = this;
          }, this);
        }
        if (args.length !== 0) {
          assert(state.args === null);
          state.args = args;
          state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object)
              return arg;
            var res = {};
            Object.keys(arg).forEach(function(key) {
              if (key == (key | 0))
                key |= 0;
              var value = arg[key];
              res[value] = key;
            });
            return res;
          });
        }
      };
      overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
          var state = this._baseState;
          throw new Error(method + " not implemented for encoding: " + state.enc);
        };
      });
      tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
          var state = this._baseState;
          var args = Array.prototype.slice.call(arguments);
          assert(state.tag === null);
          state.tag = tag;
          this._useArgs(args);
          return this;
        };
      });
      Node.prototype.use = function use(item) {
        assert(item);
        var state = this._baseState;
        assert(state.use === null);
        state.use = item;
        return this;
      };
      Node.prototype.optional = function optional() {
        var state = this._baseState;
        state.optional = true;
        return this;
      };
      Node.prototype.def = function def(val) {
        var state = this._baseState;
        assert(state["default"] === null);
        state["default"] = val;
        state.optional = true;
        return this;
      };
      Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;
        return this;
      };
      Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;
        return this;
      };
      Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        state.obj = true;
        if (args.length !== 0)
          this._useArgs(args);
        return this;
      };
      Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        assert(state.key === null);
        state.key = newKey;
        return this;
      };
      Node.prototype.any = function any() {
        var state = this._baseState;
        state.any = true;
        return this;
      };
      Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
          return obj[key];
        }));
        return this;
      };
      Node.prototype.contains = function contains(item) {
        var state = this._baseState;
        assert(state.use === null);
        state.contains = item;
        return this;
      };
      Node.prototype._decode = function decode(input, options) {
        var state = this._baseState;
        if (state.parent === null)
          return input.wrapResult(state.children[0]._decode(input, options));
        var result = state["default"];
        var present = true;
        var prevKey = null;
        if (state.key !== null)
          prevKey = input.enterKey(state.key);
        if (state.optional) {
          var tag = null;
          if (state.explicit !== null)
            tag = state.explicit;
          else if (state.implicit !== null)
            tag = state.implicit;
          else if (state.tag !== null)
            tag = state.tag;
          if (tag === null && !state.any) {
            var save = input.save();
            try {
              if (state.choice === null)
                this._decodeGeneric(state.tag, input, options);
              else
                this._decodeChoice(input, options);
              present = true;
            } catch (e) {
              present = false;
            }
            input.restore(save);
          } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present))
              return present;
          }
        }
        var prevObj;
        if (state.obj && present)
          prevObj = input.enterObject();
        if (present) {
          if (state.explicit !== null) {
            var explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit))
              return explicit;
            input = explicit;
          }
          var start = input.offset;
          if (state.use === null && state.choice === null) {
            var _save;
            if (state.any)
              _save = input.save();
            var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body))
              return body;
            if (state.any)
              result = input.raw(_save);
            else
              input = body;
          }
          if (options && options.track && state.tag !== null)
            options.track(input.path(), start, input.length, "tagged");
          if (options && options.track && state.tag !== null)
            options.track(input.path(), input.offset, input.length, "content");
          if (state.any)
            ;
          else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
          } else {
            result = this._decodeChoice(input, options);
          }
          if (input.isError(result))
            return result;
          if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
              child._decode(input, options);
            });
          }
          if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            var data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
          }
        }
        if (state.obj && present)
          result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true))
          input.leaveKey(prevKey, state.key, result);
        else if (prevKey !== null)
          input.exitKey(prevKey);
        return result;
      };
      Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
        var state = this._baseState;
        if (tag === "seq" || tag === "set")
          return null;
        if (tag === "seqof" || tag === "setof")
          return this._decodeList(input, tag, state.args[0], options);
        else if (/str$/.test(tag))
          return this._decodeStr(input, tag, options);
        else if (tag === "objid" && state.args)
          return this._decodeObjid(input, state.args[0], state.args[1], options);
        else if (tag === "objid")
          return this._decodeObjid(input, null, null, options);
        else if (tag === "gentime" || tag === "utctime")
          return this._decodeTime(input, tag, options);
        else if (tag === "null_")
          return this._decodeNull(input, options);
        else if (tag === "bool")
          return this._decodeBool(input, options);
        else if (tag === "objDesc")
          return this._decodeStr(input, tag, options);
        else if (tag === "int" || tag === "enum")
          return this._decodeInt(input, state.args && state.args[0], options);
        if (state.use !== null) {
          return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
        } else {
          return input.error("unknown tag: " + tag);
        }
      };
      Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
          state.useDecoder = state.useDecoder.clone();
          state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
      };
      Node.prototype._decodeChoice = function decodeChoice(input, options) {
        var state = this._baseState;
        var result = null;
        var match = false;
        Object.keys(state.choice).some(function(key) {
          var save = input.save();
          var node = state.choice[key];
          try {
            var value = node._decode(input, options);
            if (input.isError(value))
              return false;
            result = { type: key, value };
            match = true;
          } catch (e) {
            input.restore(save);
            return false;
          }
          return true;
        }, this);
        if (!match)
          return input.error("Choice not matched");
        return result;
      };
      Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
      };
      Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state["default"] !== null && state["default"] === data)
          return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === void 0)
          return;
        if (this._skipDefault(result, reporter, parent))
          return;
        return result;
      };
      Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null)
          return state.children[0]._encode(data, reporter || new Reporter());
        var result = null;
        this.reporter = reporter;
        if (state.optional && data === void 0) {
          if (state["default"] !== null)
            data = state["default"];
          else
            return;
        }
        var content = null;
        var primitive = false;
        if (state.any) {
          result = this._createEncoderBuffer(data);
        } else if (state.choice) {
          result = this._encodeChoice(data, reporter);
        } else if (state.contains) {
          content = this._getUse(state.contains, parent)._encode(data, reporter);
          primitive = true;
        } else if (state.children) {
          content = state.children.map(function(child2) {
            if (child2._baseState.tag === "null_")
              return child2._encode(null, reporter, data);
            if (child2._baseState.key === null)
              return reporter.error("Child should have a key");
            var prevKey = reporter.enterKey(child2._baseState.key);
            if (typeof data !== "object")
              return reporter.error("Child expected, but input is not object");
            var res = child2._encode(data[child2._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
          }, this).filter(function(child2) {
            return child2;
          });
          content = this._createEncoderBuffer(content);
        } else {
          if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1))
              return reporter.error("Too many args for : " + state.tag);
            if (!Array.isArray(data))
              return reporter.error("seqof/setof, but data is not Array");
            var child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
              var state2 = this._baseState;
              return this._getUse(state2.args[0], data)._encode(item, reporter);
            }, child));
          } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
          } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
          }
        }
        if (!state.any && state.choice === null) {
          var tag = state.implicit !== null ? state.implicit : state.tag;
          var cls = state.implicit === null ? "universal" : "context";
          if (tag === null) {
            if (state.use === null)
              reporter.error("Tag could be omitted only for .use()");
          } else {
            if (state.use === null)
              result = this._encodeComposite(tag, primitive, cls, content);
          }
        }
        if (state.explicit !== null)
          result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
      };
      Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;
        var node = state.choice[data.type];
        if (!node) {
          assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
      };
      Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;
        if (/str$/.test(tag))
          return this._encodeStr(data, tag);
        else if (tag === "objid" && state.args)
          return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
        else if (tag === "objid")
          return this._encodeObjid(data, null, null);
        else if (tag === "gentime" || tag === "utctime")
          return this._encodeTime(data, tag);
        else if (tag === "null_")
          return this._encodeNull();
        else if (tag === "int" || tag === "enum")
          return this._encodeInt(data, state.args && state.reverseArgs[0]);
        else if (tag === "bool")
          return this._encodeBool(data);
        else if (tag === "objDesc")
          return this._encodeStr(data, tag);
        else
          throw new Error("Unsupported tag: " + tag);
      };
      Node.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
      };
      Node.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
      };
    }, { "../base/buffer": 172, "../base/reporter": 175, "minimalistic-assert": 453 }], 175: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      function Reporter(options) {
        this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
      }
      exports2.Reporter = Reporter;
      Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
      };
      Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return { obj: state.obj, pathLen: state.path.length };
      };
      Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj;
        state.path = state.path.slice(0, data.pathLen);
      };
      Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
      };
      Reporter.prototype.exitKey = function exitKey(index2) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index2 - 1);
      };
      Reporter.prototype.leaveKey = function leaveKey(index2, key, value) {
        var state = this._reporterState;
        this.exitKey(index2);
        if (state.obj !== null)
          state.obj[key] = value;
      };
      Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
      };
      Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;
        var prev = state.obj;
        state.obj = {};
        return prev;
      };
      Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;
        var now = state.obj;
        state.obj = prev;
        return now;
      };
      Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;
        var inherited = msg instanceof ReporterError;
        if (inherited) {
          err = msg;
        } else {
          err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""), msg.message || msg, msg.stack);
        }
        if (!state.options.partial)
          throw err;
        if (!inherited)
          state.errors.push(err);
        return err;
      };
      Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial)
          return result;
        return { result: this.isError(result) ? null : result, errors: state.errors };
      };
      function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
      }
      inherits(ReporterError, Error);
      ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ReporterError);
        if (!this.stack) {
          try {
            throw new Error(this.message);
          } catch (e) {
            this.stack = e.stack;
          }
        }
        return this;
      };
    }, { "inherits": 440 }], 176: [function(require2, module2, exports2) {
      function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      }
      exports2.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
      exports2.tagClassByName = reverse(exports2.tagClass);
      exports2.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
      exports2.tagByName = reverse(exports2.tag);
    }, {}], 177: [function(require2, module2, exports2) {
      var constants = exports2;
      constants._reverse = function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      };
      constants.der = require2("./der");
    }, { "./der": 176 }], 178: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var bignum = require2("bn.js");
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DERDecoder;
      DERDecoder.prototype.decode = function decode(data, options) {
        if (!DecoderBuffer.isDecoderBuffer(data)) {
          data = new DecoderBuffer(data, options);
        }
        return this.tree._decode(data, options);
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
        if (buffer.isEmpty())
          return false;
        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        buffer.restore(state);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
      };
      DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer.isError(len))
          return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
          return buffer.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null)
          return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
        var state = buffer.save();
        var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res))
          return res;
        len = buffer.offset - state.offset;
        buffer.restore(state);
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      };
      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        for (; ; ) {
          var tag = derDecodeTag(buffer, fail);
          if (buffer.isError(tag))
            return tag;
          var len = derDecodeLen(buffer, tag.primitive, fail);
          if (buffer.isError(len))
            return len;
          var res = void 0;
          if (tag.primitive || len !== null)
            res = buffer.skip(len);
          else
            res = this._skipUntilEnd(buffer, fail);
          if (buffer.isError(res))
            return res;
          if (tag.tagStr === "end")
            break;
        }
      };
      DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
        var result = [];
        while (!buffer.isEmpty()) {
          var possibleEnd = this._peekTag(buffer, "end");
          if (buffer.isError(possibleEnd))
            return possibleEnd;
          var res = decoder.decode(buffer, "der", options);
          if (buffer.isError(res) && possibleEnd)
            break;
          result.push(res);
        }
        return result;
      };
      DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === "bitstr") {
          var unused = buffer.readUInt8();
          if (buffer.isError(unused))
            return unused;
          return { unused, data: buffer.raw() };
        } else if (tag === "bmpstr") {
          var raw = buffer.raw();
          if (raw.length % 2 === 1)
            return buffer.error("Decoding of string type: bmpstr length mismatch");
          var str = "";
          for (var i = 0; i < raw.length / 2; i++) {
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
          }
          return str;
        } else if (tag === "numstr") {
          var numstr = buffer.raw().toString("ascii");
          if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: numstr unsupported characters");
          }
          return numstr;
        } else if (tag === "octstr") {
          return buffer.raw();
        } else if (tag === "objDesc") {
          return buffer.raw();
        } else if (tag === "printstr") {
          var printstr = buffer.raw().toString("ascii");
          if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: printstr unsupported characters");
          }
          return printstr;
        } else if (/str$/.test(tag)) {
          return buffer.raw().toString();
        } else {
          return buffer.error("Decoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var result;
        var identifiers = [];
        var ident = 0;
        var subident = 0;
        while (!buffer.isEmpty()) {
          subident = buffer.readUInt8();
          ident <<= 7;
          ident |= subident & 127;
          if ((subident & 128) === 0) {
            identifiers.push(ident);
            ident = 0;
          }
        }
        if (subident & 128)
          identifiers.push(ident);
        var first = identifiers[0] / 40 | 0;
        var second = identifiers[0] % 40;
        if (relative)
          result = identifiers;
        else
          result = [first, second].concat(identifiers.slice(1));
        if (values) {
          var tmp = values[result.join(" ")];
          if (tmp === void 0)
            tmp = values[result.join(".")];
          if (tmp !== void 0)
            result = tmp;
        }
        return result;
      };
      DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        var year;
        var mon;
        var day;
        var hour;
        var min;
        var sec;
        if (tag === "gentime") {
          year = str.slice(0, 4) | 0;
          mon = str.slice(4, 6) | 0;
          day = str.slice(6, 8) | 0;
          hour = str.slice(8, 10) | 0;
          min = str.slice(10, 12) | 0;
          sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
          year = str.slice(0, 2) | 0;
          mon = str.slice(2, 4) | 0;
          day = str.slice(4, 6) | 0;
          hour = str.slice(6, 8) | 0;
          min = str.slice(8, 10) | 0;
          sec = str.slice(10, 12) | 0;
          if (year < 70)
            year = 2e3 + year;
          else
            year = 1900 + year;
        } else {
          return buffer.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
      };
      DERNode.prototype._decodeNull = function decodeNull() {
        return null;
      };
      DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res))
          return res;
        else
          return res !== 0;
      };
      DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var raw = buffer.raw();
        var res = new bignum(raw);
        if (values)
          res = values[res.toString(10)] || res;
        return res;
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getDecoder("der").tree;
      };
      function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag))
          return tag;
        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
          var oct = tag;
          tag = 0;
          while ((oct & 128) === 128) {
            oct = buf.readUInt8(fail);
            if (buf.isError(oct))
              return oct;
            tag <<= 7;
            tag |= oct & 127;
          }
        } else {
          tag &= 31;
        }
        var tagStr = der.tag[tag];
        return { cls, primitive, tag, tagStr };
      }
      function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len))
          return len;
        if (!primitive && len === 128)
          return null;
        if ((len & 128) === 0) {
          return len;
        }
        var num = len & 127;
        if (num > 4)
          return buf.error("length octect is too long");
        len = 0;
        for (var i = 0; i < num; i++) {
          len <<= 8;
          var j = buf.readUInt8(fail);
          if (buf.isError(j))
            return j;
          len |= j;
        }
        return len;
      }
    }, { "../base/buffer": 172, "../base/node": 174, "../constants/der": 176, "bn.js": 184, "inherits": 440 }], 179: [function(require2, module2, exports2) {
      var decoders = exports2;
      decoders.der = require2("./der");
      decoders.pem = require2("./pem");
    }, { "./der": 178, "./pem": 180 }], 180: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer2 = require2("safer-buffer").Buffer;
      var DERDecoder = require2("./der");
      function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMDecoder, DERDecoder);
      module2.exports = PEMDecoder;
      PEMDecoder.prototype.decode = function decode(data, options) {
        var lines = data.toString().split(/[\r\n]+/g);
        var label = options.label.toUpperCase();
        var re = /^-----(BEGIN|END) ([^-]+)-----$/;
        var start = -1;
        var end = -1;
        for (var i = 0; i < lines.length; i++) {
          var match = lines[i].match(re);
          if (match === null)
            continue;
          if (match[2] !== label)
            continue;
          if (start === -1) {
            if (match[1] !== "BEGIN")
              break;
            start = i;
          } else {
            if (match[1] !== "END")
              break;
            end = i;
            break;
          }
        }
        if (start === -1 || end === -1)
          throw new Error("PEM section not found for: " + label);
        var base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9+/=]+/gi, "");
        var input = Buffer2.from(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
      };
    }, { "./der": 178, "inherits": 440, "safer-buffer": 495 }], 181: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer2 = require2("safer-buffer").Buffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DEREncoder;
      DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
          var _header = Buffer2.alloc(2);
          _header[0] = encodedTag;
          _header[1] = content.length;
          return this._createEncoderBuffer([_header, content]);
        }
        var lenOctets = 1;
        for (var i = content.length; i >= 256; i >>= 8)
          lenOctets++;
        var header = Buffer2.alloc(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (var _i7 = 1 + lenOctets, j = content.length; j > 0; _i7--, j >>= 8)
          header[_i7] = j & 255;
        return this._createEncoderBuffer([header, content]);
      };
      DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "bitstr") {
          return this._createEncoderBuffer([str.unused | 0, str.data]);
        } else if (tag === "bmpstr") {
          var buf = Buffer2.alloc(str.length * 2);
          for (var i = 0; i < str.length; i++) {
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
          }
          return this._createEncoderBuffer(buf);
        } else if (tag === "numstr") {
          if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports only digits and space");
          }
          return this._createEncoderBuffer(str);
        } else if (tag === "printstr") {
          if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
          }
          return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag)) {
          return this._createEncoderBuffer(str);
        } else if (tag === "objDesc") {
          return this._createEncoderBuffer(str);
        } else {
          return this.reporter.error("Encoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
          if (!values)
            return this.reporter.error("string objid given, but no values map found");
          if (!values.hasOwnProperty(id))
            return this.reporter.error("objid not found in values map");
          id = values[id].split(/[\s.]+/g);
          for (var i = 0; i < id.length; i++)
            id[i] |= 0;
        } else if (Array.isArray(id)) {
          id = id.slice();
          for (var _i8 = 0; _i8 < id.length; _i8++)
            id[_i8] |= 0;
        }
        if (!Array.isArray(id)) {
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
        }
        if (!relative) {
          if (id[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          id.splice(0, 2, id[0] * 40 + id[1]);
        }
        var size = 0;
        for (var _i9 = 0; _i9 < id.length; _i9++) {
          var ident = id[_i9];
          for (size++; ident >= 128; ident >>= 7)
            size++;
        }
        var objid = Buffer2.alloc(size);
        var offset = objid.length - 1;
        for (var _i10 = id.length - 1; _i10 >= 0; _i10--) {
          var _ident = id[_i10];
          objid[offset--] = _ident & 127;
          while ((_ident >>= 7) > 0)
            objid[offset--] = 128 | _ident & 127;
        }
        return this._createEncoderBuffer(objid);
      };
      function two(num) {
        if (num < 10)
          return "0" + num;
        else
          return num;
      }
      DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);
        if (tag === "gentime") {
          str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else if (tag === "utctime") {
          str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else {
          this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
      };
      DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
      };
      DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
          if (!values)
            return this.reporter.error("String int or enum given, but no values map");
          if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
          }
          num = values[num];
        }
        if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
          var numArray = num.toArray();
          if (!num.sign && numArray[0] & 128) {
            numArray.unshift(0);
          }
          num = Buffer2.from(numArray);
        }
        if (Buffer2.isBuffer(num)) {
          var _size = num.length;
          if (num.length === 0)
            _size++;
          var _out = Buffer2.alloc(_size);
          num.copy(_out);
          if (num.length === 0)
            _out[0] = 0;
          return this._createEncoderBuffer(_out);
        }
        if (num < 128)
          return this._createEncoderBuffer(num);
        if (num < 256)
          return this._createEncoderBuffer([0, num]);
        var size = 1;
        for (var i = num; i >= 256; i >>= 8)
          size++;
        var out = new Array(size);
        for (var _i11 = out.length - 1; _i11 >= 0; _i11--) {
          out[_i11] = num & 255;
          num >>= 8;
        }
        if (out[0] & 128) {
          out.unshift(0);
        }
        return this._createEncoderBuffer(Buffer2.from(out));
      };
      DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getEncoder("der").tree;
      };
      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state["default"] === null)
          return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === void 0)
          state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
        if (data.length !== state.defaultBuffer.length)
          return false;
        for (i = 0; i < data.length; i++)
          if (data[i] !== state.defaultBuffer[i])
            return false;
        return true;
      };
      function encodeTag(tag, primitive, cls, reporter) {
        var res;
        if (tag === "seqof")
          tag = "seq";
        else if (tag === "setof")
          tag = "set";
        if (der.tagByName.hasOwnProperty(tag))
          res = der.tagByName[tag];
        else if (typeof tag === "number" && (tag | 0) === tag)
          res = tag;
        else
          return reporter.error("Unknown tag: " + tag);
        if (res >= 31)
          return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive)
          res |= 32;
        res |= der.tagClassByName[cls || "universal"] << 6;
        return res;
      }
    }, { "../base/node": 174, "../constants/der": 176, "inherits": 440, "safer-buffer": 495 }], 182: [function(require2, module2, exports2) {
      var encoders = exports2;
      encoders.der = require2("./der");
      encoders.pem = require2("./pem");
    }, { "./der": 181, "./pem": 183 }], 183: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var DEREncoder = require2("./der");
      function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMEncoder, DEREncoder);
      module2.exports = PEMEncoder;
      PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data);
        var p = buf.toString("base64");
        var out = ["-----BEGIN " + options.label + "-----"];
        for (var i = 0; i < p.length; i += 64)
          out.push(p.slice(i, i + 64));
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
      };
    }, { "./der": 181, "inherits": 440 }], 184: [function(require2, module2, exports2) {
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone2() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry2 = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry2) & 16777215).toString(16);
              carry2 = w >>> 24 - off & 16777215;
              if (carry2 !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry2 !== 0) {
              out = carry2.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t2 = w;
            var r = 0;
            if (t2 >= 4096) {
              r += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r += 2;
              t2 >>>= 2;
            }
            return r + t2;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t2 = w;
          var r = 0;
          if ((t2 & 8191) === 0) {
            r += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width2) {
          if (this.negative !== 0) {
            return this.abs().inotn(width2).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width2) {
          if (this.testn(width2 - 1)) {
            return this.notn(width2).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width2) {
          assert(typeof width2 === "number" && width2 >= 0);
          var bytesNeeded = Math.ceil(width2 / 26) | 0;
          var bitsLeft = width2 % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width2) {
          return this.clone().inotn(width2);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry2 = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry2;
            this.words[i] = r & 67108863;
            carry2 = r >>> 26;
          }
          for (; carry2 !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry2;
            this.words[i] = r & 67108863;
            carry2 = r >>> 26;
          }
          this.length = a.length;
          if (carry2 !== 0) {
            this.words[this.length] = carry2;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry2 = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry2;
            carry2 = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry2 !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry2;
            carry2 = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry2 === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry2 = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry2 >>> 26;
            var rword = carry2 & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry2 = ncarry | 0;
          }
          if (carry2 !== 0) {
            out.words[k] = carry2 | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry2 = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry2 & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry2 = ncarry;
            ncarry = hncarry;
          }
          if (carry2 !== 0) {
            out.words[k] = carry2;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t2 = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t2[i] = this.revBin(i, l, N);
          }
          return t2;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t2 = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t2;
            t2 = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t2;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry2 = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry2;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry2 = 0;
            } else {
              carry2 = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry2 = 0;
          for (var i = 0; i < len; i++) {
            carry2 = carry2 + (ws[i] | 0);
            rws[2 * i] = carry2 & 8191;
            carry2 = carry2 >>> 13;
            rws[2 * i + 1] = carry2 & 8191;
            carry2 = carry2 >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry2 === 0);
          assert((carry2 & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry2 = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry2 & 67108863);
            carry2 >>= 26;
            carry2 += w / 67108864 | 0;
            carry2 += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry2 !== 0) {
            this.words[i] = carry2;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry2 = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry2;
              carry2 = newCarry >>> 26 - r;
            }
            if (carry2) {
              this.words[i] = carry2;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h3 -= s;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry2 = 0;
          for (i = this.length - 1; i >= 0 && (carry2 !== 0 || i >= h3); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry2 << 26 - r | word >>> r;
            carry2 = word & mask;
          }
          if (maskedWords && carry2 !== 0) {
            maskedWords.words[maskedWords.length++] = carry2;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry2 = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry2;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry2 = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry2;
            carry2 = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry2 === 0)
            return this.strip();
          assert(carry2 === -1);
          carry2 = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry2;
            carry2 = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return { div: q || null, mod: a };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return { div: new BN(0), mod: new BN(0) };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return { div: new BN(0), mod: this };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return { div: this.divn(num.words[0]), mod: null };
            }
            if (mode === "mod") {
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            }
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry2 = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry2 * 67108864;
            this.words[i] = w / num | 0;
            carry2 = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t2 = a;
              a = b;
              b = t2;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry2 = q;
          for (var i = s; carry2 !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry2;
            carry2 = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry2 !== 0) {
            this.words[i] = carry2;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry2 = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry2;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry2 = hi;
          }
          if (carry2 !== 0) {
            num.words[num.length++] = carry2;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t2 = this.pow(a, q);
          var m = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t2 = t2.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t2 = a.mul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 188 }], 185: [function(require2, module2, exports2) {
      exports2.byteLength = byteLength;
      exports2.toByteArray = toByteArray;
      exports2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }, {}], 186: [function(require2, module2, exports2) {
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index2) {
          var c = string.charCodeAt(index2);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone2() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry2 = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry2) & 16777215).toString(16);
              carry2 = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry2 !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry2 !== 0) {
              out = carry2.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry2 = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry2;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry2 = 0;
              shift = 0;
            } else {
              carry2 = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry2;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry2 = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry2;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry2 = 0;
              shift = 0;
            } else {
              carry2 = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry2;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t2 = w;
            var r = 0;
            if (t2 >= 4096) {
              r += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r += 2;
              t2 >>>= 2;
            }
            return r + t2;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t2 = w;
          var r = 0;
          if ((t2 & 8191) === 0) {
            r += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width2) {
          if (this.negative !== 0) {
            return this.abs().inotn(width2).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width2) {
          if (this.testn(width2 - 1)) {
            return this.notn(width2).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width2) {
          assert(typeof width2 === "number" && width2 >= 0);
          var bytesNeeded = Math.ceil(width2 / 26) | 0;
          var bitsLeft = width2 % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width2) {
          return this.clone().inotn(width2);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry2 = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry2;
            this.words[i] = r & 67108863;
            carry2 = r >>> 26;
          }
          for (; carry2 !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry2;
            this.words[i] = r & 67108863;
            carry2 = r >>> 26;
          }
          this.length = a.length;
          if (carry2 !== 0) {
            this.words[this.length] = carry2;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry2 = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry2;
            carry2 = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry2 !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry2;
            carry2 = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry2 === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry2 = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry2 >>> 26;
            var rword = carry2 & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry2 = ncarry | 0;
          }
          if (carry2 !== 0) {
            out.words[k] = carry2 | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry2 = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry2 & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry2 = ncarry;
            ncarry = hncarry;
          }
          if (carry2 !== 0) {
            out.words[k] = carry2;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry2 = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry2 & 67108863);
            carry2 >>= 26;
            carry2 += w / 67108864 | 0;
            carry2 += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry2 !== 0) {
            this.words[i] = carry2;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry2 = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry2;
              carry2 = newCarry >>> 26 - r;
            }
            if (carry2) {
              this.words[i] = carry2;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h3 -= s;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry2 = 0;
          for (i = this.length - 1; i >= 0 && (carry2 !== 0 || i >= h3); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry2 << 26 - r | word >>> r;
            carry2 = word & mask;
          }
          if (maskedWords && carry2 !== 0) {
            maskedWords.words[maskedWords.length++] = carry2;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry2 = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry2;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry2 = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry2;
            carry2 = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry2 === 0)
            return this._strip();
          assert(carry2 === -1);
          carry2 = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry2;
            carry2 = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return { div: q || null, mod: a };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return { div: new BN(0), mod: new BN(0) };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return { div: new BN(0), mod: this };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return { div: this.divn(num.words[0]), mod: null };
            }
            if (mode === "mod") {
              return { div: null, mod: new BN(this.modrn(num.words[0])) };
            }
            return { div: this.divn(num.words[0]), mod: new BN(this.modrn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry2 = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry2 * 67108864;
            this.words[i] = w / num | 0;
            carry2 = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t2 = a;
              a = b;
              b = t2;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry2 = q;
          for (var i = s; carry2 !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry2;
            carry2 = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry2 !== 0) {
            this.words[i] = carry2;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry2 = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry2;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry2 = hi;
          }
          if (carry2 !== 0) {
            num.words[num.length++] = carry2;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t2 = this.pow(a, q);
          var m = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t2 = t2.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t2 = a.mul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 188 }], 187: [function(require2, module2, exports2) {
      var r;
      module2.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          var crypto2 = require2("crypto");
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
    }, { "crypto": 188 }], 188: [function(require2, module2, exports2) {
    }, {}], 189: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      function asUInt32Array(buf) {
        if (!Buffer2.isBuffer(buf))
          buf = Buffer2.from(buf);
        var len = buf.length / 4 | 0;
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
          out[i] = buf.readUInt32BE(i * 4);
        }
        return out;
      }
      function scrubVec(v) {
        for (var i = 0; i < v.length; v++) {
          v[i] = 0;
        }
      }
      function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
        var SUB_MIX0 = SUB_MIX[0];
        var SUB_MIX1 = SUB_MIX[1];
        var SUB_MIX2 = SUB_MIX[2];
        var SUB_MIX3 = SUB_MIX[3];
        var s0 = M[0] ^ keySchedule[0];
        var s1 = M[1] ^ keySchedule[1];
        var s2 = M[2] ^ keySchedule[2];
        var s3 = M[3] ^ keySchedule[3];
        var t0, t1, t2, t3;
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
          t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
          t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
          t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
          t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        t0 = t0 >>> 0;
        t1 = t1 >>> 0;
        t2 = t2 >>> 0;
        t3 = t3 >>> 0;
        return [t0, t1, t2, t3];
      }
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var G = function() {
        var d = new Array(256);
        for (var j = 0; j < 256; j++) {
          if (j < 128) {
            d[j] = j << 1;
          } else {
            d[j] = j << 1 ^ 283;
          }
        }
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX = [[], [], [], []];
        var INV_SUB_MIX = [[], [], [], []];
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; ++i) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t2 = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX[0][x] = t2 << 24 | t2 >>> 8;
          SUB_MIX[1][x] = t2 << 16 | t2 >>> 16;
          SUB_MIX[2][x] = t2 << 8 | t2 >>> 24;
          SUB_MIX[3][x] = t2;
          t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX[0][sx] = t2 << 24 | t2 >>> 8;
          INV_SUB_MIX[1][sx] = t2 << 16 | t2 >>> 16;
          INV_SUB_MIX[2][sx] = t2 << 8 | t2 >>> 24;
          INV_SUB_MIX[3][sx] = t2;
          if (x === 0) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
        return { SBOX, INV_SBOX, SUB_MIX, INV_SUB_MIX };
      }();
      function AES(key) {
        this._key = asUInt32Array(key);
        this._reset();
      }
      AES.blockSize = 4 * 4;
      AES.keySize = 256 / 8;
      AES.prototype.blockSize = AES.blockSize;
      AES.prototype.keySize = AES.keySize;
      AES.prototype._reset = function() {
        var keyWords = this._key;
        var keySize = keyWords.length;
        var nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = [];
        for (var k = 0; k < keySize; k++) {
          keySchedule[k] = keyWords[k];
        }
        for (k = keySize; k < ksRows; k++) {
          var t2 = keySchedule[k - 1];
          if (k % keySize === 0) {
            t2 = t2 << 8 | t2 >>> 24;
            t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
            t2 ^= RCON[k / keySize | 0] << 24;
          } else if (keySize > 6 && k % keySize === 4) {
            t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
          }
          keySchedule[k] = keySchedule[k - keySize] ^ t2;
        }
        var invKeySchedule = [];
        for (var ik = 0; ik < ksRows; ik++) {
          var ksR = ksRows - ik;
          var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
          if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
          } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
          }
        }
        this._nRounds = nRounds;
        this._keySchedule = keySchedule;
        this._invKeySchedule = invKeySchedule;
      };
      AES.prototype.encryptBlockRaw = function(M) {
        M = asUInt32Array(M);
        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
      };
      AES.prototype.encryptBlock = function(M) {
        var out = this.encryptBlockRaw(M);
        var buf = Buffer2.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[1], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[3], 12);
        return buf;
      };
      AES.prototype.decryptBlock = function(M) {
        M = asUInt32Array(M);
        var m1 = M[1];
        M[1] = M[3];
        M[3] = m1;
        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
        var buf = Buffer2.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[3], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[1], 12);
        return buf;
      };
      AES.prototype.scrub = function() {
        scrubVec(this._keySchedule);
        scrubVec(this._invKeySchedule);
        scrubVec(this._key);
      };
      module2.exports.AES = AES;
    }, { "safe-buffer": 494 }], 190: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer2 = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      var GHASH = require2("./ghash");
      var xor = require2("buffer-xor");
      var incr32 = require2("./incr32");
      function xorTest(a, b) {
        var out = 0;
        if (a.length !== b.length)
          out++;
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; ++i) {
          out += a[i] ^ b[i];
        }
        return out;
      }
      function calcIv(self2, iv, ck) {
        if (iv.length === 12) {
          self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]);
          return Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);
        }
        var ghash = new GHASH(ck);
        var len = iv.length;
        var toPad = len % 16;
        ghash.update(iv);
        if (toPad) {
          toPad = 16 - toPad;
          ghash.update(Buffer2.alloc(toPad, 0));
        }
        ghash.update(Buffer2.alloc(8, 0));
        var ivBits = len * 8;
        var tail = Buffer2.alloc(8);
        tail.writeUIntBE(ivBits, 0, 8);
        ghash.update(tail);
        self2._finID = ghash.state;
        var out = Buffer2.from(self2._finID);
        incr32(out);
        return out;
      }
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        var h3 = Buffer2.alloc(4, 0);
        this._cipher = new aes.AES(key);
        var ck = this._cipher.encryptBlock(h3);
        this._ghash = new GHASH(ck);
        iv = calcIv(this, iv, ck);
        this._prev = Buffer2.from(iv);
        this._cache = Buffer2.allocUnsafe(0);
        this._secCache = Buffer2.allocUnsafe(0);
        this._decrypt = decrypt;
        this._alen = 0;
        this._len = 0;
        this._mode = mode;
        this._authTag = null;
        this._called = false;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        if (!this._called && this._alen) {
          var rump = 16 - this._alen % 16;
          if (rump < 16) {
            rump = Buffer2.alloc(rump, 0);
            this._ghash.update(rump);
          }
        }
        this._called = true;
        var out = this._mode.encrypt(this, chunk);
        if (this._decrypt) {
          this._ghash.update(chunk);
        } else {
          this._ghash.update(out);
        }
        this._len += chunk.length;
        return out;
      };
      StreamCipher.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && xorTest(tag, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = tag;
        this._cipher.scrub();
      };
      StreamCipher.prototype.getAuthTag = function getAuthTag() {
        if (this._decrypt || !Buffer2.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      };
      StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = tag;
      };
      StreamCipher.prototype.setAAD = function setAAD(buf) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(buf);
        this._alen += buf.length;
      };
      module2.exports = StreamCipher;
    }, { "./aes": 189, "./ghash": 194, "./incr32": 195, "buffer-xor": 219, "cipher-base": 221, "inherits": 440, "safe-buffer": 494 }], 191: [function(require2, module2, exports2) {
      var ciphers = require2("./encrypter");
      var deciphers = require2("./decrypter");
      var modes = require2("./modes/list.json");
      function getCiphers() {
        return Object.keys(modes);
      }
      exports2.createCipher = exports2.Cipher = ciphers.createCipher;
      exports2.createCipheriv = exports2.Cipheriv = ciphers.createCipheriv;
      exports2.createDecipher = exports2.Decipher = deciphers.createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = deciphers.createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "./decrypter": 192, "./encrypter": 193, "./modes/list.json": 203 }], 192: [function(require2, module2, exports2) {
      var AuthCipher = require2("./authCipher");
      var Buffer2 = require2("safe-buffer").Buffer;
      var MODES = require2("./modes");
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Decipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._last = void 0;
        this._cipher = new aes.AES(key);
        this._prev = Buffer2.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Decipher, Transform);
      Decipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get(this._autopadding)) {
          thing = this._mode.decrypt(this, chunk);
          out.push(thing);
        }
        return Buffer2.concat(out);
      };
      Decipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          return unpad(this._mode.decrypt(this, chunk));
        } else if (chunk) {
          throw new Error("data not multiple of block length");
        }
      };
      Decipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer2.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer2.concat([this.cache, data]);
      };
      Splitter.prototype.get = function(autoPadding) {
        var out;
        if (autoPadding) {
          if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        } else {
          if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      };
      function unpad(last) {
        var padded = last[15];
        if (padded < 1 || padded > 16) {
          throw new Error("unable to decrypt data");
        }
        var i = -1;
        while (++i < padded) {
          if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
          }
        }
        if (padded === 16)
          return;
        return last.slice(0, 16 - padded);
      }
      function createDecipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof iv === "string")
          iv = Buffer2.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (typeof password === "string")
          password = Buffer2.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv, true);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv, true);
        }
        return new Decipher(config.module, password, iv);
      }
      function createDecipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys2 = ebtk(password, false, config.key, config.iv);
        return createDecipheriv(suite, keys2.key, keys2.iv);
      }
      exports2.createDecipher = createDecipher;
      exports2.createDecipheriv = createDecipheriv;
    }, { "./aes": 189, "./authCipher": 190, "./modes": 202, "./streamCipher": 205, "cipher-base": 221, "evp_bytestokey": 423, "inherits": 440, "safe-buffer": 494 }], 193: [function(require2, module2, exports2) {
      var MODES = require2("./modes");
      var AuthCipher = require2("./authCipher");
      var Buffer2 = require2("safe-buffer").Buffer;
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Cipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._cipher = new aes.AES(key);
        this._prev = Buffer2.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Cipher, Transform);
      Cipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get()) {
          thing = this._mode.encrypt(this, chunk);
          out.push(thing);
        }
        return Buffer2.concat(out);
      };
      var PADDING = Buffer2.alloc(16, 16);
      Cipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          chunk = this._mode.encrypt(this, chunk);
          this._cipher.scrub();
          return chunk;
        }
        if (!chunk.equals(PADDING)) {
          this._cipher.scrub();
          throw new Error("data not multiple of block length");
        }
      };
      Cipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer2.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer2.concat([this.cache, data]);
      };
      Splitter.prototype.get = function() {
        if (this.cache.length > 15) {
          var out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        var len = 16 - this.cache.length;
        var padBuff = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          padBuff.writeUInt8(len, i);
        }
        return Buffer2.concat([this.cache, padBuff]);
      };
      function createCipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof password === "string")
          password = Buffer2.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (typeof iv === "string")
          iv = Buffer2.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv);
        }
        return new Cipher(config.module, password, iv);
      }
      function createCipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys2 = ebtk(password, false, config.key, config.iv);
        return createCipheriv(suite, keys2.key, keys2.iv);
      }
      exports2.createCipheriv = createCipheriv;
      exports2.createCipher = createCipher;
    }, { "./aes": 189, "./authCipher": 190, "./modes": 202, "./streamCipher": 205, "cipher-base": 221, "evp_bytestokey": 423, "inherits": 440, "safe-buffer": 494 }], 194: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var ZEROES = Buffer2.alloc(16, 0);
      function toArray(buf) {
        return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
      }
      function fromArray(out) {
        var buf = Buffer2.allocUnsafe(16);
        buf.writeUInt32BE(out[0] >>> 0, 0);
        buf.writeUInt32BE(out[1] >>> 0, 4);
        buf.writeUInt32BE(out[2] >>> 0, 8);
        buf.writeUInt32BE(out[3] >>> 0, 12);
        return buf;
      }
      function GHASH(key) {
        this.h = key;
        this.state = Buffer2.alloc(16, 0);
        this.cache = Buffer2.allocUnsafe(0);
      }
      GHASH.prototype.ghash = function(block) {
        var i = -1;
        while (++i < block.length) {
          this.state[i] ^= block[i];
        }
        this._multiply();
      };
      GHASH.prototype._multiply = function() {
        var Vi = toArray(this.h);
        var Zi = [0, 0, 0, 0];
        var j, xi, lsbVi;
        var i = -1;
        while (++i < 128) {
          xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
          if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
          }
          lsbVi = (Vi[3] & 1) !== 0;
          for (j = 3; j > 0; j--) {
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
          }
          Vi[0] = Vi[0] >>> 1;
          if (lsbVi) {
            Vi[0] = Vi[0] ^ 225 << 24;
          }
        }
        this.state = fromArray(Zi);
      };
      GHASH.prototype.update = function(buf) {
        this.cache = Buffer2.concat([this.cache, buf]);
        var chunk;
        while (this.cache.length >= 16) {
          chunk = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          this.ghash(chunk);
        }
      };
      GHASH.prototype.final = function(abl, bl) {
        if (this.cache.length) {
          this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
        }
        this.ghash(fromArray([0, abl, 0, bl]));
        return this.state;
      };
      module2.exports = GHASH;
    }, { "safe-buffer": 494 }], 195: [function(require2, module2, exports2) {
      function incr32(iv) {
        var len = iv.length;
        var item;
        while (len--) {
          item = iv.readUInt8(len);
          if (item === 255) {
            iv.writeUInt8(0, len);
          } else {
            item++;
            iv.writeUInt8(item, len);
            break;
          }
        }
      }
      module2.exports = incr32;
    }, {}], 196: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      exports2.encrypt = function(self2, block) {
        var data = xor(block, self2._prev);
        self2._prev = self2._cipher.encryptBlock(data);
        return self2._prev;
      };
      exports2.decrypt = function(self2, block) {
        var pad = self2._prev;
        self2._prev = block;
        var out = self2._cipher.decryptBlock(block);
        return xor(out, pad);
      };
    }, { "buffer-xor": 219 }], 197: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var xor = require2("buffer-xor");
      function encryptStart(self2, data, decrypt) {
        var len = data.length;
        var out = xor(data, self2._cache);
        self2._cache = self2._cache.slice(len);
        self2._prev = Buffer2.concat([self2._prev, decrypt ? data : out]);
        return out;
      }
      exports2.encrypt = function(self2, data, decrypt) {
        var out = Buffer2.allocUnsafe(0);
        var len;
        while (data.length) {
          if (self2._cache.length === 0) {
            self2._cache = self2._cipher.encryptBlock(self2._prev);
            self2._prev = Buffer2.allocUnsafe(0);
          }
          if (self2._cache.length <= data.length) {
            len = self2._cache.length;
            out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]);
            data = data.slice(len);
          } else {
            out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);
            break;
          }
        }
        return out;
      };
    }, { "buffer-xor": 219, "safe-buffer": 494 }], 198: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad;
        var i = -1;
        var len = 8;
        var out = 0;
        var bit, value;
        while (++i < len) {
          pad = self2._cipher.encryptBlock(self2._prev);
          bit = byteParam & 1 << 7 - i ? 128 : 0;
          value = pad[0] ^ bit;
          out += (value & 128) >> i % 8;
          self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
        }
        return out;
      }
      function shiftIn(buffer, value) {
        var len = buffer.length;
        var i = -1;
        var out = Buffer2.allocUnsafe(buffer.length);
        buffer = Buffer2.concat([buffer, Buffer2.from([value])]);
        while (++i < len) {
          out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
        }
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 494 }], 199: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad = self2._cipher.encryptBlock(self2._prev);
        var out = pad[0] ^ byteParam;
        self2._prev = Buffer2.concat([self2._prev.slice(1), Buffer2.from([decrypt ? byteParam : out])]);
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer2.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 494 }], 200: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      var Buffer2 = require2("safe-buffer").Buffer;
      var incr32 = require2("../incr32");
      function getBlock(self2) {
        var out = self2._cipher.encryptBlockRaw(self2._prev);
        incr32(self2._prev);
        return out;
      }
      var blockSize = 16;
      exports2.encrypt = function(self2, chunk) {
        var chunkNum = Math.ceil(chunk.length / blockSize);
        var start = self2._cache.length;
        self2._cache = Buffer2.concat([self2._cache, Buffer2.allocUnsafe(chunkNum * blockSize)]);
        for (var i = 0; i < chunkNum; i++) {
          var out = getBlock(self2);
          var offset = start + i * blockSize;
          self2._cache.writeUInt32BE(out[0], offset + 0);
          self2._cache.writeUInt32BE(out[1], offset + 4);
          self2._cache.writeUInt32BE(out[2], offset + 8);
          self2._cache.writeUInt32BE(out[3], offset + 12);
        }
        var pad = self2._cache.slice(0, chunk.length);
        self2._cache = self2._cache.slice(chunk.length);
        return xor(chunk, pad);
      };
    }, { "../incr32": 195, "buffer-xor": 219, "safe-buffer": 494 }], 201: [function(require2, module2, exports2) {
      exports2.encrypt = function(self2, block) {
        return self2._cipher.encryptBlock(block);
      };
      exports2.decrypt = function(self2, block) {
        return self2._cipher.decryptBlock(block);
      };
    }, {}], 202: [function(require2, module2, exports2) {
      var modeModules = { ECB: require2("./ecb"), CBC: require2("./cbc"), CFB: require2("./cfb"), CFB8: require2("./cfb8"), CFB1: require2("./cfb1"), OFB: require2("./ofb"), CTR: require2("./ctr"), GCM: require2("./ctr") };
      var modes = require2("./list.json");
      for (var key in modes) {
        modes[key].module = modeModules[modes[key].mode];
      }
      module2.exports = modes;
    }, { "./cbc": 196, "./cfb": 197, "./cfb1": 198, "./cfb8": 199, "./ctr": 200, "./ecb": 201, "./list.json": 203, "./ofb": 204 }], 203: [function(require2, module2, exports2) {
      module2.exports = { "aes-128-ecb": { "cipher": "AES", "key": 128, "iv": 0, "mode": "ECB", "type": "block" }, "aes-192-ecb": { "cipher": "AES", "key": 192, "iv": 0, "mode": "ECB", "type": "block" }, "aes-256-ecb": { "cipher": "AES", "key": 256, "iv": 0, "mode": "ECB", "type": "block" }, "aes-128-cbc": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes-192-cbc": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes-256-cbc": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes128": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes192": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes256": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes-128-cfb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-192-cfb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-256-cfb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-128-cfb8": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-192-cfb8": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-256-cfb8": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-128-cfb1": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-192-cfb1": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-256-cfb1": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-128-ofb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-192-ofb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-256-ofb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-128-ctr": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-192-ctr": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-256-ctr": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-128-gcm": { "cipher": "AES", "key": 128, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-192-gcm": { "cipher": "AES", "key": 192, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-256-gcm": { "cipher": "AES", "key": 256, "iv": 12, "mode": "GCM", "type": "auth" } };
    }, {}], 204: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var xor = require2("buffer-xor");
          function getBlock(self2) {
            self2._prev = self2._cipher.encryptBlock(self2._prev);
            return self2._prev;
          }
          exports2.encrypt = function(self2, chunk) {
            while (self2._cache.length < chunk.length) {
              self2._cache = Buffer2.concat([self2._cache, getBlock(self2)]);
            }
            var pad = self2._cache.slice(0, chunk.length);
            self2._cache = self2._cache.slice(chunk.length);
            return xor(chunk, pad);
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 220, "buffer-xor": 219 }], 205: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer2 = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        this._cipher = new aes.AES(key);
        this._prev = Buffer2.from(iv);
        this._cache = Buffer2.allocUnsafe(0);
        this._secCache = Buffer2.allocUnsafe(0);
        this._decrypt = decrypt;
        this._mode = mode;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        return this._mode.encrypt(this, chunk, this._decrypt);
      };
      StreamCipher.prototype._final = function() {
        this._cipher.scrub();
      };
      module2.exports = StreamCipher;
    }, { "./aes": 189, "cipher-base": 221, "inherits": 440, "safe-buffer": 494 }], 206: [function(require2, module2, exports2) {
      var DES = require2("browserify-des");
      var aes = require2("browserify-aes/browser");
      var aesModes = require2("browserify-aes/modes");
      var desModes = require2("browserify-des/modes");
      var ebtk = require2("evp_bytestokey");
      function createCipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys2 = ebtk(password, false, keyLen, ivLen);
        return createCipheriv(suite, keys2.key, keys2.iv);
      }
      function createDecipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys2 = ebtk(password, false, keyLen, ivLen);
        return createDecipheriv(suite, keys2.key, keys2.iv);
      }
      function createCipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createCipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({ key, iv, mode: suite });
        throw new TypeError("invalid suite type");
      }
      function createDecipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createDecipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({ key, iv, mode: suite, decrypt: true });
        throw new TypeError("invalid suite type");
      }
      function getCiphers() {
        return Object.keys(desModes).concat(aes.getCiphers());
      }
      exports2.createCipher = exports2.Cipher = createCipher;
      exports2.createCipheriv = exports2.Cipheriv = createCipheriv;
      exports2.createDecipher = exports2.Decipher = createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "browserify-aes/browser": 191, "browserify-aes/modes": 202, "browserify-des": 207, "browserify-des/modes": 208, "evp_bytestokey": 423 }], 207: [function(require2, module2, exports2) {
      var CipherBase = require2("cipher-base");
      var des = require2("des.js");
      var inherits = require2("inherits");
      var Buffer2 = require2("safe-buffer").Buffer;
      var modes = { "des-ede3-cbc": des.CBC.instantiate(des.EDE), "des-ede3": des.EDE, "des-ede-cbc": des.CBC.instantiate(des.EDE), "des-ede": des.EDE, "des-cbc": des.CBC.instantiate(des.DES), "des-ecb": des.DES };
      modes.des = modes["des-cbc"];
      modes.des3 = modes["des-ede3-cbc"];
      module2.exports = DES;
      inherits(DES, CipherBase);
      function DES(opts) {
        CipherBase.call(this);
        var modeName = opts.mode.toLowerCase();
        var mode = modes[modeName];
        var type;
        if (opts.decrypt) {
          type = "decrypt";
        } else {
          type = "encrypt";
        }
        var key = opts.key;
        if (!Buffer2.isBuffer(key)) {
          key = Buffer2.from(key);
        }
        if (modeName === "des-ede" || modeName === "des-ede-cbc") {
          key = Buffer2.concat([key, key.slice(0, 8)]);
        }
        var iv = opts.iv;
        if (!Buffer2.isBuffer(iv)) {
          iv = Buffer2.from(iv);
        }
        this._des = mode.create({ key, iv, type });
      }
      DES.prototype._update = function(data) {
        return Buffer2.from(this._des.update(data));
      };
      DES.prototype._final = function() {
        return Buffer2.from(this._des.final());
      };
    }, { "cipher-base": 221, "des.js": 394, "inherits": 440, "safe-buffer": 494 }], 208: [function(require2, module2, exports2) {
      exports2["des-ecb"] = { key: 8, iv: 0 };
      exports2["des-cbc"] = exports2.des = { key: 8, iv: 8 };
      exports2["des-ede3-cbc"] = exports2.des3 = { key: 24, iv: 8 };
      exports2["des-ede3"] = { key: 24, iv: 0 };
      exports2["des-ede-cbc"] = { key: 16, iv: 8 };
      exports2["des-ede"] = { key: 16, iv: 0 };
    }, {}], 209: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var BN = require2("bn.js");
          var randomBytes = require2("randombytes");
          function blind(priv) {
            var r = getr(priv);
            var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
            return { blinder, unblinder: r.invm(priv.modulus) };
          }
          function getr(priv) {
            var len = priv.modulus.byteLength();
            var r;
            do {
              r = new BN(randomBytes(len));
            } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
            return r;
          }
          function crt(msg, priv) {
            var blinds = blind(priv);
            var len = priv.modulus.byteLength();
            var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
            var c1 = blinded.toRed(BN.mont(priv.prime1));
            var c2 = blinded.toRed(BN.mont(priv.prime2));
            var qinv = priv.coefficient;
            var p = priv.prime1;
            var q = priv.prime2;
            var m1 = c1.redPow(priv.exponent1).fromRed();
            var m2 = c2.redPow(priv.exponent2).fromRed();
            var h3 = m1.isub(m2).imul(qinv).umod(p).imul(q);
            return m2.iadd(h3).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer2, "be", len);
          }
          crt.getr = getr;
          module2.exports = crt;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 186, "buffer": 220, "randombytes": 475 }], 210: [function(require2, module2, exports2) {
      module2.exports = require2("./browser/algorithms.json");
    }, { "./browser/algorithms.json": 211 }], 211: [function(require2, module2, exports2) {
      module2.exports = { "sha224WithRSAEncryption": { "sign": "rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { "sign": "ecdsa/rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "sha256WithRSAEncryption": { "sign": "rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "RSA-SHA256": { "sign": "ecdsa/rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "sha384WithRSAEncryption": { "sign": "rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "RSA-SHA384": { "sign": "ecdsa/rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "sha512WithRSAEncryption": { "sign": "rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA512": { "sign": "ecdsa/rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA1": { "sign": "rsa", "hash": "sha1", "id": "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { "sign": "ecdsa", "hash": "sha1", "id": "" }, "sha256": { "sign": "ecdsa", "hash": "sha256", "id": "" }, "sha224": { "sign": "ecdsa", "hash": "sha224", "id": "" }, "sha384": { "sign": "ecdsa", "hash": "sha384", "id": "" }, "sha512": { "sign": "ecdsa", "hash": "sha512", "id": "" }, "DSA-SHA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-SHA1": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-WITH-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-WITH-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-WITH-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-WITH-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-RIPEMD160": { "sign": "dsa", "hash": "rmd160", "id": "" }, "ripemd160WithRSA": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "md5WithRSAEncryption": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" } };
    }, {}], 212: [function(require2, module2, exports2) {
      module2.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
    }, {}], 213: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var createHash = require2("create-hash");
      var stream = require2("readable-stream");
      var inherits = require2("inherits");
      var sign = require2("./sign");
      var verify = require2("./verify");
      var algorithms = require2("./algorithms.json");
      Object.keys(algorithms).forEach(function(key) {
        algorithms[key].id = Buffer2.from(algorithms[key].id, "hex");
        algorithms[key.toLowerCase()] = algorithms[key];
      });
      function Sign(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hashType = data.hash;
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Sign, stream.Writable);
      Sign.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Sign.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer2.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Sign.prototype.sign = function signMethod(key, enc) {
        this.end();
        var hash = this._hash.digest();
        var sig = sign(hash, key, this._hashType, this._signType, this._tag);
        return enc ? sig.toString(enc) : sig;
      };
      function Verify(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Verify, stream.Writable);
      Verify.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Verify.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer2.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Verify.prototype.verify = function verifyMethod(key, sig, enc) {
        if (typeof sig === "string")
          sig = Buffer2.from(sig, enc);
        this.end();
        var hash = this._hash.digest();
        return verify(sig, hash, key, this._signType, this._tag);
      };
      function createSign(algorithm) {
        return new Sign(algorithm);
      }
      function createVerify(algorithm) {
        return new Verify(algorithm);
      }
      module2.exports = { Sign: createSign, Verify: createVerify, createSign, createVerify };
    }, { "./algorithms.json": 211, "./sign": 214, "./verify": 215, "create-hash": 386, "inherits": 440, "readable-stream": 491, "safe-buffer": 494 }], 214: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var createHmac = require2("create-hmac");
      var crt = require2("browserify-rsa");
      var EC = require2("elliptic").ec;
      var BN = require2("bn.js");
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function sign(hash, key, hashType, signType, tag) {
        var priv = parseKeys(key);
        if (priv.curve) {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
          return ecSign(hash, priv);
        } else if (priv.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong private key type");
          return dsaSign(hash, priv, hashType);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        }
        hash = Buffer2.concat([tag, hash]);
        var len = priv.modulus.byteLength();
        var pad = [0, 1];
        while (hash.length + pad.length + 1 < len)
          pad.push(255);
        pad.push(0);
        var i = -1;
        while (++i < hash.length)
          pad.push(hash[i]);
        var out = crt(pad, priv);
        return out;
      }
      function ecSign(hash, priv) {
        var curveId = curves[priv.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + priv.curve.join("."));
        var curve = new EC(curveId);
        var key = curve.keyFromPrivate(priv.privateKey);
        var out = key.sign(hash);
        return Buffer2.from(out.toDER());
      }
      function dsaSign(hash, priv, algo) {
        var x = priv.params.priv_key;
        var p = priv.params.p;
        var q = priv.params.q;
        var g = priv.params.g;
        var r = new BN(0);
        var k;
        var H = bits2int(hash, q).mod(q);
        var s = false;
        var kv = getKey(x, q, hash, algo);
        while (s === false) {
          k = makeKey(q, kv, algo);
          r = makeR(g, k, p, q);
          s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
          if (s.cmpn(0) === 0) {
            s = false;
            r = new BN(0);
          }
        }
        return toDER(r, s);
      }
      function toDER(r, s) {
        r = r.toArray();
        s = s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        var total = r.length + s.length + 4;
        var res = [48, total, 2, r.length];
        res = res.concat(r, [2, s.length], s);
        return Buffer2.from(res);
      }
      function getKey(x, q, hash, algo) {
        x = Buffer2.from(x.toArray());
        if (x.length < q.byteLength()) {
          var zeros = Buffer2.alloc(q.byteLength() - x.length);
          x = Buffer2.concat([zeros, x]);
        }
        var hlen = hash.length;
        var hbits = bits2octets(hash, q);
        var v = Buffer2.alloc(hlen);
        v.fill(1);
        var k = Buffer2.alloc(hlen);
        k = createHmac(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        k = createHmac(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        return { k, v };
      }
      function bits2int(obits, q) {
        var bits = new BN(obits);
        var shift = (obits.length << 3) - q.bitLength();
        if (shift > 0)
          bits.ishrn(shift);
        return bits;
      }
      function bits2octets(bits, q) {
        bits = bits2int(bits, q);
        bits = bits.mod(q);
        var out = Buffer2.from(bits.toArray());
        if (out.length < q.byteLength()) {
          var zeros = Buffer2.alloc(q.byteLength() - out.length);
          out = Buffer2.concat([zeros, out]);
        }
        return out;
      }
      function makeKey(q, kv, algo) {
        var t2;
        var k;
        do {
          t2 = Buffer2.alloc(0);
          while (t2.length * 8 < q.bitLength()) {
            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            t2 = Buffer2.concat([t2, kv.v]);
          }
          k = bits2int(t2, q);
          kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest();
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        } while (k.cmp(q) !== -1);
        return k;
      }
      function makeR(g, k, p, q) {
        return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
      }
      module2.exports = sign;
      module2.exports.getKey = getKey;
      module2.exports.makeKey = makeKey;
    }, { "./curves.json": 212, "bn.js": 186, "browserify-rsa": 209, "create-hmac": 388, "elliptic": 405, "parse-asn1": 459, "safe-buffer": 494 }], 215: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var BN = require2("bn.js");
      var EC = require2("elliptic").ec;
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function verify(sig, hash, key, signType, tag) {
        var pub = parseKeys(key);
        if (pub.type === "ec") {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
          return ecVerify(sig, hash, pub);
        } else if (pub.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong public key type");
          return dsaVerify(sig, hash, pub);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        }
        hash = Buffer2.concat([tag, hash]);
        var len = pub.modulus.byteLength();
        var pad = [1];
        var padNum = 0;
        while (hash.length + pad.length + 2 < len) {
          pad.push(255);
          padNum++;
        }
        pad.push(0);
        var i = -1;
        while (++i < hash.length) {
          pad.push(hash[i]);
        }
        pad = Buffer2.from(pad);
        var red = BN.mont(pub.modulus);
        sig = new BN(sig).toRed(red);
        sig = sig.redPow(new BN(pub.publicExponent));
        sig = Buffer2.from(sig.fromRed().toArray());
        var out = padNum < 8 ? 1 : 0;
        len = Math.min(sig.length, pad.length);
        if (sig.length !== pad.length)
          out = 1;
        i = -1;
        while (++i < len)
          out |= sig[i] ^ pad[i];
        return out === 0;
      }
      function ecVerify(sig, hash, pub) {
        var curveId = curves[pub.data.algorithm.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
        var curve = new EC(curveId);
        var pubkey = pub.data.subjectPrivateKey.data;
        return curve.verify(hash, sig, pubkey);
      }
      function dsaVerify(sig, hash, pub) {
        var p = pub.data.p;
        var q = pub.data.q;
        var g = pub.data.g;
        var y = pub.data.pub_key;
        var unpacked = parseKeys.signature.decode(sig, "der");
        var s = unpacked.s;
        var r = unpacked.r;
        checkValue(s, q);
        checkValue(r, q);
        var montp = BN.mont(p);
        var w = s.invm(q);
        var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
        return v.cmp(r) === 0;
      }
      function checkValue(b, q) {
        if (b.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (b.cmp(q) >= q)
          throw new Error("invalid sig");
      }
      module2.exports = verify;
    }, { "./curves.json": 212, "bn.js": 186, "elliptic": 405, "parse-asn1": 459, "safe-buffer": 494 }], 216: [function(require2, module2, exports2) {
    }, {}], 217: [function(require2, module2, exports2) {
      var buffer = require2("buffer");
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill2, encoding);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 220 }], 218: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var isEncoding = Buffer2.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }, { "safe-buffer": 217 }], 219: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          module2.exports = function xor(a, b) {
            var length = Math.min(a.length, b.length);
            var buffer = new Buffer2(length);
            for (var i = 0; i < length; ++i) {
              buffer[i] = a[i] ^ b[i];
            }
            return buffer;
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 220 }], 220: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var base64 = require2("base64-js");
          var ieee754 = require2("ieee754");
          exports2.Buffer = Buffer3;
          exports2.SlowBuffer = SlowBuffer;
          exports2.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 2147483647;
          exports2.kMaxLength = K_MAX_LENGTH;
          Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
          }
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
                return 42;
              } };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer3.prototype, "parent", { enumerable: true, get: function get() {
            if (!Buffer3.isBuffer(this))
              return void 0;
            return this.buffer;
          } });
          Object.defineProperty(Buffer3.prototype, "offset", { enumerable: true, get: function get() {
            if (!Buffer3.isBuffer(this))
              return void 0;
            return this.byteOffset;
          } });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer3.prototype;
            return buf;
          }
          function Buffer3(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }
          if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer3[Symbol.species] === Buffer3) {
            Object.defineProperty(Buffer3, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false });
          }
          Buffer3.poolSize = 8192;
          function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer3.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b)
              return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
              return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            }
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
          }
          Buffer3.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };
          Buffer3.prototype.__proto__ = Uint8Array.prototype;
          Buffer3.__proto__ = Uint8Array;
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill2, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill2 !== void 0) {
              return typeof encoding === "string" ? createBuffer(size).fill(fill2, encoding) : createBuffer(size).fill(fill2);
            }
            return createBuffer(size);
          }
          Buffer3.alloc = function(size, fill2, encoding) {
            return alloc(size, fill2, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }
          Buffer3.allocUnsafe = function(size) {
            return allocUnsafe(size);
          };
          Buffer3.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer3.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === void 0 && length === void 0) {
              buf = new Uint8Array(array);
            } else if (length === void 0) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }
            buf.__proto__ = Buffer3.prototype;
            return buf;
          }
          function fromObject(obj) {
            if (Buffer3.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== void 0) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            if (length >= K_MAX_LENGTH) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer3.alloc(+length);
          }
          Buffer3.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer3.prototype;
          };
          Buffer3.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array))
              a = Buffer3.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array))
              b = Buffer3.from(b, b.offset, b.byteLength);
            if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer3.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer3.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer3.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer3.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer3.from(buf);
              }
              if (!Buffer3.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer3.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length;
                  }
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer3.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding)
              encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer3.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer3.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer3.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer3.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer3.prototype.toString = function toString2() {
            var length = this.length;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
          Buffer3.prototype.equals = function equals2(b) {
            if (!Buffer3.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer3.compare(this, b) === 0;
          };
          Buffer3.prototype.inspect = function inspect() {
            var str = "";
            var max = exports2.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max)
              str += " ... ";
            return "<Buffer " + str + ">";
          };
          Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer3.from(target, target.offset, target.byteLength);
            }
            if (!Buffer3.isBuffer(target)) {
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target)
              return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0)
              byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir)
                return -1;
              else
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir)
                byteOffset = 0;
              else
                return -1;
            }
            if (typeof val === "string") {
              val = Buffer3.from(val, encoding);
            }
            if (Buffer3.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1)
                    i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found)
                  return i;
              }
            }
            return -1;
          }
          Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer3.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer3.prototype.toJSON = function toJSON() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += toHex2(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer3.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer3.prototype;
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer3.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
          };
          Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
            if (!Buffer3.isBuffer(target))
              throw new TypeError("argument should be a Buffer");
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("Index out of range");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
          };
          Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                  val = code;
                }
              }
            } else if (typeof val === "number") {
              val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val)
              val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function toHex2(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            return obj !== obj;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "base64-js": 185, "buffer": 220, "ieee754": 439 }], 221: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var Transform = require2("stream").Transform;
      var StringDecoder = require2("string_decoder").StringDecoder;
      var inherits = require2("inherits");
      function CipherBase(hashMode) {
        Transform.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits(CipherBase, Transform);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer2.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode)
          return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer2.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc)
          throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      module2.exports = CipherBase;
    }, { "inherits": 440, "safe-buffer": 494, "stream": 505, "string_decoder": 218 }], 222: [function(require2, module2, exports2) {
      var isCallable = require2("../internals/is-callable");
      var tryToString = require2("../internals/try-to-string");
      var $TypeError = TypeError;
      module2.exports = function(argument) {
        if (isCallable(argument))
          return argument;
        throw new $TypeError(tryToString(argument) + " is not a function");
      };
    }, { "../internals/is-callable": 285, "../internals/try-to-string": 349 }], 223: [function(require2, module2, exports2) {
      var isConstructor = require2("../internals/is-constructor");
      var tryToString = require2("../internals/try-to-string");
      var $TypeError = TypeError;
      module2.exports = function(argument) {
        if (isConstructor(argument))
          return argument;
        throw new $TypeError(tryToString(argument) + " is not a constructor");
      };
    }, { "../internals/is-constructor": 286, "../internals/try-to-string": 349 }], 224: [function(require2, module2, exports2) {
      var isCallable = require2("../internals/is-callable");
      var $String = String;
      var $TypeError = TypeError;
      module2.exports = function(argument) {
        if (typeof argument == "object" || isCallable(argument))
          return argument;
        throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
      };
    }, { "../internals/is-callable": 285 }], 225: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var create = require2("../internals/object-create");
      var defineProperty = require2("../internals/object-define-property").f;
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] === void 0) {
        defineProperty(ArrayPrototype, UNSCOPABLES, { configurable: true, value: create(null) });
      }
      module2.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }, { "../internals/object-create": 306, "../internals/object-define-property": 308, "../internals/well-known-symbol": 357 }], 226: [function(require2, module2, exports2) {
      var isPrototypeOf = require2("../internals/object-is-prototype-of");
      var $TypeError = TypeError;
      module2.exports = function(it, Prototype) {
        if (isPrototypeOf(Prototype, it))
          return it;
        throw new $TypeError("Incorrect invocation");
      };
    }, { "../internals/object-is-prototype-of": 314 }], 227: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      var $String = String;
      var $TypeError = TypeError;
      module2.exports = function(argument) {
        if (isObject(argument))
          return argument;
        throw new $TypeError($String(argument) + " is not an object");
      };
    }, { "../internals/is-object": 289 }], 228: [function(require2, module2, exports2) {
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toAbsoluteIndex = require2("../internals/to-absolute-index");
      var lengthOfArrayLike = require2("../internals/length-of-array-like");
      var createMethod = function createMethod2(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = lengthOfArrayLike(O);
          var index2 = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el !== el)
            while (length > index2) {
              value = O[index2++];
              if (value !== value)
                return true;
            }
          else
            for (; length > index2; index2++) {
              if ((IS_INCLUDES || index2 in O) && O[index2] === el)
                return IS_INCLUDES || index2 || 0;
            }
          return !IS_INCLUDES && -1;
        };
      };
      module2.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }, { "../internals/length-of-array-like": 299, "../internals/to-absolute-index": 340, "../internals/to-indexed-object": 341 }], 229: [function(require2, module2, exports2) {
      var bind2 = require2("../internals/function-bind-context");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var IndexedObject = require2("../internals/indexed-object");
      var toObject = require2("../internals/to-object");
      var lengthOfArrayLike = require2("../internals/length-of-array-like");
      var arraySpeciesCreate = require2("../internals/array-species-create");
      var push = uncurryThis([].push);
      var createMethod = function createMethod2(TYPE) {
        var IS_MAP = TYPE === 1;
        var IS_FILTER = TYPE === 2;
        var IS_SOME = TYPE === 3;
        var IS_EVERY = TYPE === 4;
        var IS_FIND_INDEX = TYPE === 6;
        var IS_FILTER_REJECT = TYPE === 7;
        var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var boundFunction = bind2(callbackfn, that);
          var length = lengthOfArrayLike(self2);
          var index2 = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
          var value, result;
          for (; length > index2; index2++)
            if (NO_HOLES || index2 in self2) {
              value = self2[index2];
              result = boundFunction(value, index2, O);
              if (TYPE) {
                if (IS_MAP)
                  target[index2] = result;
                else if (result)
                  switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return value;
                    case 6:
                      return index2;
                    case 2:
                      push(target, value);
                  }
                else
                  switch (TYPE) {
                    case 4:
                      return false;
                    case 7:
                      push(target, value);
                  }
              }
            }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module2.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6),
        // `Array.prototype.filterReject` method
        // https://github.com/tc39/proposal-array-filtering
        filterReject: createMethod(7)
      };
    }, { "../internals/array-species-create": 233, "../internals/function-bind-context": 262, "../internals/function-uncurry-this": 268, "../internals/indexed-object": 280, "../internals/length-of-array-like": 299, "../internals/to-object": 344 }], 230: [function(require2, module2, exports2) {
      var toAbsoluteIndex = require2("../internals/to-absolute-index");
      var lengthOfArrayLike = require2("../internals/length-of-array-like");
      var createProperty = require2("../internals/create-property");
      var $Array = Array;
      var max = Math.max;
      module2.exports = function(O, start, end) {
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var result = $Array(max(fin - k, 0));
        var n = 0;
        for (; k < fin; k++, n++)
          createProperty(result, n, O[k]);
        result.length = n;
        return result;
      };
    }, { "../internals/create-property": 243, "../internals/length-of-array-like": 299, "../internals/to-absolute-index": 340 }], 231: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      module2.exports = uncurryThis([].slice);
    }, { "../internals/function-uncurry-this": 268 }], 232: [function(require2, module2, exports2) {
      var isArray = require2("../internals/is-array");
      var isConstructor = require2("../internals/is-constructor");
      var isObject = require2("../internals/is-object");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      module2.exports = function(originalArray) {
        var C;
        if (isArray(originalArray)) {
          C = originalArray.constructor;
          if (isConstructor(C) && (C === $Array || isArray(C.prototype)))
            C = void 0;
          else if (isObject(C)) {
            C = C[SPECIES];
            if (C === null)
              C = void 0;
          }
        }
        return C === void 0 ? $Array : C;
      };
    }, { "../internals/is-array": 284, "../internals/is-constructor": 286, "../internals/is-object": 289, "../internals/well-known-symbol": 357 }], 233: [function(require2, module2, exports2) {
      var arraySpeciesConstructor = require2("../internals/array-species-constructor");
      module2.exports = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    }, { "../internals/array-species-constructor": 232 }], 234: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        var called = 0;
        var iteratorWithReturn = { next: function next() {
          return { done: !!called++ };
        }, "return": function _return() {
          SAFE_CLOSING = true;
        } };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      module2.exports = function(exec, SKIP_CLOSING) {
        try {
          if (!SKIP_CLOSING && !SAFE_CLOSING)
            return false;
        } catch (error) {
          return false;
        }
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return { next: function next() {
              return { done: ITERATION_SUPPORT = true };
            } };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
    }, { "../internals/well-known-symbol": 357 }], 235: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var toString2 = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module2.exports = function(it) {
        return stringSlice(toString2(it), 8, -1);
      };
    }, { "../internals/function-uncurry-this": 268 }], 236: [function(require2, module2, exports2) {
      var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
      var isCallable = require2("../internals/is-callable");
      var classofRaw = require2("../internals/classof-raw");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS = classofRaw(function() {
        return arguments;
      }()) === "Arguments";
      var tryGet = function tryGet2(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
      };
    }, { "../internals/classof-raw": 235, "../internals/is-callable": 285, "../internals/to-string-tag-support": 347, "../internals/well-known-symbol": 357 }], 237: [function(require2, module2, exports2) {
      var hasOwn = require2("../internals/has-own-property");
      var ownKeys2 = require2("../internals/own-keys");
      var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
      var definePropertyModule = require2("../internals/object-define-property");
      module2.exports = function(target, source, exceptions) {
        var keys2 = ownKeys2(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/object-get-own-property-descriptor": 309, "../internals/own-keys": 321 }], 238: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var MATCH = wellKnownSymbol("match");
      module2.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
    }, { "../internals/well-known-symbol": 357 }], 239: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    }, { "../internals/fails": 260 }], 240: [function(require2, module2, exports2) {
      module2.exports = function(value, done) {
        return { value, done };
      };
    }, {}], 241: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var definePropertyModule = require2("../internals/object-define-property");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      module2.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }, { "../internals/create-property-descriptor": 242, "../internals/descriptors": 247, "../internals/object-define-property": 308 }], 242: [function(require2, module2, exports2) {
      module2.exports = function(bitmap, value) {
        return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value };
      };
    }, {}], 243: [function(require2, module2, exports2) {
      var toPropertyKey2 = require2("../internals/to-property-key");
      var definePropertyModule = require2("../internals/object-define-property");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      module2.exports = function(object, key, value) {
        var propertyKey = toPropertyKey2(key);
        if (propertyKey in object)
          definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
        else
          object[propertyKey] = value;
      };
    }, { "../internals/create-property-descriptor": 242, "../internals/object-define-property": 308, "../internals/to-property-key": 346 }], 244: [function(require2, module2, exports2) {
      var makeBuiltIn = require2("../internals/make-built-in");
      var defineProperty = require2("../internals/object-define-property");
      module2.exports = function(target, name, descriptor) {
        if (descriptor.get)
          makeBuiltIn(descriptor.get, name, { getter: true });
        if (descriptor.set)
          makeBuiltIn(descriptor.set, name, { setter: true });
        return defineProperty.f(target, name, descriptor);
      };
    }, { "../internals/make-built-in": 300, "../internals/object-define-property": 308 }], 245: [function(require2, module2, exports2) {
      var isCallable = require2("../internals/is-callable");
      var definePropertyModule = require2("../internals/object-define-property");
      var makeBuiltIn = require2("../internals/make-built-in");
      var defineGlobalProperty = require2("../internals/define-global-property");
      module2.exports = function(O, key, value, options) {
        if (!options)
          options = {};
        var simple = options.enumerable;
        var name = options.name !== void 0 ? options.name : key;
        if (isCallable(value))
          makeBuiltIn(value, name, options);
        if (options.global) {
          if (simple)
            O[key] = value;
          else
            defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe)
              delete O[key];
            else if (O[key])
              simple = true;
          } catch (error) {
          }
          if (simple)
            O[key] = value;
          else
            definePropertyModule.f(O, key, { value, enumerable: false, configurable: !options.nonConfigurable, writable: !options.nonWritable });
        }
        return O;
      };
    }, { "../internals/define-global-property": 246, "../internals/is-callable": 285, "../internals/make-built-in": 300, "../internals/object-define-property": 308 }], 246: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var defineProperty = Object.defineProperty;
      module2.exports = function(key, value) {
        try {
          defineProperty(global2, key, { value, configurable: true, writable: true });
        } catch (error) {
          global2[key] = value;
        }
        return value;
      };
    }, { "../internals/global": 274 }], 247: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function get() {
          return 7;
        } })[1] !== 7;
      });
    }, { "../internals/fails": 260 }], 248: [function(require2, module2, exports2) {
      var documentAll = typeof document == "object" && document.all;
      var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
      module2.exports = { all: documentAll, IS_HTMLDDA };
    }, {}], 249: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var isObject = require2("../internals/is-object");
      var document2 = global2.document;
      var EXISTS = isObject(document2) && isObject(document2.createElement);
      module2.exports = function(it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    }, { "../internals/global": 274, "../internals/is-object": 289 }], 250: [function(require2, module2, exports2) {
      var IS_DENO = require2("../internals/engine-is-deno");
      var IS_NODE = require2("../internals/engine-is-node");
      module2.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
    }, { "../internals/engine-is-deno": 251, "../internals/engine-is-node": 254 }], 251: [function(require2, module2, exports2) {
      module2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    }, {}], 252: [function(require2, module2, exports2) {
      var userAgent = require2("../internals/engine-user-agent");
      module2.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
    }, { "../internals/engine-user-agent": 256 }], 253: [function(require2, module2, exports2) {
      var userAgent = require2("../internals/engine-user-agent");
      module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    }, { "../internals/engine-user-agent": 256 }], 254: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var classof = require2("../internals/classof-raw");
      module2.exports = classof(global2.process) === "process";
    }, { "../internals/classof-raw": 235, "../internals/global": 274 }], 255: [function(require2, module2, exports2) {
      var userAgent = require2("../internals/engine-user-agent");
      module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
    }, { "../internals/engine-user-agent": 256 }], 256: [function(require2, module2, exports2) {
      module2.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    }, {}], 257: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var userAgent = require2("../internals/engine-user-agent");
      var process2 = global2.process;
      var Deno2 = global2.Deno;
      var versions = process2 && process2.versions || Deno2 && Deno2.version;
      var v8 = versions && versions.v8;
      var match, version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match)
            version = +match[1];
        }
      }
      module2.exports = version;
    }, { "../internals/engine-user-agent": 256, "../internals/global": 274 }], 258: [function(require2, module2, exports2) {
      module2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, {}], 259: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var defineBuiltIn = require2("../internals/define-built-in");
      var defineGlobalProperty = require2("../internals/define-global-property");
      var copyConstructorProperties = require2("../internals/copy-constructor-properties");
      var isForced = require2("../internals/is-forced");
      module2.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global2;
        } else if (STATIC) {
          target = global2[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = (global2[TARGET] || {}).prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options.dontCallGetSet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else
              targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty)
                continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            defineBuiltIn(target, key, sourceProperty, options);
          }
      };
    }, { "../internals/copy-constructor-properties": 237, "../internals/create-non-enumerable-property": 241, "../internals/define-built-in": 245, "../internals/define-global-property": 246, "../internals/global": 274, "../internals/is-forced": 287, "../internals/object-get-own-property-descriptor": 309 }], 260: [function(require2, module2, exports2) {
      module2.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }, {}], 261: [function(require2, module2, exports2) {
      var NATIVE_BIND = require2("../internals/function-bind-native");
      var FunctionPrototype = Function.prototype;
      var apply = FunctionPrototype.apply;
      var call = FunctionPrototype.call;
      module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
        return call.apply(apply, arguments);
      });
    }, { "../internals/function-bind-native": 263 }], 262: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this-clause");
      var aCallable = require2("../internals/a-callable");
      var NATIVE_BIND = require2("../internals/function-bind-native");
      var bind2 = uncurryThis(uncurryThis.bind);
      module2.exports = function(fn, that) {
        aCallable(fn);
        return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
          return fn.apply(that, arguments);
        };
      };
    }, { "../internals/a-callable": 222, "../internals/function-bind-native": 263, "../internals/function-uncurry-this-clause": 267 }], 263: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !fails(function() {
        var test = function() {
        }.bind();
        return typeof test != "function" || test.hasOwnProperty("prototype");
      });
    }, { "../internals/fails": 260 }], 264: [function(require2, module2, exports2) {
      var NATIVE_BIND = require2("../internals/function-bind-native");
      var call = Function.prototype.call;
      module2.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }, { "../internals/function-bind-native": 263 }], 265: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var hasOwn = require2("../internals/has-own-property");
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module2.exports = { EXISTS, PROPER, CONFIGURABLE };
    }, { "../internals/descriptors": 247, "../internals/has-own-property": 275 }], 266: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var aCallable = require2("../internals/a-callable");
      module2.exports = function(object, key, method) {
        try {
          return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
        } catch (error) {
        }
      };
    }, { "../internals/a-callable": 222, "../internals/function-uncurry-this": 268 }], 267: [function(require2, module2, exports2) {
      var classofRaw = require2("../internals/classof-raw");
      var uncurryThis = require2("../internals/function-uncurry-this");
      module2.exports = function(fn) {
        if (classofRaw(fn) === "Function")
          return uncurryThis(fn);
      };
    }, { "../internals/classof-raw": 235, "../internals/function-uncurry-this": 268 }], 268: [function(require2, module2, exports2) {
      var NATIVE_BIND = require2("../internals/function-bind-native");
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
        return function() {
          return call.apply(fn, arguments);
        };
      };
    }, { "../internals/function-bind-native": 263 }], 269: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var isCallable = require2("../internals/is-callable");
      var aFunction = function aFunction2(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module2.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
      };
    }, { "../internals/global": 274, "../internals/is-callable": 285 }], 270: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof");
      var getMethod = require2("../internals/get-method");
      var isNullOrUndefined = require2("../internals/is-null-or-undefined");
      var Iterators = require2("../internals/iterators");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var ITERATOR = wellKnownSymbol("iterator");
      module2.exports = function(it) {
        if (!isNullOrUndefined(it))
          return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
      };
    }, { "../internals/classof": 236, "../internals/get-method": 273, "../internals/is-null-or-undefined": 288, "../internals/iterators": 298, "../internals/well-known-symbol": 357 }], 271: [function(require2, module2, exports2) {
      var call = require2("../internals/function-call");
      var aCallable = require2("../internals/a-callable");
      var anObject = require2("../internals/an-object");
      var tryToString = require2("../internals/try-to-string");
      var getIteratorMethod = require2("../internals/get-iterator-method");
      var $TypeError = TypeError;
      module2.exports = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod))
          return anObject(call(iteratorMethod, argument));
        throw new $TypeError(tryToString(argument) + " is not iterable");
      };
    }, { "../internals/a-callable": 222, "../internals/an-object": 227, "../internals/function-call": 264, "../internals/get-iterator-method": 270, "../internals/try-to-string": 349 }], 272: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var isArray = require2("../internals/is-array");
      var isCallable = require2("../internals/is-callable");
      var classof = require2("../internals/classof-raw");
      var toString2 = require2("../internals/to-string");
      var push = uncurryThis([].push);
      module2.exports = function(replacer) {
        if (isCallable(replacer))
          return replacer;
        if (!isArray(replacer))
          return;
        var rawLength = replacer.length;
        var keys2 = [];
        for (var i = 0; i < rawLength; i++) {
          var element = replacer[i];
          if (typeof element == "string")
            push(keys2, element);
          else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
            push(keys2, toString2(element));
        }
        var keysLength = keys2.length;
        var root = true;
        return function(key, value) {
          if (root) {
            root = false;
            return value;
          }
          if (isArray(this))
            return value;
          for (var j = 0; j < keysLength; j++)
            if (keys2[j] === key)
              return value;
        };
      };
    }, { "../internals/classof-raw": 235, "../internals/function-uncurry-this": 268, "../internals/is-array": 284, "../internals/is-callable": 285, "../internals/to-string": 348 }], 273: [function(require2, module2, exports2) {
      var aCallable = require2("../internals/a-callable");
      var isNullOrUndefined = require2("../internals/is-null-or-undefined");
      module2.exports = function(V, P) {
        var func = V[P];
        return isNullOrUndefined(func) ? void 0 : aCallable(func);
      };
    }, { "../internals/a-callable": 222, "../internals/is-null-or-undefined": 288 }], 274: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var check = function check2(it) {
            return it && it.Math === Math && it;
          };
          module2.exports = // eslint-disable-next-line es/no-global-this -- safe
          check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
          check(typeof self == "object" && self) || check(typeof global2 == "object" && global2) || // eslint-disable-next-line no-new-func -- fallback
          function() {
            return this;
          }() || this || Function("return this")();
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 275: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var toObject = require2("../internals/to-object");
      var hasOwnProperty3 = uncurryThis({}.hasOwnProperty);
      module2.exports = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty3(toObject(it), key);
      };
    }, { "../internals/function-uncurry-this": 268, "../internals/to-object": 344 }], 276: [function(require2, module2, exports2) {
      module2.exports = {};
    }, {}], 277: [function(require2, module2, exports2) {
      module2.exports = function(a, b) {
        try {
          arguments.length === 1 ? console.error(a) : console.error(a, b);
        } catch (error) {
        }
      };
    }, {}], 278: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      module2.exports = getBuiltIn("document", "documentElement");
    }, { "../internals/get-built-in": 269 }], 279: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      var createElement = require2("../internals/document-create-element");
      module2.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement("div"), "a", { get: function get() {
          return 7;
        } }).a !== 7;
      });
    }, { "../internals/descriptors": 247, "../internals/document-create-element": 249, "../internals/fails": 260 }], 280: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var fails = require2("../internals/fails");
      var classof = require2("../internals/classof-raw");
      var $Object = Object;
      var split = uncurryThis("".split);
      module2.exports = fails(function() {
        return !$Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) === "String" ? split(it, "") : $Object(it);
      } : $Object;
    }, { "../internals/classof-raw": 235, "../internals/fails": 260, "../internals/function-uncurry-this": 268 }], 281: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var isCallable = require2("../internals/is-callable");
      var store = require2("../internals/shared-store");
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      module2.exports = store.inspectSource;
    }, { "../internals/function-uncurry-this": 268, "../internals/is-callable": 285, "../internals/shared-store": 333 }], 282: [function(require2, module2, exports2) {
      var NATIVE_WEAK_MAP = require2("../internals/weak-map-basic-detection");
      var global2 = require2("../internals/global");
      var isObject = require2("../internals/is-object");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var hasOwn = require2("../internals/has-own-property");
      var shared = require2("../internals/shared-store");
      var sharedKey = require2("../internals/shared-key");
      var hiddenKeys = require2("../internals/hidden-keys");
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = global2.TypeError;
      var WeakMap2 = global2.WeakMap;
      var set, get, has;
      var enforce = function enforce2(it) {
        return has(it) ? get(it) : set(it, {});
      };
      var getterFor = function getterFor2(TYPE) {
        return function(it) {
          var state;
          if (!isObject(it) || (state = get(it)).type !== TYPE) {
            throw new TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        var store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = function set2(it, metadata) {
          if (store.has(it))
            throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          store.set(it, metadata);
          return metadata;
        };
        get = function get2(it) {
          return store.get(it) || {};
        };
        has = function has2(it) {
          return store.has(it);
        };
      } else {
        var STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function set2(it, metadata) {
          if (hasOwn(it, STATE))
            throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get = function get2(it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        };
        has = function has2(it) {
          return hasOwn(it, STATE);
        };
      }
      module2.exports = { set, get, has, enforce, getterFor };
    }, { "../internals/create-non-enumerable-property": 241, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/is-object": 289, "../internals/shared-key": 332, "../internals/shared-store": 333, "../internals/weak-map-basic-detection": 354 }], 283: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var Iterators = require2("../internals/iterators");
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module2.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    }, { "../internals/iterators": 298, "../internals/well-known-symbol": 357 }], 284: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof-raw");
      module2.exports = Array.isArray || function isArray(argument) {
        return classof(argument) === "Array";
      };
    }, { "../internals/classof-raw": 235 }], 285: [function(require2, module2, exports2) {
      var $documentAll = require2("../internals/document-all");
      var documentAll = $documentAll.all;
      module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
    }, { "../internals/document-all": 248 }], 286: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var fails = require2("../internals/fails");
      var isCallable = require2("../internals/is-callable");
      var classof = require2("../internals/classof");
      var getBuiltIn = require2("../internals/get-built-in");
      var inspectSource = require2("../internals/inspect-source");
      var noop = function noop2() {
      };
      var empty = [];
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
      var isConstructorModern = function isConstructor(argument) {
        if (!isCallable(argument))
          return false;
        try {
          construct(noop, empty, argument);
          return true;
        } catch (error) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor(argument) {
        if (!isCallable(argument))
          return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      module2.exports = !construct || fails(function() {
        var called;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called = true;
        }) || called;
      }) ? isConstructorLegacy : isConstructorModern;
    }, { "../internals/classof": 236, "../internals/fails": 260, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/inspect-source": 281, "../internals/is-callable": 285 }], 287: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      var isCallable = require2("../internals/is-callable");
      var replacement = /#|\.prototype\./;
      var isForced = function isForced2(feature, detection) {
        var value = data[normalize(feature)];
        return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module2.exports = isForced;
    }, { "../internals/fails": 260, "../internals/is-callable": 285 }], 288: [function(require2, module2, exports2) {
      module2.exports = function(it) {
        return it === null || it === void 0;
      };
    }, {}], 289: [function(require2, module2, exports2) {
      var isCallable = require2("../internals/is-callable");
      var $documentAll = require2("../internals/document-all");
      var documentAll = $documentAll.all;
      module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
        return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
      } : function(it) {
        return typeof it == "object" ? it !== null : isCallable(it);
      };
    }, { "../internals/document-all": 248, "../internals/is-callable": 285 }], 290: [function(require2, module2, exports2) {
      module2.exports = false;
    }, {}], 291: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      var classof = require2("../internals/classof-raw");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var MATCH = wellKnownSymbol("match");
      module2.exports = function(it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
      };
    }, { "../internals/classof-raw": 235, "../internals/is-object": 289, "../internals/well-known-symbol": 357 }], 292: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      var isCallable = require2("../internals/is-callable");
      var isPrototypeOf = require2("../internals/object-is-prototype-of");
      var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
      var $Object = Object;
      module2.exports = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
      };
    }, { "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/object-is-prototype-of": 314, "../internals/use-symbol-as-uid": 351 }], 293: [function(require2, module2, exports2) {
      var bind2 = require2("../internals/function-bind-context");
      var call = require2("../internals/function-call");
      var anObject = require2("../internals/an-object");
      var tryToString = require2("../internals/try-to-string");
      var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
      var lengthOfArrayLike = require2("../internals/length-of-array-like");
      var isPrototypeOf = require2("../internals/object-is-prototype-of");
      var getIterator = require2("../internals/get-iterator");
      var getIteratorMethod = require2("../internals/get-iterator-method");
      var iteratorClose = require2("../internals/iterator-close");
      var $TypeError = TypeError;
      var Result = function Result2(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      module2.exports = function(iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_RECORD = !!(options && options.IS_RECORD);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn = bind2(unboundFunction, that);
        var iterator, iterFn, index2, length, result, next, step;
        var stop = function stop2(condition) {
          if (iterator)
            iteratorClose(iterator, "normal", condition);
          return new Result(true, condition);
        };
        var callFn = function callFn2(value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
          }
          return INTERRUPTED ? fn(value, stop) : fn(value);
        };
        if (IS_RECORD) {
          iterator = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn)
            throw new $TypeError(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
              result = callFn(iterable[index2]);
              if (result && isPrototypeOf(ResultPrototype, result))
                return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next = IS_RECORD ? iterable.next : iterator.next;
        while (!(step = call(next, iterator)).done) {
          try {
            result = callFn(step.value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
            return result;
        }
        return new Result(false);
      };
    }, { "../internals/an-object": 227, "../internals/function-bind-context": 262, "../internals/function-call": 264, "../internals/get-iterator": 271, "../internals/get-iterator-method": 270, "../internals/is-array-iterator-method": 283, "../internals/iterator-close": 294, "../internals/length-of-array-like": 299, "../internals/object-is-prototype-of": 314, "../internals/try-to-string": 349 }], 294: [function(require2, module2, exports2) {
      var call = require2("../internals/function-call");
      var anObject = require2("../internals/an-object");
      var getMethod = require2("../internals/get-method");
      module2.exports = function(iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
          innerResult = getMethod(iterator, "return");
          if (!innerResult) {
            if (kind === "throw")
              throw value;
            return value;
          }
          innerResult = call(innerResult, iterator);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw")
          throw value;
        if (innerError)
          throw innerResult;
        anObject(innerResult);
        return value;
      };
    }, { "../internals/an-object": 227, "../internals/function-call": 264, "../internals/get-method": 273 }], 295: [function(require2, module2, exports2) {
      var IteratorPrototype = require2("../internals/iterators-core").IteratorPrototype;
      var create = require2("../internals/object-create");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var Iterators = require2("../internals/iterators");
      var returnThis = function returnThis2() {
        return this;
      };
      module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }, { "../internals/create-property-descriptor": 242, "../internals/iterators": 298, "../internals/iterators-core": 297, "../internals/object-create": 306, "../internals/set-to-string-tag": 331 }], 296: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var call = require2("../internals/function-call");
      var IS_PURE = require2("../internals/is-pure");
      var FunctionName = require2("../internals/function-name");
      var isCallable = require2("../internals/is-callable");
      var createIteratorConstructor = require2("../internals/iterator-create-constructor");
      var getPrototypeOf = require2("../internals/object-get-prototype-of");
      var setPrototypeOf = require2("../internals/object-set-prototype-of");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var defineBuiltIn = require2("../internals/define-built-in");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var Iterators = require2("../internals/iterators");
      var IteratorsCore = require2("../internals/iterators-core");
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function returnThis2() {
        return this;
      };
      module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function getIterationMethod2(KIND) {
          if (KIND === DEFAULT && defaultIterator)
            return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
            return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys2() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE)
              Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return call(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) };
          if (FORCED)
            for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
              }
            }
          else
            $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
        }
        Iterators[NAME] = defaultIterator;
        return methods;
      };
    }, { "../internals/create-non-enumerable-property": 241, "../internals/define-built-in": 245, "../internals/export": 259, "../internals/function-call": 264, "../internals/function-name": 265, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/iterator-create-constructor": 295, "../internals/iterators": 298, "../internals/iterators-core": 297, "../internals/object-get-prototype-of": 313, "../internals/object-set-prototype-of": 318, "../internals/set-to-string-tag": 331, "../internals/well-known-symbol": 357 }], 297: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      var isCallable = require2("../internals/is-callable");
      var isObject = require2("../internals/is-object");
      var create = require2("../internals/object-create");
      var getPrototypeOf = require2("../internals/object-get-prototype-of");
      var defineBuiltIn = require2("../internals/define-built-in");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var IS_PURE = require2("../internals/is-pure");
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator))
          BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
            IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
        var test = {};
        return IteratorPrototype[ITERATOR].call(test) !== test;
      });
      if (NEW_ITERATOR_PROTOTYPE)
        IteratorPrototype = {};
      else if (IS_PURE)
        IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        defineBuiltIn(IteratorPrototype, ITERATOR, function() {
          return this;
        });
      }
      module2.exports = { IteratorPrototype, BUGGY_SAFARI_ITERATORS };
    }, { "../internals/define-built-in": 245, "../internals/fails": 260, "../internals/is-callable": 285, "../internals/is-object": 289, "../internals/is-pure": 290, "../internals/object-create": 306, "../internals/object-get-prototype-of": 313, "../internals/well-known-symbol": 357 }], 298: [function(require2, module2, exports2) {
      arguments[4][276][0].apply(exports2, arguments);
    }, { "dup": 276 }], 299: [function(require2, module2, exports2) {
      var toLength = require2("../internals/to-length");
      module2.exports = function(obj) {
        return toLength(obj.length);
      };
    }, { "../internals/to-length": 343 }], 300: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var fails = require2("../internals/fails");
      var isCallable = require2("../internals/is-callable");
      var hasOwn = require2("../internals/has-own-property");
      var DESCRIPTORS = require2("../internals/descriptors");
      var CONFIGURABLE_FUNCTION_NAME = require2("../internals/function-name").CONFIGURABLE;
      var inspectSource = require2("../internals/inspect-source");
      var InternalStateModule = require2("../internals/internal-state");
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var $String = String;
      var defineProperty = Object.defineProperty;
      var stringSlice = uncurryThis("".slice);
      var replace = uncurryThis("".replace);
      var join = uncurryThis([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
        return defineProperty(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = module2.exports = function(value, name, options) {
        if (stringSlice($String(name), 0, 7) === "Symbol(") {
          name = "[" + replace($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
        }
        if (options && options.getter)
          name = "get " + name;
        if (options && options.setter)
          name = "set " + name;
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          if (DESCRIPTORS)
            defineProperty(value, "name", { value: name, configurable: true });
          else
            value.name = name;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", { value: options.arity });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS)
              defineProperty(value, "prototype", { writable: false });
          } else if (value.prototype)
            value.prototype = void 0;
        } catch (error) {
        }
        var state = enforceInternalState(value);
        if (!hasOwn(state, "source")) {
          state.source = join(TEMPLATE, typeof name == "string" ? name : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn(function toString2() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      }, "toString");
    }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-name": 265, "../internals/function-uncurry-this": 268, "../internals/has-own-property": 275, "../internals/inspect-source": 281, "../internals/internal-state": 282, "../internals/is-callable": 285 }], 301: [function(require2, module2, exports2) {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module2.exports = Math.trunc || function trunc(x) {
        var n = +x;
        return (n > 0 ? floor : ceil)(n);
      };
    }, {}], 302: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var bind2 = require2("../internals/function-bind-context");
      var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
      var macrotask = require2("../internals/task").set;
      var Queue = require2("../internals/queue");
      var IS_IOS = require2("../internals/engine-is-ios");
      var IS_IOS_PEBBLE = require2("../internals/engine-is-ios-pebble");
      var IS_WEBOS_WEBKIT = require2("../internals/engine-is-webos-webkit");
      var IS_NODE = require2("../internals/engine-is-node");
      var MutationObserver2 = global2.MutationObserver || global2.WebKitMutationObserver;
      var document2 = global2.document;
      var process2 = global2.process;
      var Promise2 = global2.Promise;
      var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
      var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
      var notify, toggle, node, promise, then;
      if (!microtask) {
        var queue = new Queue();
        var flush = function flush2() {
          var parent, fn;
          if (IS_NODE && (parent = process2.domain))
            parent.exit();
          while (fn = queue.get())
            try {
              fn();
            } catch (error) {
              if (queue.head)
                notify();
              throw error;
            }
          if (parent)
            parent.enter();
        };
        if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document2) {
          toggle = true;
          node = document2.createTextNode("");
          new MutationObserver2(flush).observe(node, { characterData: true });
          notify = function notify2() {
            node.data = toggle = !toggle;
          };
        } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          promise.constructor = Promise2;
          then = bind2(promise.then, promise);
          notify = function notify2() {
            then(flush);
          };
        } else if (IS_NODE) {
          notify = function notify2() {
            process2.nextTick(flush);
          };
        } else {
          macrotask = bind2(macrotask, global2);
          notify = function notify2() {
            macrotask(flush);
          };
        }
        microtask = function microtask2(fn) {
          if (!queue.head)
            notify();
          queue.add(fn);
        };
      }
      module2.exports = microtask;
    }, { "../internals/engine-is-ios": 253, "../internals/engine-is-ios-pebble": 252, "../internals/engine-is-node": 254, "../internals/engine-is-webos-webkit": 255, "../internals/function-bind-context": 262, "../internals/global": 274, "../internals/object-get-own-property-descriptor": 309, "../internals/queue": 328, "../internals/task": 339 }], 303: [function(require2, module2, exports2) {
      var aCallable = require2("../internals/a-callable");
      var $TypeError = TypeError;
      var PromiseCapability = function PromiseCapability2(C) {
        var resolve, reject;
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0)
            throw new $TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aCallable(resolve);
        this.reject = aCallable(reject);
      };
      module2.exports.f = function(C) {
        return new PromiseCapability(C);
      };
    }, { "../internals/a-callable": 222 }], 304: [function(require2, module2, exports2) {
      var isRegExp = require2("../internals/is-regexp");
      var $TypeError = TypeError;
      module2.exports = function(it) {
        if (isRegExp(it)) {
          throw new $TypeError("The method doesn't accept regular expressions");
        }
        return it;
      };
    }, { "../internals/is-regexp": 291 }], 305: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var call = require2("../internals/function-call");
      var fails = require2("../internals/fails");
      var objectKeys = require2("../internals/object-keys");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var toObject = require2("../internals/to-object");
      var IndexedObject = require2("../internals/indexed-object");
      var $assign = Object.assign;
      var defineProperty = Object.defineProperty;
      var concat = uncurryThis([].concat);
      module2.exports = !$assign || fails(function() {
        if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", { enumerable: true, get: function get() {
          defineProperty(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b !== 1)
          return true;
        var A = {};
        var B = {};
        var symbol = Symbol("assign detection");
        var alphabet = "abcdefghijklmnopqrst";
        A[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B[chr] = chr;
        });
        return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join("") !== alphabet;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index2 = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index2) {
          var S = IndexedObject(arguments[index2++]);
          var keys2 = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
          var length = keys2.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys2[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key))
              T[key] = S[key];
          }
        }
        return T;
      } : $assign;
    }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/indexed-object": 280, "../internals/object-get-own-property-symbols": 312, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/to-object": 344 }], 306: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var definePropertiesModule = require2("../internals/object-define-properties");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      var hiddenKeys = require2("../internals/hidden-keys");
      var html = require2("../internals/html");
      var documentCreateElement = require2("../internals/document-create-element");
      var sharedKey = require2("../internals/shared-key");
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function EmptyConstructor2() {
      };
      var scriptTag = function scriptTag2(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX2(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame2() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var _NullProtoObject = function NullProtoObject() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {
        }
        _NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--)
          delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return _NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module2.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else
          result = _NullProtoObject();
        return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
      };
    }, { "../internals/an-object": 227, "../internals/document-create-element": 249, "../internals/enum-bug-keys": 258, "../internals/hidden-keys": 276, "../internals/html": 278, "../internals/object-define-properties": 307, "../internals/shared-key": 332 }], 307: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
      var definePropertyModule = require2("../internals/object-define-property");
      var anObject = require2("../internals/an-object");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var objectKeys = require2("../internals/object-keys");
      exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var props = toIndexedObject(Properties);
        var keys2 = objectKeys(Properties);
        var length = keys2.length;
        var index2 = 0;
        var key;
        while (length > index2)
          definePropertyModule.f(O, key = keys2[index2++], props[key]);
        return O;
      };
    }, { "../internals/an-object": 227, "../internals/descriptors": 247, "../internals/object-define-property": 308, "../internals/object-keys": 316, "../internals/to-indexed-object": 341, "../internals/v8-prototype-define-bug": 352 }], 308: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
      var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
      var anObject = require2("../internals/an-object");
      var toPropertyKey2 = require2("../internals/to-property-key");
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey2(P);
        anObject(Attributes);
        if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O, P);
          if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = { configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE], enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE], writable: false };
          }
        }
        return $defineProperty(O, P, Attributes);
      } : $defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPropertyKey2(P);
        anObject(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return $defineProperty(O, P, Attributes);
          } catch (error) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw new $TypeError("Accessors not supported");
        if ("value" in Attributes)
          O[P] = Attributes.value;
        return O;
      };
    }, { "../internals/an-object": 227, "../internals/descriptors": 247, "../internals/ie8-dom-define": 279, "../internals/to-property-key": 346, "../internals/v8-prototype-define-bug": 352 }], 309: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var call = require2("../internals/function-call");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toPropertyKey2 = require2("../internals/to-property-key");
      var hasOwn = require2("../internals/has-own-property");
      var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPropertyKey2(P);
        if (IE8_DOM_DEFINE)
          try {
            return $getOwnPropertyDescriptor(O, P);
          } catch (error) {
          }
        if (hasOwn(O, P))
          return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
      };
    }, { "../internals/create-property-descriptor": 242, "../internals/descriptors": 247, "../internals/function-call": 264, "../internals/has-own-property": 275, "../internals/ie8-dom-define": 279, "../internals/object-property-is-enumerable": 317, "../internals/to-indexed-object": 341, "../internals/to-property-key": 346 }], 310: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof-raw");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var $getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
      var arraySlice = require2("../internals/array-slice-simple");
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function getWindowNames2(it) {
        try {
          return $getOwnPropertyNames(it);
        } catch (error) {
          return arraySlice(windowNames);
        }
      };
      module2.exports.f = function getOwnPropertyNames(it) {
        return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
      };
    }, { "../internals/array-slice-simple": 230, "../internals/classof-raw": 235, "../internals/object-get-own-property-names": 311, "../internals/to-indexed-object": 341 }], 311: [function(require2, module2, exports2) {
      var internalObjectKeys = require2("../internals/object-keys-internal");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys(O, hiddenKeys);
      };
    }, { "../internals/enum-bug-keys": 258, "../internals/object-keys-internal": 315 }], 312: [function(require2, module2, exports2) {
      exports2.f = Object.getOwnPropertySymbols;
    }, {}], 313: [function(require2, module2, exports2) {
      var hasOwn = require2("../internals/has-own-property");
      var isCallable = require2("../internals/is-callable");
      var toObject = require2("../internals/to-object");
      var sharedKey = require2("../internals/shared-key");
      var CORRECT_PROTOTYPE_GETTER = require2("../internals/correct-prototype-getter");
      var IE_PROTO = sharedKey("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
        var object = toObject(O);
        if (hasOwn(object, IE_PROTO))
          return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof $Object ? ObjectPrototype : null;
      };
    }, { "../internals/correct-prototype-getter": 239, "../internals/has-own-property": 275, "../internals/is-callable": 285, "../internals/shared-key": 332, "../internals/to-object": 344 }], 314: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      module2.exports = uncurryThis({}.isPrototypeOf);
    }, { "../internals/function-uncurry-this": 268 }], 315: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var hasOwn = require2("../internals/has-own-property");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var indexOf = require2("../internals/array-includes").indexOf;
      var hiddenKeys = require2("../internals/hidden-keys");
      var push = uncurryThis([].push);
      module2.exports = function(object, names2) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O)
          !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
        while (names2.length > i)
          if (hasOwn(O, key = names2[i++])) {
            ~indexOf(result, key) || push(result, key);
          }
        return result;
      };
    }, { "../internals/array-includes": 228, "../internals/function-uncurry-this": 268, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/to-indexed-object": 341 }], 316: [function(require2, module2, exports2) {
      var internalObjectKeys = require2("../internals/object-keys-internal");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      module2.exports = Object.keys || function keys2(O) {
        return internalObjectKeys(O, enumBugKeys);
      };
    }, { "../internals/enum-bug-keys": 258, "../internals/object-keys-internal": 315 }], 317: [function(require2, module2, exports2) {
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }, {}], 318: [function(require2, module2, exports2) {
      var uncurryThisAccessor = require2("../internals/function-uncurry-this-accessor");
      var anObject = require2("../internals/an-object");
      var aPossiblePrototype = require2("../internals/a-possible-prototype");
      module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
          setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
          setter(test, []);
          CORRECT_SETTER = test instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O, proto) {
          anObject(O);
          aPossiblePrototype(proto);
          if (CORRECT_SETTER)
            setter(O, proto);
          else
            O.__proto__ = proto;
          return O;
        };
      }() : void 0);
    }, { "../internals/a-possible-prototype": 224, "../internals/an-object": 227, "../internals/function-uncurry-this-accessor": 266 }], 319: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var objectGetPrototypeOf = require2("../internals/object-get-prototype-of");
      var objectKeys = require2("../internals/object-keys");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var $propertyIsEnumerable = require2("../internals/object-property-is-enumerable").f;
      var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
      var push = uncurryThis([].push);
      var IE_BUG = DESCRIPTORS && fails(function() {
        var O = /* @__PURE__ */ Object.create(null);
        O[2] = 2;
        return !propertyIsEnumerable(O, 2);
      });
      var createMethod = function createMethod2(TO_ENTRIES) {
        return function(it) {
          var O = toIndexedObject(it);
          var keys2 = objectKeys(O);
          var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
          var length = keys2.length;
          var i = 0;
          var result = [];
          var key;
          while (length > i) {
            key = keys2[i++];
            if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
              push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
            }
          }
          return result;
        };
      };
      module2.exports = {
        // `Object.entries` method
        // https://tc39.es/ecma262/#sec-object.entries
        entries: createMethod(true),
        // `Object.values` method
        // https://tc39.es/ecma262/#sec-object.values
        values: createMethod(false)
      };
    }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-uncurry-this": 268, "../internals/object-get-prototype-of": 313, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/to-indexed-object": 341 }], 320: [function(require2, module2, exports2) {
      var call = require2("../internals/function-call");
      var isCallable = require2("../internals/is-callable");
      var isObject = require2("../internals/is-object");
      var $TypeError = TypeError;
      module2.exports = function(input, pref) {
        var fn, val;
        if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
          return val;
        if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
          return val;
        if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
          return val;
        throw new $TypeError("Can't convert object to primitive value");
      };
    }, { "../internals/function-call": 264, "../internals/is-callable": 285, "../internals/is-object": 289 }], 321: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var anObject = require2("../internals/an-object");
      var concat = uncurryThis([].concat);
      module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
        var keys2 = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
      };
    }, { "../internals/an-object": 227, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/object-get-own-property-names": 311, "../internals/object-get-own-property-symbols": 312 }], 322: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      module2.exports = global2;
    }, { "../internals/global": 274 }], 323: [function(require2, module2, exports2) {
      module2.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error) {
          return { error: true, value: error };
        }
      };
    }, {}], 324: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var isCallable = require2("../internals/is-callable");
      var isForced = require2("../internals/is-forced");
      var inspectSource = require2("../internals/inspect-source");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var IS_BROWSER = require2("../internals/engine-is-browser");
      var IS_DENO = require2("../internals/engine-is-deno");
      var IS_PURE = require2("../internals/is-pure");
      var V8_VERSION = require2("../internals/engine-v8-version");
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var SPECIES = wellKnownSymbol("species");
      var SUBCLASSING = false;
      var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
      var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
          return true;
        if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
          return true;
        if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
          var promise = new NativePromiseConstructor(function(resolve) {
            resolve(1);
          });
          var FakePromise = function FakePromise2(exec) {
            exec(function() {
            }, function() {
            });
          };
          var constructor = promise.constructor = {};
          constructor[SPECIES] = FakePromise;
          SUBCLASSING = promise.then(function() {
          }) instanceof FakePromise;
          if (!SUBCLASSING)
            return true;
        }
        return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
      });
      module2.exports = { CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR, REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT, SUBCLASSING };
    }, { "../internals/engine-is-browser": 250, "../internals/engine-is-deno": 251, "../internals/engine-v8-version": 257, "../internals/global": 274, "../internals/inspect-source": 281, "../internals/is-callable": 285, "../internals/is-forced": 287, "../internals/is-pure": 290, "../internals/promise-native-constructor": 325, "../internals/well-known-symbol": 357 }], 325: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      module2.exports = global2.Promise;
    }, { "../internals/global": 274 }], 326: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var isObject = require2("../internals/is-object");
      var newPromiseCapability = require2("../internals/new-promise-capability");
      module2.exports = function(C, x) {
        anObject(C);
        if (isObject(x) && x.constructor === C)
          return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }, { "../internals/an-object": 227, "../internals/is-object": 289, "../internals/new-promise-capability": 303 }], 327: [function(require2, module2, exports2) {
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
      var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
      module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
        NativePromiseConstructor.all(iterable).then(void 0, function() {
        });
      });
    }, { "../internals/check-correctness-of-iteration": 234, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325 }], 328: [function(require2, module2, exports2) {
      var Queue = function Queue2() {
        this.head = null;
        this.tail = null;
      };
      Queue.prototype = { add: function add(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      }, get: function get() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      } };
      module2.exports = Queue;
    }, {}], 329: [function(require2, module2, exports2) {
      var isNullOrUndefined = require2("../internals/is-null-or-undefined");
      var $TypeError = TypeError;
      module2.exports = function(it) {
        if (isNullOrUndefined(it))
          throw new $TypeError("Can't call method on " + it);
        return it;
      };
    }, { "../internals/is-null-or-undefined": 288 }], 330: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var DESCRIPTORS = require2("../internals/descriptors");
      var SPECIES = wellKnownSymbol("species");
      module2.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineBuiltInAccessor(Constructor, SPECIES, { configurable: true, get: function get() {
            return this;
          } });
        }
      };
    }, { "../internals/define-built-in-accessor": 244, "../internals/descriptors": 247, "../internals/get-built-in": 269, "../internals/well-known-symbol": 357 }], 331: [function(require2, module2, exports2) {
      var defineProperty = require2("../internals/object-define-property").f;
      var hasOwn = require2("../internals/has-own-property");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module2.exports = function(target, TAG, STATIC) {
        if (target && !STATIC)
          target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/well-known-symbol": 357 }], 332: [function(require2, module2, exports2) {
      var shared = require2("../internals/shared");
      var uid = require2("../internals/uid");
      var keys2 = shared("keys");
      module2.exports = function(key) {
        return keys2[key] || (keys2[key] = uid(key));
      };
    }, { "../internals/shared": 334, "../internals/uid": 350 }], 333: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var defineGlobalProperty = require2("../internals/define-global-property");
      var SHARED = "__core-js_shared__";
      var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
      module2.exports = store;
    }, { "../internals/define-global-property": 246, "../internals/global": 274 }], 334: [function(require2, module2, exports2) {
      var IS_PURE = require2("../internals/is-pure");
      var store = require2("../internals/shared-store");
      (module2.exports = function(key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({ version: "3.33.0", mode: IS_PURE ? "pure" : "global", copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE", source: "https://github.com/zloirock/core-js" });
    }, { "../internals/is-pure": 290, "../internals/shared-store": 333 }], 335: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var aConstructor = require2("../internals/a-constructor");
      var isNullOrUndefined = require2("../internals/is-null-or-undefined");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var SPECIES = wellKnownSymbol("species");
      module2.exports = function(O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === void 0 || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
      };
    }, { "../internals/a-constructor": 223, "../internals/an-object": 227, "../internals/is-null-or-undefined": 288, "../internals/well-known-symbol": 357 }], 336: [function(require2, module2, exports2) {
      var V8_VERSION = require2("../internals/engine-v8-version");
      var fails = require2("../internals/fails");
      var global2 = require2("../internals/global");
      var $String = global2.String;
      module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol("symbol detection");
        return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }, { "../internals/engine-v8-version": 257, "../internals/fails": 260, "../internals/global": 274 }], 337: [function(require2, module2, exports2) {
      var call = require2("../internals/function-call");
      var getBuiltIn = require2("../internals/get-built-in");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var defineBuiltIn = require2("../internals/define-built-in");
      module2.exports = function() {
        var Symbol2 = getBuiltIn("Symbol");
        var SymbolPrototype = Symbol2 && Symbol2.prototype;
        var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
          defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
            return call(valueOf, this);
          }, { arity: 1 });
        }
      };
    }, { "../internals/define-built-in": 245, "../internals/function-call": 264, "../internals/get-built-in": 269, "../internals/well-known-symbol": 357 }], 338: [function(require2, module2, exports2) {
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      module2.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
    }, { "../internals/symbol-constructor-detection": 336 }], 339: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var apply = require2("../internals/function-apply");
      var bind2 = require2("../internals/function-bind-context");
      var isCallable = require2("../internals/is-callable");
      var hasOwn = require2("../internals/has-own-property");
      var fails = require2("../internals/fails");
      var html = require2("../internals/html");
      var arraySlice = require2("../internals/array-slice");
      var createElement = require2("../internals/document-create-element");
      var validateArgumentsLength = require2("../internals/validate-arguments-length");
      var IS_IOS = require2("../internals/engine-is-ios");
      var IS_NODE = require2("../internals/engine-is-node");
      var set = global2.setImmediate;
      var clear = global2.clearImmediate;
      var process2 = global2.process;
      var Dispatch = global2.Dispatch;
      var Function2 = global2.Function;
      var MessageChannel2 = global2.MessageChannel;
      var String2 = global2.String;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var $location, defer, channel, port;
      fails(function() {
        $location = global2.location;
      });
      var run = function run2(id) {
        if (hasOwn(queue, id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var runner = function runner2(id) {
        return function() {
          run(id);
        };
      };
      var eventListener = function eventListener2(event) {
        run(event.data);
      };
      var globalPostMessageDefer = function globalPostMessageDefer2(id) {
        global2.postMessage(String2(id), $location.protocol + "//" + $location.host);
      };
      if (!set || !clear) {
        set = function setImmediate(handler) {
          validateArgumentsLength(arguments.length, 1);
          var fn = isCallable(handler) ? handler : Function2(handler);
          var args = arraySlice(arguments, 1);
          queue[++counter] = function() {
            apply(fn, void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue[id];
        };
        if (IS_NODE) {
          defer = function defer2(id) {
            process2.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function defer2(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel2 && !IS_IOS) {
          channel = new MessageChannel2();
          port = channel.port2;
          channel.port1.onmessage = eventListener;
          defer = bind2(port.postMessage, port);
        } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
          defer = globalPostMessageDefer;
          global2.addEventListener("message", eventListener, false);
        } else if (ONREADYSTATECHANGE in createElement("script")) {
          defer = function defer2(id) {
            html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function defer2(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module2.exports = { set, clear };
    }, { "../internals/array-slice": 231, "../internals/document-create-element": 249, "../internals/engine-is-ios": 253, "../internals/engine-is-node": 254, "../internals/fails": 260, "../internals/function-apply": 261, "../internals/function-bind-context": 262, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/html": 278, "../internals/is-callable": 285, "../internals/validate-arguments-length": 353 }], 340: [function(require2, module2, exports2) {
      var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
      var max = Math.max;
      var min = Math.min;
      module2.exports = function(index2, length) {
        var integer = toIntegerOrInfinity(index2);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }, { "../internals/to-integer-or-infinity": 342 }], 341: [function(require2, module2, exports2) {
      var IndexedObject = require2("../internals/indexed-object");
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      module2.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }, { "../internals/indexed-object": 280, "../internals/require-object-coercible": 329 }], 342: [function(require2, module2, exports2) {
      var trunc = require2("../internals/math-trunc");
      module2.exports = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : trunc(number);
      };
    }, { "../internals/math-trunc": 301 }], 343: [function(require2, module2, exports2) {
      var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
      var min = Math.min;
      module2.exports = function(argument) {
        return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
      };
    }, { "../internals/to-integer-or-infinity": 342 }], 344: [function(require2, module2, exports2) {
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      var $Object = Object;
      module2.exports = function(argument) {
        return $Object(requireObjectCoercible(argument));
      };
    }, { "../internals/require-object-coercible": 329 }], 345: [function(require2, module2, exports2) {
      var call = require2("../internals/function-call");
      var isObject = require2("../internals/is-object");
      var isSymbol = require2("../internals/is-symbol");
      var getMethod = require2("../internals/get-method");
      var ordinaryToPrimitive = require2("../internals/ordinary-to-primitive");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module2.exports = function(input, pref) {
        if (!isObject(input) || isSymbol(input))
          return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0)
            pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject(result) || isSymbol(result))
            return result;
          throw new $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0)
          pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }, { "../internals/function-call": 264, "../internals/get-method": 273, "../internals/is-object": 289, "../internals/is-symbol": 292, "../internals/ordinary-to-primitive": 320, "../internals/well-known-symbol": 357 }], 346: [function(require2, module2, exports2) {
      var toPrimitive2 = require2("../internals/to-primitive");
      var isSymbol = require2("../internals/is-symbol");
      module2.exports = function(argument) {
        var key = toPrimitive2(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }, { "../internals/is-symbol": 292, "../internals/to-primitive": 345 }], 347: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module2.exports = String(test) === "[object z]";
    }, { "../internals/well-known-symbol": 357 }], 348: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof");
      var $String = String;
      module2.exports = function(argument) {
        if (classof(argument) === "Symbol")
          throw new TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    }, { "../internals/classof": 236 }], 349: [function(require2, module2, exports2) {
      var $String = String;
      module2.exports = function(argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    }, {}], 350: [function(require2, module2, exports2) {
      var uncurryThis = require2("../internals/function-uncurry-this");
      var id = 0;
      var postfix = Math.random();
      var toString2 = uncurryThis(1 .toString);
      module2.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
      };
    }, { "../internals/function-uncurry-this": 268 }], 351: [function(require2, module2, exports2) {
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }, { "../internals/symbol-constructor-detection": 336 }], 352: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      module2.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype !== 42;
      });
    }, { "../internals/descriptors": 247, "../internals/fails": 260 }], 353: [function(require2, module2, exports2) {
      var $TypeError = TypeError;
      module2.exports = function(passed, required) {
        if (passed < required)
          throw new $TypeError("Not enough arguments");
        return passed;
      };
    }, {}], 354: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var isCallable = require2("../internals/is-callable");
      var WeakMap2 = global2.WeakMap;
      module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    }, { "../internals/global": 274, "../internals/is-callable": 285 }], 355: [function(require2, module2, exports2) {
      var path = require2("../internals/path");
      var hasOwn = require2("../internals/has-own-property");
      var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
      var defineProperty = require2("../internals/object-define-property").f;
      module2.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!hasOwn(Symbol2, NAME))
          defineProperty(Symbol2, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });
      };
    }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/path": 322, "../internals/well-known-symbol-wrapped": 356 }], 356: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      exports2.f = wellKnownSymbol;
    }, { "../internals/well-known-symbol": 357 }], 357: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var shared = require2("../internals/shared");
      var hasOwn = require2("../internals/has-own-property");
      var uid = require2("../internals/uid");
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
      var Symbol2 = global2.Symbol;
      var WellKnownSymbolsStore = shared("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module2.exports = function(name) {
        if (!hasOwn(WellKnownSymbolsStore, name)) {
          WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
    }, { "../internals/global": 274, "../internals/has-own-property": 275, "../internals/shared": 334, "../internals/symbol-constructor-detection": 336, "../internals/uid": 350, "../internals/use-symbol-as-uid": 351 }], 358: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var $findIndex = require2("../internals/array-iteration").findIndex;
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      if (FIND_INDEX in [])
        Array(1)[FIND_INDEX](function() {
          SKIPS_HOLES = false;
        });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, { findIndex: function findIndex(callbackfn) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables(FIND_INDEX);
    }, { "../internals/add-to-unscopables": 225, "../internals/array-iteration": 229, "../internals/export": 259 }], 359: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var $find = require2("../internals/array-iteration").find;
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var FIND = "find";
      var SKIPS_HOLES = true;
      if (FIND in [])
        Array(1)[FIND](function() {
          SKIPS_HOLES = false;
        });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, { find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables(FIND);
    }, { "../internals/add-to-unscopables": 225, "../internals/array-iteration": 229, "../internals/export": 259 }], 360: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var $includes = require2("../internals/array-includes").includes;
      var fails = require2("../internals/fails");
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var BROKEN_ON_SPARSE = fails(function() {
        return !Array(1).includes();
      });
      $2({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, { includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables("includes");
    }, { "../internals/add-to-unscopables": 225, "../internals/array-includes": 228, "../internals/export": 259, "../internals/fails": 260 }], 361: [function(require2, module2, exports2) {
      var toIndexedObject = require2("../internals/to-indexed-object");
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var Iterators = require2("../internals/iterators");
      var InternalStateModule = require2("../internals/internal-state");
      var defineProperty = require2("../internals/object-define-property").f;
      var defineIterator = require2("../internals/iterator-define");
      var createIterResultObject = require2("../internals/create-iter-result-object");
      var IS_PURE = require2("../internals/is-pure");
      var DESCRIPTORS = require2("../internals/descriptors");
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var kind = state.kind;
        var index2 = state.index++;
        if (!target || index2 >= target.length) {
          state.target = void 0;
          return createIterResultObject(void 0, true);
        }
        switch (kind) {
          case "keys":
            return createIterResultObject(index2, false);
          case "values":
            return createIterResultObject(target[index2], false);
        }
        return createIterResultObject([index2, target[index2]], false);
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values")
        try {
          defineProperty(values, "name", { value: "values" });
        } catch (error) {
        }
    }, { "../internals/add-to-unscopables": 225, "../internals/create-iter-result-object": 240, "../internals/descriptors": 247, "../internals/internal-state": 282, "../internals/is-pure": 290, "../internals/iterator-define": 296, "../internals/iterators": 298, "../internals/object-define-property": 308, "../internals/to-indexed-object": 341 }], 362: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var getBuiltIn = require2("../internals/get-built-in");
      var apply = require2("../internals/function-apply");
      var call = require2("../internals/function-call");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var fails = require2("../internals/fails");
      var isCallable = require2("../internals/is-callable");
      var isSymbol = require2("../internals/is-symbol");
      var arraySlice = require2("../internals/array-slice");
      var getReplacerFunction = require2("../internals/get-json-replacer-function");
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      var $String = String;
      var $stringify = getBuiltIn("JSON", "stringify");
      var exec = uncurryThis(/./.exec);
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var replace = uncurryThis("".replace);
      var numberToString = uncurryThis(1 .toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi = /^[\uDC00-\uDFFF]$/;
      var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
        var symbol = getBuiltIn("Symbol")("stringify detection");
        return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
      });
      var ILL_FORMED_UNICODE = fails(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      var stringifyWithSymbolsFix = function stringifyWithSymbolsFix2(it, replacer) {
        var args = arraySlice(arguments);
        var $replacer = getReplacerFunction(replacer);
        if (!isCallable($replacer) && (it === void 0 || isSymbol(it)))
          return;
        args[1] = function(key, value) {
          if (isCallable($replacer))
            value = call($replacer, this, $String(key), value);
          if (!isSymbol(value))
            return value;
        };
        return apply($stringify, null, args);
      };
      var fixIllFormed = function fixIllFormed2(match, offset, string) {
        var prev = charAt(string, offset - 1);
        var next = charAt(string, offset + 1);
        if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match, 0), 16);
        }
        return match;
      };
      if ($stringify) {
        $2({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          stringify: function stringify(it, replacer, space) {
            var args = arraySlice(arguments);
            var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
            return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
          }
        });
      }
    }, { "../internals/array-slice": 231, "../internals/export": 259, "../internals/fails": 260, "../internals/function-apply": 261, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/get-json-replacer-function": 272, "../internals/is-callable": 285, "../internals/is-symbol": 292, "../internals/symbol-constructor-detection": 336 }], 363: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      $2({ target: "Number", stat: true }, { isNaN: function isNaN2(number) {
        return number !== number;
      } });
    }, { "../internals/export": 259 }], 364: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var assign = require2("../internals/object-assign");
      $2({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, { assign });
    }, { "../internals/export": 259, "../internals/object-assign": 305 }], 365: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      var fails = require2("../internals/fails");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var toObject = require2("../internals/to-object");
      var FORCED = !NATIVE_SYMBOL || fails(function() {
        getOwnPropertySymbolsModule.f(1);
      });
      $2({ target: "Object", stat: true, forced: FORCED }, { getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
      } });
    }, { "../internals/export": 259, "../internals/fails": 260, "../internals/object-get-own-property-symbols": 312, "../internals/symbol-constructor-detection": 336, "../internals/to-object": 344 }], 366: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var toObject = require2("../internals/to-object");
      var nativeKeys = require2("../internals/object-keys");
      var fails = require2("../internals/fails");
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, { keys: function keys2(it) {
        return nativeKeys(toObject(it));
      } });
    }, { "../internals/export": 259, "../internals/fails": 260, "../internals/object-keys": 316, "../internals/to-object": 344 }], 367: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var $values = require2("../internals/object-to-array").values;
      $2({ target: "Object", stat: true }, { values: function values(O) {
        return $values(O);
      } });
    }, { "../internals/export": 259, "../internals/object-to-array": 319 }], 368: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var call = require2("../internals/function-call");
      var aCallable = require2("../internals/a-callable");
      var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
      var perform = require2("../internals/perform");
      var iterate = require2("../internals/iterate");
      var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, { all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index2 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index2] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      } });
    }, { "../internals/a-callable": 222, "../internals/export": 259, "../internals/function-call": 264, "../internals/iterate": 293, "../internals/new-promise-capability": 303, "../internals/perform": 323, "../internals/promise-statics-incorrect-iteration": 327 }], 369: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var IS_PURE = require2("../internals/is-pure");
      var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var getBuiltIn = require2("../internals/get-built-in");
      var isCallable = require2("../internals/is-callable");
      var defineBuiltIn = require2("../internals/define-built-in");
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, { "catch": function _catch(onRejected) {
        return this.then(void 0, onRejected);
      } });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        var method = getBuiltIn("Promise").prototype["catch"];
        if (NativePromisePrototype["catch"] !== method) {
          defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
        }
      }
    }, { "../internals/define-built-in": 245, "../internals/export": 259, "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325 }], 370: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var IS_PURE = require2("../internals/is-pure");
      var IS_NODE = require2("../internals/engine-is-node");
      var global2 = require2("../internals/global");
      var call = require2("../internals/function-call");
      var defineBuiltIn = require2("../internals/define-built-in");
      var setPrototypeOf = require2("../internals/object-set-prototype-of");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var setSpecies = require2("../internals/set-species");
      var aCallable = require2("../internals/a-callable");
      var isCallable = require2("../internals/is-callable");
      var isObject = require2("../internals/is-object");
      var anInstance = require2("../internals/an-instance");
      var speciesConstructor = require2("../internals/species-constructor");
      var task = require2("../internals/task").set;
      var microtask = require2("../internals/microtask");
      var hostReportErrors = require2("../internals/host-report-errors");
      var perform = require2("../internals/perform");
      var Queue = require2("../internals/queue");
      var InternalStateModule = require2("../internals/internal-state");
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var PromiseConstructorDetection = require2("../internals/promise-constructor-detection");
      var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
      var PROMISE = "Promise";
      var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
      var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
      var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var setInternalState = InternalStateModule.set;
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var PromiseConstructor = NativePromiseConstructor;
      var PromisePrototype = NativePromisePrototype;
      var TypeError2 = global2.TypeError;
      var document2 = global2.document;
      var process2 = global2.process;
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
      var isThenable = function isThenable2(it) {
        var then;
        return isObject(it) && isCallable(then = it.then) ? then : false;
      };
      var callReaction = function callReaction2(reaction, state) {
        var value = state.value;
        var ok = state.state === FULFILLED;
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED)
                onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true)
              result = value;
            else {
              if (domain)
                domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(new TypeError2("Promise-chain cycle"));
            } else if (then = isThenable(result)) {
              call(then, result, resolve, reject);
            } else
              resolve(result);
          } else
            reject(value);
        } catch (error) {
          if (domain && !exited)
            domain.exit();
          reject(error);
        }
      };
      var notify = function notify2(state, isReject) {
        if (state.notified)
          return;
        state.notified = true;
        microtask(function() {
          var reactions = state.reactions;
          var reaction;
          while (reaction = reactions.get()) {
            callReaction(reaction, state);
          }
          state.notified = false;
          if (isReject && !state.rejection)
            onUnhandled(state);
        });
      };
      var dispatchEvent = function dispatchEvent2(name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document2.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name, false, true);
          global2.dispatchEvent(event);
        } else
          event = { promise, reason };
        if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name]))
          handler(event);
        else if (name === UNHANDLED_REJECTION)
          hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function onUnhandled2(state) {
        call(task, global2, function() {
          var promise = state.facade;
          var value = state.value;
          var IS_UNHANDLED = isUnhandled(state);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process2.emit("unhandledRejection", value, promise);
              } else
                dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error)
              throw result.value;
          }
        });
      };
      var isUnhandled = function isUnhandled2(state) {
        return state.rejection !== HANDLED && !state.parent;
      };
      var onHandleUnhandled = function onHandleUnhandled2(state) {
        call(task, global2, function() {
          var promise = state.facade;
          if (IS_NODE) {
            process2.emit("rejectionHandled", promise);
          } else
            dispatchEvent(REJECTION_HANDLED, promise, state.value);
        });
      };
      var bind2 = function bind3(fn, state, unwrap) {
        return function(value) {
          fn(state, value, unwrap);
        };
      };
      var internalReject = function internalReject2(state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify(state, true);
      };
      var internalResolve = function internalResolve2(state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        try {
          if (state.facade === value)
            throw new TypeError2("Promise can't be resolved itself");
          var then = isThenable(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                call(then, value, bind2(internalResolve2, wrapper, state), bind2(internalReject, wrapper, state));
              } catch (error) {
                internalReject(wrapper, error, state);
              }
            });
          } else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
          }
        } catch (error) {
          internalReject({ done: false }, error, state);
        }
      };
      if (FORCED_PROMISE_CONSTRUCTOR) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromisePrototype);
          aCallable(executor);
          call(Internal, this);
          var state = getInternalPromiseState(this);
          try {
            executor(bind2(internalResolve, state), bind2(internalReject, state));
          } catch (error) {
            internalReject(state, error);
          }
        };
        PromisePrototype = PromiseConstructor.prototype;
        Internal = function Promise2(executor) {
          setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: new Queue(), rejection: false, state: PENDING, value: void 0 });
        };
        Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          state.parent = true;
          reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
          reaction.fail = isCallable(onRejected) && onRejected;
          reaction.domain = IS_NODE ? process2.domain : void 0;
          if (state.state === PENDING)
            state.reactions.add(reaction);
          else
            microtask(function() {
              callReaction(reaction, state);
            });
          return reaction.promise;
        });
        OwnPromiseCapability = function OwnPromiseCapability2() {
          var promise = new Internal();
          var state = getInternalPromiseState(promise);
          this.promise = promise;
          this.resolve = bind2(internalResolve, state);
          this.reject = bind2(internalReject, state);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability2(C) {
          return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
        if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
          nativeThen = NativePromisePrototype.then;
          if (!NATIVE_PROMISE_SUBCLASSING) {
            defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
              var that = this;
              return new PromiseConstructor(function(resolve, reject) {
                call(nativeThen, that, resolve, reject);
              }).then(onFulfilled, onRejected);
            }, { unsafe: true });
          }
          try {
            delete NativePromisePrototype.constructor;
          } catch (error) {
          }
          if (setPrototypeOf) {
            setPrototypeOf(NativePromisePrototype, PromisePrototype);
          }
        }
      }
      $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, { Promise: PromiseConstructor });
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
    }, { "../internals/a-callable": 222, "../internals/an-instance": 226, "../internals/define-built-in": 245, "../internals/engine-is-node": 254, "../internals/export": 259, "../internals/function-call": 264, "../internals/global": 274, "../internals/host-report-errors": 277, "../internals/internal-state": 282, "../internals/is-callable": 285, "../internals/is-object": 289, "../internals/is-pure": 290, "../internals/microtask": 302, "../internals/new-promise-capability": 303, "../internals/object-set-prototype-of": 318, "../internals/perform": 323, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325, "../internals/queue": 328, "../internals/set-species": 330, "../internals/set-to-string-tag": 331, "../internals/species-constructor": 335, "../internals/task": 339 }], 371: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var IS_PURE = require2("../internals/is-pure");
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var fails = require2("../internals/fails");
      var getBuiltIn = require2("../internals/get-built-in");
      var isCallable = require2("../internals/is-callable");
      var speciesConstructor = require2("../internals/species-constructor");
      var promiseResolve = require2("../internals/promise-resolve");
      var defineBuiltIn = require2("../internals/define-built-in");
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
        NativePromisePrototype["finally"].call({ then: function then() {
        } }, function() {
        });
      });
      $2({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, { "finally": function _finally(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction = isCallable(onFinally);
        return this.then(isFunction ? function(x) {
          return promiseResolve(C, onFinally()).then(function() {
            return x;
          });
        } : onFinally, isFunction ? function(e) {
          return promiseResolve(C, onFinally()).then(function() {
            throw e;
          });
        } : onFinally);
      } });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        var method = getBuiltIn("Promise").prototype["finally"];
        if (NativePromisePrototype["finally"] !== method) {
          defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
        }
      }
    }, { "../internals/define-built-in": 245, "../internals/export": 259, "../internals/fails": 260, "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/promise-native-constructor": 325, "../internals/promise-resolve": 326, "../internals/species-constructor": 335 }], 372: [function(require2, module2, exports2) {
      require2("../modules/es.promise.constructor");
      require2("../modules/es.promise.all");
      require2("../modules/es.promise.catch");
      require2("../modules/es.promise.race");
      require2("../modules/es.promise.reject");
      require2("../modules/es.promise.resolve");
    }, { "../modules/es.promise.all": 368, "../modules/es.promise.catch": 369, "../modules/es.promise.constructor": 370, "../modules/es.promise.race": 373, "../modules/es.promise.reject": 374, "../modules/es.promise.resolve": 375 }], 373: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var call = require2("../internals/function-call");
      var aCallable = require2("../internals/a-callable");
      var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
      var perform = require2("../internals/perform");
      var iterate = require2("../internals/iterate");
      var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, { race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      } });
    }, { "../internals/a-callable": 222, "../internals/export": 259, "../internals/function-call": 264, "../internals/iterate": 293, "../internals/new-promise-capability": 303, "../internals/perform": 323, "../internals/promise-statics-incorrect-iteration": 327 }], 374: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var call = require2("../internals/function-call");
      var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
      var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
      $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, { reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        call(capability.reject, void 0, r);
        return capability.promise;
      } });
    }, { "../internals/export": 259, "../internals/function-call": 264, "../internals/new-promise-capability": 303, "../internals/promise-constructor-detection": 324 }], 375: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var getBuiltIn = require2("../internals/get-built-in");
      var IS_PURE = require2("../internals/is-pure");
      var NativePromiseConstructor = require2("../internals/promise-native-constructor");
      var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
      var promiseResolve = require2("../internals/promise-resolve");
      var PromiseConstructorWrapper = getBuiltIn("Promise");
      var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
      $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, { resolve: function resolve(x) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
      } });
    }, { "../internals/export": 259, "../internals/get-built-in": 269, "../internals/is-pure": 290, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325, "../internals/promise-resolve": 326 }], 376: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var toAbsoluteIndex = require2("../internals/to-absolute-index");
      var $RangeError = RangeError;
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      var join = uncurryThis([].join);
      var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
      $2({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        fromCodePoint: function fromCodePoint(x) {
          var elements = [];
          var length = arguments.length;
          var i = 0;
          var code;
          while (length > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code)
              throw new $RangeError(code + " is not a valid code point");
            elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
          }
          return join(elements, "");
        }
      });
    }, { "../internals/export": 259, "../internals/function-uncurry-this": 268, "../internals/to-absolute-index": 340 }], 377: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var notARegExp = require2("../internals/not-a-regexp");
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      var toString2 = require2("../internals/to-string");
      var correctIsRegExpLogic = require2("../internals/correct-is-regexp-logic");
      var stringIndexOf = uncurryThis("".indexOf);
      $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, { includes: function includes(searchString) {
        return !!~stringIndexOf(toString2(requireObjectCoercible(this)), toString2(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, { "../internals/correct-is-regexp-logic": 238, "../internals/export": 259, "../internals/function-uncurry-this": 268, "../internals/not-a-regexp": 304, "../internals/require-object-coercible": 329, "../internals/to-string": 348 }], 378: [function(require2, module2, exports2) {
      var defineWellKnownSymbol = require2("../internals/well-known-symbol-define");
      defineWellKnownSymbol("asyncIterator");
    }, { "../internals/well-known-symbol-define": 355 }], 379: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var global2 = require2("../internals/global");
      var call = require2("../internals/function-call");
      var uncurryThis = require2("../internals/function-uncurry-this");
      var IS_PURE = require2("../internals/is-pure");
      var DESCRIPTORS = require2("../internals/descriptors");
      var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
      var fails = require2("../internals/fails");
      var hasOwn = require2("../internals/has-own-property");
      var isPrototypeOf = require2("../internals/object-is-prototype-of");
      var anObject = require2("../internals/an-object");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toPropertyKey2 = require2("../internals/to-property-key");
      var $toString = require2("../internals/to-string");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var nativeObjectCreate = require2("../internals/object-create");
      var objectKeys = require2("../internals/object-keys");
      var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
      var getOwnPropertyNamesExternal = require2("../internals/object-get-own-property-names-external");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
      var definePropertyModule = require2("../internals/object-define-property");
      var definePropertiesModule = require2("../internals/object-define-properties");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var defineBuiltIn = require2("../internals/define-built-in");
      var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
      var shared = require2("../internals/shared");
      var sharedKey = require2("../internals/shared-key");
      var hiddenKeys = require2("../internals/hidden-keys");
      var uid = require2("../internals/uid");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
      var defineWellKnownSymbol = require2("../internals/well-known-symbol-define");
      var defineSymbolToPrimitive = require2("../internals/symbol-define-to-primitive");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var InternalStateModule = require2("../internals/internal-state");
      var $forEach = require2("../internals/array-iteration").forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = global2.Symbol;
      var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
      var RangeError2 = global2.RangeError;
      var TypeError2 = global2.TypeError;
      var QObject = global2.QObject;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push = uncurryThis([].push);
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var WellKnownSymbolsStore = shared("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var fallbackDefineProperty = function fallbackDefineProperty2(O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor)
          delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      };
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", { get: function get() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        } })).a !== 7;
      }) ? fallbackDefineProperty : nativeDefineProperty;
      var wrap = function wrap2(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
        setInternalState(symbol, { type: SYMBOL, tag, description });
        if (!DESCRIPTORS)
          symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype)
          $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPropertyKey2(P);
        anObject(Attributes);
        if (hasOwn(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn(O, HIDDEN))
              nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
            O[HIDDEN][key] = true;
          } else {
            if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
              O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys2, function(key) {
          if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
            $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create(O, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPropertyKey2(V);
        var enumerable = call(nativePropertyIsEnumerable, this, P);
        if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
          return false;
        return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPropertyKey2(P);
        if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
          return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names2 = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach(names2, function(key) {
          if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
            push(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function $getOwnPropertySymbols2(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names2 = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names2, function(key) {
          if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
            push(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf(SymbolPrototype, this))
            throw new TypeError2("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function setter2(value) {
            if (this === ObjectPrototype)
              call(setter2, ObjectPrototypeSymbols, value);
            if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
              this[HIDDEN][tag] = false;
            var descriptor = createPropertyDescriptor(1, value);
            try {
              setSymbolDescriptor(this, tag, descriptor);
            } catch (error) {
              if (!(error instanceof RangeError2))
                throw error;
              fallbackDefineProperty(this, tag, descriptor);
            }
          };
          if (DESCRIPTORS && USE_SETTER)
            setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap(tag, description);
        };
        SymbolPrototype = $Symbol[PROTOTYPE];
        defineBuiltIn(SymbolPrototype, "toString", function toString2() {
          return getInternalState(this).tag;
        });
        defineBuiltIn($Symbol, "withoutSetter", function(description) {
          return wrap(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap(wellKnownSymbol(name), name);
        };
        if (DESCRIPTORS) {
          defineBuiltInAccessor(SymbolPrototype, "description", { configurable: true, get: function description() {
            return getInternalState(this).description;
          } });
          if (!IS_PURE) {
            defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $2({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name);
      });
      $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, { useSetter: function useSetter() {
        USE_SETTER = true;
      }, useSimple: function useSimple() {
        USE_SETTER = false;
      } });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames
      });
      defineSymbolToPrimitive();
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }, { "../internals/an-object": 227, "../internals/array-iteration": 229, "../internals/create-property-descriptor": 242, "../internals/define-built-in": 245, "../internals/define-built-in-accessor": 244, "../internals/descriptors": 247, "../internals/export": 259, "../internals/fails": 260, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/internal-state": 282, "../internals/is-pure": 290, "../internals/object-create": 306, "../internals/object-define-properties": 307, "../internals/object-define-property": 308, "../internals/object-get-own-property-descriptor": 309, "../internals/object-get-own-property-names": 311, "../internals/object-get-own-property-names-external": 310, "../internals/object-get-own-property-symbols": 312, "../internals/object-is-prototype-of": 314, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/set-to-string-tag": 331, "../internals/shared": 334, "../internals/shared-key": 332, "../internals/symbol-constructor-detection": 336, "../internals/symbol-define-to-primitive": 337, "../internals/to-indexed-object": 341, "../internals/to-property-key": 346, "../internals/to-string": 348, "../internals/uid": 350, "../internals/well-known-symbol": 357, "../internals/well-known-symbol-define": 355, "../internals/well-known-symbol-wrapped": 356 }], 380: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var getBuiltIn = require2("../internals/get-built-in");
      var hasOwn = require2("../internals/has-own-property");
      var toString2 = require2("../internals/to-string");
      var shared = require2("../internals/shared");
      var NATIVE_SYMBOL_REGISTRY = require2("../internals/symbol-registry-detection");
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, { "for": function _for(key) {
        var string = toString2(key);
        if (hasOwn(StringToSymbolRegistry, string))
          return StringToSymbolRegistry[string];
        var symbol = getBuiltIn("Symbol")(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      } });
    }, { "../internals/export": 259, "../internals/get-built-in": 269, "../internals/has-own-property": 275, "../internals/shared": 334, "../internals/symbol-registry-detection": 338, "../internals/to-string": 348 }], 381: [function(require2, module2, exports2) {
      require2("../modules/es.symbol.constructor");
      require2("../modules/es.symbol.for");
      require2("../modules/es.symbol.key-for");
      require2("../modules/es.json.stringify");
      require2("../modules/es.object.get-own-property-symbols");
    }, { "../modules/es.json.stringify": 362, "../modules/es.object.get-own-property-symbols": 365, "../modules/es.symbol.constructor": 379, "../modules/es.symbol.for": 380, "../modules/es.symbol.key-for": 382 }], 382: [function(require2, module2, exports2) {
      var $2 = require2("../internals/export");
      var hasOwn = require2("../internals/has-own-property");
      var isSymbol = require2("../internals/is-symbol");
      var tryToString = require2("../internals/try-to-string");
      var shared = require2("../internals/shared");
      var NATIVE_SYMBOL_REGISTRY = require2("../internals/symbol-registry-detection");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, { keyFor: function keyFor(sym) {
        if (!isSymbol(sym))
          throw new TypeError(tryToString(sym) + " is not a symbol");
        if (hasOwn(SymbolToStringRegistry, sym))
          return SymbolToStringRegistry[sym];
      } });
    }, { "../internals/export": 259, "../internals/has-own-property": 275, "../internals/is-symbol": 292, "../internals/shared": 334, "../internals/symbol-registry-detection": 338, "../internals/try-to-string": 349 }], 383: [function(require2, module2, exports2) {
      function isArray(arg) {
        if (Array.isArray) {
          return Array.isArray(arg);
        }
        return objectToString(arg) === "[object Array]";
      }
      exports2.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d) {
        return objectToString(d) === "[object Date]";
      }
      exports2.isDate = isDate;
      function isError(e) {
        return objectToString(e) === "[object Error]" || e instanceof Error;
      }
      exports2.isError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = require2("buffer").Buffer.isBuffer;
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
    }, { "buffer": 220 }], 384: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var elliptic = require2("elliptic");
          var BN = require2("bn.js");
          module2.exports = function createECDH(curve) {
            return new ECDH(curve);
          };
          var aliases = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
          aliases.p224 = aliases.secp224r1;
          aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
          aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
          aliases.p384 = aliases.secp384r1;
          aliases.p521 = aliases.secp521r1;
          function ECDH(curve) {
            this.curveType = aliases[curve];
            if (!this.curveType) {
              this.curveType = { name: curve };
            }
            this.curve = new elliptic.ec(this.curveType.name);
            this.keys = void 0;
          }
          ECDH.prototype.generateKeys = function(enc, format) {
            this.keys = this.curve.genKeyPair();
            return this.getPublicKey(enc, format);
          };
          ECDH.prototype.computeSecret = function(other, inenc, enc) {
            inenc = inenc || "utf8";
            if (!Buffer2.isBuffer(other)) {
              other = new Buffer2(other, inenc);
            }
            var otherPub = this.curve.keyFromPublic(other).getPublic();
            var out = otherPub.mul(this.keys.getPrivate()).getX();
            return formatReturnValue(out, enc, this.curveType.byteLength);
          };
          ECDH.prototype.getPublicKey = function(enc, format) {
            var key = this.keys.getPublic(format === "compressed", true);
            if (format === "hybrid") {
              if (key[key.length - 1] % 2) {
                key[0] = 7;
              } else {
                key[0] = 6;
              }
            }
            return formatReturnValue(key, enc);
          };
          ECDH.prototype.getPrivateKey = function(enc) {
            return formatReturnValue(this.keys.getPrivate(), enc);
          };
          ECDH.prototype.setPublicKey = function(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer2.isBuffer(pub)) {
              pub = new Buffer2(pub, enc);
            }
            this.keys._importPublic(pub);
            return this;
          };
          ECDH.prototype.setPrivateKey = function(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer2.isBuffer(priv)) {
              priv = new Buffer2(priv, enc);
            }
            var _priv = new BN(priv);
            _priv = _priv.toString(16);
            this.keys = this.curve.genKeyPair();
            this.keys._importPrivate(_priv);
            return this;
          };
          function formatReturnValue(bn, enc, len) {
            if (!Array.isArray(bn)) {
              bn = bn.toArray();
            }
            var buf = new Buffer2(bn);
            if (len && buf.length < len) {
              var zeros = new Buffer2(len - buf.length);
              zeros.fill(0);
              buf = Buffer2.concat([zeros, buf]);
            }
            if (!enc) {
              return buf;
            } else {
              return buf.toString(enc);
            }
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 385, "buffer": 220, "elliptic": 405 }], 385: [function(require2, module2, exports2) {
      arguments[4][184][0].apply(exports2, arguments);
    }, { "buffer": 188, "dup": 184 }], 386: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var MD5 = require2("md5.js");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Base = require2("cipher-base");
      function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
      }
      inherits(Hash, Base);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      module2.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5")
          return new MD5();
        if (alg === "rmd160" || alg === "ripemd160")
          return new RIPEMD160();
        return new Hash(sha(alg));
      };
    }, { "cipher-base": 221, "inherits": 440, "md5.js": 450, "ripemd160": 493, "sha.js": 498 }], 387: [function(require2, module2, exports2) {
      var MD5 = require2("md5.js");
      module2.exports = function(buffer) {
        return new MD5().update(buffer).digest();
      };
    }, { "md5.js": 450 }], 388: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Legacy = require2("./legacy");
      var Base = require2("cipher-base");
      var Buffer2 = require2("safe-buffer").Buffer;
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var ZEROS = Buffer2.alloc(128);
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer2.from(key);
        }
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
          key = hash.update(key).digest();
        } else if (key.length < blocksize) {
          key = Buffer2.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
        var opad = this._opad = Buffer2.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        this._hash.update(ipad);
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hmac.prototype._final = function() {
        var h3 = this._hash.digest();
        var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
        return hash.update(this._opad).update(h3).digest();
      };
      module2.exports = function createHmac(alg, key) {
        alg = alg.toLowerCase();
        if (alg === "rmd160" || alg === "ripemd160") {
          return new Hmac("rmd160", key);
        }
        if (alg === "md5") {
          return new Legacy(md5, key);
        }
        return new Hmac(alg, key);
      };
    }, { "./legacy": 389, "cipher-base": 221, "create-hash/md5": 387, "inherits": 440, "ripemd160": 493, "safe-buffer": 494, "sha.js": 498 }], 389: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer2 = require2("safe-buffer").Buffer;
      var Base = require2("cipher-base");
      var ZEROS = Buffer2.alloc(128);
      var blocksize = 64;
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer2.from(key);
        }
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          key = alg(key);
        } else if (key.length < blocksize) {
          key = Buffer2.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
        var opad = this._opad = Buffer2.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = [ipad];
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.push(data);
      };
      Hmac.prototype._final = function() {
        var h3 = this._alg(Buffer2.concat(this._hash));
        return this._alg(Buffer2.concat([this._opad, h3]));
      };
      module2.exports = Hmac;
    }, { "cipher-base": 221, "inherits": 440, "safe-buffer": 494 }], 390: [function(require2, module2, exports2) {
      exports2.randomBytes = exports2.rng = exports2.pseudoRandomBytes = exports2.prng = require2("randombytes");
      exports2.createHash = exports2.Hash = require2("create-hash");
      exports2.createHmac = exports2.Hmac = require2("create-hmac");
      var algos = require2("browserify-sign/algos");
      var algoKeys = Object.keys(algos);
      var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
      exports2.getHashes = function() {
        return hashes;
      };
      var p = require2("pbkdf2");
      exports2.pbkdf2 = p.pbkdf2;
      exports2.pbkdf2Sync = p.pbkdf2Sync;
      var aes = require2("browserify-cipher");
      exports2.Cipher = aes.Cipher;
      exports2.createCipher = aes.createCipher;
      exports2.Cipheriv = aes.Cipheriv;
      exports2.createCipheriv = aes.createCipheriv;
      exports2.Decipher = aes.Decipher;
      exports2.createDecipher = aes.createDecipher;
      exports2.Decipheriv = aes.Decipheriv;
      exports2.createDecipheriv = aes.createDecipheriv;
      exports2.getCiphers = aes.getCiphers;
      exports2.listCiphers = aes.listCiphers;
      var dh = require2("diffie-hellman");
      exports2.DiffieHellmanGroup = dh.DiffieHellmanGroup;
      exports2.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
      exports2.getDiffieHellman = dh.getDiffieHellman;
      exports2.createDiffieHellman = dh.createDiffieHellman;
      exports2.DiffieHellman = dh.DiffieHellman;
      var sign = require2("browserify-sign");
      exports2.createSign = sign.createSign;
      exports2.Sign = sign.Sign;
      exports2.createVerify = sign.createVerify;
      exports2.Verify = sign.Verify;
      exports2.createECDH = require2("create-ecdh");
      var publicEncrypt = require2("public-encrypt");
      exports2.publicEncrypt = publicEncrypt.publicEncrypt;
      exports2.privateEncrypt = publicEncrypt.privateEncrypt;
      exports2.publicDecrypt = publicEncrypt.publicDecrypt;
      exports2.privateDecrypt = publicEncrypt.privateDecrypt;
      var rf = require2("randomfill");
      exports2.randomFill = rf.randomFill;
      exports2.randomFillSync = rf.randomFillSync;
      exports2.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
      };
      exports2.constants = { "DH_CHECK_P_NOT_SAFE_PRIME": 2, "DH_CHECK_P_NOT_PRIME": 1, "DH_UNABLE_TO_CHECK_GENERATOR": 4, "DH_NOT_SUITABLE_GENERATOR": 8, "NPN_ENABLED": 1, "ALPN_ENABLED": 1, "RSA_PKCS1_PADDING": 1, "RSA_SSLV23_PADDING": 2, "RSA_NO_PADDING": 3, "RSA_PKCS1_OAEP_PADDING": 4, "RSA_X931_PADDING": 5, "RSA_PKCS1_PSS_PADDING": 6, "POINT_CONVERSION_COMPRESSED": 2, "POINT_CONVERSION_UNCOMPRESSED": 4, "POINT_CONVERSION_HYBRID": 6 };
    }, { "browserify-cipher": 206, "browserify-sign": 213, "browserify-sign/algos": 210, "create-ecdh": 384, "create-hash": 386, "create-hmac": 388, "diffie-hellman": 400, "pbkdf2": 460, "public-encrypt": 468, "randombytes": 475, "randomfill": 476 }], 391: [function(require2, module2, exports2) {
      !function(t2, e) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e();
      }(void 0, function() {
        var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h3 = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function ordinal(t3) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
          return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        } }, m = function m2(t3, e2, n2) {
          var r2 = String(t3);
          return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
        }, v = { s: m, z: function z(t3) {
          var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t3(e2, n2) {
          if (e2.date() < n2.date())
            return -t3(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function a2(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function p2(t3) {
          return { M: c, y: h3, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function u2(t3) {
          return void 0 === t3;
        } }, g = "en", D = {};
        D[g] = M;
        var p = "$isDayjsObject", S = function S2(t3) {
          return t3 instanceof _ || !(!t3 || !t3[p]);
        }, w = function t3(e2, n2, r2) {
          var i2;
          if (!e2)
            return g;
          if ("string" == typeof e2) {
            var s2 = e2.toLowerCase();
            D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
            var u2 = e2.split("-");
            if (!i2 && u2.length > 1)
              return t3(u2[0]);
          } else {
            var a2 = e2.name;
            D[a2] = e2, i2 = a2;
          }
          return !r2 && i2 && (g = i2), i2 || !r2 && g;
        }, O = function O2(t3, e2) {
          if (S(t3))
            return t3.clone();
          var n2 = "object" == typeof e2 ? e2 : {};
          return n2.date = t3, n2.args = arguments, new _(n2);
        }, b = v;
        b.l = w, b.i = S, b.w = function(t3, e2) {
          return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
        };
        var _ = function() {
          function M2(t3) {
            this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
          }
          var m2 = M2.prototype;
          return m2.parse = function(t3) {
            this.$d = function(t4) {
              var e2 = t4.date, n2 = t4.utc;
              if (null === e2)
                return /* @__PURE__ */ new Date(NaN);
              if (b.u(e2))
                return /* @__PURE__ */ new Date();
              if (e2 instanceof Date)
                return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r2 = e2.match($2);
                if (r2) {
                  var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                }
              }
              return new Date(e2);
            }(t3), this.init();
          }, m2.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m2.$utils = function() {
            return b;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t3, e2) {
            var n2 = O(t3);
            return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
          }, m2.isAfter = function(t3, e2) {
            return O(t3) < this.startOf(e2);
          }, m2.isBefore = function(t3, e2) {
            return this.endOf(e2) < O(t3);
          }, m2.$g = function(t3, e2, n2) {
            return b.u(t3) ? this[e2] : this.set(n2, t3);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t3, e2) {
            var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function l3(t4, e3) {
              var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
              return r2 ? i2 : i2.endOf(a);
            }, $3 = function $4(t4, e3) {
              return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
            }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f2) {
              case h3:
                return r2 ? l2(1, 0) : l2(31, 11);
              case c:
                return r2 ? l2(1, M3) : l2(0, M3 + 1);
              case o:
                var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
              case a:
              case d:
                return $3(v2 + "Hours", 0);
              case u:
                return $3(v2 + "Minutes", 1);
              case s:
                return $3(v2 + "Seconds", 2);
              case i:
                return $3(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m2.$set = function(t3, e2) {
            var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h3] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
            if (o2 === c || o2 === h3) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else
              l2 && this.$d[l2]($3);
            return this.init(), this;
          }, m2.set = function(t3, e2) {
            return this.clone().$set(t3, e2);
          }, m2.get = function(t3) {
            return this[b.p(t3)]();
          }, m2.add = function(r2, f2) {
            var d2, l2 = this;
            r2 = Number(r2);
            var $3 = b.p(f2), y2 = function y3(t3) {
              var e2 = O(l2);
              return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
            };
            if ($3 === c)
              return this.set(c, this.$M + r2);
            if ($3 === h3)
              return this.set(h3, this.$y + r2);
            if ($3 === a)
              return y2(1);
            if ($3 === o)
              return y2(7);
            var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t2, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
            return b.w(m3, this);
          }, m2.subtract = function(t3, e2) {
            return this.add(-1 * t3, e2);
          }, m2.format = function(t3) {
            var e2 = this, n2 = this.$locale();
            if (!this.isValid())
              return n2.invalidDate || l;
            var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h4 = function h5(t4, n3, i3, s3) {
              return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
            }, d2 = function d3(t4) {
              return b.s(s2 % 12 || 12, t4, "0");
            }, $3 = f2 || function(t4, e3, n3) {
              var r3 = t4 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            };
            return r2.replace(y, function(t4, r3) {
              return r3 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e2.$y).slice(-2);
                  case "YYYY":
                    return b.s(e2.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h4(n2.monthsShort, a2, c2, 3);
                  case "MMMM":
                    return h4(c2, a2);
                  case "D":
                    return e2.$D;
                  case "DD":
                    return b.s(e2.$D, 2, "0");
                  case "d":
                    return String(e2.$W);
                  case "dd":
                    return h4(n2.weekdaysMin, e2.$W, o2, 2);
                  case "ddd":
                    return h4(n2.weekdaysShort, e2.$W, o2, 3);
                  case "dddd":
                    return o2[e2.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b.s(s2, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $3(s2, u2, true);
                  case "A":
                    return $3(s2, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b.s(u2, 2, "0");
                  case "s":
                    return String(e2.$s);
                  case "ss":
                    return b.s(e2.$s, 2, "0");
                  case "SSS":
                    return b.s(e2.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              }(t4) || i2.replace(":", "");
            });
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r2, d2, l2) {
            var $3, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function D3() {
              return b.m(y2, m3);
            };
            switch (M3) {
              case h3:
                $3 = D2() / 12;
                break;
              case c:
                $3 = D2();
                break;
              case f:
                $3 = D2() / 3;
                break;
              case o:
                $3 = (g2 - v2) / 6048e5;
                break;
              case a:
                $3 = (g2 - v2) / 864e5;
                break;
              case u:
                $3 = g2 / n;
                break;
              case s:
                $3 = g2 / e;
                break;
              case i:
                $3 = g2 / t2;
                break;
              default:
                $3 = g2;
            }
            return l2 ? $3 : b.a($3);
          }, m2.daysInMonth = function() {
            return this.endOf(c).$D;
          }, m2.$locale = function() {
            return D[this.$L];
          }, m2.locale = function(t3, e2) {
            if (!t3)
              return this.$L;
            var n2 = this.clone(), r2 = w(t3, e2, true);
            return r2 && (n2.$L = r2), n2;
          }, m2.clone = function() {
            return b.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        }(), k = _.prototype;
        return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h3], ["$D", d]].forEach(function(t3) {
          k[t3[1]] = function(e2) {
            return this.$g(e2, t3[0], t3[1]);
          };
        }), O.extend = function(t3, e2) {
          return t3.$i || (t3(e2, _, O), t3.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
          return O(1e3 * t3);
        }, O.en = D[g], O.Ls = D, O.p = {}, O;
      });
    }, {}], 392: [function(require2, module2, exports2) {
      !function(e, t2) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t2() : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t2();
      }(void 0, function() {
        var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function s2(e2) {
          return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
        };
        var a = function a2(e2) {
          return function(t3) {
            this[e2] = +t3;
          };
        }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
          (this.zone || (this.zone = {})).offset = function(e3) {
            if (!e3)
              return 0;
            if ("Z" === e3)
              return 0;
            var t3 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n2 ? 0 : "+" === t3[0] ? -n2 : n2;
          }(e2);
        }], h3 = function h4(e2) {
          var t3 = o[e2];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, u = function u2(e2, t3) {
          var n2, r2 = o.meridiem;
          if (r2) {
            for (var i2 = 1; i2 <= 24; i2 += 1)
              if (e2.indexOf(r2(i2, 0, t3)) > -1) {
                n2 = i2 > 12;
                break;
              }
          } else
            n2 = e2 === (t3 ? "pm" : "PM");
          return n2;
        }, d = { A: [i, function(e2) {
          this.afternoon = u(e2, false);
        }], a: [i, function(e2) {
          this.afternoon = u(e2, true);
        }], S: [/\d/, function(e2) {
          this.milliseconds = 100 * +e2;
        }], SS: [n, function(e2) {
          this.milliseconds = 10 * +e2;
        }], SSS: [/\d{3}/, function(e2) {
          this.milliseconds = +e2;
        }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
          var t3 = o.ordinal, n2 = e2.match(/\d+/);
          if (this.day = n2[0], t3)
            for (var r2 = 1; r2 <= 31; r2 += 1)
              t3(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
        }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
          var t3 = h3("months"), n2 = (h3("monthsShort") || t3.map(function(e3) {
            return e3.slice(0, 3);
          })).indexOf(e2) + 1;
          if (n2 < 1)
            throw new Error();
          this.month = n2 % 12 || n2;
        }], MMMM: [i, function(e2) {
          var t3 = h3("months").indexOf(e2) + 1;
          if (t3 < 1)
            throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
          this.year = s(e2);
        }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
        function c(n2) {
          var r2, i2;
          r2 = n2, i2 = o && o.formats;
          for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n3, r3) {
            var o2 = r3 && r3.toUpperCase();
            return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t4, n4) {
              return t4 || n4.slice(1);
            });
          })).match(t2), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
            var h4 = s2[f2], u2 = d[h4], c2 = u2 && u2[0], l = u2 && u2[1];
            s2[f2] = l ? { regex: c2, parser: l } : h4.replace(/^\[|\]$/g, "");
          }
          return function(e2) {
            for (var t3 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
              var i3 = s2[n3];
              if ("string" == typeof i3)
                r3 += i3.length;
              else {
                var o2 = i3.regex, f3 = i3.parser, h5 = e2.slice(r3), u3 = o2.exec(h5)[0];
                f3.call(t3, u3), e2 = e2.replace(u3, "");
              }
            }
            return function(e3) {
              var t4 = e3.afternoon;
              if (void 0 !== t4) {
                var n4 = e3.hours;
                t4 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e2, t3, n2) {
          n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
          var r2 = t3.prototype, i2 = r2.parse;
          r2.parse = function(e3) {
            var t4 = e3.date, r3 = e3.utc, s2 = e3.args;
            this.$u = r3;
            var a2 = s2[1];
            if ("string" == typeof a2) {
              var f2 = true === s2[2], h4 = true === s2[3], u2 = f2 || h4, d2 = s2[2];
              h4 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t5, n3) {
                try {
                  if (["x", "X"].indexOf(t5) > -1)
                    return new Date(("X" === t5 ? 1e3 : 1) * e4);
                  var r4 = c(t5)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h5 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = /* @__PURE__ */ new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                  i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                  var p = a3 || 0, v = f3 || 0, D = h5 || 0, g = u3 || 0;
                  return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
                } catch (e5) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t4, a2, r3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
            } else if (a2 instanceof Array)
              for (var l = a2.length, m = 1; m <= l; m += 1) {
                s2[1] = a2[m - 1];
                var M = n2.apply(this, s2);
                if (M.isValid()) {
                  this.$d = M.$d, this.$L = M.$L, this.init();
                  break;
                }
                m === l && (this.$d = /* @__PURE__ */ new Date(""));
              }
            else
              i2.call(this, e3);
          };
        };
      });
    }, {}], 393: [function(require2, module2, exports2) {
      !function(t2, i) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = i() : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs_plugin_utc = i();
      }(void 0, function() {
        var t2 = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
        return function(s, f, n) {
          var u = f.prototype;
          n.utc = function(t3) {
            var i2 = { date: t3, utc: true, args: arguments };
            return new f(i2);
          }, u.utc = function(i2) {
            var e2 = n(this.toDate(), { locale: this.$L, utc: true });
            return i2 ? e2.add(this.utcOffset(), t2) : e2;
          }, u.local = function() {
            return n(this.toDate(), { locale: this.$L, utc: false });
          };
          var o = u.parse;
          u.parse = function(t3) {
            t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), o.call(this, t3);
          };
          var r = u.init;
          u.init = function() {
            if (this.$u) {
              var t3 = this.$d;
              this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
            } else
              r.call(this);
          };
          var a = u.utcOffset;
          u.utcOffset = function(s2, f2) {
            var n2 = this.$utils().u;
            if (n2(s2))
              return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
            if ("string" == typeof s2 && (s2 = function(t3) {
              void 0 === t3 && (t3 = "");
              var s3 = t3.match(i);
              if (!s3)
                return null;
              var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
              return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
            }(s2), null === s2))
              return this;
            var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
            if (f2)
              return o2.$offset = u2, o2.$u = 0 === s2, o2;
            if (0 !== s2) {
              var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
              (o2 = this.local().add(u2 + r2, t2)).$offset = u2, o2.$x.$localOffset = r2;
            } else
              o2 = this.utc();
            return o2;
          };
          var h3 = u.format;
          u.format = function(t3) {
            var i2 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h3.call(this, i2);
          }, u.valueOf = function() {
            var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t3;
          }, u.isUTC = function() {
            return !!this.$u;
          }, u.toISOString = function() {
            return this.toDate().toISOString();
          }, u.toString = function() {
            return this.toDate().toUTCString();
          };
          var l = u.toDate;
          u.toDate = function(t3) {
            return "s" === t3 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
          };
          var c = u.diff;
          u.diff = function(t3, i2, e2) {
            if (t3 && this.$u === t3.$u)
              return c.call(this, t3, i2, e2);
            var s2 = this.local(), f2 = n(t3).local();
            return c.call(s2, f2, i2, e2);
          };
        };
      });
    }, {}], 394: [function(require2, module2, exports2) {
      exports2.utils = require2("./des/utils");
      exports2.Cipher = require2("./des/cipher");
      exports2.DES = require2("./des/des");
      exports2.CBC = require2("./des/cbc");
      exports2.EDE = require2("./des/ede");
    }, { "./des/cbc": 395, "./des/cipher": 396, "./des/des": 397, "./des/ede": 398, "./des/utils": 399 }], 395: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var proto = {};
      function CBCState(iv) {
        assert.equal(iv.length, 8, "Invalid IV length");
        this.iv = new Array(8);
        for (var i = 0; i < this.iv.length; i++)
          this.iv[i] = iv[i];
      }
      function instantiate(Base) {
        function CBC(options) {
          Base.call(this, options);
          this._cbcInit();
        }
        inherits(CBC, Base);
        var keys2 = Object.keys(proto);
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          CBC.prototype[key] = proto[key];
        }
        CBC.create = function create(options) {
          return new CBC(options);
        };
        return CBC;
      }
      exports2.instantiate = instantiate;
      proto._cbcInit = function _cbcInit() {
        var state = new CBCState(this.options.iv);
        this._cbcState = state;
      };
      proto._update = function _update(inp, inOff, out, outOff) {
        var state = this._cbcState;
        var superProto = this.constructor.super_.prototype;
        var iv = state.iv;
        if (this.type === "encrypt") {
          for (var i = 0; i < this.blockSize; i++)
            iv[i] ^= inp[inOff + i];
          superProto._update.call(this, iv, 0, out, outOff);
          for (var i = 0; i < this.blockSize; i++)
            iv[i] = out[outOff + i];
        } else {
          superProto._update.call(this, inp, inOff, out, outOff);
          for (var i = 0; i < this.blockSize; i++)
            out[outOff + i] ^= iv[i];
          for (var i = 0; i < this.blockSize; i++)
            iv[i] = inp[inOff + i];
        }
      };
    }, { "inherits": 440, "minimalistic-assert": 453 }], 396: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      function Cipher(options) {
        this.options = options;
        this.type = this.options.type;
        this.blockSize = 8;
        this._init();
        this.buffer = new Array(this.blockSize);
        this.bufferOff = 0;
        this.padding = options.padding !== false;
      }
      module2.exports = Cipher;
      Cipher.prototype._init = function _init() {
      };
      Cipher.prototype.update = function update(data) {
        if (data.length === 0)
          return [];
        if (this.type === "decrypt")
          return this._updateDecrypt(data);
        else
          return this._updateEncrypt(data);
      };
      Cipher.prototype._buffer = function _buffer(data, off) {
        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
        for (var i = 0; i < min; i++)
          this.buffer[this.bufferOff + i] = data[off + i];
        this.bufferOff += min;
        return min;
      };
      Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
        this._update(this.buffer, 0, out, off);
        this.bufferOff = 0;
        return this.blockSize;
      };
      Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = (this.bufferOff + data.length) / this.blockSize | 0;
        var out = new Array(count * this.blockSize);
        if (this.bufferOff !== 0) {
          inputOff += this._buffer(data, inputOff);
          if (this.bufferOff === this.buffer.length)
            outputOff += this._flushBuffer(out, outputOff);
        }
        var max = data.length - (data.length - inputOff) % this.blockSize;
        for (; inputOff < max; inputOff += this.blockSize) {
          this._update(data, inputOff, out, outputOff);
          outputOff += this.blockSize;
        }
        for (; inputOff < data.length; inputOff++, this.bufferOff++)
          this.buffer[this.bufferOff] = data[inputOff];
        return out;
      };
      Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
        var out = new Array(count * this.blockSize);
        for (; count > 0; count--) {
          inputOff += this._buffer(data, inputOff);
          outputOff += this._flushBuffer(out, outputOff);
        }
        inputOff += this._buffer(data, inputOff);
        return out;
      };
      Cipher.prototype.final = function final(buffer) {
        var first;
        if (buffer)
          first = this.update(buffer);
        var last;
        if (this.type === "encrypt")
          last = this._finalEncrypt();
        else
          last = this._finalDecrypt();
        if (first)
          return first.concat(last);
        else
          return last;
      };
      Cipher.prototype._pad = function _pad(buffer, off) {
        if (off === 0)
          return false;
        while (off < buffer.length)
          buffer[off++] = 0;
        return true;
      };
      Cipher.prototype._finalEncrypt = function _finalEncrypt() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var out = new Array(this.blockSize);
        this._update(this.buffer, 0, out, 0);
        return out;
      };
      Cipher.prototype._unpad = function _unpad(buffer) {
        return buffer;
      };
      Cipher.prototype._finalDecrypt = function _finalDecrypt() {
        assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var out = new Array(this.blockSize);
        this._flushBuffer(out, 0);
        return this._unpad(out);
      };
    }, { "minimalistic-assert": 453 }], 397: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var utils = require2("./utils");
      var Cipher = require2("./cipher");
      function DESState() {
        this.tmp = new Array(2);
        this.keys = null;
      }
      function DES(options) {
        Cipher.call(this, options);
        var state = new DESState();
        this._desState = state;
        this.deriveKeys(state, options.key);
      }
      inherits(DES, Cipher);
      module2.exports = DES;
      DES.create = function create(options) {
        return new DES(options);
      };
      var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      DES.prototype.deriveKeys = function deriveKeys(state, key) {
        state.keys = new Array(16 * 2);
        assert.equal(key.length, this.blockSize, "Invalid key length");
        var kL = utils.readUInt32BE(key, 0);
        var kR = utils.readUInt32BE(key, 4);
        utils.pc1(kL, kR, state.tmp, 0);
        kL = state.tmp[0];
        kR = state.tmp[1];
        for (var i = 0; i < state.keys.length; i += 2) {
          var shift = shiftTable[i >>> 1];
          kL = utils.r28shl(kL, shift);
          kR = utils.r28shl(kR, shift);
          utils.pc2(kL, kR, state.keys, i);
        }
      };
      DES.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._desState;
        var l = utils.readUInt32BE(inp, inOff);
        var r = utils.readUInt32BE(inp, inOff + 4);
        utils.ip(l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        if (this.type === "encrypt")
          this._encrypt(state, l, r, state.tmp, 0);
        else
          this._decrypt(state, l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        utils.writeUInt32BE(out, l, outOff);
        utils.writeUInt32BE(out, r, outOff + 4);
      };
      DES.prototype._pad = function _pad(buffer, off) {
        if (this.padding === false) {
          return false;
        }
        var value = buffer.length - off;
        for (var i = off; i < buffer.length; i++)
          buffer[i] = value;
        return true;
      };
      DES.prototype._unpad = function _unpad(buffer) {
        if (this.padding === false) {
          return buffer;
        }
        var pad = buffer[buffer.length - 1];
        for (var i = buffer.length - pad; i < buffer.length; i++)
          assert.equal(buffer[i], pad);
        return buffer.slice(0, buffer.length - pad);
      };
      DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
        var l = lStart;
        var r = rStart;
        for (var i = 0; i < state.keys.length; i += 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(r, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t2 = r;
          r = (l ^ f) >>> 0;
          l = t2;
        }
        utils.rip(r, l, out, off);
      };
      DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
        var l = rStart;
        var r = lStart;
        for (var i = state.keys.length - 2; i >= 0; i -= 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(l, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t2 = l;
          l = (r ^ f) >>> 0;
          r = t2;
        }
        utils.rip(l, r, out, off);
      };
    }, { "./cipher": 396, "./utils": 399, "inherits": 440, "minimalistic-assert": 453 }], 398: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var Cipher = require2("./cipher");
      var DES = require2("./des");
      function EDEState(type, key) {
        assert.equal(key.length, 24, "Invalid key length");
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        var k3 = key.slice(16, 24);
        if (type === "encrypt") {
          this.ciphers = [DES.create({ type: "encrypt", key: k1 }), DES.create({ type: "decrypt", key: k2 }), DES.create({ type: "encrypt", key: k3 })];
        } else {
          this.ciphers = [DES.create({ type: "decrypt", key: k3 }), DES.create({ type: "encrypt", key: k2 }), DES.create({ type: "decrypt", key: k1 })];
        }
      }
      function EDE(options) {
        Cipher.call(this, options);
        var state = new EDEState(this.type, this.options.key);
        this._edeState = state;
      }
      inherits(EDE, Cipher);
      module2.exports = EDE;
      EDE.create = function create(options) {
        return new EDE(options);
      };
      EDE.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._edeState;
        state.ciphers[0]._update(inp, inOff, out, outOff);
        state.ciphers[1]._update(out, outOff, out, outOff);
        state.ciphers[2]._update(out, outOff, out, outOff);
      };
      EDE.prototype._pad = DES.prototype._pad;
      EDE.prototype._unpad = DES.prototype._unpad;
    }, { "./cipher": 396, "./des": 397, "inherits": 440, "minimalistic-assert": 453 }], 399: [function(require2, module2, exports2) {
      exports2.readUInt32BE = function readUInt32BE(bytes, off) {
        var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
        return res >>> 0;
      };
      exports2.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
        bytes[0 + off] = value >>> 24;
        bytes[1 + off] = value >>> 16 & 255;
        bytes[2 + off] = value >>> 8 & 255;
        bytes[3 + off] = value & 255;
      };
      exports2.ip = function ip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
          }
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.rip = function rip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 0; i < 4; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 4; i < 8; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.pc1 = function pc1(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 7; i >= 5; i--) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var i = 1; i <= 3; i++) {
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.r28shl = function r28shl(num, shift) {
        return num << shift & 268435455 | num >>> 28 - shift;
      };
      var pc2table = [
        // inL => outL
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        // inR => outR
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
      ];
      exports2.pc2 = function pc2(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        var len = pc2table.length >>> 1;
        for (var i = 0; i < len; i++) {
          outL <<= 1;
          outL |= inL >>> pc2table[i] & 1;
        }
        for (var i = len; i < pc2table.length; i++) {
          outR <<= 1;
          outR |= inR >>> pc2table[i] & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.expand = function expand(r, out, off) {
        var outL = 0;
        var outR = 0;
        outL = (r & 1) << 5 | r >>> 27;
        for (var i = 23; i >= 15; i -= 4) {
          outL <<= 6;
          outL |= r >>> i & 63;
        }
        for (var i = 11; i >= 3; i -= 4) {
          outR |= r >>> i & 63;
          outR <<= 6;
        }
        outR |= (r & 31) << 1 | r >>> 31;
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
      exports2.substitute = function substitute(inL, inR) {
        var out = 0;
        for (var i = 0; i < 4; i++) {
          var b = inL >>> 18 - i * 6 & 63;
          var sb = sTable[i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        for (var i = 0; i < 4; i++) {
          var b = inR >>> 18 - i * 6 & 63;
          var sb = sTable[4 * 64 + i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        return out >>> 0;
      };
      var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
      exports2.permute = function permute(num) {
        var out = 0;
        for (var i = 0; i < permuteTable.length; i++) {
          out <<= 1;
          out |= num >>> permuteTable[i] & 1;
        }
        return out >>> 0;
      };
      exports2.padSplit = function padSplit(num, size, group) {
        var str = num.toString(2);
        while (str.length < size)
          str = "0" + str;
        var out = [];
        for (var i = 0; i < size; i += group)
          out.push(str.slice(i, i + group));
        return out.join(" ");
      };
    }, {}], 400: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var generatePrime = require2("./lib/generatePrime");
          var primes = require2("./lib/primes.json");
          var DH = require2("./lib/dh");
          function getDiffieHellman(mod) {
            var prime = new Buffer2(primes[mod].prime, "hex");
            var gen = new Buffer2(primes[mod].gen, "hex");
            return new DH(prime, gen);
          }
          var ENCODINGS = { "binary": true, "hex": true, "base64": true };
          function createDiffieHellman(prime, enc, generator, genc) {
            if (Buffer2.isBuffer(enc) || ENCODINGS[enc] === void 0) {
              return createDiffieHellman(prime, "binary", enc, generator);
            }
            enc = enc || "binary";
            genc = genc || "binary";
            generator = generator || new Buffer2([2]);
            if (!Buffer2.isBuffer(generator)) {
              generator = new Buffer2(generator, genc);
            }
            if (typeof prime === "number") {
              return new DH(generatePrime(prime, generator), generator, true);
            }
            if (!Buffer2.isBuffer(prime)) {
              prime = new Buffer2(prime, enc);
            }
            return new DH(prime, generator, true);
          }
          exports2.DiffieHellmanGroup = exports2.createDiffieHellmanGroup = exports2.getDiffieHellman = getDiffieHellman;
          exports2.createDiffieHellman = exports2.DiffieHellman = createDiffieHellman;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./lib/dh": 401, "./lib/generatePrime": 402, "./lib/primes.json": 403, "buffer": 220 }], 401: [function(require2, module2, exports2) {
      (function(Buffer2) {
        (function() {
          var BN = require2("bn.js");
          var MillerRabin = require2("miller-rabin");
          var millerRabin = new MillerRabin();
          var TWENTYFOUR = new BN(24);
          var ELEVEN = new BN(11);
          var TEN = new BN(10);
          var THREE = new BN(3);
          var SEVEN = new BN(7);
          var primes = require2("./generatePrime");
          var randomBytes = require2("randombytes");
          module2.exports = DH;
          function setPublicKey(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer2.isBuffer(pub)) {
              pub = new Buffer2(pub, enc);
            }
            this._pub = new BN(pub);
            return this;
          }
          function setPrivateKey(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer2.isBuffer(priv)) {
              priv = new Buffer2(priv, enc);
            }
            this._priv = new BN(priv);
            return this;
          }
          var primeCache = {};
          function checkPrime(prime, generator) {
            var gen = generator.toString("hex");
            var hex = [gen, prime.toString(16)].join("_");
            if (hex in primeCache) {
              return primeCache[hex];
            }
            var error = 0;
            if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
              error += 1;
              if (gen === "02" || gen === "05") {
                error += 8;
              } else {
                error += 4;
              }
              primeCache[hex] = error;
              return error;
            }
            if (!millerRabin.test(prime.shrn(1))) {
              error += 2;
            }
            var rem;
            switch (gen) {
              case "02":
                if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                  error += 8;
                }
                break;
              case "05":
                rem = prime.mod(TEN);
                if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                  error += 8;
                }
                break;
              default:
                error += 4;
            }
            primeCache[hex] = error;
            return error;
          }
          function DH(prime, generator, malleable) {
            this.setGenerator(generator);
            this.__prime = new BN(prime);
            this._prime = BN.mont(this.__prime);
            this._primeLen = prime.length;
            this._pub = void 0;
            this._priv = void 0;
            this._primeCode = void 0;
            if (malleable) {
              this.setPublicKey = setPublicKey;
              this.setPrivateKey = setPrivateKey;
            } else {
              this._primeCode = 8;
            }
          }
          Object.defineProperty(DH.prototype, "verifyError", { enumerable: true, get: function get() {
            if (typeof this._primeCode !== "number") {
              this._primeCode = checkPrime(this.__prime, this.__gen);
            }
            return this._primeCode;
          } });
          DH.prototype.generateKeys = function() {
            if (!this._priv) {
              this._priv = new BN(randomBytes(this._primeLen));
            }
            this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
            return this.getPublicKey();
          };
          DH.prototype.computeSecret = function(other) {
            other = new BN(other);
            other = other.toRed(this._prime);
            var secret = other.redPow(this._priv).fromRed();
            var out = new Buffer2(secret.toArray());
            var prime = this.getPrime();
            if (out.length < prime.length) {
              var front = new Buffer2(prime.length - out.length);
              front.fill(0);
              out = Buffer2.concat([front, out]);
            }
            return out;
          };
          DH.prototype.getPublicKey = function getPublicKey(enc) {
            return formatReturnValue(this._pub, enc);
          };
          DH.prototype.getPrivateKey = function getPrivateKey(enc) {
            return formatReturnValue(this._priv, enc);
          };
          DH.prototype.getPrime = function(enc) {
            return formatReturnValue(this.__prime, enc);
          };
          DH.prototype.getGenerator = function(enc) {
            return formatReturnValue(this._gen, enc);
          };
          DH.prototype.setGenerator = function(gen, enc) {
            enc = enc || "utf8";
            if (!Buffer2.isBuffer(gen)) {
              gen = new Buffer2(gen, enc);
            }
            this.__gen = gen;
            this._gen = new BN(gen);
            return this;
          };
          function formatReturnValue(bn, enc) {
            var buf = new Buffer2(bn.toArray());
            if (!enc) {
              return buf;
            } else {
              return buf.toString(enc);
            }
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./generatePrime": 402, "bn.js": 404, "buffer": 220, "miller-rabin": 451, "randombytes": 475 }], 402: [function(require2, module2, exports2) {
      var randomBytes = require2("randombytes");
      module2.exports = findPrime;
      findPrime.simpleSieve = simpleSieve;
      findPrime.fermatTest = fermatTest;
      var BN = require2("bn.js");
      var TWENTYFOUR = new BN(24);
      var MillerRabin = require2("miller-rabin");
      var millerRabin = new MillerRabin();
      var ONE = new BN(1);
      var TWO = new BN(2);
      var FIVE = new BN(5);
      new BN(16);
      new BN(8);
      var TEN = new BN(10);
      var THREE = new BN(3);
      new BN(7);
      var ELEVEN = new BN(11);
      var FOUR = new BN(4);
      new BN(12);
      var primes = null;
      function _getPrimes() {
        if (primes !== null)
          return primes;
        var limit = 1048576;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
          var sqrt = Math.ceil(Math.sqrt(k));
          for (var j = 0; j < i && res[j] <= sqrt; j++)
            if (k % res[j] === 0)
              break;
          if (i !== j && res[j] <= sqrt)
            continue;
          res[i++] = k;
        }
        primes = res;
        return res;
      }
      function simpleSieve(p) {
        var primes2 = _getPrimes();
        for (var i = 0; i < primes2.length; i++)
          if (p.modn(primes2[i]) === 0) {
            if (p.cmpn(primes2[i]) === 0) {
              return true;
            } else {
              return false;
            }
          }
        return true;
      }
      function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
      }
      function findPrime(bits, gen) {
        if (bits < 16) {
          if (gen === 2 || gen === 5) {
            return new BN([140, 123]);
          } else {
            return new BN([140, 39]);
          }
        }
        gen = new BN(gen);
        var num, n2;
        while (true) {
          num = new BN(randomBytes(Math.ceil(bits / 8)));
          while (num.bitLength() > bits) {
            num.ishrn(1);
          }
          if (num.isEven()) {
            num.iadd(ONE);
          }
          if (!num.testn(1)) {
            num.iadd(TWO);
          }
          if (!gen.cmp(TWO)) {
            while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
              num.iadd(FOUR);
            }
          } else if (!gen.cmp(FIVE)) {
            while (num.mod(TEN).cmp(THREE)) {
              num.iadd(FOUR);
            }
          }
          n2 = num.shrn(1);
          if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
            return num;
          }
        }
      }
    }, { "bn.js": 404, "miller-rabin": 451, "randombytes": 475 }], 403: [function(require2, module2, exports2) {
      module2.exports = { "modp1": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, "modp2": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, "modp5": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, "modp14": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, "modp15": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, "modp16": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, "modp17": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, "modp18": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
    }, {}], 404: [function(require2, module2, exports2) {
      arguments[4][184][0].apply(exports2, arguments);
    }, { "buffer": 188, "dup": 184 }], 405: [function(require2, module2, exports2) {
      var elliptic = exports2;
      elliptic.version = require2("../package.json").version;
      elliptic.utils = require2("./elliptic/utils");
      elliptic.rand = require2("brorand");
      elliptic.curve = require2("./elliptic/curve");
      elliptic.curves = require2("./elliptic/curves");
      elliptic.ec = require2("./elliptic/ec");
      elliptic.eddsa = require2("./elliptic/eddsa");
    }, { "../package.json": 421, "./elliptic/curve": 408, "./elliptic/curves": 411, "./elliptic/ec": 412, "./elliptic/eddsa": 415, "./elliptic/utils": 419, "brorand": 187 }], 406: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index2 = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = { doubles: null, naf: null, beta: null };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return { step, points: doubles };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
          res[i] = res[i - 1].add(dbl);
        return { wnd, points: res };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }, { "../utils": 419, "bn.js": 420 }], 407: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t2) {
        return this.point(x, y, z, t2);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t2) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t2 && new BN(t2, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t2) {
        return new Point(this, x, y, z, t2);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h3 = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h3);
        var nt = e.redMul(h3);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h3;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h3 = this.z.redSqr();
            j = f.redSub(h3).redISub(h3);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h3 = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h3).redSub(h3);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h3 = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h3);
        var nt = e.redMul(h3);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t2 = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t2);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }, { "../utils": 419, "./base": 406, "bn.js": 420, "inherits": 440 }], 408: [function(require2, module2, exports2) {
      var curve = exports2;
      curve.base = require2("./base");
      curve.short = require2("./short");
      curve.mont = require2("./mont");
      curve.edwards = require2("./edwards");
    }, { "./base": 406, "./edwards": 407, "./mont": 409, "./short": 410 }], 409: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var utils = require2("../utils");
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t2 = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
          bits.push(t2.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }, { "../utils": 419, "./base": 406, "bn.js": 420, "inherits": 440 }], 410: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return { beta, lambda, basis };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function endoMul2(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } };
        return res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function negate2(p) {
            return p.neg();
          };
          res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate) } };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h3 = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h3.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h3.redSqr();
        var h32 = h22.redMul(h3);
        var v = u1.redMul(h22);
        var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(p.z).redMul(h3);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h3 = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h3.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h3.redSqr();
        var h32 = h22.redMul(h3);
        var v = u1.redMul(h22);
        var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(h3);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t2 = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t2;
          ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t2 = m.redSqr().redISub(s).redISub(s);
          nx = t2;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t2 = yyyy.redIAdd(yyyy);
        t2 = t2.redIAdd(t2);
        t2 = t2.redIAdd(t2);
        t2 = t2.redIAdd(t2);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t2);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t2 = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t2);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }, { "../utils": 419, "./base": 406, "bn.js": 420, "inherits": 440 }], 411: [function(require2, module2, exports2) {
      var curves = exports2;
      var hash = require2("hash.js");
      var curve = require2("./curve");
      var utils = require2("./utils");
      var assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, { configurable: true, enumerable: true, get: function get() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, { configurable: true, enumerable: true, value: curve2 });
          return curve2;
        } });
      }
      defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
      defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
      defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
      defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
      defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
      defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash.sha256, gRed: false, g: ["9"] });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require2("./precomputed/secp256k1");
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }],
        gRed: false,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
      });
    }, { "./curve": 408, "./precomputed/secp256k1": 418, "./utils": 419, "hash.js": 426 }], 412: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var HmacDRBG = require2("hmac-drbg");
      var utils = require2("../utils");
      var curves = require2("../curves");
      var rand = require2("brorand");
      var assert = utils.assert;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }, { "../curves": 411, "../utils": 419, "./key": 413, "./signature": 414, "bn.js": 420, "brorand": 187, "hmac-drbg": 438 }], 413: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, { pub, pubEnc: enc });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, { priv, privEnc: enc });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }, { "../utils": 419, "bn.js": 420 }], 414: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }, { "../utils": 419, "bn.js": 420 }], 415: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var curves = require2("../curves");
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h3 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h3));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash2.update(arguments[i]);
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }, { "../curves": 411, "../utils": 419, "./key": 416, "./signature": 417, "hash.js": 426 }], 416: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }, { "../utils": 419 }], 417: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = { R: sig.slice(0, eddsa.encodingLength), S: sig.slice(eddsa.encodingLength) };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex2() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature;
    }, { "../utils": 419, "bn.js": 420 }], 418: [function(require2, module2, exports2) {
      module2.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    }, {}], 419: [function(require2, module2, exports2) {
      var utils = exports2;
      var BN = require2("bn.js");
      var minAssert = require2("minimalistic-assert");
      var minUtils = require2("minimalistic-crypto-utils");
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [[], []];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }, { "bn.js": 420, "minimalistic-assert": 453, "minimalistic-crypto-utils": 454 }], 420: [function(require2, module2, exports2) {
      arguments[4][184][0].apply(exports2, arguments);
    }, { "buffer": 188, "dup": 184 }], 421: [function(require2, module2, exports2) {
      module2.exports = { "name": "elliptic", "version": "6.5.4", "description": "EC cryptography", "main": "lib/elliptic.js", "files": ["lib"], "scripts": { "lint": "eslint lib test", "lint:fix": "npm run lint -- --fix", "unit": "istanbul test _mocha --reporter=spec test/index.js", "test": "npm run lint && npm run unit", "version": "grunt dist && git add dist/" }, "repository": { "type": "git", "url": "git@github.com:indutny/elliptic" }, "keywords": ["EC", "Elliptic", "curve", "Cryptography"], "author": "Fedor Indutny <fedor@indutny.com>", "license": "MIT", "bugs": { "url": "https://github.com/indutny/elliptic/issues" }, "homepage": "https://github.com/indutny/elliptic", "devDependencies": { "brfs": "^2.0.2", "coveralls": "^3.1.0", "eslint": "^7.6.0", "grunt": "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", "istanbul": "^0.4.5", "mocha": "^8.0.1" }, "dependencies": { "bn.js": "^4.11.9", "brorand": "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", "inherits": "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
    }, {}], 422: [function(require2, module2, exports2) {
      var objectCreate = Object.create || objectCreatePolyfill;
      var objectKeys = Object.keys || objectKeysPolyfill;
      var bind2 = Function.prototype.bind || functionBindPolyfill;
      function EventEmitter() {
        if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      }
      module2.exports = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      var hasDefineProperty;
      try {
        var o = {};
        if (Object.defineProperty)
          Object.defineProperty(o, "x", { value: 0 });
        hasDefineProperty = o.x === 0;
      } catch (err) {
        hasDefineProperty = false;
      }
      if (hasDefineProperty) {
        Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function get() {
          return defaultMaxListeners;
        }, set: function set(arg) {
          if (typeof arg !== "number" || arg < 0 || arg !== arg)
            throw new TypeError('"defaultMaxListeners" must be a positive number');
          defaultMaxListeners = arg;
        } });
      } else {
        EventEmitter.defaultMaxListeners = defaultMaxListeners;
      }
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2);
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1);
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2);
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2, arg3);
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].apply(self2, args);
        }
      }
      EventEmitter.prototype.emit = function emit(type) {
        var er, handler, len, args, i, events;
        var doError = type === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        if (doError) {
          if (arguments.length > 1)
            er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Unhandled "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
        }
        handler = events[type];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = objectCreate(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (!existing) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              if (typeof console === "object" && console.warn) {
                console.warn("%s: %s", w.name, w.message);
              }
            }
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          switch (arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; ++i)
                args[i] = arguments[i];
              this.listener.apply(this.target, args);
          }
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = bind2.call(onceWrapper, state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = objectKeys(events);
          var key;
          for (i = 0; i < keys2.length; ++i) {
            key = keys2[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = objectCreate(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (!events)
          return [];
        var evlistener = events[type];
        if (!evlistener)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index2) {
        for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      function arrayClone(arr, n) {
        var copy2 = new Array(n);
        for (var i = 0; i < n; ++i)
          copy2[i] = arr[i];
        return copy2;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function objectCreatePolyfill(proto) {
        var F = function F2() {
        };
        F.prototype = proto;
        return new F();
      }
      function objectKeysPolyfill(obj) {
        for (var k in obj)
          if (Object.prototype.hasOwnProperty.call(obj, k))
            ;
        return k;
      }
      function functionBindPolyfill(context) {
        var fn = this;
        return function() {
          return fn.apply(context, arguments);
        };
      }
    }, {}], 423: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var MD5 = require2("md5.js");
      function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer2.isBuffer(password))
          password = Buffer2.from(password, "binary");
        if (salt) {
          if (!Buffer2.isBuffer(salt))
            salt = Buffer2.from(salt, "binary");
          if (salt.length !== 8)
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8;
        var key = Buffer2.alloc(keyLen);
        var iv = Buffer2.alloc(ivLen || 0);
        var tmp = Buffer2.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
          var hash = new MD5();
          hash.update(tmp);
          hash.update(password);
          if (salt)
            hash.update(salt);
          tmp = hash.digest();
          var used = 0;
          if (keyLen > 0) {
            var keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
          }
          if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen;
            var length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
          }
        }
        tmp.fill(0);
        return { key, iv };
      }
      module2.exports = EVP_BytesToKey;
    }, { "md5.js": 450, "safe-buffer": 494 }], 424: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CsvParserStream = exports2.ParserOptions = exports2.parseFile = exports2.parseStream = exports2.parseString = exports2.parse = exports2.FormatterOptions = exports2.CsvFormatterStream = exports2.writeToPath = exports2.writeToString = exports2.writeToBuffer = exports2.writeToStream = exports2.write = exports2.format = void 0;
      var format_1 = require2("@fast-csv/format");
      Object.defineProperty(exports2, "format", { enumerable: true, get: function get() {
        return format_1.format;
      } });
      Object.defineProperty(exports2, "write", { enumerable: true, get: function get() {
        return format_1.write;
      } });
      Object.defineProperty(exports2, "writeToStream", { enumerable: true, get: function get() {
        return format_1.writeToStream;
      } });
      Object.defineProperty(exports2, "writeToBuffer", { enumerable: true, get: function get() {
        return format_1.writeToBuffer;
      } });
      Object.defineProperty(exports2, "writeToString", { enumerable: true, get: function get() {
        return format_1.writeToString;
      } });
      Object.defineProperty(exports2, "writeToPath", { enumerable: true, get: function get() {
        return format_1.writeToPath;
      } });
      Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function get() {
        return format_1.CsvFormatterStream;
      } });
      Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function get() {
        return format_1.FormatterOptions;
      } });
      var parse_1 = require2("@fast-csv/parse");
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function get() {
        return parse_1.parse;
      } });
      Object.defineProperty(exports2, "parseString", { enumerable: true, get: function get() {
        return parse_1.parseString;
      } });
      Object.defineProperty(exports2, "parseStream", { enumerable: true, get: function get() {
        return parse_1.parseStream;
      } });
      Object.defineProperty(exports2, "parseFile", { enumerable: true, get: function get() {
        return parse_1.parseFile;
      } });
      Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function get() {
        return parse_1.ParserOptions;
      } });
      Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function get() {
        return parse_1.CsvParserStream;
      } });
    }, { "@fast-csv/format": 151, "@fast-csv/parse": 155 }], 425: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      var Transform = require2("readable-stream").Transform;
      var inherits = require2("inherits");
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer2.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform.call(this);
        this._block = Buffer2.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits(HashBase, Transform);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; )
            block[i++] = data[offset++];
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length)
          block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry2 = data.length * 8; carry2 > 0; ++j) {
          this._length[j] += carry2;
          carry2 = this._length[j] / 4294967296 | 0;
          if (carry2 > 0)
            this._length[j] -= 4294967296 * carry2;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i)
          this._length[i] = 0;
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module2.exports = HashBase;
    }, { "inherits": 440, "readable-stream": 491, "safe-buffer": 494 }], 426: [function(require2, module2, exports2) {
      var hash = exports2;
      hash.utils = require2("./hash/utils");
      hash.common = require2("./hash/common");
      hash.sha = require2("./hash/sha");
      hash.ripemd = require2("./hash/ripemd");
      hash.hmac = require2("./hash/hmac");
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }, { "./hash/common": 427, "./hash/hmac": 428, "./hash/ripemd": 429, "./hash/sha": 430, "./hash/utils": 437 }], 427: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t2 = 8; t2 < this.padLength; t2++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t2 = 8; t2 < this.padLength; t2++)
            res[i++] = 0;
        }
        return res;
      };
    }, { "./utils": 437, "minimalistic-assert": 453 }], 428: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }, { "./utils": 437, "minimalistic-assert": 453 }], 429: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var common = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports2.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    }, { "./common": 427, "./utils": 437 }], 430: [function(require2, module2, exports2) {
      exports2.sha1 = require2("./sha/1");
      exports2.sha224 = require2("./sha/224");
      exports2.sha256 = require2("./sha/256");
      exports2.sha384 = require2("./sha/384");
      exports2.sha512 = require2("./sha/512");
    }, { "./sha/1": 431, "./sha/224": 432, "./sha/256": 433, "./sha/384": 434, "./sha/512": 435 }], 431: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t2 = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t2;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 427, "../utils": 437, "./common": 436 }], 432: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA256 = require2("./256");
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      utils.inherits(SHA224, SHA256);
      module2.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }, { "../utils": 437, "./256": 433 }], 433: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var assert = require2("minimalistic-assert");
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module2.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h3 = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h3, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h3 = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h3);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 427, "../utils": 437, "./common": 436, "minimalistic-assert": 453 }], 434: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA512 = require2("./512");
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      utils.inherits(SHA384, SHA512);
      module2.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }, { "../utils": 437, "./512": 435 }], 435: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var assert = require2("minimalistic-assert");
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module2.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }, { "../common": 427, "../utils": 437, "minimalistic-assert": 453 }], 436: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports2.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports2.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports2.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports2.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports2.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports2.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports2.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports2.g1_256 = g1_256;
    }, { "../utils": 437 }], 437: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      exports2.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports2.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports2.toHex = toHex2;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports2.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports2.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports2.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports2.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports2.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports2.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry2 = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry2 += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry2 += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry2 += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry2;
        return hi >>> 0;
      }
      exports2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry2 = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry2 += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry2 += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry2 += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry2 += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry2;
        return hi >>> 0;
      }
      exports2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.shr64_lo = shr64_lo;
    }, { "inherits": 440, "minimalistic-assert": 453 }], 438: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var utils = require2("minimalistic-crypto-utils");
      var assert = require2("minimalistic-assert");
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }, { "hash.js": 426, "minimalistic-assert": 453, "minimalistic-crypto-utils": 454 }], 439: [function(require2, module2, exports2) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }, {}], 440: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor2() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}], 441: [function(require2, module2, exports2) {
      (function(process2, global2, Buffer2, __argument0, __argument1, __argument2, __argument3, setImmediate) {
        (function() {
          /*!
          
          	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
          	<http://stuartk.com/jszip>
          
          	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
          	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
          
          	JSZip uses the library pako released under the MIT license :
          	https://github.com/nodeca/pako/blob/main/LICENSE
          	*/
          !function(e) {
            if ("object" == typeof exports2 && "undefined" != typeof module2)
              module2.exports = e();
            else {
              ("undefined" != typeof window ? window : "undefined" != typeof global2 ? global2 : "undefined" != typeof self ? self : this).JSZip = e();
            }
          }(function() {
            return function s(a, o, h3) {
              function u(r, e2) {
                if (!o[r]) {
                  if (!a[r]) {
                    var t2 = "function" == typeof require2 && require2;
                    if (!e2 && t2)
                      return t2(r, true);
                    if (l)
                      return l(r, true);
                    var n = new Error("Cannot find module '" + r + "'");
                    throw n.code = "MODULE_NOT_FOUND", n;
                  }
                  var i = o[r] = { exports: {} };
                  a[r][0].call(i.exports, function(e3) {
                    var t3 = a[r][1][e3];
                    return u(t3 || e3);
                  }, i, i.exports, s, a, o, h3);
                }
                return o[r].exports;
              }
              for (var l = "function" == typeof require2 && require2, e = 0; e < h3.length; e++)
                u(h3[e]);
              return u;
            }({ 1: [function(e, t2, r) {
              var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              r.encode = function(e2) {
                for (var t3, r2, n, i, s, a, o, h3 = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
                  f = l - u, n = c2 ? (t3 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t3 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t3 >> 2, s = (3 & t3) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h3.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
                return h3.join("");
              }, r.decode = function(e2) {
                var t3, r2, n, i, s, a, o = 0, h3 = 0, u = "data:";
                if (e2.substr(0, u.length) === u)
                  throw new Error("Invalid base64 input, it looks like a data url.");
                var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
                  throw new Error("Invalid base64 input, bad content length.");
                for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
                  t3 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h3++] = t3, 64 !== s && (l[h3++] = r2), 64 !== a && (l[h3++] = n);
                return l;
              };
            }, { "./support": 30, "./utils": 32 }], 2: [function(e, t2, r) {
              var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
              function o(e2, t3, r2, n2, i2) {
                this.compressedSize = e2, this.uncompressedSize = t3, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
              }
              o.prototype = { getContentWorker: function getContentWorker() {
                var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t3 = this;
                return e2.on("end", function() {
                  if (this.streamInfo.data_length !== t3.uncompressedSize)
                    throw new Error("Bug : uncompressed data size mismatch");
                }), e2;
              }, getCompressedWorker: function getCompressedWorker() {
                return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
              } }, o.createWorkerFrom = function(e2, t3, r2) {
                return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t3.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t3);
              }, t2.exports = o;
            }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t2, r) {
              var n = e("./stream/GenericWorker");
              r.STORE = { magic: "\0\0", compressWorker: function compressWorker() {
                return new n("STORE compression");
              }, uncompressWorker: function uncompressWorker() {
                return new n("STORE decompression");
              } }, r.DEFLATE = e("./flate");
            }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t2, r) {
              var n = e("./utils");
              var o = function() {
                for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
                  e2 = r2;
                  for (var n2 = 0; n2 < 8; n2++)
                    e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                  t3[r2] = e2;
                }
                return t3;
              }();
              t2.exports = function(e2, t3) {
                return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t4, r2, n2) {
                  var i = o, s = n2 + r2;
                  e3 ^= -1;
                  for (var a = n2; a < s; a++)
                    e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4[a])];
                  return -1 ^ e3;
                }(0 | t3, e2, e2.length, 0) : function(e3, t4, r2, n2) {
                  var i = o, s = n2 + r2;
                  e3 ^= -1;
                  for (var a = n2; a < s; a++)
                    e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4.charCodeAt(a))];
                  return -1 ^ e3;
                }(0 | t3, e2, e2.length, 0) : 0;
              };
            }, { "./utils": 32 }], 5: [function(e, t2, r) {
              r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
            }, {}], 6: [function(e, t2, r) {
              var n = null;
              n = "undefined" != typeof Promise ? Promise : e("lie"), t2.exports = { Promise: n };
            }, { lie: 37 }], 7: [function(e, t2, r) {
              var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
              function h3(e2, t3) {
                a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t3, this.meta = {};
              }
              r.magic = "\b\0", s.inherits(h3, a), h3.prototype.processChunk = function(e2) {
                this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
              }, h3.prototype.flush = function() {
                a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
              }, h3.prototype.cleanUp = function() {
                a.prototype.cleanUp.call(this), this._pako = null;
              }, h3.prototype._createPako = function() {
                this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
                var t3 = this;
                this._pako.onData = function(e2) {
                  t3.push({ data: e2, meta: t3.meta });
                };
              }, r.compressWorker = function(e2) {
                return new h3("Deflate", e2);
              }, r.uncompressWorker = function() {
                return new h3("Inflate", {});
              };
            }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t2, r) {
              function A(e2, t3) {
                var r2, n2 = "";
                for (r2 = 0; r2 < t3; r2++)
                  n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
                return n2;
              }
              function n(e2, t3, r2, n2, i2, s2) {
                var a, o, h3 = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h3.name)), c = I.transformTo("string", O.utf8encode(h3.name)), d = h3.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h3.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h3.dir, k = h3.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                t3 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
                var S = 0;
                t3 && (S |= 8), l || !_ && !g || (S |= 2048);
                var z = 0, C = 0;
                w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t4) {
                  var r3 = e3;
                  return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16;
                }(h3.unixPermissions, w)) : (C = 20, z |= function(e3) {
                  return 63 & (e3 || 0);
                }(h3.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
                var E = "";
                return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
              }
              var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
              function s(e2, t3, r2, n2) {
                i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
              }
              I.inherits(s, i), s.prototype.push = function(e2) {
                var t3 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
                this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
              }, s.prototype.openedSource = function(e2) {
                this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
                var t3 = this.streamFiles && !e2.file.dir;
                if (t3) {
                  var r2 = n(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                  this.push({ data: r2.fileRecord, meta: { percent: 0 } });
                } else
                  this.accumulate = true;
              }, s.prototype.closedSource = function(e2) {
                this.accumulate = false;
                var t3 = this.streamFiles && !e2.file.dir, r2 = n(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                if (this.dirRecords.push(r2.dirRecord), t3)
                  this.push({ data: function(e3) {
                    return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
                  }(e2), meta: { percent: 100 } });
                else
                  for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                    this.push(this.contentBuffer.shift());
                this.currentFile = null;
              }, s.prototype.flush = function() {
                for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
                  this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
                var r2 = this.bytesWritten - e2, n2 = function(e3, t4, r3, n3, i2) {
                  var s2 = I.transformTo("string", i2(n3));
                  return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t4, 4) + A(r3, 4) + A(s2.length, 2) + s2;
                }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
                this.push({ data: n2, meta: { percent: 100 } });
              }, s.prototype.prepareNextSource = function() {
                this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
              }, s.prototype.registerPrevious = function(e2) {
                this._sources.push(e2);
                var t3 = this;
                return e2.on("data", function(e3) {
                  t3.processChunk(e3);
                }), e2.on("end", function() {
                  t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
                }), e2.on("error", function(e3) {
                  t3.error(e3);
                }), this;
              }, s.prototype.resume = function() {
                return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
              }, s.prototype.error = function(e2) {
                var t3 = this._sources;
                if (!i.prototype.error.call(this, e2))
                  return false;
                for (var r2 = 0; r2 < t3.length; r2++)
                  try {
                    t3[r2].error(e2);
                  } catch (e3) {
                  }
                return true;
              }, s.prototype.lock = function() {
                i.prototype.lock.call(this);
                for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++)
                  e2[t3].lock();
              }, t2.exports = s;
            }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t2, r) {
              var u = e("../compressions"), n = e("./ZipFileWorker");
              r.generateWorker = function(e2, a, t3) {
                var o = new n(a.streamFiles, t3, a.platform, a.encodeFileName), h3 = 0;
                try {
                  e2.forEach(function(e3, t4) {
                    h3++;
                    var r2 = function(e4, t5) {
                      var r3 = e4 || t5, n3 = u[r3];
                      if (!n3)
                        throw new Error(r3 + " is not a valid compression method !");
                      return n3;
                    }(t4.options.compression, a.compression), n2 = t4.options.compressionOptions || a.compressionOptions || {}, i = t4.dir, s = t4.date;
                    t4._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o);
                  }), o.entriesCount = h3;
                } catch (e3) {
                  o.error(e3);
                }
                return o;
              };
            }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t2, r) {
              function n() {
                if (!(this instanceof n))
                  return new n();
                if (arguments.length)
                  throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                  var e2 = new n();
                  for (var t3 in this)
                    "function" != typeof this[t3] && (e2[t3] = this[t3]);
                  return e2;
                };
              }
              (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t3) {
                return new n().loadAsync(e2, t3);
              }, n.external = e("./external"), t2.exports = n;
            }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t2, r) {
              var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
              function f(n2) {
                return new i.Promise(function(e2, t3) {
                  var r2 = n2.decompressed.getContentWorker().pipe(new a());
                  r2.on("error", function(e3) {
                    t3(e3);
                  }).on("end", function() {
                    r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e2();
                  }).resume();
                });
              }
              t2.exports = function(e2, o) {
                var h3 = this;
                return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
                  var t3 = new s(o);
                  return t3.load(e3), t3;
                }).then(function(e3) {
                  var t3 = [i.Promise.resolve(e3)], r2 = e3.files;
                  if (o.checkCRC32)
                    for (var n2 = 0; n2 < r2.length; n2++)
                      t3.push(f(r2[n2]));
                  return i.Promise.all(t3);
                }).then(function(e3) {
                  for (var t3 = e3.shift(), r2 = t3.files, n2 = 0; n2 < r2.length; n2++) {
                    var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
                    h3.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h3.file(a2).unsafeOriginalName = s2);
                  }
                  return t3.zipComment.length && (h3.comment = t3.zipComment), h3;
                });
              };
            }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t2, r) {
              var n = e("../utils"), i = e("../stream/GenericWorker");
              function s(e2, t3) {
                i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t3);
              }
              n.inherits(s, i), s.prototype._bindStream = function(e2) {
                var t3 = this;
                (this._stream = e2).pause(), e2.on("data", function(e3) {
                  t3.push({ data: e3, meta: { percent: 0 } });
                }).on("error", function(e3) {
                  t3.isPaused ? this.generatedError = e3 : t3.error(e3);
                }).on("end", function() {
                  t3.isPaused ? t3._upstreamEnded = true : t3.end();
                });
              }, s.prototype.pause = function() {
                return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
              }, s.prototype.resume = function() {
                return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
              }, t2.exports = s;
            }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t2, r) {
              var i = e("readable-stream").Readable;
              function n(e2, t3, r2) {
                i.call(this, t3), this._helper = e2;
                var n2 = this;
                e2.on("data", function(e3, t4) {
                  n2.push(e3) || n2._helper.pause(), r2 && r2(t4);
                }).on("error", function(e3) {
                  n2.emit("error", e3);
                }).on("end", function() {
                  n2.push(null);
                });
              }
              e("../utils").inherits(n, i), n.prototype._read = function() {
                this._helper.resume();
              }, t2.exports = n;
            }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t2, r) {
              t2.exports = { isNode: "undefined" != typeof Buffer2, newBufferFrom: function newBufferFrom(e2, t3) {
                if (Buffer2.from && Buffer2.from !== Uint8Array.from)
                  return Buffer2.from(e2, t3);
                if ("number" == typeof e2)
                  throw new Error('The "data" argument must not be a number');
                return new Buffer2(e2, t3);
              }, allocBuffer: function allocBuffer(e2) {
                if (Buffer2.alloc)
                  return Buffer2.alloc(e2);
                var t3 = new Buffer2(e2);
                return t3.fill(0), t3;
              }, isBuffer: function isBuffer(e2) {
                return Buffer2.isBuffer(e2);
              }, isStream: function isStream(e2) {
                return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
              } };
            }, {}], 15: [function(e, t2, r) {
              function s(e2, t3, r2) {
                var n2, i2 = u.getTypeOf(t3), s2 = u.extend(r2 || {}, f);
                s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
                var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
                r2 && void 0 !== r2.binary || (s2.binary = !a2), (t3 instanceof c && 0 === t3.uncompressedSize || s2.dir || !t3 || 0 === t3.length) && (s2.base64 = false, s2.binary = true, t3 = "", s2.compression = "STORE", i2 = "string");
                var o2 = null;
                o2 = t3 instanceof c || t3 instanceof l ? t3 : p.isNode && p.isStream(t3) ? new m(e2, t3) : u.prepareContent(e2, t3, s2.binary, s2.optimizedBinaryString, s2.base64);
                var h4 = new d(e2, o2, s2);
                this.files[e2] = h4;
              }
              var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function _2(e2) {
                "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
                var t3 = e2.lastIndexOf("/");
                return 0 < t3 ? e2.substring(0, t3) : "";
              }, g = function g2(e2) {
                return "/" !== e2.slice(-1) && (e2 += "/"), e2;
              }, b = function b2(e2, t3) {
                return t3 = void 0 !== t3 ? t3 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t3 }), this.files[e2];
              };
              function h3(e2) {
                return "[object RegExp]" === Object.prototype.toString.call(e2);
              }
              var n = { load: function load() {
                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
              }, forEach: function forEach(e2) {
                var t3, r2, n2;
                for (t3 in this.files)
                  n2 = this.files[t3], (r2 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e2(r2, n2);
              }, filter: function filter(r2) {
                var n2 = [];
                return this.forEach(function(e2, t3) {
                  r2(e2, t3) && n2.push(t3);
                }), n2;
              }, file: function file(e2, t3, r2) {
                if (1 !== arguments.length)
                  return e2 = this.root + e2, s.call(this, e2, t3, r2), this;
                if (h3(e2)) {
                  var n2 = e2;
                  return this.filter(function(e3, t4) {
                    return !t4.dir && n2.test(e3);
                  });
                }
                var i2 = this.files[this.root + e2];
                return i2 && !i2.dir ? i2 : null;
              }, folder: function folder(r2) {
                if (!r2)
                  return this;
                if (h3(r2))
                  return this.filter(function(e3, t4) {
                    return t4.dir && r2.test(e3);
                  });
                var e2 = this.root + r2, t3 = b.call(this, e2), n2 = this.clone();
                return n2.root = t3.name, n2;
              }, remove: function remove(r2) {
                r2 = this.root + r2;
                var e2 = this.files[r2];
                if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
                  delete this.files[r2];
                else
                  for (var t3 = this.filter(function(e3, t4) {
                    return t4.name.slice(0, r2.length) === r2;
                  }), n2 = 0; n2 < t3.length; n2++)
                    delete this.files[t3[n2].name];
                return this;
              }, generate: function generate() {
                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
              }, generateInternalStream: function generateInternalStream(e2) {
                var t3, r2 = {};
                try {
                  if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
                    throw new Error("No output type specified.");
                  u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
                  var n2 = r2.comment || this.comment || "";
                  t3 = o.generateWorker(this, r2, n2);
                } catch (e3) {
                  (t3 = new l("error")).error(e3);
                }
                return new a(t3, r2.type || "string", r2.mimeType);
              }, generateAsync: function generateAsync(e2, t3) {
                return this.generateInternalStream(e2).accumulate(t3);
              }, generateNodeStream: function generateNodeStream(e2, t3) {
                return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t3);
              } };
              t2.exports = n;
            }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t2, r) {
              t2.exports = e("stream");
            }, { stream: void 0 }], 17: [function(e, t2, r) {
              var n = e("./DataReader");
              function i(e2) {
                n.call(this, e2);
                for (var t3 = 0; t3 < this.data.length; t3++)
                  e2[t3] = 255 & e2[t3];
              }
              e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
                return this.data[this.zero + e2];
              }, i.prototype.lastIndexOfSignature = function(e2) {
                for (var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
                  if (this.data[s] === t3 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
                    return s - this.zero;
                return -1;
              }, i.prototype.readAndCheckSignature = function(e2) {
                var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
                return t3 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
              }, i.prototype.readData = function(e2) {
                if (this.checkOffset(e2), 0 === e2)
                  return [];
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                return this.index += e2, t3;
              }, t2.exports = i;
            }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t2, r) {
              var n = e("../utils");
              function i(e2) {
                this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
              }
              i.prototype = { checkOffset: function checkOffset(e2) {
                this.checkIndex(this.index + e2);
              }, checkIndex: function checkIndex(e2) {
                if (this.length < this.zero + e2 || e2 < 0)
                  throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
              }, setIndex: function setIndex(e2) {
                this.checkIndex(e2), this.index = e2;
              }, skip: function skip(e2) {
                this.setIndex(this.index + e2);
              }, byteAt: function byteAt() {
              }, readInt: function readInt(e2) {
                var t3, r2 = 0;
                for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--)
                  r2 = (r2 << 8) + this.byteAt(t3);
                return this.index += e2, r2;
              }, readString: function readString(e2) {
                return n.transformTo("string", this.readData(e2));
              }, readData: function readData() {
              }, lastIndexOfSignature: function lastIndexOfSignature() {
              }, readAndCheckSignature: function readAndCheckSignature() {
              }, readDate: function readDate() {
                var e2 = this.readInt(4);
                return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
              } }, t2.exports = i;
            }, { "../utils": 32 }], 19: [function(e, t2, r) {
              var n = e("./Uint8ArrayReader");
              function i(e2) {
                n.call(this, e2);
              }
              e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
                this.checkOffset(e2);
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                return this.index += e2, t3;
              }, t2.exports = i;
            }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t2, r) {
              var n = e("./DataReader");
              function i(e2) {
                n.call(this, e2);
              }
              e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
                return this.data.charCodeAt(this.zero + e2);
              }, i.prototype.lastIndexOfSignature = function(e2) {
                return this.data.lastIndexOf(e2) - this.zero;
              }, i.prototype.readAndCheckSignature = function(e2) {
                return e2 === this.readData(4);
              }, i.prototype.readData = function(e2) {
                this.checkOffset(e2);
                var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                return this.index += e2, t3;
              }, t2.exports = i;
            }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t2, r) {
              var n = e("./ArrayReader");
              function i(e2) {
                n.call(this, e2);
              }
              e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
                if (this.checkOffset(e2), 0 === e2)
                  return new Uint8Array(0);
                var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
                return this.index += e2, t3;
              }, t2.exports = i;
            }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t2, r) {
              var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h3 = e("./Uint8ArrayReader");
              t2.exports = function(e2) {
                var t3 = n.getTypeOf(e2);
                return n.checkSupport(t3), "string" !== t3 || i.uint8array ? "nodebuffer" === t3 ? new o(e2) : i.uint8array ? new h3(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
              };
            }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t2, r) {
              r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
            }, {}], 24: [function(e, t2, r) {
              var n = e("./GenericWorker"), i = e("../utils");
              function s(e2) {
                n.call(this, "ConvertWorker to " + e2), this.destType = e2;
              }
              i.inherits(s, n), s.prototype.processChunk = function(e2) {
                this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
              }, t2.exports = s;
            }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t2, r) {
              var n = e("./GenericWorker"), i = e("../crc32");
              function s() {
                n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
              }
              e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
                this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
              }, t2.exports = s;
            }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t2, r) {
              var n = e("../utils"), i = e("./GenericWorker");
              function s(e2) {
                i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
              }
              n.inherits(s, i), s.prototype.processChunk = function(e2) {
                if (e2) {
                  var t3 = this.streamInfo[this.propName] || 0;
                  this.streamInfo[this.propName] = t3 + e2.data.length;
                }
                i.prototype.processChunk.call(this, e2);
              }, t2.exports = s;
            }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t2, r) {
              var n = e("../utils"), i = e("./GenericWorker");
              function s(e2) {
                i.call(this, "DataWorker");
                var t3 = this;
                this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
                  t3.dataIsReady = true, t3.data = e3, t3.max = e3 && e3.length || 0, t3.type = n.getTypeOf(e3), t3.isPaused || t3._tickAndRepeat();
                }, function(e3) {
                  t3.error(e3);
                });
              }
              n.inherits(s, i), s.prototype.cleanUp = function() {
                i.prototype.cleanUp.call(this), this.data = null;
              }, s.prototype.resume = function() {
                return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
              }, s.prototype._tickAndRepeat = function() {
                this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
              }, s.prototype._tick = function() {
                if (this.isPaused || this.isFinished)
                  return false;
                var e2 = null, t3 = Math.min(this.max, this.index + 16384);
                if (this.index >= this.max)
                  return this.end();
                switch (this.type) {
                  case "string":
                    e2 = this.data.substring(this.index, t3);
                    break;
                  case "uint8array":
                    e2 = this.data.subarray(this.index, t3);
                    break;
                  case "array":
                  case "nodebuffer":
                    e2 = this.data.slice(this.index, t3);
                }
                return this.index = t3, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
              }, t2.exports = s;
            }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t2, r) {
              function n(e2) {
                this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
              }
              n.prototype = { push: function push(e2) {
                this.emit("data", e2);
              }, end: function end() {
                if (this.isFinished)
                  return false;
                this.flush();
                try {
                  this.emit("end"), this.cleanUp(), this.isFinished = true;
                } catch (e2) {
                  this.emit("error", e2);
                }
                return true;
              }, error: function error(e2) {
                return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
              }, on: function on(e2, t3) {
                return this._listeners[e2].push(t3), this;
              }, cleanUp: function cleanUp() {
                this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
              }, emit: function emit(e2, t3) {
                if (this._listeners[e2])
                  for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
                    this._listeners[e2][r2].call(this, t3);
              }, pipe: function pipe(e2) {
                return e2.registerPrevious(this);
              }, registerPrevious: function registerPrevious(e2) {
                if (this.isLocked)
                  throw new Error("The stream '" + this + "' has already been used.");
                this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
                var t3 = this;
                return e2.on("data", function(e3) {
                  t3.processChunk(e3);
                }), e2.on("end", function() {
                  t3.end();
                }), e2.on("error", function(e3) {
                  t3.error(e3);
                }), this;
              }, pause: function pause() {
                return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
              }, resume: function resume() {
                if (!this.isPaused || this.isFinished)
                  return false;
                var e2 = this.isPaused = false;
                return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
              }, flush: function flush() {
              }, processChunk: function processChunk(e2) {
                this.push(e2);
              }, withStreamInfo: function withStreamInfo(e2, t3) {
                return this.extraStreamInfo[e2] = t3, this.mergeStreamInfo(), this;
              }, mergeStreamInfo: function mergeStreamInfo() {
                for (var e2 in this.extraStreamInfo)
                  Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
              }, lock: function lock() {
                if (this.isLocked)
                  throw new Error("The stream '" + this + "' has already been used.");
                this.isLocked = true, this.previous && this.previous.lock();
              }, toString: function toString2() {
                var e2 = "Worker " + this.name;
                return this.previous ? this.previous + " -> " + e2 : e2;
              } }, t2.exports = n;
            }, {}], 29: [function(e, t2, r) {
              var h3 = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
              if (n.nodestream)
                try {
                  o = e("../nodejs/NodejsStreamOutputAdapter");
                } catch (e2) {
                }
              function l(e2, o2) {
                return new a.Promise(function(t3, r2) {
                  var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
                  e2.on("data", function(e3, t4) {
                    n2.push(e3), o2 && o2(t4);
                  }).on("error", function(e3) {
                    n2 = [], r2(e3);
                  }).on("end", function() {
                    try {
                      var e3 = function(e4, t4, r3) {
                        switch (e4) {
                          case "blob":
                            return h3.newBlob(h3.transformTo("arraybuffer", t4), r3);
                          case "base64":
                            return u.encode(t4);
                          default:
                            return h3.transformTo(e4, t4);
                        }
                      }(s2, function(e4, t4) {
                        var r3, n3 = 0, i3 = null, s3 = 0;
                        for (r3 = 0; r3 < t4.length; r3++)
                          s3 += t4[r3].length;
                        switch (e4) {
                          case "string":
                            return t4.join("");
                          case "array":
                            return Array.prototype.concat.apply([], t4);
                          case "uint8array":
                            for (i3 = new Uint8Array(s3), r3 = 0; r3 < t4.length; r3++)
                              i3.set(t4[r3], n3), n3 += t4[r3].length;
                            return i3;
                          case "nodebuffer":
                            return Buffer2.concat(t4);
                          default:
                            throw new Error("concat : unsupported type '" + e4 + "'");
                        }
                      }(i2, n2), a2);
                      t3(e3);
                    } catch (e4) {
                      r2(e4);
                    }
                    n2 = [];
                  }).resume();
                });
              }
              function f(e2, t3, r2) {
                var n2 = t3;
                switch (t3) {
                  case "blob":
                  case "arraybuffer":
                    n2 = "uint8array";
                    break;
                  case "base64":
                    n2 = "string";
                }
                try {
                  this._internalType = n2, this._outputType = t3, this._mimeType = r2, h3.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
                } catch (e3) {
                  this._worker = new s("error"), this._worker.error(e3);
                }
              }
              f.prototype = { accumulate: function accumulate(e2) {
                return l(this, e2);
              }, on: function on(e2, t3) {
                var r2 = this;
                return "data" === e2 ? this._worker.on(e2, function(e3) {
                  t3.call(r2, e3.data, e3.meta);
                }) : this._worker.on(e2, function() {
                  h3.delay(t3, arguments, r2);
                }), this;
              }, resume: function resume() {
                return h3.delay(this._worker.resume, [], this._worker), this;
              }, pause: function pause() {
                return this._worker.pause(), this;
              }, toNodejsStream: function toNodejsStream(e2) {
                if (h3.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
                  throw new Error(this._outputType + " is not supported by this method");
                return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
              } }, t2.exports = f;
            }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t2, r) {
              if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer2, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
                r.blob = false;
              else {
                var n = new ArrayBuffer(0);
                try {
                  r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
                } catch (e2) {
                  try {
                    var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                    i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
                  } catch (e3) {
                    r.blob = false;
                  }
                }
              }
              try {
                r.nodestream = !!e("readable-stream").Readable;
              } catch (e2) {
                r.nodestream = false;
              }
            }, { "readable-stream": 16 }], 31: [function(e, t2, s) {
              for (var o = e("./utils"), h3 = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
                u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
              u[254] = u[254] = 1;
              function a() {
                n.call(this, "utf-8 decode"), this.leftOver = null;
              }
              function l() {
                n.call(this, "utf-8 encode");
              }
              s.utf8encode = function(e2) {
                return h3.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
                  var t3, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
                  for (i2 = 0; i2 < a2; i2++)
                    55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
                  for (t3 = h3.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
                    55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
                  return t3;
                }(e2);
              }, s.utf8decode = function(e2) {
                return h3.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
                  var t3, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
                  for (t3 = r2 = 0; t3 < s2; )
                    if ((n2 = e3[t3++]) < 128)
                      a2[r2++] = n2;
                    else if (4 < (i2 = u[n2]))
                      a2[r2++] = 65533, t3 += i2 - 1;
                    else {
                      for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t3 < s2; )
                        n2 = n2 << 6 | 63 & e3[t3++], i2--;
                      1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
                    }
                  return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
                }(e2 = o.transformTo(h3.uint8array ? "uint8array" : "array", e2));
              }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
                var t3 = o.transformTo(h3.uint8array ? "uint8array" : "array", e2.data);
                if (this.leftOver && this.leftOver.length) {
                  if (h3.uint8array) {
                    var r2 = t3;
                    (t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r2, this.leftOver.length);
                  } else
                    t3 = this.leftOver.concat(t3);
                  this.leftOver = null;
                }
                var n2 = function(e3, t4) {
                  var r3;
                  for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
                    r3--;
                  return r3 < 0 ? t4 : 0 === r3 ? t4 : r3 + u[e3[r3]] > t4 ? r3 : t4;
                }(t3), i2 = t3;
                n2 !== t3.length && (h3.uint8array ? (i2 = t3.subarray(0, n2), this.leftOver = t3.subarray(n2, t3.length)) : (i2 = t3.slice(0, n2), this.leftOver = t3.slice(n2, t3.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
              }, a.prototype.flush = function() {
                this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
              }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
                this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
              }, s.Utf8EncodeWorker = l;
            }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t2, a) {
              var o = e("./support"), h3 = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
              function n(e2) {
                return e2;
              }
              function l(e2, t3) {
                for (var r2 = 0; r2 < e2.length; ++r2)
                  t3[r2] = 255 & e2.charCodeAt(r2);
                return t3;
              }
              e("setimmediate"), a.newBlob = function(t3, r2) {
                a.checkSupport("blob");
                try {
                  return new Blob([t3], { type: r2 });
                } catch (e2) {
                  try {
                    var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                    return n2.append(t3), n2.getBlob(r2);
                  } catch (e3) {
                    throw new Error("Bug : can't construct the Blob.");
                  }
                }
              };
              var i = { stringifyByChunk: function stringifyByChunk(e2, t3, r2) {
                var n2 = [], i2 = 0, s2 = e2.length;
                if (s2 <= r2)
                  return String.fromCharCode.apply(null, e2);
                for (; i2 < s2; )
                  "array" === t3 || "nodebuffer" === t3 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
                return n2.join("");
              }, stringifyByChar: function stringifyByChar(e2) {
                for (var t3 = "", r2 = 0; r2 < e2.length; r2++)
                  t3 += String.fromCharCode(e2[r2]);
                return t3;
              }, applyCanBeUsed: { uint8array: function() {
                try {
                  return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                } catch (e2) {
                  return false;
                }
              }(), nodebuffer: function() {
                try {
                  return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
                } catch (e2) {
                  return false;
                }
              }() } };
              function s(e2) {
                var t3 = 65536, r2 = a.getTypeOf(e2), n2 = true;
                if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
                  for (; 1 < t3; )
                    try {
                      return i.stringifyByChunk(e2, r2, t3);
                    } catch (e3) {
                      t3 = Math.floor(t3 / 2);
                    }
                return i.stringifyByChar(e2);
              }
              function f(e2, t3) {
                for (var r2 = 0; r2 < e2.length; r2++)
                  t3[r2] = e2[r2];
                return t3;
              }
              a.applyFromCharCode = s;
              var c = {};
              c.string = { string: n, array: function array(e2) {
                return l(e2, new Array(e2.length));
              }, arraybuffer: function arraybuffer(e2) {
                return c.string.uint8array(e2).buffer;
              }, uint8array: function uint8array(e2) {
                return l(e2, new Uint8Array(e2.length));
              }, nodebuffer: function nodebuffer(e2) {
                return l(e2, r.allocBuffer(e2.length));
              } }, c.array = { string: s, array: n, arraybuffer: function arraybuffer(e2) {
                return new Uint8Array(e2).buffer;
              }, uint8array: function uint8array(e2) {
                return new Uint8Array(e2);
              }, nodebuffer: function nodebuffer(e2) {
                return r.newBufferFrom(e2);
              } }, c.arraybuffer = { string: function string(e2) {
                return s(new Uint8Array(e2));
              }, array: function array(e2) {
                return f(new Uint8Array(e2), new Array(e2.byteLength));
              }, arraybuffer: n, uint8array: function uint8array(e2) {
                return new Uint8Array(e2);
              }, nodebuffer: function nodebuffer(e2) {
                return r.newBufferFrom(new Uint8Array(e2));
              } }, c.uint8array = { string: s, array: function array(e2) {
                return f(e2, new Array(e2.length));
              }, arraybuffer: function arraybuffer(e2) {
                return e2.buffer;
              }, uint8array: n, nodebuffer: function nodebuffer(e2) {
                return r.newBufferFrom(e2);
              } }, c.nodebuffer = { string: s, array: function array(e2) {
                return f(e2, new Array(e2.length));
              }, arraybuffer: function arraybuffer(e2) {
                return c.nodebuffer.uint8array(e2).buffer;
              }, uint8array: function uint8array(e2) {
                return f(e2, new Uint8Array(e2.length));
              }, nodebuffer: n }, a.transformTo = function(e2, t3) {
                if (t3 = t3 || "", !e2)
                  return t3;
                a.checkSupport(e2);
                var r2 = a.getTypeOf(t3);
                return c[r2][e2](t3);
              }, a.resolve = function(e2) {
                for (var t3 = e2.split("/"), r2 = [], n2 = 0; n2 < t3.length; n2++) {
                  var i2 = t3[n2];
                  "." === i2 || "" === i2 && 0 !== n2 && n2 !== t3.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
                }
                return r2.join("/");
              }, a.getTypeOf = function(e2) {
                return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
              }, a.checkSupport = function(e2) {
                if (!o[e2.toLowerCase()])
                  throw new Error(e2 + " is not supported by this platform");
              }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
                var t3, r2, n2 = "";
                for (r2 = 0; r2 < (e2 || "").length; r2++)
                  n2 += "\\x" + ((t3 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
                return n2;
              }, a.delay = function(e2, t3, r2) {
                setImmediate(function() {
                  e2.apply(r2 || null, t3 || []);
                });
              }, a.inherits = function(e2, t3) {
                function r2() {
                }
                r2.prototype = t3.prototype, e2.prototype = new r2();
              }, a.extend = function() {
                var e2, t3, r2 = {};
                for (e2 = 0; e2 < arguments.length; e2++)
                  for (t3 in arguments[e2])
                    Object.prototype.hasOwnProperty.call(arguments[e2], t3) && void 0 === r2[t3] && (r2[t3] = arguments[e2][t3]);
                return r2;
              }, a.prepareContent = function(r2, e2, n2, i2, s2) {
                return u.Promise.resolve(e2).then(function(n3) {
                  return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t3, r3) {
                    var e3 = new FileReader();
                    e3.onload = function(e4) {
                      t3(e4.target.result);
                    }, e3.onerror = function(e4) {
                      r3(e4.target.error);
                    }, e3.readAsArrayBuffer(n3);
                  }) : n3;
                }).then(function(e3) {
                  var t3 = a.getTypeOf(e3);
                  return t3 ? ("arraybuffer" === t3 ? e3 = a.transformTo("uint8array", e3) : "string" === t3 && (s2 ? e3 = h3.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
                    return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
                  }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                });
              };
            }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t2, r) {
              var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
              function h3(e2) {
                this.files = [], this.loadOptions = e2;
              }
              h3.prototype = { checkSignature: function checkSignature(e2) {
                if (!this.reader.readAndCheckSignature(e2)) {
                  this.reader.index -= 4;
                  var t3 = this.reader.readString(4);
                  throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t3) + ", expected " + i.pretty(e2) + ")");
                }
              }, isSignature: function isSignature(e2, t3) {
                var r2 = this.reader.index;
                this.reader.setIndex(e2);
                var n2 = this.reader.readString(4) === t3;
                return this.reader.setIndex(r2), n2;
              }, readBlockEndOfCentral: function readBlockEndOfCentral() {
                this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                var e2 = this.reader.readData(this.zipCommentLength), t3 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t3, e2);
                this.zipComment = this.loadOptions.decodeFileName(r2);
              }, readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
                this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                for (var e2, t3, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
                  e2 = this.reader.readInt(2), t3 = this.reader.readInt(4), r2 = this.reader.readData(t3), this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 };
              }, readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
                if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                  throw new Error("Multi-volumes zip are not supported");
              }, readLocalFiles: function readLocalFiles() {
                var e2, t3;
                for (e2 = 0; e2 < this.files.length; e2++)
                  t3 = this.files[e2], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
              }, readCentralDir: function readCentralDir() {
                var e2;
                for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
                  (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
                if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
                  throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
              }, readEndOfCentral: function readEndOfCentral() {
                var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
                if (e2 < 0)
                  throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
                this.reader.setIndex(e2);
                var t3 = e2;
                if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
                  if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                  if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                  this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                }
                var r2 = this.centralDirOffset + this.centralDirSize;
                this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
                var n2 = t3 - r2;
                if (0 < n2)
                  this.isSignature(t3, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
                else if (n2 < 0)
                  throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
              }, prepareReader: function prepareReader(e2) {
                this.reader = n(e2);
              }, load: function load(e2) {
                this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
              } }, t2.exports = h3;
            }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t2, r) {
              var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h3 = e("./compressions"), u = e("./support");
              function l(e2, t3) {
                this.options = e2, this.loadOptions = t3;
              }
              l.prototype = { isEncrypted: function isEncrypted() {
                return 1 == (1 & this.bitFlag);
              }, useUTF8: function useUTF8() {
                return 2048 == (2048 & this.bitFlag);
              }, readLocalPart: function readLocalPart(e2) {
                var t3, r2;
                if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
                  throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                if (null === (t3 = function(e3) {
                  for (var t4 in h3)
                    if (Object.prototype.hasOwnProperty.call(h3, t4) && h3[t4].magic === e3)
                      return h3[t4];
                  return null;
                }(this.compressionMethod)))
                  throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t3, e2.readData(this.compressedSize));
              }, readCentralPart: function readCentralPart(e2) {
                this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
                var t3 = e2.readInt(2);
                if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
                  throw new Error("Encrypted zip are not supported");
                e2.skip(t3), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
              }, processAttributes: function processAttributes() {
                this.unixPermissions = null, this.dosPermissions = null;
                var e2 = this.versionMadeBy >> 8;
                this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
              }, parseZIP64ExtraField: function parseZIP64ExtraField() {
                if (this.extraFields[1]) {
                  var e2 = n(this.extraFields[1].value);
                  this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
                }
              }, readExtraFields: function readExtraFields(e2) {
                var t3, r2, n2, i2 = e2.index + this.extraFieldsLength;
                for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
                  t3 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t3] = { id: t3, length: r2, value: n2 };
                e2.setIndex(i2);
              }, handleUTF8: function handleUTF8() {
                var e2 = u.uint8array ? "uint8array" : "array";
                if (this.useUTF8())
                  this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
                else {
                  var t3 = this.findExtraFieldUnicodePath();
                  if (null !== t3)
                    this.fileNameStr = t3;
                  else {
                    var r2 = s.transformTo(e2, this.fileName);
                    this.fileNameStr = this.loadOptions.decodeFileName(r2);
                  }
                  var n2 = this.findExtraFieldUnicodeComment();
                  if (null !== n2)
                    this.fileCommentStr = n2;
                  else {
                    var i2 = s.transformTo(e2, this.fileComment);
                    this.fileCommentStr = this.loadOptions.decodeFileName(i2);
                  }
                }
              }, findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
                var e2 = this.extraFields[28789];
                if (e2) {
                  var t3 = n(e2.value);
                  return 1 !== t3.readInt(1) ? null : a(this.fileName) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
                }
                return null;
              }, findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
                var e2 = this.extraFields[25461];
                if (e2) {
                  var t3 = n(e2.value);
                  return 1 !== t3.readInt(1) ? null : a(this.fileComment) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
                }
                return null;
              } }, t2.exports = l;
            }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t2, r) {
              function n(e2, t3, r2) {
                this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t3, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
              }
              var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h3 = e("./stream/GenericWorker");
              n.prototype = { internalStream: function internalStream(e2) {
                var t3 = null, r2 = "string";
                try {
                  if (!e2)
                    throw new Error("No output type specified.");
                  var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
                  "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t3 = this._decompressWorker();
                  var i2 = !this._dataBinary;
                  i2 && !n2 && (t3 = t3.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t3 = t3.pipe(new a.Utf8DecodeWorker()));
                } catch (e3) {
                  (t3 = new h3("error")).error(e3);
                }
                return new s(t3, r2, "");
              }, async: function async(e2, t3) {
                return this.internalStream(e2).accumulate(t3);
              }, nodeStream: function nodeStream(e2, t3) {
                return this.internalStream(e2 || "nodebuffer").toNodejsStream(t3);
              }, _compressWorker: function _compressWorker(e2, t3) {
                if (this._data instanceof o && this._data.compression.magic === e2.magic)
                  return this._data.getCompressedWorker();
                var r2 = this._decompressWorker();
                return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t3);
              }, _decompressWorker: function _decompressWorker() {
                return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h3 ? this._data : new i(this._data);
              } };
              for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function l2() {
                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
              }, f = 0; f < u.length; f++)
                n.prototype[u[f]] = l;
              t2.exports = n;
            }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t2) {
              (function(t3) {
                var r, n, e2 = t3.MutationObserver || t3.WebKitMutationObserver;
                if (e2) {
                  var i = 0, s = new e2(u), a = t3.document.createTextNode("");
                  s.observe(a, { characterData: true }), r = function r2() {
                    a.data = i = ++i % 2;
                  };
                } else if (t3.setImmediate || void 0 === t3.MessageChannel)
                  r = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
                    var e3 = t3.document.createElement("script");
                    e3.onreadystatechange = function() {
                      u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
                    }, t3.document.documentElement.appendChild(e3);
                  } : function() {
                    setTimeout(u, 0);
                  };
                else {
                  var o = new t3.MessageChannel();
                  o.port1.onmessage = u, r = function r2() {
                    o.port2.postMessage(0);
                  };
                }
                var h3 = [];
                function u() {
                  var e3, t4;
                  n = true;
                  for (var r2 = h3.length; r2; ) {
                    for (t4 = h3, h3 = [], e3 = -1; ++e3 < r2; )
                      t4[e3]();
                    r2 = h3.length;
                  }
                  n = false;
                }
                l.exports = function(e3) {
                  1 !== h3.push(e3) || n || r();
                };
              }).call(this, "undefined" != typeof global2 ? global2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            }, {}], 37: [function(e, t2, r) {
              var i = e("immediate");
              function u() {
              }
              var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
              function o(e2) {
                if ("function" != typeof e2)
                  throw new TypeError("resolver must be a function");
                this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
              }
              function h3(e2, t3, r2) {
                this.promise = e2, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
              }
              function f(t3, r2, n2) {
                i(function() {
                  var e2;
                  try {
                    e2 = r2(n2);
                  } catch (e3) {
                    return l.reject(t3, e3);
                  }
                  e2 === t3 ? l.reject(t3, new TypeError("Cannot resolve promise with itself")) : l.resolve(t3, e2);
                });
              }
              function c(e2) {
                var t3 = e2 && e2.then;
                if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t3)
                  return function() {
                    t3.apply(e2, arguments);
                  };
              }
              function d(t3, e2) {
                var r2 = false;
                function n2(e3) {
                  r2 || (r2 = true, l.reject(t3, e3));
                }
                function i2(e3) {
                  r2 || (r2 = true, l.resolve(t3, e3));
                }
                var s2 = p(function() {
                  e2(i2, n2);
                });
                "error" === s2.status && n2(s2.value);
              }
              function p(e2, t3) {
                var r2 = {};
                try {
                  r2.value = e2(t3), r2.status = "success";
                } catch (e3) {
                  r2.status = "error", r2.value = e3;
                }
                return r2;
              }
              (t2.exports = o).prototype.finally = function(t3) {
                if ("function" != typeof t3)
                  return this;
                var r2 = this.constructor;
                return this.then(function(e2) {
                  return r2.resolve(t3()).then(function() {
                    return e2;
                  });
                }, function(e2) {
                  return r2.resolve(t3()).then(function() {
                    throw e2;
                  });
                });
              }, o.prototype.catch = function(e2) {
                return this.then(null, e2);
              }, o.prototype.then = function(e2, t3) {
                if ("function" != typeof e2 && this.state === a || "function" != typeof t3 && this.state === s)
                  return this;
                var r2 = new this.constructor(u);
                this.state !== n ? f(r2, this.state === a ? e2 : t3, this.outcome) : this.queue.push(new h3(r2, e2, t3));
                return r2;
              }, h3.prototype.callFulfilled = function(e2) {
                l.resolve(this.promise, e2);
              }, h3.prototype.otherCallFulfilled = function(e2) {
                f(this.promise, this.onFulfilled, e2);
              }, h3.prototype.callRejected = function(e2) {
                l.reject(this.promise, e2);
              }, h3.prototype.otherCallRejected = function(e2) {
                f(this.promise, this.onRejected, e2);
              }, l.resolve = function(e2, t3) {
                var r2 = p(c, t3);
                if ("error" === r2.status)
                  return l.reject(e2, r2.value);
                var n2 = r2.value;
                if (n2)
                  d(e2, n2);
                else {
                  e2.state = a, e2.outcome = t3;
                  for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
                    e2.queue[i2].callFulfilled(t3);
                }
                return e2;
              }, l.reject = function(e2, t3) {
                e2.state = s, e2.outcome = t3;
                for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
                  e2.queue[r2].callRejected(t3);
                return e2;
              }, o.resolve = function(e2) {
                if (e2 instanceof this)
                  return e2;
                return l.resolve(new this(u), e2);
              }, o.reject = function(e2) {
                var t3 = new this(u);
                return l.reject(t3, e2);
              }, o.all = function(e2) {
                var r2 = this;
                if ("[object Array]" !== Object.prototype.toString.call(e2))
                  return this.reject(new TypeError("must be an array"));
                var n2 = e2.length, i2 = false;
                if (!n2)
                  return this.resolve([]);
                var s2 = new Array(n2), a2 = 0, t3 = -1, o2 = new this(u);
                for (; ++t3 < n2; )
                  h4(e2[t3], t3);
                return o2;
                function h4(e3, t4) {
                  r2.resolve(e3).then(function(e4) {
                    s2[t4] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
                  }, function(e4) {
                    i2 || (i2 = true, l.reject(o2, e4));
                  });
                }
              }, o.race = function(e2) {
                var t3 = this;
                if ("[object Array]" !== Object.prototype.toString.call(e2))
                  return this.reject(new TypeError("must be an array"));
                var r2 = e2.length, n2 = false;
                if (!r2)
                  return this.resolve([]);
                var i2 = -1, s2 = new this(u);
                for (; ++i2 < r2; )
                  a2 = e2[i2], t3.resolve(a2).then(function(e3) {
                    n2 || (n2 = true, l.resolve(s2, e3));
                  }, function(e3) {
                    n2 || (n2 = true, l.reject(s2, e3));
                  });
                var a2;
                return s2;
              };
            }, { immediate: 36 }], 38: [function(e, t2, r) {
              var n = {};
              (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t2.exports = n;
            }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t2, r) {
              var a = e("./zlib/deflate"), o = e("./utils/common"), h3 = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
              function p(e2) {
                if (!(this instanceof p))
                  return new p(e2);
                this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
                var t3 = this.options;
                t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
                var r2 = a.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
                if (r2 !== l)
                  throw new Error(i[r2]);
                if (t3.header && a.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
                  var n2;
                  if (n2 = "string" == typeof t3.dictionary ? h3.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
                    throw new Error(i[r2]);
                  this._dict_set = true;
                }
              }
              function n(e2, t3) {
                var r2 = new p(t3);
                if (r2.push(e2, true), r2.err)
                  throw r2.msg || i[r2.err];
                return r2.result;
              }
              p.prototype.push = function(e2, t3) {
                var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
                if (this.ended)
                  return false;
                n2 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e2 ? i2.input = h3.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
                do {
                  if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
                    return this.onEnd(r2), !(this.ended = true);
                  0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h3.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
                } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
                return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
              }, p.prototype.onData = function(e2) {
                this.chunks.push(e2);
              }, p.prototype.onEnd = function(e2) {
                e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
              }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t3) {
                return (t3 = t3 || {}).raw = true, n(e2, t3);
              }, r.gzip = function(e2, t3) {
                return (t3 = t3 || {}).gzip = true, n(e2, t3);
              };
            }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t2, r) {
              var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
              function a(e2) {
                if (!(this instanceof a))
                  return new a(e2);
                this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
                var t3 = this.options;
                t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
                var r2 = c.inflateInit2(this.strm, t3.windowBits);
                if (r2 !== m.Z_OK)
                  throw new Error(n[r2]);
                this.header = new s(), c.inflateGetHeader(this.strm, this.header);
              }
              function o(e2, t3) {
                var r2 = new a(t3);
                if (r2.push(e2, true), r2.err)
                  throw r2.msg || n[r2.err];
                return r2.result;
              }
              a.prototype.push = function(e2, t3) {
                var r2, n2, i2, s2, a2, o2, h3 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
                if (this.ended)
                  return false;
                n2 = t3 === ~~t3 ? t3 : true === t3 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h3.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h3.input = new Uint8Array(e2) : h3.input = e2, h3.next_in = 0, h3.avail_in = h3.input.length;
                do {
                  if (0 === h3.avail_out && (h3.output = new d.Buf8(u), h3.next_out = 0, h3.avail_out = u), (r2 = c.inflate(h3, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
                    return this.onEnd(r2), !(this.ended = true);
                  h3.next_out && (0 !== h3.avail_out && r2 !== m.Z_STREAM_END && (0 !== h3.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h3.output, h3.next_out), s2 = h3.next_out - i2, a2 = p.buf2string(h3.output, i2), h3.next_out = s2, h3.avail_out = u - s2, s2 && d.arraySet(h3.output, h3.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h3.output, h3.next_out)))), 0 === h3.avail_in && 0 === h3.avail_out && (f = true);
                } while ((0 < h3.avail_in || 0 === h3.avail_out) && r2 !== m.Z_STREAM_END);
                return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h3.avail_out = 0));
              }, a.prototype.onData = function(e2) {
                this.chunks.push(e2);
              }, a.prototype.onEnd = function(e2) {
                e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
              }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t3) {
                return (t3 = t3 || {}).raw = true, o(e2, t3);
              }, r.ungzip = o;
            }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t2, r) {
              var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
              r.assign = function(e2) {
                for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
                  var r2 = t3.shift();
                  if (r2) {
                    if ("object" != typeof r2)
                      throw new TypeError(r2 + "must be non-object");
                    for (var n2 in r2)
                      r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
                  }
                }
                return e2;
              }, r.shrinkBuf = function(e2, t3) {
                return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : (e2.length = t3, e2);
              };
              var i = { arraySet: function arraySet(e2, t3, r2, n2, i2) {
                if (t3.subarray && e2.subarray)
                  e2.set(t3.subarray(r2, r2 + n2), i2);
                else
                  for (var s2 = 0; s2 < n2; s2++)
                    e2[i2 + s2] = t3[r2 + s2];
              }, flattenChunks: function flattenChunks(e2) {
                var t3, r2, n2, i2, s2, a;
                for (t3 = n2 = 0, r2 = e2.length; t3 < r2; t3++)
                  n2 += e2[t3].length;
                for (a = new Uint8Array(n2), t3 = i2 = 0, r2 = e2.length; t3 < r2; t3++)
                  s2 = e2[t3], a.set(s2, i2), i2 += s2.length;
                return a;
              } }, s = { arraySet: function arraySet(e2, t3, r2, n2, i2) {
                for (var s2 = 0; s2 < n2; s2++)
                  e2[i2 + s2] = t3[r2 + s2];
              }, flattenChunks: function flattenChunks(e2) {
                return [].concat.apply([], e2);
              } };
              r.setTyped = function(e2) {
                e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
              }, r.setTyped(n);
            }, {}], 42: [function(e, t2, r) {
              var h3 = e("./common"), i = true, s = true;
              try {
                String.fromCharCode.apply(null, [0]);
              } catch (e2) {
                i = false;
              }
              try {
                String.fromCharCode.apply(null, new Uint8Array(1));
              } catch (e2) {
                s = false;
              }
              for (var u = new h3.Buf8(256), n = 0; n < 256; n++)
                u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
              function l(e2, t3) {
                if (t3 < 65537 && (e2.subarray && s || !e2.subarray && i))
                  return String.fromCharCode.apply(null, h3.shrinkBuf(e2, t3));
                for (var r2 = "", n2 = 0; n2 < t3; n2++)
                  r2 += String.fromCharCode(e2[n2]);
                return r2;
              }
              u[254] = u[254] = 1, r.string2buf = function(e2) {
                var t3, r2, n2, i2, s2, a = e2.length, o = 0;
                for (i2 = 0; i2 < a; i2++)
                  55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
                for (t3 = new h3.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
                  55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
                return t3;
              }, r.buf2binstring = function(e2) {
                return l(e2, e2.length);
              }, r.binstring2buf = function(e2) {
                for (var t3 = new h3.Buf8(e2.length), r2 = 0, n2 = t3.length; r2 < n2; r2++)
                  t3[r2] = e2.charCodeAt(r2);
                return t3;
              }, r.buf2string = function(e2, t3) {
                var r2, n2, i2, s2, a = t3 || e2.length, o = new Array(2 * a);
                for (r2 = n2 = 0; r2 < a; )
                  if ((i2 = e2[r2++]) < 128)
                    o[n2++] = i2;
                  else if (4 < (s2 = u[i2]))
                    o[n2++] = 65533, r2 += s2 - 1;
                  else {
                    for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                      i2 = i2 << 6 | 63 & e2[r2++], s2--;
                    1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
                  }
                return l(o, n2);
              }, r.utf8border = function(e2, t3) {
                var r2;
                for ((t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
                  r2--;
                return r2 < 0 ? t3 : 0 === r2 ? t3 : r2 + u[e2[r2]] > t3 ? r2 : t3;
              };
            }, { "./common": 41 }], 43: [function(e, t2, r) {
              t2.exports = function(e2, t3, r2, n) {
                for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
                  for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t3[n++] | 0) | 0, --a; )
                    ;
                  i %= 65521, s %= 65521;
                }
                return i | s << 16 | 0;
              };
            }, {}], 44: [function(e, t2, r) {
              t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
            }, {}], 45: [function(e, t2, r) {
              var o = function() {
                for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
                  e2 = r2;
                  for (var n = 0; n < 8; n++)
                    e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                  t3[r2] = e2;
                }
                return t3;
              }();
              t2.exports = function(e2, t3, r2, n) {
                var i = o, s = n + r2;
                e2 ^= -1;
                for (var a = n; a < s; a++)
                  e2 = e2 >>> 8 ^ i[255 & (e2 ^ t3[a])];
                return -1 ^ e2;
              };
            }, {}], 46: [function(e, t2, r) {
              var h3, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
              function R(e2, t3) {
                return e2.msg = n[t3], t3;
              }
              function T(e2) {
                return (e2 << 1) - (4 < e2 ? 9 : 0);
              }
              function D(e2) {
                for (var t3 = e2.length; 0 <= --t3; )
                  e2[t3] = 0;
              }
              function F(e2) {
                var t3 = e2.state, r2 = t3.pending;
                r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out), e2.next_out += r2, t3.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t3.pending -= r2, 0 === t3.pending && (t3.pending_out = 0));
              }
              function N(e2, t3) {
                u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, F(e2.strm);
              }
              function U(e2, t3) {
                e2.pending_buf[e2.pending++] = t3;
              }
              function P(e2, t3) {
                e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
              }
              function L(e2, t3) {
                var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h4 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
                do {
                  if (u2[(r2 = t3) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                    s2 += 2, r2++;
                    do {
                    } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
                    if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                      if (e2.match_start = t3, o2 <= (a2 = n2))
                        break;
                      d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                    }
                  }
                } while ((t3 = f2[t3 & l2]) > h4 && 0 != --i2);
                return a2 <= e2.lookahead ? a2 : e2.lookahead;
              }
              function j(e2) {
                var t3, r2, n2, i2, s2, a2, o2, h4, u2, l2, f2 = e2.w_size;
                do {
                  if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
                    for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t3 = r2 = e2.hash_size; n2 = e2.head[--t3], e2.head[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                      ;
                    for (t3 = r2 = f2; n2 = e2.prev[--t3], e2.prev[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                      ;
                    i2 += f2;
                  }
                  if (0 === e2.strm.avail_in)
                    break;
                  if (a2 = e2.strm, o2 = e2.window, h4 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h4), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h4) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h4)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
                    for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                      ;
                } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
              }
              function Z(e2, t3) {
                for (var r2, n2; ; ) {
                  if (e2.lookahead < z) {
                    if (j(e2), e2.lookahead < z && t3 === l)
                      return A;
                    if (0 === e2.lookahead)
                      break;
                  }
                  if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) {
                    if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                      for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                        ;
                      e2.strstart++;
                    } else
                      e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
                  } else
                    n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
                  if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
                    return A;
                }
                return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
              }
              function W(e2, t3) {
                for (var r2, n2, i2; ; ) {
                  if (e2.lookahead < z) {
                    if (j(e2), e2.lookahead < z && t3 === l)
                      return A;
                    if (0 === e2.lookahead)
                      break;
                  }
                  if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
                    for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                      ;
                    if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                      return A;
                  } else if (e2.match_available) {
                    if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                      return A;
                  } else
                    e2.match_available = 1, e2.strstart++, e2.lookahead--;
                }
                return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
              }
              function M(e2, t3, r2, n2, i2) {
                this.good_length = e2, this.max_lazy = t3, this.nice_length = r2, this.max_chain = n2, this.func = i2;
              }
              function H() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
              }
              function G(e2) {
                var t3;
                return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t3 = e2.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C : E, e2.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l, u._tr_init(t3), m) : R(e2, _);
              }
              function K(e2) {
                var t3 = G(e2);
                return t3 === m && function(e3) {
                  e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h3[e3.level].max_lazy, e3.good_match = h3[e3.level].good_length, e3.nice_match = h3[e3.level].nice_length, e3.max_chain_length = h3[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
                }(e2.state), t3;
              }
              function Y(e2, t3, r2, n2, i2, s2) {
                if (!e2)
                  return _;
                var a2 = 1;
                if (t3 === g && (t3 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t3 < 0 || 9 < t3 || s2 < 0 || b < s2)
                  return R(e2, _);
                8 === n2 && (n2 = 9);
                var o2 = new H();
                return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = s2, o2.method = r2, K(e2);
              }
              h3 = [new M(0, 0, 0, 0, function(e2, t3) {
                var r2 = 65535;
                for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
                  if (e2.lookahead <= 1) {
                    if (j(e2), 0 === e2.lookahead && t3 === l)
                      return A;
                    if (0 === e2.lookahead)
                      break;
                  }
                  e2.strstart += e2.lookahead, e2.lookahead = 0;
                  var n2 = e2.block_start + r2;
                  if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
                    return A;
                  if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
                    return A;
                }
                return e2.insert = 0, t3 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
              }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t3) {
                return Y(e2, t3, v, 15, 8, 0);
              }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t3) {
                return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t3, m) : _;
              }, r.deflate = function(e2, t3) {
                var r2, n2, i2, s2;
                if (!e2 || !e2.state || 5 < t3 || t3 < 0)
                  return e2 ? R(e2, _) : _;
                if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t3 !== f)
                  return R(e2, 0 === e2.avail_out ? -5 : _);
                if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t3, n2.status === C)
                  if (2 === n2.wrap)
                    e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
                  else {
                    var a2 = v + (n2.w_bits - 8 << 4) << 8;
                    a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
                  }
                if (69 === n2.status)
                  if (n2.gzhead.extra) {
                    for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                      U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
                  } else
                    n2.status = 73;
                if (73 === n2.status)
                  if (n2.gzhead.name) {
                    i2 = n2.pending;
                    do {
                      if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                        s2 = 1;
                        break;
                      }
                      s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                    } while (0 !== s2);
                    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
                  } else
                    n2.status = 91;
                if (91 === n2.status)
                  if (n2.gzhead.comment) {
                    i2 = n2.pending;
                    do {
                      if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                        s2 = 1;
                        break;
                      }
                      s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                    } while (0 !== s2);
                    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
                  } else
                    n2.status = 103;
                if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
                  if (F(e2), 0 === e2.avail_out)
                    return n2.last_flush = -1, m;
                } else if (0 === e2.avail_in && T(t3) <= T(r2) && t3 !== f)
                  return R(e2, -5);
                if (666 === n2.status && 0 !== e2.avail_in)
                  return R(e2, -5);
                if (0 !== e2.avail_in || 0 !== n2.lookahead || t3 !== l && 666 !== n2.status) {
                  var o2 = 2 === n2.strategy ? function(e3, t4) {
                    for (var r3; ; ) {
                      if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                        if (t4 === l)
                          return A;
                        break;
                      }
                      if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                        return A;
                    }
                    return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
                  }(n2, t3) : 3 === n2.strategy ? function(e3, t4) {
                    for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                      if (e3.lookahead <= S) {
                        if (j(e3), e3.lookahead <= S && t4 === l)
                          return A;
                        if (0 === e3.lookahead)
                          break;
                      }
                      if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                        s3 = e3.strstart + S;
                        do {
                        } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                        e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                      }
                      if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                        return A;
                    }
                    return e3.insert = 0, t4 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
                  }(n2, t3) : h3[n2.level].func(n2, t3);
                  if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
                    return 0 === e2.avail_out && (n2.last_flush = -1), m;
                  if (o2 === I && (1 === t3 ? u._tr_align(n2) : 5 !== t3 && (u._tr_stored_block(n2, 0, 0, false), 3 === t3 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
                    return n2.last_flush = -1, m;
                }
                return t3 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
              }, r.deflateEnd = function(e2) {
                var t3;
                return e2 && e2.state ? (t3 = e2.state.status) !== C && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E && 666 !== t3 ? R(e2, _) : (e2.state = null, t3 === E ? R(e2, -3) : m) : _;
              }, r.deflateSetDictionary = function(e2, t3) {
                var r2, n2, i2, s2, a2, o2, h4, u2, l2 = t3.length;
                if (!e2 || !e2.state)
                  return _;
                if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
                  return _;
                for (1 === s2 && (e2.adler = d(e2.adler, t3, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t3, l2 - r2.w_size, r2.w_size, 0), t3 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h4 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t3, j(r2); r2.lookahead >= x; ) {
                  for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
                    ;
                  r2.strstart = n2, r2.lookahead = x - 1, j(r2);
                }
                return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h4, e2.avail_in = a2, r2.wrap = s2, m;
              }, r.deflateInfo = "pako deflate (from Nodeca project)";
            }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t2, r) {
              t2.exports = function() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
              };
            }, {}], 48: [function(e, t2, r) {
              t2.exports = function(e2, t3) {
                var r2, n, i, s, a, o, h3, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
                r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t3 - e2.avail_out), o = s + (e2.avail_out - 257), h3 = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
                e:
                  do {
                    p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
                    t:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                          C[s++] = 65535 & v;
                        else {
                          if (!(16 & y)) {
                            if (0 == (64 & y)) {
                              v = m[(65535 & v) + (d & (1 << y) - 1)];
                              continue t;
                            }
                            if (32 & y) {
                              r2.mode = 12;
                              break e;
                            }
                            e2.msg = "invalid literal/length code", r2.mode = 30;
                            break e;
                          }
                          w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                          r:
                            for (; ; ) {
                              if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                                if (0 == (64 & y)) {
                                  v = _[(65535 & v) + (d & (1 << y) - 1)];
                                  continue r;
                                }
                                e2.msg = "invalid distance code", r2.mode = 30;
                                break e;
                              }
                              if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h3 < (k += d & (1 << y) - 1)) {
                                e2.msg = "invalid distance too far back", r2.mode = 30;
                                break e;
                              }
                              if (d >>>= y, p -= y, (y = s - a) < k) {
                                if (l < (y = k - y) && r2.sane) {
                                  e2.msg = "invalid distance too far back", r2.mode = 30;
                                  break e;
                                }
                                if (S = c, (x = 0) === f) {
                                  if (x += u - y, y < w) {
                                    for (w -= y; C[s++] = c[x++], --y; )
                                      ;
                                    x = s - k, S = C;
                                  }
                                } else if (f < y) {
                                  if (x += u + f - y, (y -= f) < w) {
                                    for (w -= y; C[s++] = c[x++], --y; )
                                      ;
                                    if (x = 0, f < w) {
                                      for (w -= y = f; C[s++] = c[x++], --y; )
                                        ;
                                      x = s - k, S = C;
                                    }
                                  }
                                } else if (x += f - y, y < w) {
                                  for (w -= y; C[s++] = c[x++], --y; )
                                    ;
                                  x = s - k, S = C;
                                }
                                for (; 2 < w; )
                                  C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                                w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                              } else {
                                for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                                  ;
                                w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                              }
                              break;
                            }
                        }
                        break;
                      }
                  } while (n < i && s < o);
                n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
              };
            }, {}], 49: [function(e, t2, r) {
              var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
              function L(e2) {
                return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
              }
              function s() {
                this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
              }
              function a(e2) {
                var t3;
                return e2 && e2.state ? (t3 = e2.state, e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n), t3.distcode = t3.distdyn = new I.Buf32(i), t3.sane = 1, t3.back = -1, N) : U;
              }
              function o(e2) {
                var t3;
                return e2 && e2.state ? ((t3 = e2.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a(e2)) : U;
              }
              function h3(e2, t3) {
                var r2, n2;
                return e2 && e2.state ? (n2 = e2.state, t3 < 0 ? (r2 = 0, t3 = -t3) : (r2 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U : (null !== n2.window && n2.wbits !== t3 && (n2.window = null), n2.wrap = r2, n2.wbits = t3, o(e2))) : U;
              }
              function u(e2, t3) {
                var r2, n2;
                return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h3(e2, t3)) !== N && (e2.state = null), r2) : U;
              }
              var l, f, c = true;
              function j(e2) {
                if (c) {
                  var t3;
                  for (l = new I.Buf32(512), f = new I.Buf32(32), t3 = 0; t3 < 144; )
                    e2.lens[t3++] = 8;
                  for (; t3 < 256; )
                    e2.lens[t3++] = 9;
                  for (; t3 < 280; )
                    e2.lens[t3++] = 7;
                  for (; t3 < 288; )
                    e2.lens[t3++] = 8;
                  for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; )
                    e2.lens[t3++] = 5;
                  T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
                }
                e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
              }
              function Z(e2, t3, r2, n2) {
                var i2, s2 = e2.state;
                return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t3, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t3, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t3, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
              }
              r.inflateReset = o, r.inflateReset2 = h3, r.inflateResetKeep = a, r.inflateInit = function(e2) {
                return u(e2, 15);
              }, r.inflateInit2 = u, r.inflate = function(e2, t3) {
                var r2, n2, i2, s2, a2, o2, h4, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
                  return U;
                12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h4 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h4, x = N;
                e:
                  for (; ; )
                    switch (r2.mode) {
                      case P:
                        if (0 === r2.wrap) {
                          r2.mode = 13;
                          break;
                        }
                        for (; l2 < 16; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (2 & r2.wrap && 35615 === u2) {
                          E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                          break;
                        }
                        if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                          e2.msg = "incorrect header check", r2.mode = 30;
                          break;
                        }
                        if (8 != (15 & u2)) {
                          e2.msg = "unknown compression method", r2.mode = 30;
                          break;
                        }
                        if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                          r2.wbits = k;
                        else if (k > r2.wbits) {
                          e2.msg = "invalid window size", r2.mode = 30;
                          break;
                        }
                        r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                        break;
                      case 2:
                        for (; l2 < 16; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (r2.flags = u2, 8 != (255 & r2.flags)) {
                          e2.msg = "unknown compression method", r2.mode = 30;
                          break;
                        }
                        if (57344 & r2.flags) {
                          e2.msg = "unknown header flags set", r2.mode = 30;
                          break;
                        }
                        r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                      case 3:
                        for (; l2 < 32; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                      case 4:
                        for (; l2 < 16; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                      case 5:
                        if (1024 & r2.flags) {
                          for (; l2 < 16; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                        } else
                          r2.head && (r2.head.extra = null);
                        r2.mode = 6;
                      case 6:
                        if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                          break e;
                        r2.length = 0, r2.mode = 7;
                      case 7:
                        if (2048 & r2.flags) {
                          if (0 === o2)
                            break e;
                          for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                            ;
                          if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                            break e;
                        } else
                          r2.head && (r2.head.name = null);
                        r2.length = 0, r2.mode = 8;
                      case 8:
                        if (4096 & r2.flags) {
                          if (0 === o2)
                            break e;
                          for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                            ;
                          if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                            break e;
                        } else
                          r2.head && (r2.head.comment = null);
                        r2.mode = 9;
                      case 9:
                        if (512 & r2.flags) {
                          for (; l2 < 16; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          if (u2 !== (65535 & r2.check)) {
                            e2.msg = "header crc mismatch", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                        break;
                      case 10:
                        for (; l2 < 32; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                      case 11:
                        if (0 === r2.havedict)
                          return e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                        e2.adler = r2.check = 1, r2.mode = 12;
                      case 12:
                        if (5 === t3 || 6 === t3)
                          break e;
                      case 13:
                        if (r2.last) {
                          u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                          break;
                        }
                        for (; l2 < 3; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                          case 0:
                            r2.mode = 14;
                            break;
                          case 1:
                            if (j(r2), r2.mode = 20, 6 !== t3)
                              break;
                            u2 >>>= 2, l2 -= 2;
                            break e;
                          case 2:
                            r2.mode = 17;
                            break;
                          case 3:
                            e2.msg = "invalid block type", r2.mode = 30;
                        }
                        u2 >>>= 2, l2 -= 2;
                        break;
                      case 14:
                        for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                          e2.msg = "invalid stored block lengths", r2.mode = 30;
                          break;
                        }
                        if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t3)
                          break e;
                      case 15:
                        r2.mode = 16;
                      case 16:
                        if (d = r2.length) {
                          if (o2 < d && (d = o2), h4 < d && (d = h4), 0 === d)
                            break e;
                          I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h4 -= d, a2 += d, r2.length -= d;
                          break;
                        }
                        r2.mode = 12;
                        break;
                      case 17:
                        for (; l2 < 14; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                          e2.msg = "too many length or distance symbols", r2.mode = 30;
                          break;
                        }
                        r2.have = 0, r2.mode = 18;
                      case 18:
                        for (; r2.have < r2.ncode; ) {
                          for (; l2 < 3; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                        }
                        for (; r2.have < 19; )
                          r2.lens[A[r2.have++]] = 0;
                        if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                          e2.msg = "invalid code lengths set", r2.mode = 30;
                          break;
                        }
                        r2.have = 0, r2.mode = 19;
                      case 19:
                        for (; r2.have < r2.nlen + r2.ndist; ) {
                          for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          if (b < 16)
                            u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                          else {
                            if (16 === b) {
                              for (z = _ + 2; l2 < z; ) {
                                if (0 === o2)
                                  break e;
                                o2--, u2 += n2[s2++] << l2, l2 += 8;
                              }
                              if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                                e2.msg = "invalid bit length repeat", r2.mode = 30;
                                break;
                              }
                              k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                            } else if (17 === b) {
                              for (z = _ + 3; l2 < z; ) {
                                if (0 === o2)
                                  break e;
                                o2--, u2 += n2[s2++] << l2, l2 += 8;
                              }
                              l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                            } else {
                              for (z = _ + 7; l2 < z; ) {
                                if (0 === o2)
                                  break e;
                                o2--, u2 += n2[s2++] << l2, l2 += 8;
                              }
                              l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                            }
                            if (r2.have + d > r2.nlen + r2.ndist) {
                              e2.msg = "invalid bit length repeat", r2.mode = 30;
                              break;
                            }
                            for (; d--; )
                              r2.lens[r2.have++] = k;
                          }
                        }
                        if (30 === r2.mode)
                          break;
                        if (0 === r2.lens[256]) {
                          e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                          break;
                        }
                        if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                          e2.msg = "invalid literal/lengths set", r2.mode = 30;
                          break;
                        }
                        if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                          e2.msg = "invalid distances set", r2.mode = 30;
                          break;
                        }
                        if (r2.mode = 20, 6 === t3)
                          break e;
                      case 20:
                        r2.mode = 21;
                      case 21:
                        if (6 <= o2 && 258 <= h4) {
                          e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h4 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                          break;
                        }
                        for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (g && 0 == (240 & g)) {
                          for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          u2 >>>= v, l2 -= v, r2.back += v;
                        }
                        if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                          r2.mode = 26;
                          break;
                        }
                        if (32 & g) {
                          r2.back = -1, r2.mode = 12;
                          break;
                        }
                        if (64 & g) {
                          e2.msg = "invalid literal/length code", r2.mode = 30;
                          break;
                        }
                        r2.extra = 15 & g, r2.mode = 22;
                      case 22:
                        if (r2.extra) {
                          for (z = r2.extra; l2 < z; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                        }
                        r2.was = r2.length, r2.mode = 23;
                      case 23:
                        for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (0 == (240 & g)) {
                          for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          u2 >>>= v, l2 -= v, r2.back += v;
                        }
                        if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break;
                        }
                        r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                      case 24:
                        if (r2.extra) {
                          for (z = r2.extra; l2 < z; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                        }
                        if (r2.offset > r2.dmax) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break;
                        }
                        r2.mode = 25;
                      case 25:
                        if (0 === h4)
                          break e;
                        if (d = c2 - h4, r2.offset > d) {
                          if ((d = r2.offset - d) > r2.whave && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break;
                          }
                          p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                        } else
                          m = i2, p = a2 - r2.offset, d = r2.length;
                        for (h4 < d && (d = h4), h4 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                          ;
                        0 === r2.length && (r2.mode = 21);
                        break;
                      case 26:
                        if (0 === h4)
                          break e;
                        i2[a2++] = r2.length, h4--, r2.mode = 21;
                        break;
                      case 27:
                        if (r2.wrap) {
                          for (; l2 < 32; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 |= n2[s2++] << l2, l2 += 8;
                          }
                          if (c2 -= h4, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h4, (r2.flags ? u2 : L(u2)) !== r2.check) {
                            e2.msg = "incorrect data check", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.mode = 28;
                      case 28:
                        if (r2.wrap && r2.flags) {
                          for (; l2 < 32; ) {
                            if (0 === o2)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          if (u2 !== (4294967295 & r2.total)) {
                            e2.msg = "incorrect length check", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.mode = 29;
                      case 29:
                        x = 1;
                        break e;
                      case 30:
                        x = -3;
                        break e;
                      case 31:
                        return -4;
                      case 32:
                      default:
                        return U;
                    }
                return e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t3)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t3) && x === N && (x = -5), x);
              }, r.inflateEnd = function(e2) {
                if (!e2 || !e2.state)
                  return U;
                var t3 = e2.state;
                return t3.window && (t3.window = null), e2.state = null, N;
              }, r.inflateGetHeader = function(e2, t3) {
                var r2;
                return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t3).done = false, N) : U;
              }, r.inflateSetDictionary = function(e2, t3) {
                var r2, n2 = t3.length;
                return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t3, n2, 0) !== r2.check ? -3 : Z(e2, t3, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
              }, r.inflateInfo = "pako inflate (from Nodeca project)";
            }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t2, r) {
              var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
              t2.exports = function(e2, t3, r2, n, i, s, a, o) {
                var h3, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
                for (b = 0; b <= 15; b++)
                  O[b] = 0;
                for (v = 0; v < n; v++)
                  O[t3[r2 + v]]++;
                for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
                  ;
                if (w < k && (k = w), 0 === w)
                  return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
                for (y = 1; y < w && 0 === O[y]; y++)
                  ;
                for (k < y && (k = y), b = z = 1; b <= 15; b++)
                  if (z <<= 1, (z -= O[b]) < 0)
                    return -1;
                if (0 < z && (0 === e2 || 1 !== w))
                  return -1;
                for (B[1] = 0, b = 1; b < 15; b++)
                  B[b + 1] = B[b] + O[b];
                for (v = 0; v < n; v++)
                  0 !== t3[r2 + v] && (a[B[t3[r2 + v]]++] = v);
                if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                  return 1;
                for (; ; ) {
                  for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h3 = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h3)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
                    ;
                  for (h3 = 1 << b - 1; E & h3; )
                    h3 >>= 1;
                  if (0 !== h3 ? (E &= h3 - 1, E += h3) : E = 0, v++, 0 == --O[b]) {
                    if (b === w)
                      break;
                    b = t3[r2 + a[v]];
                  }
                  if (k < b && (E & f) !== l) {
                    for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                      x++, z <<= 1;
                    if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                      return 1;
                    i[l = E & f] = k << 24 | x << 16 | c - s | 0;
                  }
                }
                return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
              };
            }, { "../utils/common": 41 }], 51: [function(e, t2, r) {
              t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
            }, {}], 52: [function(e, t2, r) {
              var i = e("../utils/common"), o = 0, h3 = 1;
              function n(e2) {
                for (var t3 = e2.length; 0 <= --t3; )
                  e2[t3] = 0;
              }
              var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
              n(z);
              var C = new Array(2 * f);
              n(C);
              var E = new Array(512);
              n(E);
              var A = new Array(256);
              n(A);
              var I = new Array(a);
              n(I);
              var O, B, R, T = new Array(f);
              function D(e2, t3, r2, n2, i2) {
                this.static_tree = e2, this.extra_bits = t3, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
              }
              function F(e2, t3) {
                this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
              }
              function N(e2) {
                return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
              }
              function U(e2, t3) {
                e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
              }
              function P(e2, t3, r2) {
                e2.bi_valid > d - r2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t3 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += r2);
              }
              function L(e2, t3, r2) {
                P(e2, r2[2 * t3], r2[2 * t3 + 1]);
              }
              function j(e2, t3) {
                for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t3; )
                  ;
                return r2 >>> 1;
              }
              function Z(e2, t3, r2) {
                var n2, i2, s2 = new Array(g + 1), a2 = 0;
                for (n2 = 1; n2 <= g; n2++)
                  s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
                for (i2 = 0; i2 <= t3; i2++) {
                  var o2 = e2[2 * i2 + 1];
                  0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
                }
              }
              function W(e2) {
                var t3;
                for (t3 = 0; t3 < l; t3++)
                  e2.dyn_ltree[2 * t3] = 0;
                for (t3 = 0; t3 < f; t3++)
                  e2.dyn_dtree[2 * t3] = 0;
                for (t3 = 0; t3 < c; t3++)
                  e2.bl_tree[2 * t3] = 0;
                e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
              }
              function M(e2) {
                8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
              }
              function H(e2, t3, r2, n2) {
                var i2 = 2 * t3, s2 = 2 * r2;
                return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t3] <= n2[r2];
              }
              function G(e2, t3, r2) {
                for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t3, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t3, n2, e2.heap[i2], e2.depth)); )
                  e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
                e2.heap[r2] = n2;
              }
              function K(e2, t3, r2) {
                var n2, i2, s2, a2, o2 = 0;
                if (0 !== e2.last_lit)
                  for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t3) : (L(e2, (s2 = A[i2]) + u + 1, t3), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
                    ;
                L(e2, m, t3);
              }
              function Y(e2, t3) {
                var r2, n2, i2, s2 = t3.dyn_tree, a2 = t3.stat_desc.static_tree, o2 = t3.stat_desc.has_stree, h4 = t3.stat_desc.elems, u2 = -1;
                for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h4; r2++)
                  0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
                for (; e2.heap_len < 2; )
                  s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
                for (t3.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
                  G(e2, s2, r2);
                for (i2 = h4; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
                  ;
                e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t4) {
                  var r3, n3, i3, s3, a3, o3, h5 = t4.dyn_tree, u3 = t4.max_code, l2 = t4.stat_desc.static_tree, f2 = t4.stat_desc.has_stree, c2 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p2 = t4.stat_desc.max_length, m2 = 0;
                  for (s3 = 0; s3 <= g; s3++)
                    e3.bl_count[s3] = 0;
                  for (h5[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
                    p2 < (s3 = h5[2 * h5[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h5[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h5[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
                  if (0 !== m2) {
                    do {
                      for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                        s3--;
                      e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                    } while (0 < m2);
                    for (s3 = p2; 0 !== s3; s3--)
                      for (n3 = e3.bl_count[s3]; 0 !== n3; )
                        u3 < (i3 = e3.heap[--r3]) || (h5[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h5[2 * i3 + 1]) * h5[2 * i3], h5[2 * i3 + 1] = s3), n3--);
                  }
                }(e2, t3), Z(s2, u2, e2.bl_count);
              }
              function X(e2, t3, r2) {
                var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h4 = 7, u2 = 4;
                for (0 === a2 && (h4 = 138, u2 = 3), t3[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
                  i2 = a2, a2 = t3[2 * (n2 + 1) + 1], ++o2 < h4 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h4 = 138, 3) : i2 === a2 ? (h4 = 6, 3) : (h4 = 7, 4));
              }
              function V(e2, t3, r2) {
                var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h4 = 7, u2 = 4;
                for (0 === a2 && (h4 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
                  if (i2 = a2, a2 = t3[2 * (n2 + 1) + 1], !(++o2 < h4 && i2 === a2)) {
                    if (o2 < u2)
                      for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                        ;
                    else
                      0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
                    s2 = i2, u2 = (o2 = 0) === a2 ? (h4 = 138, 3) : i2 === a2 ? (h4 = 6, 3) : (h4 = 7, 4);
                  }
              }
              n(T);
              var q = false;
              function J(e2, t3, r2, n2) {
                P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
                  M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending), e3.pending += r3;
                }(e2, t3, r2, true);
              }
              r._tr_init = function(e2) {
                q || (function() {
                  var e3, t3, r2, n2, i2, s2 = new Array(g + 1);
                  for (n2 = r2 = 0; n2 < a - 1; n2++)
                    for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                      A[r2++] = n2;
                  for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
                    for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                      E[i2++] = n2;
                  for (i2 >>= 7; n2 < f; n2++)
                    for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                      E[256 + i2++] = n2;
                  for (t3 = 0; t3 <= g; t3++)
                    s2[t3] = 0;
                  for (e3 = 0; e3 <= 143; )
                    z[2 * e3 + 1] = 8, e3++, s2[8]++;
                  for (; e3 <= 255; )
                    z[2 * e3 + 1] = 9, e3++, s2[9]++;
                  for (; e3 <= 279; )
                    z[2 * e3 + 1] = 7, e3++, s2[7]++;
                  for (; e3 <= 287; )
                    z[2 * e3 + 1] = 8, e3++, s2[8]++;
                  for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
                    C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
                  O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
                }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
              }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t3, r2, n2) {
                var i2, s2, a2 = 0;
                0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
                  var t4, r3 = 4093624447;
                  for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1)
                    if (1 & r3 && 0 !== e3.dyn_ltree[2 * t4])
                      return o;
                  if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
                    return h3;
                  for (t4 = 32; t4 < u; t4++)
                    if (0 !== e3.dyn_ltree[2 * t4])
                      return h3;
                  return o;
                }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
                  var t4;
                  for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t4 = c - 1; 3 <= t4 && 0 === e3.bl_tree[2 * S[t4] + 1]; t4--)
                    ;
                  return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
                }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t3 ? J(e2, t3, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
                  var i3;
                  for (P(e3, t4 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
                    P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
                  V(e3, e3.dyn_ltree, t4 - 1), V(e3, e3.dyn_dtree, r3 - 1);
                }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
              }, r._tr_tally = function(e2, t3, r2) {
                return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t3 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t3 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t3)]++), e2.last_lit === e2.lit_bufsize - 1;
              }, r._tr_align = function(e2) {
                P(e2, 2, 3), L(e2, m, z), function(e3) {
                  16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
                }(e2);
              };
            }, { "../utils/common": 41 }], 53: [function(e, t2, r) {
              t2.exports = function() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
              };
            }, {}], 54: [function(e, t2, r) {
              (function(e2) {
                !function(r2, n) {
                  if (!r2.setImmediate) {
                    var i, s, t3, a, o = 1, h3 = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
                    e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                      process2.nextTick(function() {
                        c(e4);
                      });
                    } : function() {
                      if (r2.postMessage && !r2.importScripts) {
                        var e4 = true, t4 = r2.onmessage;
                        return r2.onmessage = function() {
                          e4 = false;
                        }, r2.postMessage("", "*"), r2.onmessage = t4, e4;
                      }
                    }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                      r2.postMessage(a + e4, "*");
                    }) : r2.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e4) {
                      c(e4.data);
                    }, function(e4) {
                      t3.port2.postMessage(e4);
                    }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                      var t4 = l.createElement("script");
                      t4.onreadystatechange = function() {
                        c(e4), t4.onreadystatechange = null, s.removeChild(t4), t4 = null;
                      }, s.appendChild(t4);
                    }) : function(e4) {
                      setTimeout(c, 0, e4);
                    }, e3.setImmediate = function(e4) {
                      "function" != typeof e4 && (e4 = new Function("" + e4));
                      for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++)
                        t4[r3] = arguments[r3 + 1];
                      var n2 = { callback: e4, args: t4 };
                      return h3[o] = n2, i(o), o++;
                    }, e3.clearImmediate = f;
                  }
                  function f(e4) {
                    delete h3[e4];
                  }
                  function c(e4) {
                    if (u)
                      setTimeout(c, 0, e4);
                    else {
                      var t4 = h3[e4];
                      if (t4) {
                        u = true;
                        try {
                          !function(e5) {
                            var t5 = e5.callback, r3 = e5.args;
                            switch (r3.length) {
                              case 0:
                                t5();
                                break;
                              case 1:
                                t5(r3[0]);
                                break;
                              case 2:
                                t5(r3[0], r3[1]);
                                break;
                              case 3:
                                t5(r3[0], r3[1], r3[2]);
                                break;
                              default:
                                t5.apply(n, r3);
                            }
                          }(t4);
                        } finally {
                          f(e4), u = false;
                        }
                      }
                    }
                  }
                  function d(e4) {
                    e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
                  }
                }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
              }).call(this, "undefined" != typeof global2 ? global2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            }, {}] }, {}, [10])(10);
          });
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], require2("timers").setImmediate);
    }, { "_process": 467, "buffer": 220, "timers": 523 }], 442: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var INFINITY = 1 / 0;
          var symbolTag = "[object Symbol]";
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
          var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          var objectProto = Object.prototype;
          var objectToString = objectProto.toString;
          var Symbol2 = root.Symbol;
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          function isObjectLike(value) {
            return !!value && typeof value == "object";
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          module2.exports = escapeRegExp;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 443: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var LARGE_ARRAY_SIZE = 200;
          var FUNC_ERROR_TEXT = "Expected a function";
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
          var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reEscapeChar = /\\(\\)?/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
          var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
          var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
          var moduleExports = freeModule && freeModule.exports === freeExports;
          var freeProcess = moduleExports && freeGlobal.process;
          var nodeUtil = function() {
            try {
              return freeProcess && freeProcess.binding("util");
            } catch (e) {
            }
          }();
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          function arrayAggregator(array, setter, iteratee, accumulator) {
            var index2 = -1, length = array ? array.length : 0;
            while (++index2 < length) {
              var value = array[index2];
              setter(accumulator, value, iteratee(value), array);
            }
            return accumulator;
          }
          function arraySome(array, predicate) {
            var index2 = -1, length = array ? array.length : 0;
            while (++index2 < length) {
              if (predicate(array[index2], index2, array)) {
                return true;
              }
            }
            return false;
          }
          function baseProperty(key) {
            return function(object) {
              return object == null ? void 0 : object[key];
            };
          }
          function baseTimes(n, iteratee) {
            var index2 = -1, result = Array(n);
            while (++index2 < n) {
              result[index2] = iteratee(index2);
            }
            return result;
          }
          function baseUnary(func) {
            return function(value) {
              return func(value);
            };
          }
          function getValue(object, key) {
            return object == null ? void 0 : object[key];
          }
          function isHostObject(value) {
            var result = false;
            if (value != null && typeof value.toString != "function") {
              try {
                result = !!(value + "");
              } catch (e) {
              }
            }
            return result;
          }
          function mapToArray(map) {
            var index2 = -1, result = Array(map.size);
            map.forEach(function(value, key) {
              result[++index2] = [key, value];
            });
            return result;
          }
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          function setToArray(set) {
            var index2 = -1, result = Array(set.size);
            set.forEach(function(value) {
              result[++index2] = value;
            });
            return result;
          }
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          var coreJsData = root["__core-js_shared__"];
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var funcToString = funcProto.toString;
          var hasOwnProperty3 = objectProto.hasOwnProperty;
          var objectToString = objectProto.toString;
          var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
          var nativeKeys = overArg(Object.keys, Object);
          var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
          function Hash(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty3.call(data, key) ? data[key] : void 0;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? void 0 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
          }
          function mapCacheDelete(key) {
            return getMapData(this, key)["delete"](key);
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values) {
            var index2 = -1, length = values ? values.length : 0;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            this.__data__ = new ListCache(entries);
          }
          function stackClear() {
            this.__data__ = new ListCache();
          }
          function stackDelete(key) {
            return this.__data__["delete"](key);
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var cache2 = this.__data__;
            if (cache2 instanceof ListCache) {
              var pairs = cache2.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                return this;
              }
              cache2 = this.__data__ = new MapCache(pairs);
            }
            cache2.set(key, value);
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
            var length = result.length, skipIndexes = !!length;
            for (var key in value) {
              if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee(value), collection2);
            });
            return accumulator;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseFor = createBaseFor();
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys2);
          }
          function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path);
            var index2 = 0, length = path.length;
            while (object != null && index2 < length) {
              object = object[toKey(path[index2++])];
            }
            return index2 && index2 == length ? object : void 0;
          }
          function baseGetTag(value) {
            return objectToString.call(value);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }
          function baseIsEqual(value, other, customizer, bitmask, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
          }
          function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
              objTag = getTag(object);
              objTag = objTag == argsTag ? objectTag : objTag;
            }
            if (!othIsArr) {
              othTag = getTag(other);
              othTag = othTag == argsTag ? objectTag : othTag;
            }
            var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
            }
            if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === void 0 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty3.call(object, key) && key != "constructor") {
                result.push(key);
              }
            }
            return result;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
            };
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, baseIteratee(iteratee), accumulator);
            };
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== void 0) {
                if (compared) {
                  continue;
                }
                result = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                    return seen.add(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                result = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
          }
          function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= UNORDERED_COMPARE_FLAG;
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
                stack["delete"](object);
                return result;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
                return false;
              }
            }
            var stacked = stack.get(object);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
          }
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result = keys2(object), length = result.length;
            while (length--) {
              var key = result[length], value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }
            return result;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
          }
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function getTag2(value) {
              var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result;
            };
          }
          function hasPath(object, path, hasFunc) {
            path = isKey(path, object) ? [path] : castPath(path);
            var result, index2 = -1, length = path.length;
            while (++index2 < length) {
              var key = toKey(path[index2]);
              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result) {
              return result;
            }
            var length = object ? object.length : 0;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
            };
          }
          var stringToPath = memoize(function(string) {
            string = toString2(string);
            var result = [];
            if (reLeadingDot.test(string)) {
              result.push("");
            }
            string.replace(rePropName, function(match, number, quote, string2) {
              result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty3.call(result, key)) {
              result[key].push(value);
            } else {
              result[key] = [value];
            }
          });
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver && typeof resolver != "function") {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function memoized2() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized2.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result = func.apply(this, args);
              memoized2.cache = cache2.set(key, result);
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          function isArguments(value) {
            return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
          }
          var isArray = Array.isArray;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag;
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return !!value && typeof value == "object";
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          function get(object, path, defaultValue) {
            var result = object == null ? void 0 : baseGet(object, path);
            return result === void 0 ? defaultValue : result;
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          function keys2(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function identity(value) {
            return value;
          }
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          module2.exports = groupBy;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 444: [function(require2, module2, exports2) {
      var boolTag = "[object Boolean]";
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      module2.exports = isBoolean;
    }, {}], 445: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var LARGE_ARRAY_SIZE = 200;
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
          var MAX_SAFE_INTEGER = 9007199254740991;
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          var typedArrayTags = {};
          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
          var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
          var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
          var moduleExports = freeModule && freeModule.exports === freeExports;
          var freeProcess = moduleExports && freeGlobal.process;
          var nodeUtil = function() {
            try {
              return freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e) {
            }
          }();
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          function arrayFilter(array, predicate) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index2 < length) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result[resIndex++] = value;
              }
            }
            return result;
          }
          function arrayPush(array, values) {
            var index2 = -1, length = values.length, offset = array.length;
            while (++index2 < length) {
              array[offset + index2] = values[index2];
            }
            return array;
          }
          function arraySome(array, predicate) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
              if (predicate(array[index2], index2, array)) {
                return true;
              }
            }
            return false;
          }
          function baseTimes(n, iteratee) {
            var index2 = -1, result = Array(n);
            while (++index2 < n) {
              result[index2] = iteratee(index2);
            }
            return result;
          }
          function baseUnary(func) {
            return function(value) {
              return func(value);
            };
          }
          function cacheHas(cache2, key) {
            return cache2.has(key);
          }
          function getValue(object, key) {
            return object == null ? void 0 : object[key];
          }
          function mapToArray(map) {
            var index2 = -1, result = Array(map.size);
            map.forEach(function(value, key) {
              result[++index2] = [key, value];
            });
            return result;
          }
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          function setToArray(set) {
            var index2 = -1, result = Array(set.size);
            set.forEach(function(value) {
              result[++index2] = value;
            });
            return result;
          }
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          var coreJsData = root["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty3 = objectProto.hasOwnProperty;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
          var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
          function Hash(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty3.call(data, key) ? data[key] : void 0;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? void 0 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
          }
          function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values) {
            var index2 = -1, length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty3.call(object, key) && key != "constructor") {
                result.push(key);
              }
            }
            return result;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== void 0) {
                if (compared) {
                  continue;
                }
                result = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
                return false;
              }
            }
            var stacked = stack.get(object);
            if (stacked && stack.get(other)) {
              return stacked == other;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys2, getSymbols);
          }
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = void 0;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function getTag2(value) {
              var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result;
            };
          }
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array.isArray;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function keys2(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          module2.exports = isEqual;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 446: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", nullTag = "[object Null]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]";
          var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          var objectProto = Object.prototype;
          var hasOwnProperty3 = objectProto.hasOwnProperty;
          var nativeObjectToString = objectProto.toString;
          var Symbol2 = root.Symbol, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          function baseGetTag(value) {
            if (value == null) {
              return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = void 0;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          module2.exports = isFunction;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 447: [function(require2, module2, exports2) {
      function isNil(value) {
        return value == null;
      }
      module2.exports = isNil;
    }, {}], 448: [function(require2, module2, exports2) {
      function isUndefined(value) {
        return value === void 0;
      }
      module2.exports = isUndefined;
    }, {}], 449: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var LARGE_ARRAY_SIZE = 200;
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          var INFINITY = 1 / 0;
          var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          function arrayIncludes(array, value) {
            var length = array ? array.length : 0;
            return !!length && baseIndexOf(array, value, 0) > -1;
          }
          function arrayIncludesWith(array, value, comparator) {
            var index2 = -1, length = array ? array.length : 0;
            while (++index2 < length) {
              if (comparator(value, array[index2])) {
                return true;
              }
            }
            return false;
          }
          function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
            while (fromRight ? index2-- : ++index2 < length) {
              if (predicate(array[index2], index2, array)) {
                return index2;
              }
            }
            return -1;
          }
          function baseIndexOf(array, value, fromIndex) {
            if (value !== value) {
              return baseFindIndex(array, baseIsNaN, fromIndex);
            }
            var index2 = fromIndex - 1, length = array.length;
            while (++index2 < length) {
              if (array[index2] === value) {
                return index2;
              }
            }
            return -1;
          }
          function baseIsNaN(value) {
            return value !== value;
          }
          function cacheHas(cache2, key) {
            return cache2.has(key);
          }
          function getValue(object, key) {
            return object == null ? void 0 : object[key];
          }
          function isHostObject(value) {
            var result = false;
            if (value != null && typeof value.toString != "function") {
              try {
                result = !!(value + "");
              } catch (e) {
              }
            }
            return result;
          }
          function setToArray(set) {
            var index2 = -1, result = Array(set.size);
            set.forEach(function(value) {
              result[++index2] = value;
            });
            return result;
          }
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          var coreJsData = root["__core-js_shared__"];
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var funcToString = funcProto.toString;
          var hasOwnProperty3 = objectProto.hasOwnProperty;
          var objectToString = objectProto.toString;
          var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var splice = arrayProto.splice;
          var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
          function Hash(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
          }
          function hashDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? void 0 : result;
            }
            return hasOwnProperty3.call(data, key) ? data[key] : void 0;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? void 0 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries ? entries.length : 0;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
          }
          function mapCacheDelete(key) {
            return getMapData(this, key)["delete"](key);
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            getMapData(this, key).set(key, value);
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values) {
            var index2 = -1, length = values ? values.length : 0;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseUniq(array, iteratee, comparator) {
            var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);
              if (set) {
                return setToArray(set);
              }
              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee) {
                    seen.push(computed);
                  }
                  result.push(value);
                } else if (!includes(seen, computed, comparator)) {
                  if (seen !== result) {
                    seen.push(computed);
                  }
                  result.push(value);
                }
              }
            return result;
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
            return new Set2(values);
          };
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : void 0;
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag;
          }
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function");
          }
          function noop() {
          }
          module2.exports = uniq;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 450: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var Buffer2 = require2("safe-buffer").Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i)
          M[i] = this._block.readInt32LE(i * 4);
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer2.allocUnsafe(16);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module2.exports = MD5;
    }, { "hash-base": 425, "inherits": 440, "safe-buffer": 494 }], 451: [function(require2, module2, exports2) {
      var bn = require2("bn.js");
      var brorand = require2("brorand");
      function MillerRabin(rand) {
        this.rand = rand || new brorand.Rand();
      }
      module2.exports = MillerRabin;
      MillerRabin.create = function create(rand) {
        return new MillerRabin(rand);
      };
      MillerRabin.prototype._randbelow = function _randbelow(n) {
        var len = n.bitLength();
        var min_bytes = Math.ceil(len / 8);
        do
          var a = new bn(this.rand.generate(min_bytes));
        while (a.cmp(n) >= 0);
        return a;
      };
      MillerRabin.prototype._randrange = function _randrange(start, stop) {
        var size = stop.sub(start);
        return start.add(this._randbelow(size));
      };
      MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        var prime = true;
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          if (cb)
            cb(a);
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return false;
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s)
            return false;
        }
        return prime;
      };
      MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          var g = n.gcd(a);
          if (g.cmpn(1) !== 0)
            return g;
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return x.fromRed().subn(1).gcd(n);
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s) {
            x = x.redSqr();
            return x.fromRed().subn(1).gcd(n);
          }
        }
        return false;
      };
    }, { "bn.js": 452, "brorand": 187 }], 452: [function(require2, module2, exports2) {
      arguments[4][184][0].apply(exports2, arguments);
    }, { "buffer": 188, "dup": 184 }], 453: [function(require2, module2, exports2) {
      module2.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }, {}], 454: [function(require2, module2, exports2) {
      var utils = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    }, {}], 455: [function(require2, module2, exports2) {
      module2.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
    }, {}], 456: [function(require2, module2, exports2) {
      var asn1 = require2("asn1.js");
      exports2.certificate = require2("./certificate");
      var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      exports2.RSAPrivateKey = RSAPrivateKey;
      var RSAPublicKey = asn1.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      exports2.RSAPublicKey = RSAPublicKey;
      var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      exports2.PublicKey = PublicKey;
      var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      });
      var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
      });
      exports2.PrivateKey = PrivateKeyInfo;
      var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      exports2.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
      var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      exports2.DSAPrivateKey = DSAPrivateKey;
      exports2.DSAparam = asn1.define("DSAparam", function() {
        this.int();
      });
      var ECPrivateKey = asn1.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
      });
      exports2.ECPrivateKey = ECPrivateKey;
      var ECParameters = asn1.define("ECParameters", function() {
        this.choice({ namedCurve: this.objid() });
      });
      exports2.signature = asn1.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    }, { "./certificate": 457, "asn1.js": 170 }], 457: [function(require2, module2, exports2) {
      var asn = require2("asn1.js");
      var Time = asn.define("Time", function() {
        this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
      });
      var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      });
      var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      });
      var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
      });
      var RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
      });
      var Name = asn.define("Name", function() {
        this.choice({ rdnSequence: this.use(RDNSequence) });
      });
      var Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
      });
      var Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      });
      var TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
      });
      var X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
      });
      module2.exports = X509Certificate;
    }, { "asn1.js": 170 }], 458: [function(require2, module2, exports2) {
      var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
      var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
      var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
      var evp = require2("evp_bytestokey");
      var ciphers = require2("browserify-aes");
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = function(okey, password) {
        var key = okey.toString();
        var match = key.match(findProc);
        var decrypted;
        if (!match) {
          var match2 = key.match(fullRegex);
          decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
        } else {
          var suite = "aes" + match[1];
          var iv = Buffer2.from(match[2], "hex");
          var cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
          var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
          var out = [];
          var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
          out.push(cipher.update(cipherText));
          out.push(cipher.final());
          decrypted = Buffer2.concat(out);
        }
        var tag = key.match(startRegex)[1];
        return { tag, data: decrypted };
      };
    }, { "browserify-aes": 191, "evp_bytestokey": 423, "safe-buffer": 494 }], 459: [function(require2, module2, exports2) {
      var asn1 = require2("./asn1");
      var aesid = require2("./aesid.json");
      var fixProc = require2("./fixProc");
      var ciphers = require2("browserify-aes");
      var compat = require2("pbkdf2");
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = parseKeys;
      function parseKeys(buffer) {
        var password;
        if (typeof buffer === "object" && !Buffer2.isBuffer(buffer)) {
          password = buffer.passphrase;
          buffer = buffer.key;
        }
        if (typeof buffer === "string") {
          buffer = Buffer2.from(buffer);
        }
        var stripped = fixProc(buffer, password);
        var type = stripped.tag;
        var data = stripped.data;
        var subtype, ndata;
        switch (type) {
          case "CERTIFICATE":
            ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            if (!ndata) {
              ndata = asn1.PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                ndata.subjectPrivateKey = ndata.subjectPublicKey;
                return { type: "ec", data: ndata };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                return { type: "dsa", data: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "ENCRYPTED PRIVATE KEY":
            data = asn1.EncryptedPrivateKey.decode(data, "der");
            data = decrypt(data, password);
          case "PRIVATE KEY":
            ndata = asn1.PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return { curve: ndata.algorithm.curve, privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
                return { type: "dsa", params: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "RSA PUBLIC KEY":
            return asn1.RSAPublicKey.decode(data, "der");
          case "RSA PRIVATE KEY":
            return asn1.RSAPrivateKey.decode(data, "der");
          case "DSA PRIVATE KEY":
            return { type: "dsa", params: asn1.DSAPrivateKey.decode(data, "der") };
          case "EC PRIVATE KEY":
            data = asn1.ECPrivateKey.decode(data, "der");
            return { curve: data.parameters.value, privateKey: data.privateKey };
          default:
            throw new Error("unknown key type " + type);
        }
      }
      parseKeys.signature = asn1.signature;
      function decrypt(data, password) {
        var salt = data.algorithm.decrypt.kde.kdeparams.salt;
        var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
        var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
        var iv = data.algorithm.decrypt.cipher.iv;
        var cipherText = data.subjectPrivateKey;
        var keylen = parseInt(algo.split("-")[1], 10) / 8;
        var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
        var cipher = ciphers.createDecipheriv(algo, key, iv);
        var out = [];
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        return Buffer2.concat(out);
      }
    }, { "./aesid.json": 455, "./asn1": 456, "./fixProc": 458, "browserify-aes": 191, "pbkdf2": 460, "safe-buffer": 494 }], 460: [function(require2, module2, exports2) {
      exports2.pbkdf2 = require2("./lib/async");
      exports2.pbkdf2Sync = require2("./lib/sync");
    }, { "./lib/async": 461, "./lib/sync": 464 }], 461: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var Buffer2 = require2("safe-buffer").Buffer;
          var checkParameters = require2("./precondition");
          var defaultEncoding = require2("./default-encoding");
          var sync = require2("./sync");
          var toBuffer = require2("./to-buffer");
          var ZERO_BUF;
          var subtle = global2.crypto && global2.crypto.subtle;
          var toBrowser = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" };
          var checks = [];
          function checkNative(algo) {
            if (global2.process && !global2.process.browser) {
              return Promise.resolve(false);
            }
            if (!subtle || !subtle.importKey || !subtle.deriveBits) {
              return Promise.resolve(false);
            }
            if (checks[algo] !== void 0) {
              return checks[algo];
            }
            ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
            var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
              return true;
            }).catch(function() {
              return false;
            });
            checks[algo] = prom;
            return prom;
          }
          var nextTick2;
          function getNextTick() {
            if (nextTick2) {
              return nextTick2;
            }
            if (global2.process && global2.process.nextTick) {
              nextTick2 = global2.process.nextTick;
            } else if (global2.queueMicrotask) {
              nextTick2 = global2.queueMicrotask;
            } else if (global2.setImmediate) {
              nextTick2 = global2.setImmediate;
            } else {
              nextTick2 = global2.setTimeout;
            }
            return nextTick2;
          }
          function browserPbkdf2(password, salt, iterations, length, algo) {
            return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
              return subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: { name: algo } }, key, length << 3);
            }).then(function(res) {
              return Buffer2.from(res);
            });
          }
          function resolvePromise(promise, callback) {
            promise.then(function(out) {
              getNextTick()(function() {
                callback(null, out);
              });
            }, function(e) {
              getNextTick()(function() {
                callback(e);
              });
            });
          }
          module2.exports = function(password, salt, iterations, keylen, digest, callback) {
            if (typeof digest === "function") {
              callback = digest;
              digest = void 0;
            }
            digest = digest || "sha1";
            var algo = toBrowser[digest.toLowerCase()];
            if (!algo || typeof global2.Promise !== "function") {
              getNextTick()(function() {
                var out;
                try {
                  out = sync(password, salt, iterations, keylen, digest);
                } catch (e) {
                  return callback(e);
                }
                callback(null, out);
              });
              return;
            }
            checkParameters(iterations, keylen);
            password = toBuffer(password, defaultEncoding, "Password");
            salt = toBuffer(salt, defaultEncoding, "Salt");
            if (typeof callback !== "function")
              throw new Error("No callback provided to pbkdf2");
            resolvePromise(checkNative(algo).then(function(resp) {
              if (resp)
                return browserPbkdf2(password, salt, iterations, keylen, algo);
              return sync(password, salt, iterations, keylen, digest);
            }), callback);
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./default-encoding": 462, "./precondition": 463, "./sync": 464, "./to-buffer": 465, "safe-buffer": 494 }], 462: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          var defaultEncoding;
          if (global2.process && global2.process.browser) {
            defaultEncoding = "utf-8";
          } else if (global2.process && global2.process.version) {
            var pVersionMajor = parseInt(process2.version.split(".")[0].slice(1), 10);
            defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
          } else {
            defaultEncoding = "utf-8";
          }
          module2.exports = defaultEncoding;
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 467 }], 463: [function(require2, module2, exports2) {
      var MAX_ALLOC = Math.pow(2, 30) - 1;
      module2.exports = function(iterations, keylen) {
        if (typeof iterations !== "number") {
          throw new TypeError("Iterations not a number");
        }
        if (iterations < 0) {
          throw new TypeError("Bad iterations");
        }
        if (typeof keylen !== "number") {
          throw new TypeError("Key length not a number");
        }
        if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
          throw new TypeError("Bad key length");
        }
      };
    }, {}], 464: [function(require2, module2, exports2) {
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Buffer2 = require2("safe-buffer").Buffer;
      var checkParameters = require2("./precondition");
      var defaultEncoding = require2("./default-encoding");
      var toBuffer = require2("./to-buffer");
      var ZEROS = Buffer2.alloc(128);
      var sizes = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
      function Hmac(alg, key, saltLen) {
        var hash = getDigest(alg);
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
          key = hash(key);
        } else if (key.length < blocksize) {
          key = Buffer2.concat([key, ZEROS], blocksize);
        }
        var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.hash = hash;
        this.size = sizes[alg];
      }
      Hmac.prototype.run = function(data, ipad) {
        data.copy(ipad, this.blocksize);
        var h3 = this.hash(ipad);
        h3.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
      };
      function getDigest(alg) {
        function shaFunc(data) {
          return sha(alg).update(data).digest();
        }
        function rmd160Func(data) {
          return new RIPEMD160().update(data).digest();
        }
        if (alg === "rmd160" || alg === "ripemd160")
          return rmd160Func;
        if (alg === "md5")
          return md5;
        return shaFunc;
      }
      function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(iterations, keylen);
        password = toBuffer(password, defaultEncoding, "Password");
        salt = toBuffer(salt, defaultEncoding, "Salt");
        digest = digest || "sha1";
        var hmac = new Hmac(digest, password, salt.length);
        var DK = Buffer2.allocUnsafe(keylen);
        var block1 = Buffer2.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0;
        var hLen = sizes[digest];
        var l = Math.ceil(keylen / hLen);
        for (var i = 1; i <= l; i++) {
          block1.writeUInt32BE(i, salt.length);
          var T = hmac.run(block1, hmac.ipad1);
          var U = T;
          for (var j = 1; j < iterations; j++) {
            U = hmac.run(U, hmac.ipad2);
            for (var k = 0; k < hLen; k++)
              T[k] ^= U[k];
          }
          T.copy(DK, destPos);
          destPos += hLen;
        }
        return DK;
      }
      module2.exports = pbkdf2;
    }, { "./default-encoding": 462, "./precondition": 463, "./to-buffer": 465, "create-hash/md5": 387, "ripemd160": 493, "safe-buffer": 494, "sha.js": 498 }], 465: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = function(thing, encoding, name) {
        if (Buffer2.isBuffer(thing)) {
          return thing;
        } else if (typeof thing === "string") {
          return Buffer2.from(thing, encoding);
        } else if (ArrayBuffer.isView(thing)) {
          return Buffer2.from(thing.buffer);
        } else {
          throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
        }
      };
    }, { "safe-buffer": 494 }], 466: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          if (typeof process2 === "undefined" || !process2.version || process2.version.indexOf("v0.") === 0 || process2.version.indexOf("v1.") === 0 && process2.version.indexOf("v1.8.") !== 0) {
            module2.exports = { nextTick: nextTick2 };
          } else {
            module2.exports = process2;
          }
          function nextTick2(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process2.nextTick(fn);
              case 2:
                return process2.nextTick(function afterTickOne() {
                  fn.call(null, arg1);
                });
              case 3:
                return process2.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2);
                });
              case 4:
                return process2.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3);
                });
              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) {
                  args[i++] = arguments[i];
                }
                return process2.nextTick(function afterTick() {
                  fn.apply(null, args);
                });
            }
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 467 }], 467: [function(require2, module2, exports2) {
      var process2 = module2.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item2(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item2(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop() {
      }
      process2.on = noop;
      process2.addListener = noop;
      process2.once = noop;
      process2.off = noop;
      process2.removeListener = noop;
      process2.removeAllListeners = noop;
      process2.emit = noop;
      process2.prependListener = noop;
      process2.prependOnceListener = noop;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }, {}], 468: [function(require2, module2, exports2) {
      exports2.publicEncrypt = require2("./publicEncrypt");
      exports2.privateDecrypt = require2("./privateDecrypt");
      exports2.privateEncrypt = function privateEncrypt(key, buf) {
        return exports2.publicEncrypt(key, buf, true);
      };
      exports2.publicDecrypt = function publicDecrypt(key, buf) {
        return exports2.privateDecrypt(key, buf, true);
      };
    }, { "./privateDecrypt": 471, "./publicEncrypt": 472 }], 469: [function(require2, module2, exports2) {
      var createHash = require2("create-hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = function(seed, len) {
        var t2 = Buffer2.alloc(0);
        var i = 0;
        var c;
        while (t2.length < len) {
          c = i2ops(i++);
          t2 = Buffer2.concat([t2, createHash("sha1").update(seed).update(c).digest()]);
        }
        return t2.slice(0, len);
      };
      function i2ops(c) {
        var out = Buffer2.allocUnsafe(4);
        out.writeUInt32BE(c, 0);
        return out;
      }
    }, { "create-hash": 386, "safe-buffer": 494 }], 470: [function(require2, module2, exports2) {
      arguments[4][184][0].apply(exports2, arguments);
    }, { "buffer": 188, "dup": 184 }], 471: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var crt = require2("browserify-rsa");
      var createHash = require2("create-hash");
      var withPublic = require2("./withPublic");
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = function privateDecrypt(privateKey, enc, reverse) {
        var padding;
        if (privateKey.padding) {
          padding = privateKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(privateKey);
        var k = key.modulus.byteLength();
        if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
          throw new Error("decryption error");
        }
        var msg;
        if (reverse) {
          msg = withPublic(new BN(enc), key);
        } else {
          msg = crt(enc, key);
        }
        var zBuffer = Buffer2.alloc(k - msg.length);
        msg = Buffer2.concat([zBuffer, msg], k);
        if (padding === 4) {
          return oaep(key, msg);
        } else if (padding === 1) {
          return pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          return msg;
        } else {
          throw new Error("unknown padding");
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
        var hLen = iHash.length;
        if (msg[0] !== 0) {
          throw new Error("decryption error");
        }
        var maskedSeed = msg.slice(1, hLen + 1);
        var maskedDb = msg.slice(hLen + 1);
        var seed = xor(maskedSeed, mgf(maskedDb, hLen));
        var db = xor(maskedDb, mgf(seed, k - hLen - 1));
        if (compare(iHash, db.slice(0, hLen))) {
          throw new Error("decryption error");
        }
        var i = hLen;
        while (db[i] === 0) {
          i++;
        }
        if (db[i++] !== 1) {
          throw new Error("decryption error");
        }
        return db.slice(i);
      }
      function pkcs1(key, msg, reverse) {
        var p1 = msg.slice(0, 2);
        var i = 2;
        var status = 0;
        while (msg[i++] !== 0) {
          if (i >= msg.length) {
            status++;
            break;
          }
        }
        var ps = msg.slice(2, i - 1);
        if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
          status++;
        }
        if (ps.length < 8) {
          status++;
        }
        if (status) {
          throw new Error("decryption error");
        }
        return msg.slice(i);
      }
      function compare(a, b) {
        a = Buffer2.from(a);
        b = Buffer2.from(b);
        var dif = 0;
        var len = a.length;
        if (a.length !== b.length) {
          dif++;
          len = Math.min(a.length, b.length);
        }
        var i = -1;
        while (++i < len) {
          dif += a[i] ^ b[i];
        }
        return dif;
      }
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 209, "create-hash": 386, "parse-asn1": 459, "safe-buffer": 494 }], 472: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var randomBytes = require2("randombytes");
      var createHash = require2("create-hash");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var withPublic = require2("./withPublic");
      var crt = require2("browserify-rsa");
      var Buffer2 = require2("safe-buffer").Buffer;
      module2.exports = function publicEncrypt(publicKey, msg, reverse) {
        var padding;
        if (publicKey.padding) {
          padding = publicKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(publicKey);
        var paddedMsg;
        if (padding === 4) {
          paddedMsg = oaep(key, msg);
        } else if (padding === 1) {
          paddedMsg = pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          paddedMsg = new BN(msg);
          if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
          }
        } else {
          throw new Error("unknown padding");
        }
        if (reverse) {
          return crt(paddedMsg, key);
        } else {
          return withPublic(paddedMsg, key);
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var mLen = msg.length;
        var iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
        var hLen = iHash.length;
        var hLen2 = 2 * hLen;
        if (mLen > k - hLen2 - 2) {
          throw new Error("message too long");
        }
        var ps = Buffer2.alloc(k - mLen - hLen2 - 2);
        var dblen = k - hLen - 1;
        var seed = randomBytes(hLen);
        var maskedDb = xor(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf(seed, dblen));
        var maskedSeed = xor(seed, mgf(maskedDb, hLen));
        return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));
      }
      function pkcs1(key, msg, reverse) {
        var mLen = msg.length;
        var k = key.modulus.byteLength();
        if (mLen > k - 11) {
          throw new Error("message too long");
        }
        var ps;
        if (reverse) {
          ps = Buffer2.alloc(k - mLen - 3, 255);
        } else {
          ps = nonZero(k - mLen - 3);
        }
        return new BN(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps, Buffer2.alloc(1), msg], k));
      }
      function nonZero(len) {
        var out = Buffer2.allocUnsafe(len);
        var i = 0;
        var cache2 = randomBytes(len * 2);
        var cur = 0;
        var num;
        while (i < len) {
          if (cur === cache2.length) {
            cache2 = randomBytes(len * 2);
            cur = 0;
          }
          num = cache2[cur++];
          if (num) {
            out[i++] = num;
          }
        }
        return out;
      }
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 209, "create-hash": 386, "parse-asn1": 459, "randombytes": 475, "safe-buffer": 494 }], 473: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var Buffer2 = require2("safe-buffer").Buffer;
      function withPublic(paddedMsg, key) {
        return Buffer2.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
      }
      module2.exports = withPublic;
    }, { "bn.js": 470, "safe-buffer": 494 }], 474: [function(require2, module2, exports2) {
      module2.exports = function xor(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
          a[i] ^= b[i];
        }
        return a;
      };
    }, {}], 475: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          var MAX_BYTES = 65536;
          var MAX_UINT32 = 4294967295;
          function oldBrowser() {
            throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
          }
          var Buffer2 = require2("safe-buffer").Buffer;
          var crypto2 = global2.crypto || global2.msCrypto;
          if (crypto2 && crypto2.getRandomValues) {
            module2.exports = randomBytes;
          } else {
            module2.exports = oldBrowser;
          }
          function randomBytes(size, cb) {
            if (size > MAX_UINT32)
              throw new RangeError("requested too many random bytes");
            var bytes = Buffer2.allocUnsafe(size);
            if (size > 0) {
              if (size > MAX_BYTES) {
                for (var generated = 0; generated < size; generated += MAX_BYTES) {
                  crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
                }
              } else {
                crypto2.getRandomValues(bytes);
              }
            }
            if (typeof cb === "function") {
              return process2.nextTick(function() {
                cb(null, bytes);
              });
            }
            return bytes;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 467, "safe-buffer": 494 }], 476: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          function oldBrowser() {
            throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
          }
          var safeBuffer = require2("safe-buffer");
          var randombytes = require2("randombytes");
          var Buffer2 = safeBuffer.Buffer;
          var kBufferMaxLength = safeBuffer.kMaxLength;
          var crypto2 = global2.crypto || global2.msCrypto;
          var kMaxUint32 = Math.pow(2, 32) - 1;
          function assertOffset(offset, length) {
            if (typeof offset !== "number" || offset !== offset) {
              throw new TypeError("offset must be a number");
            }
            if (offset > kMaxUint32 || offset < 0) {
              throw new TypeError("offset must be a uint32");
            }
            if (offset > kBufferMaxLength || offset > length) {
              throw new RangeError("offset out of range");
            }
          }
          function assertSize(size, offset, length) {
            if (typeof size !== "number" || size !== size) {
              throw new TypeError("size must be a number");
            }
            if (size > kMaxUint32 || size < 0) {
              throw new TypeError("size must be a uint32");
            }
            if (size + offset > length || size > kBufferMaxLength) {
              throw new RangeError("buffer too small");
            }
          }
          if (crypto2 && crypto2.getRandomValues || !process2.browser) {
            exports2.randomFill = randomFill;
            exports2.randomFillSync = randomFillSync;
          } else {
            exports2.randomFill = oldBrowser;
            exports2.randomFillSync = oldBrowser;
          }
          function randomFill(buf, offset, size, cb) {
            if (!Buffer2.isBuffer(buf) && !(buf instanceof global2.Uint8Array)) {
              throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            if (typeof offset === "function") {
              cb = offset;
              offset = 0;
              size = buf.length;
            } else if (typeof size === "function") {
              cb = size;
              size = buf.length - offset;
            } else if (typeof cb !== "function") {
              throw new TypeError('"cb" argument must be a function');
            }
            assertOffset(offset, buf.length);
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size, cb);
          }
          function actualFill(buf, offset, size, cb) {
            if (process2.browser) {
              var ourBuf = buf.buffer;
              var uint = new Uint8Array(ourBuf, offset, size);
              crypto2.getRandomValues(uint);
              if (cb) {
                process2.nextTick(function() {
                  cb(null, buf);
                });
                return;
              }
              return buf;
            }
            if (cb) {
              randombytes(size, function(err, bytes2) {
                if (err) {
                  return cb(err);
                }
                bytes2.copy(buf, offset);
                cb(null, buf);
              });
              return;
            }
            var bytes = randombytes(size);
            bytes.copy(buf, offset);
            return buf;
          }
          function randomFillSync(buf, offset, size) {
            if (typeof offset === "undefined") {
              offset = 0;
            }
            if (!Buffer2.isBuffer(buf) && !(buf instanceof global2.Uint8Array)) {
              throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            assertOffset(offset, buf.length);
            if (size === void 0)
              size = buf.length - offset;
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size);
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 467, "randombytes": 475, "safe-buffer": 494 }], 477: [function(require2, module2, exports2) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module2.exports.codes = codes;
    }, {}], 478: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          var objectKeys = Object.keys || function(obj) {
            var keys3 = [];
            for (var key in obj)
              keys3.push(key);
            return keys3;
          };
          module2.exports = Duplex;
          var Readable = require2("./_stream_readable");
          var Writable = require2("./_stream_writable");
          require2("inherits")(Duplex, Readable);
          {
            var keys2 = objectKeys(Writable.prototype);
            for (var v = 0; v < keys2.length; v++) {
              var method = keys2[v];
              if (!Duplex.prototype[method])
                Duplex.prototype[method] = Writable.prototype[method];
            }
          }
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            this.allowHalfOpen = true;
            if (options) {
              if (options.readable === false)
                this.readable = false;
              if (options.writable === false)
                this.writable = false;
              if (options.allowHalfOpen === false) {
                this.allowHalfOpen = false;
                this.once("end", onend);
              }
            }
          }
          Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          Object.defineProperty(Duplex.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          Object.defineProperty(Duplex.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function onend() {
            if (this._writableState.ended)
              return;
            process2.nextTick(onEndNT, this);
          }
          function onEndNT(self2) {
            self2.end();
          }
          Object.defineProperty(Duplex.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function set(value) {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return;
              }
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./_stream_readable": 480, "./_stream_writable": 482, "_process": 467, "inherits": 440 }], 479: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      require2("inherits")(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 481, "inherits": 440 }], 480: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          module2.exports = Readable;
          var Duplex;
          Readable.ReadableState = ReadableState;
          require2("events").EventEmitter;
          var EElistenerCount = function EElistenerCount2(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer2 = require2("buffer").Buffer;
          var OurUint8Array = (typeof global2 !== "undefined" ? global2 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer2.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var debugUtil = require2("util");
          var debug;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function debug2() {
            };
          }
          var BufferList = require2("./internal/streams/buffer_list");
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          var StringDecoder;
          var createReadableStreamAsyncIterator;
          var from;
          require2("inherits")(Readable, Stream);
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (Array.isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.paused = true;
            this.emitClose = options.emitClose !== false;
            this.autoDestroy = !!options.autoDestroy;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            var isDuplex = this instanceof Duplex;
            this._readableState = new ReadableState(options, this, isDuplex);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer2.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            debug("readableAddChunk", chunk);
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                errorOrDestroy(stream, er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
            }
            return !state.ended && (state.length < state.highWaterMark || state.length === 0);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              state.awaitDrain = 0;
              stream.emit("data", chunk);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
            }
            return er;
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            var decoder = new StringDecoder(enc);
            this._readableState.decoder = decoder;
            this._readableState.encoding = this._readableState.decoder.encoding;
            var p = this._readableState.buffer.head;
            var content = "";
            while (p !== null) {
              content += decoder.write(p.data);
              p = p.next;
            }
            this._readableState.buffer.clear();
            if (content !== "")
              this._readableState.buffer.push(content);
            this._readableState.length = content.length;
            return this;
          };
          var MAX_HWM = 1073741824;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = state.length <= state.highWaterMark;
              n = 0;
            } else {
              state.length -= n;
              state.awaitDrain = 0;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            debug("onEofChunk");
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.sync) {
              emitReadable(stream);
            } else {
              state.needReadable = false;
              if (!state.emittedReadable) {
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            debug("emitReadable", state.needReadable, state.emittedReadable);
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              process2.nextTick(emitReadable_, stream);
            }
          }
          function emitReadable_(stream) {
            var state = stream._readableState;
            debug("emitReadable_", state.destroyed, state.length, state.ended);
            if (!state.destroyed && (state.length || state.ended)) {
              stream.emit("readable");
              state.emittedReadable = false;
            }
            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process2.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
              var len = state.length;
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              process2.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              var ret = dest.write(chunk);
              debug("dest.write", ret);
              if (ret === false) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", state.awaitDrain);
                  state.awaitDrain++;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                errorOrDestroy(dest, er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function pipeOnDrainFunctionResult() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = { hasUnpiped: false };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++)
                dests[i].emit("unpipe", this, { hasUnpiped: false });
              return this;
            }
            var index2 = indexOf(state.pipes, dest);
            if (index2 === -1)
              return this;
            state.pipes.splice(index2, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            var state = this._readableState;
            if (ev === "data") {
              state.readableListening = this.listenerCount("readable") > 0;
              if (state.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.flowing = false;
                state.emittedReadable = false;
                debug("on readable", state.length, state.reading);
                if (state.length) {
                  emitReadable(this);
                } else if (!state.reading) {
                  process2.nextTick(nReadingNextTick, this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.removeListener = function(ev, fn) {
            var res = Stream.prototype.removeListener.call(this, ev, fn);
            if (ev === "readable") {
              process2.nextTick(updateReadableListening, this);
            }
            return res;
          };
          Readable.prototype.removeAllListeners = function(ev) {
            var res = Stream.prototype.removeAllListeners.apply(this, arguments);
            if (ev === "readable" || ev === void 0) {
              process2.nextTick(updateReadableListening, this);
            }
            return res;
          };
          function updateReadableListening(self2) {
            var state = self2._readableState;
            state.readableListening = self2.listenerCount("readable") > 0;
            if (state.resumeScheduled && !state.paused) {
              state.flowing = true;
            } else if (self2.listenerCount("data") > 0) {
              self2.resume();
            }
          }
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = !state.readableListening;
              resume(this, state);
            }
            state.paused = false;
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              process2.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            debug("resume", state.reading);
            if (!state.reading) {
              stream.read(0);
            }
            state.resumeScheduled = false;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (this._readableState.flowing !== false) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            this._readableState.paused = true;
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null)
              ;
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function methodWrap(method) {
                  return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          if (typeof Symbol === "function") {
            Readable.prototype[Symbol.asyncIterator] = function() {
              if (createReadableStreamAsyncIterator === void 0) {
                createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
              }
              return createReadableStreamAsyncIterator(this);
            };
          }
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Object.defineProperty(Readable.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState && this._readableState.buffer;
            }
          });
          Object.defineProperty(Readable.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.flowing;
            },
            set: function set(state) {
              if (this._readableState) {
                this._readableState.flowing = state;
              }
            }
          });
          Readable._fromList = fromList;
          Object.defineProperty(Readable.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.length;
            }
          });
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.first();
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = state.buffer.consume(n, state.decoder);
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            debug("endReadable", state.endEmitted);
            if (!state.endEmitted) {
              state.ended = true;
              process2.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            debug("endReadableNT", state.endEmitted, state.length);
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
              if (state.autoDestroy) {
                var wState = stream._writableState;
                if (!wState || wState.autoDestroy && wState.finished) {
                  stream.destroy();
                }
              }
            }
          }
          if (typeof Symbol === "function") {
            Readable.from = function(iterable, opts) {
              if (from === void 0) {
                from = require2("./internal/streams/from");
              }
              return from(Readable, iterable, opts);
            };
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/async_iterator": 483, "./internal/streams/buffer_list": 484, "./internal/streams/destroy": 485, "./internal/streams/from": 487, "./internal/streams/state": 489, "./internal/streams/stream": 490, "_process": 467, "buffer": 220, "events": 422, "inherits": 440, "string_decoder/": 522, "util": 188 }], 481: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require2("./_stream_duplex");
      require2("inherits")(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }, { "../errors": 477, "./_stream_duplex": 478, "inherits": 440 }], 482: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          module2.exports = Writable;
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var Duplex;
          Writable.WritableState = WritableState;
          var internalUtil = { deprecate: require2("util-deprecate") };
          var Stream = require2("./internal/streams/stream");
          var Buffer2 = require2("buffer").Buffer;
          var OurUint8Array = (typeof global2 !== "undefined" ? global2 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer2.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          require2("inherits")(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.emitClose = options.emitClose !== false;
            this.autoDestroy = !!options.autoDestroy;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(object) {
              if (realHasInstance.call(this, object))
                return true;
              if (this !== Writable)
                return false;
              return object && object._writableState instanceof WritableState;
            } });
          } else {
            realHasInstance = function realHasInstance2(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            var isDuplex = this instanceof Duplex;
            if (!isDuplex && !realHasInstance.call(Writable, this))
              return new Writable(options);
            this._writableState = new WritableState(options, this, isDuplex);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
          };
          function writeAfterEnd(stream, cb) {
            var er = new ERR_STREAM_WRITE_AFTER_END();
            errorOrDestroy(stream, er);
            process2.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var er;
            if (chunk === null) {
              er = new ERR_STREAM_NULL_VALUES();
            } else if (typeof chunk !== "string" && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
            }
            if (er) {
              errorOrDestroy(stream, er);
              process2.nextTick(cb, er);
              return false;
            }
            return true;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer2.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ending)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            this._writableState.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new ERR_UNKNOWN_ENCODING(encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer2.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (state.destroyed)
              state.onwrite(new ERR_STREAM_DESTROYED("write"));
            else if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              process2.nextTick(cb, er);
              process2.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            if (typeof cb !== "function")
              throw new ERR_MULTIPLE_CALLBACK();
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state) || stream.destroyed;
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                process2.nextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending)
              endWritable(this, state, cb);
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                errorOrDestroy(stream, err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function" && !state.destroyed) {
                state.pendingcb++;
                state.finalCalled = true;
                process2.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
                if (state.autoDestroy) {
                  var rState = stream._readableState;
                  if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                  }
                }
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                process2.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            cb(err);
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/destroy": 485, "./internal/streams/state": 489, "./internal/streams/stream": 490, "_process": 467, "buffer": 220, "inherits": 440, "util-deprecate": 524 }], 483: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          var _Object$setPrototypeO;
          function _defineProperty2(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return typeof key === "symbol" ? key : String(key);
          }
          function _toPrimitive(input, hint) {
            if (typeof input !== "object" || input === null)
              return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
              var res = prim.call(input, hint || "default");
              if (typeof res !== "object")
                return res;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
          }
          var finished = require2("./end-of-stream");
          var kLastResolve = Symbol("lastResolve");
          var kLastReject = Symbol("lastReject");
          var kError = Symbol("error");
          var kEnded = Symbol("ended");
          var kLastPromise = Symbol("lastPromise");
          var kHandlePromise = Symbol("handlePromise");
          var kStream = Symbol("stream");
          function createIterResult(value, done) {
            return { value, done };
          }
          function readAndResolve(iter) {
            var resolve = iter[kLastResolve];
            if (resolve !== null) {
              var data = iter[kStream].read();
              if (data !== null) {
                iter[kLastPromise] = null;
                iter[kLastResolve] = null;
                iter[kLastReject] = null;
                resolve(createIterResult(data, false));
              }
            }
          }
          function onReadable(iter) {
            process2.nextTick(readAndResolve, iter);
          }
          function wrapForNext(lastPromise, iter) {
            return function(resolve, reject) {
              lastPromise.then(function() {
                if (iter[kEnded]) {
                  resolve(createIterResult(void 0, true));
                  return;
                }
                iter[kHandlePromise](resolve, reject);
              }, reject);
            };
          }
          var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
          });
          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = { get stream() {
            return this[kStream];
          }, next: function next() {
            var _this = this;
            var error = this[kError];
            if (error !== null) {
              return Promise.reject(error);
            }
            if (this[kEnded]) {
              return Promise.resolve(createIterResult(void 0, true));
            }
            if (this[kStream].destroyed) {
              return new Promise(function(resolve, reject) {
                process2.nextTick(function() {
                  if (_this[kError]) {
                    reject(_this[kError]);
                  } else {
                    resolve(createIterResult(void 0, true));
                  }
                });
              });
            }
            var lastPromise = this[kLastPromise];
            var promise;
            if (lastPromise) {
              promise = new Promise(wrapForNext(lastPromise, this));
            } else {
              var data = this[kStream].read();
              if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
              }
              promise = new Promise(this[kHandlePromise]);
            }
            this[kLastPromise] = promise;
            return promise;
          } }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
            return this;
          }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
            var _this2 = this;
            return new Promise(function(resolve, reject) {
              _this2[kStream].destroy(null, function(err) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve(createIterResult(void 0, true));
              });
            });
          }), _Object$setPrototypeO), AsyncIteratorPrototype);
          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
            var _Object$create;
            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, { value: stream, writable: true }), _defineProperty2(_Object$create, kLastResolve, { value: null, writable: true }), _defineProperty2(_Object$create, kLastReject, { value: null, writable: true }), _defineProperty2(_Object$create, kError, { value: null, writable: true }), _defineProperty2(_Object$create, kEnded, { value: stream._readableState.endEmitted, writable: true }), _defineProperty2(_Object$create, kHandlePromise, { value: function value(resolve, reject) {
              var data = iterator[kStream].read();
              if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
              } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
              }
            }, writable: true }), _Object$create));
            iterator[kLastPromise] = null;
            finished(stream, function(err) {
              if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var reject = iterator[kLastReject];
                if (reject !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  reject(err);
                }
                iterator[kError] = err;
                return;
              }
              var resolve = iterator[kLastResolve];
              if (resolve !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(void 0, true));
              }
              iterator[kEnded] = true;
            });
            stream.on("readable", onReadable.bind(null, iterator));
            return iterator;
          };
          module2.exports = createReadableStreamAsyncIterator;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./end-of-stream": 486, "_process": 467 }], 484: [function(require2, module2, exports2) {
      function ownKeys2(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread3(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {};
          i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var _require = require2("buffer"), Buffer2 = _require.Buffer;
      var _require2 = require2("util"), inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer2.prototype.copy.call(src, target, offset);
      }
      module2.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck2(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass2(BufferList, [{ key: "push", value: function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        } }, { key: "unshift", value: function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        } }, { key: "shift", value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        } }, { key: "clear", value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        } }, { key: "join", value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        } }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, { key: "consume", value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        } }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer2.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, { key: custom, value: function value(_, options) {
          return inspect(this, _objectSpread3(_objectSpread3({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        } }]);
        return BufferList;
      }();
    }, { "buffer": 220, "util": 188 }], 485: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (err) {
                if (!this._writableState) {
                  process2.nextTick(emitErrorNT, this, err);
                } else if (!this._writableState.errorEmitted) {
                  this._writableState.errorEmitted = true;
                  process2.nextTick(emitErrorNT, this, err);
                }
              }
              return this;
            }
            if (this._readableState) {
              this._readableState.destroyed = true;
            }
            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function(err2) {
              if (!cb && err2) {
                if (!_this._writableState) {
                  process2.nextTick(emitErrorAndCloseNT, _this, err2);
                } else if (!_this._writableState.errorEmitted) {
                  _this._writableState.errorEmitted = true;
                  process2.nextTick(emitErrorAndCloseNT, _this, err2);
                } else {
                  process2.nextTick(emitCloseNT, _this);
                }
              } else if (cb) {
                process2.nextTick(emitCloseNT, _this);
                cb(err2);
              } else {
                process2.nextTick(emitCloseNT, _this);
              }
            });
            return this;
          }
          function emitErrorAndCloseNT(self2, err) {
            emitErrorNT(self2, err);
            emitCloseNT(self2);
          }
          function emitCloseNT(self2) {
            if (self2._writableState && !self2._writableState.emitClose)
              return;
            if (self2._readableState && !self2._readableState.emitClose)
              return;
            self2.emit("close");
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finalCalled = false;
              this._writableState.prefinished = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self2, err) {
            self2.emit("error", err);
          }
          function errorOrDestroy(stream, err) {
            var rState = stream._readableState;
            var wState = stream._writableState;
            if (rState && rState.autoDestroy || wState && wState.autoDestroy)
              stream.destroy(err);
            else
              stream.emit("error", err);
          }
          module2.exports = { destroy, undestroy, errorOrDestroy };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 467 }], 486: [function(require2, module2, exports2) {
      var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module2.exports = eos;
    }, { "../../../errors": 477 }], 487: [function(require2, module2, exports2) {
      module2.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 488: [function(require2, module2, exports2) {
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require2("./end-of-stream");
        eos(stream, { readable: reading, writable: writing }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module2.exports = pipeline;
    }, { "../../../errors": 477, "./end-of-stream": 486 }], 489: [function(require2, module2, exports2) {
      var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module2.exports = { getHighWaterMark };
    }, { "../../../errors": 477 }], 490: [function(require2, module2, exports2) {
      module2.exports = require2("events").EventEmitter;
    }, { "events": 422 }], 491: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
      exports2.finished = require2("./lib/internal/streams/end-of-stream.js");
      exports2.pipeline = require2("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 478, "./lib/_stream_passthrough.js": 479, "./lib/_stream_readable.js": 480, "./lib/_stream_transform.js": 481, "./lib/_stream_writable.js": 482, "./lib/internal/streams/end-of-stream.js": 486, "./lib/internal/streams/pipeline.js": 488 }], 492: [function(require2, module2, exports2) {
      var runtime2 = function(exports3) {
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        };
        var undefined$1;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          return obj[key];
        }
        try {
          define({}, "");
        } catch (err) {
          define = function define2(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
          return generator;
        }
        exports3.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
        defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true });
        GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports3.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports3.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports3.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          defineProperty(this, "_invoke", { value: enqueue });
        }
        defineIteratorMethods(AsyncIterator.prototype);
        define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        });
        exports3.AsyncIterator = AsyncIterator;
        exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0)
            PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return { value: record.arg, done: context.done };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method;
          var method = delegate.iterator[methodName];
          if (method === undefined$1) {
            context.delegate = null;
            if (methodName === "throw" && delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            if (methodName !== "return") {
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined$1;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator");
        define(Gp, iteratorSymbol, function() {
          return this;
        });
        define(Gp, "toString", function() {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports3.keys = function(val) {
          var object = Object(val);
          var keys2 = [];
          for (var key in object) {
            keys2.push(key);
          }
          keys2.reverse();
          return function next() {
            while (keys2.length) {
              var key2 = keys2.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined$1;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          return { next: doneResult };
        }
        exports3.values = values;
        function doneResult() {
          return { value: undefined$1, done: true };
        }
        Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        }, stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        }, dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined$1;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        }, abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        }, complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        }, finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        }, "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = { iterator: values(iterable), resultName, nextLoc };
          if (this.method === "next") {
            this.arg = undefined$1;
          }
          return ContinueSentinel;
        } };
        return exports3;
      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        typeof module2 === "object" ? module2.exports : {}
      );
      try {
        regeneratorRuntime = runtime2;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime2;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime2);
        }
      }
    }, {}], 493: [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var ARRAY16 = new Array(16);
      var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j)
          words[j] = this._block.readInt32LE(j * 4);
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t2 = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t2;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      module2.exports = RIPEMD160;
    }, { "buffer": 220, "hash-base": 425, "inherits": 440 }], 494: [function(require2, module2, exports2) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var buffer = require2("buffer");
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill2, encoding);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 220 }], 495: [function(require2, module2, exports2) {
      (function(process2) {
        (function() {
          var buffer = require2("buffer");
          var Buffer2 = buffer.Buffer;
          var safer = {};
          var key;
          for (key in buffer) {
            if (!buffer.hasOwnProperty(key))
              continue;
            if (key === "SlowBuffer" || key === "Buffer")
              continue;
            safer[key] = buffer[key];
          }
          var Safer = safer.Buffer = {};
          for (key in Buffer2) {
            if (!Buffer2.hasOwnProperty(key))
              continue;
            if (key === "allocUnsafe" || key === "allocUnsafeSlow")
              continue;
            Safer[key] = Buffer2[key];
          }
          safer.Buffer.prototype = Buffer2.prototype;
          if (!Safer.from || Safer.from === Uint8Array.from) {
            Safer.from = function(value, encodingOrOffset, length) {
              if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
              }
              if (value && typeof value.length === "undefined") {
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
              }
              return Buffer2(value, encodingOrOffset, length);
            };
          }
          if (!Safer.alloc) {
            Safer.alloc = function(size, fill2, encoding) {
              if (typeof size !== "number") {
                throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
              }
              if (size < 0 || size >= 2 * (1 << 30)) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
              var buf = Buffer2(size);
              if (!fill2 || fill2.length === 0) {
                buf.fill(0);
              } else if (typeof encoding === "string") {
                buf.fill(fill2, encoding);
              } else {
                buf.fill(fill2);
              }
              return buf;
            };
          }
          if (!safer.kStringMaxLength) {
            try {
              safer.kStringMaxLength = process2.binding("buffer").kStringMaxLength;
            } catch (e) {
            }
          }
          if (!safer.constants) {
            safer.constants = { MAX_LENGTH: safer.kMaxLength };
            if (safer.kStringMaxLength) {
              safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
            }
          }
          module2.exports = safer;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 467, "buffer": 220 }], 496: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ed5 = require2("xmlchars/xml/1.0/ed5");
      var ed2 = require2("xmlchars/xml/1.1/ed2");
      var NSed3 = require2("xmlchars/xmlns/1.0/ed3");
      var isS = ed5.isS;
      var isChar10 = ed5.isChar;
      var isNameStartChar = ed5.isNameStartChar;
      var isNameChar = ed5.isNameChar;
      var S_LIST = ed5.S_LIST;
      var NAME_RE = ed5.NAME_RE;
      var isChar11 = ed2.isChar;
      var isNCNameStartChar = NSed3.isNCNameStartChar;
      var isNCNameChar = NSed3.isNCNameChar;
      var NC_NAME_RE = NSed3.NC_NAME_RE;
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        __proto__: null,
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
      };
      var XML_ENTITIES = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        __proto__: null,
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      var EOC = -1;
      var NL_LIKE = -2;
      var S_BEGIN = 0;
      var S_BEGIN_WHITESPACE = 1;
      var S_DOCTYPE = 2;
      var S_DOCTYPE_QUOTE = 3;
      var S_DTD = 4;
      var S_DTD_QUOTED = 5;
      var S_DTD_OPEN_WAKA = 6;
      var S_DTD_OPEN_WAKA_BANG = 7;
      var S_DTD_COMMENT = 8;
      var S_DTD_COMMENT_ENDING = 9;
      var S_DTD_COMMENT_ENDED = 10;
      var S_DTD_PI = 11;
      var S_DTD_PI_ENDING = 12;
      var S_TEXT = 13;
      var S_ENTITY = 14;
      var S_OPEN_WAKA = 15;
      var S_OPEN_WAKA_BANG = 16;
      var S_COMMENT = 17;
      var S_COMMENT_ENDING = 18;
      var S_COMMENT_ENDED = 19;
      var S_CDATA = 20;
      var S_CDATA_ENDING = 21;
      var S_CDATA_ENDING_2 = 22;
      var S_PI_FIRST_CHAR = 23;
      var S_PI_REST = 24;
      var S_PI_BODY = 25;
      var S_PI_ENDING = 26;
      var S_XML_DECL_NAME_START = 27;
      var S_XML_DECL_NAME = 28;
      var S_XML_DECL_EQ = 29;
      var S_XML_DECL_VALUE_START = 30;
      var S_XML_DECL_VALUE = 31;
      var S_XML_DECL_SEPARATOR = 32;
      var S_XML_DECL_ENDING = 33;
      var S_OPEN_TAG = 34;
      var S_OPEN_TAG_SLASH = 35;
      var S_ATTRIB = 36;
      var S_ATTRIB_NAME = 37;
      var S_ATTRIB_NAME_SAW_WHITE = 38;
      var S_ATTRIB_VALUE = 39;
      var S_ATTRIB_VALUE_QUOTED = 40;
      var S_ATTRIB_VALUE_CLOSED = 41;
      var S_ATTRIB_VALUE_UNQUOTED = 42;
      var S_CLOSE_TAG = 43;
      var S_CLOSE_TAG_SAW_WHITE = 44;
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      var BANG = 33;
      var DQUOTE = 34;
      var AMP = 38;
      var SQUOTE = 39;
      var MINUS = 45;
      var FORWARD_SLASH = 47;
      var SEMICOLON = 59;
      var LESS = 60;
      var EQUAL = 61;
      var GREATER = 62;
      var QUESTION = 63;
      var OPEN_BRACKET = 91;
      var CLOSE_BRACKET = 93;
      var NEL = 133;
      var LS = 8232;
      var isQuote = function isQuote2(c) {
        return c === DQUOTE || c === SQUOTE;
      };
      var QUOTES = [DQUOTE, SQUOTE];
      var DOCTYPE_TERMINATOR = [].concat(QUOTES, [OPEN_BRACKET, GREATER]);
      var DTD_TERMINATOR = [].concat(QUOTES, [LESS, CLOSE_BRACKET]);
      var XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION].concat(_toConsumableArray(S_LIST));
      var ATTRIB_VALUE_UNQUOTED_TERMINATOR = [].concat(_toConsumableArray(S_LIST), [GREATER, AMP, LESS]);
      function nsPairCheck(parser, prefix, uri) {
        switch (prefix) {
          case "xml":
            if (uri !== XML_NAMESPACE) {
              parser.fail("xml prefix must be bound to ".concat(XML_NAMESPACE, "."));
            }
            break;
          case "xmlns":
            if (uri !== XMLNS_NAMESPACE) {
              parser.fail("xmlns prefix must be bound to ".concat(XMLNS_NAMESPACE, "."));
            }
            break;
        }
        switch (uri) {
          case XMLNS_NAMESPACE:
            parser.fail(prefix === "" ? "the default namespace may not be set to ".concat(uri, ".") : 'may not assign a prefix (even "xmlns") to the URI '.concat(XMLNS_NAMESPACE, "."));
            break;
          case XML_NAMESPACE:
            switch (prefix) {
              case "xml":
                break;
              case "":
                parser.fail("the default namespace may not be set to ".concat(uri, "."));
                break;
              default:
                parser.fail("may not assign the xml namespace to another prefix.");
            }
            break;
        }
      }
      function nsMappingCheck(parser, mapping) {
        for (var _i12 = 0, _Object$keys = Object.keys(mapping); _i12 < _Object$keys.length; _i12++) {
          var local = _Object$keys[_i12];
          nsPairCheck(parser, local, mapping[local]);
        }
      }
      var isNCName = function isNCName2(name) {
        return NC_NAME_RE.test(name);
      };
      var isName = function isName2(name) {
        return NAME_RE.test(name);
      };
      var FORBIDDEN_START = 0;
      var FORBIDDEN_BRACKET = 1;
      var FORBIDDEN_BRACKET_BRACKET = 2;
      exports2.EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
      var EVENT_NAME_TO_HANDLER_NAME = { xmldecl: "xmldeclHandler", text: "textHandler", processinginstruction: "piHandler", doctype: "doctypeHandler", comment: "commentHandler", opentagstart: "openTagStartHandler", attribute: "attributeHandler", opentag: "openTagHandler", closetag: "closeTagHandler", cdata: "cdataHandler", error: "errorHandler", end: "endHandler", ready: "readyHandler" };
      var SaxesParser = /* @__PURE__ */ function() {
        function SaxesParser2(opt) {
          _classCallCheck(this, SaxesParser2);
          this.opt = opt !== null && opt !== void 0 ? opt : {};
          this.fragmentOpt = !!this.opt.fragment;
          var xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
          this.trackPosition = this.opt.position !== false;
          this.fileName = this.opt.fileName;
          if (xmlnsOpt) {
            this.nameStartCheck = isNCNameStartChar;
            this.nameCheck = isNCNameChar;
            this.isName = isNCName;
            this.processAttribs = this.processAttribsNS;
            this.pushAttrib = this.pushAttribNS;
            this.ns = Object.assign({ __proto__: null }, rootNS);
            var additional = this.opt.additionalNamespaces;
            if (additional != null) {
              nsMappingCheck(this, additional);
              Object.assign(this.ns, additional);
            }
          } else {
            this.nameStartCheck = isNameStartChar;
            this.nameCheck = isNameChar;
            this.isName = isName;
            this.processAttribs = this.processAttribsPlain;
            this.pushAttrib = this.pushAttribPlain;
          }
          this.stateTable = [
            /* eslint-disable @typescript-eslint/unbound-method */
            this.sBegin,
            this.sBeginWhitespace,
            this.sDoctype,
            this.sDoctypeQuote,
            this.sDTD,
            this.sDTDQuoted,
            this.sDTDOpenWaka,
            this.sDTDOpenWakaBang,
            this.sDTDComment,
            this.sDTDCommentEnding,
            this.sDTDCommentEnded,
            this.sDTDPI,
            this.sDTDPIEnding,
            this.sText,
            this.sEntity,
            this.sOpenWaka,
            this.sOpenWakaBang,
            this.sComment,
            this.sCommentEnding,
            this.sCommentEnded,
            this.sCData,
            this.sCDataEnding,
            this.sCDataEnding2,
            this.sPIFirstChar,
            this.sPIRest,
            this.sPIBody,
            this.sPIEnding,
            this.sXMLDeclNameStart,
            this.sXMLDeclName,
            this.sXMLDeclEq,
            this.sXMLDeclValueStart,
            this.sXMLDeclValue,
            this.sXMLDeclSeparator,
            this.sXMLDeclEnding,
            this.sOpenTag,
            this.sOpenTagSlash,
            this.sAttrib,
            this.sAttribName,
            this.sAttribNameSawWhite,
            this.sAttribValue,
            this.sAttribValueQuoted,
            this.sAttribValueClosed,
            this.sAttribValueUnquoted,
            this.sCloseTag,
            this.sCloseTagSawWhite
          ];
          this._init();
        }
        _createClass(SaxesParser2, [{ key: "closed", get: function get() {
          return this._closed;
        } }, {
          key: "_init",
          value: function _init() {
            var _a;
            this.openWakaBang = "";
            this.text = "";
            this.name = "";
            this.piTarget = "";
            this.entity = "";
            this.q = null;
            this.tags = [];
            this.tag = null;
            this.topNS = null;
            this.chunk = "";
            this.chunkPosition = 0;
            this.i = 0;
            this.prevI = 0;
            this.carriedFromPrevious = void 0;
            this.forbiddenState = FORBIDDEN_START;
            this.attribList = [];
            var fragmentOpt = this.fragmentOpt;
            this.state = fragmentOpt ? S_TEXT : S_BEGIN;
            this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
            this.xmlDeclPossible = !fragmentOpt;
            this.xmlDeclExpects = ["version"];
            this.entityReturnState = void 0;
            var defaultXMLVersion = this.opt.defaultXMLVersion;
            if (defaultXMLVersion === void 0) {
              if (this.opt.forceXMLVersion === true) {
                throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
              }
              defaultXMLVersion = "1.0";
            }
            this.setXMLVersion(defaultXMLVersion);
            this.positionAtNewLine = 0;
            this.doctype = false;
            this._closed = false;
            this.xmlDecl = { version: void 0, encoding: void 0, standalone: void 0 };
            this.line = 1;
            this.column = 0;
            this.ENTITIES = Object.create(XML_ENTITIES);
            (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
          }
          /**
          * The stream position the parser is currently looking at. This field is
          * zero-based.
          *
          * This field is not based on counting Unicode characters but is to be
          * interpreted as a plain index into a JavaScript string.
          */
        }, {
          key: "position",
          get: function get() {
            return this.chunkPosition + this.i;
          }
          /**
          * The column number of the next character to be read by the parser.  *
          * This field is zero-based. (The first column in a line is 0.)
          *
          * This field reports the index at which the next character would be in the
          * line if the line were represented as a JavaScript string.  Note that this
          * *can* be different to a count based on the number of *Unicode characters*
          * due to how JavaScript handles astral plane characters.
          *
          * See [[column]] for a number that corresponds to a count of Unicode
          * characters.
          */
        }, {
          key: "columnIndex",
          get: function get() {
            return this.position - this.positionAtNewLine;
          }
          /**
          * Set an event listener on an event. The parser supports one handler per
          * event type. If you try to set an event handler over an existing handler,
          * the old handler is silently overwritten.
          *
          * @param name The event to listen to.
          *
          * @param handler The handler to set.
          */
        }, {
          key: "on",
          value: function on(name, handler) {
            this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
          }
          /**
          * Unset an event handler.
          *
          * @parma name The event to stop listening to.
          */
        }, {
          key: "off",
          value: function off(name) {
            this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
          }
          /**
          * Make an error object. The error object will have a message that contains
          * the ``fileName`` option passed at the creation of the parser. If position
          * tracking was turned on, it will also have line and column number
          * information.
          *
          * @param message The message describing the error to report.
          *
          * @returns An error object with a properly formatted message.
          */
        }, {
          key: "makeError",
          value: function makeError(message) {
            var _a;
            var msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
            if (this.trackPosition) {
              if (msg.length > 0) {
                msg += ":";
              }
              msg += "".concat(this.line, ":").concat(this.column);
            }
            if (msg.length > 0) {
              msg += ": ";
            }
            return new Error(msg + message);
          }
          /**
          * Report a parsing error. This method is made public so that client code may
          * check for issues that are outside the scope of this project and can report
          * errors.
          *
          * @param message The error to report.
          *
          * @returns this
          */
        }, {
          key: "fail",
          value: function fail(message) {
            var err = this.makeError(message);
            var handler = this.errorHandler;
            if (handler === void 0) {
              throw err;
            } else {
              handler(err);
            }
            return this;
          }
          /**
          * Write a XML data to the parser.
          *
          * @param chunk The XML data to write.
          *
          * @returns this
          */
        }, {
          key: "write",
          value: function write(chunk) {
            if (this.closed) {
              return this.fail("cannot write after close; assign an onready handler.");
            }
            var end = false;
            if (chunk === null) {
              end = true;
              chunk = "";
            } else if (typeof chunk === "object") {
              chunk = chunk.toString();
            }
            if (this.carriedFromPrevious !== void 0) {
              chunk = "".concat(this.carriedFromPrevious).concat(chunk);
              this.carriedFromPrevious = void 0;
            }
            var limit = chunk.length;
            var lastCode = chunk.charCodeAt(limit - 1);
            if (!end && // A trailing CR or surrogate must be carried over to the next
            // chunk.
            (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
              this.carriedFromPrevious = chunk[limit - 1];
              limit--;
              chunk = chunk.slice(0, limit);
            }
            var stateTable = this.stateTable;
            this.chunk = chunk;
            this.i = 0;
            while (this.i < limit) {
              stateTable[this.state].call(this);
            }
            this.chunkPosition += limit;
            return end ? this.end() : this;
          }
          /**
          * Close the current stream. Perform final well-formedness checks and reset
          * the parser tstate.
          *
          * @returns this
          */
        }, {
          key: "close",
          value: function close() {
            return this.write(null);
          }
          /**
          * Get a single code point out of the current chunk. This updates the current
          * position if we do position tracking.
          *
          * This is the algorithm to use for XML 1.0.
          *
          * @returns The character read.
          */
        }, {
          key: "getCode10",
          value: function getCode10() {
            var chunk = this.chunk, i = this.i;
            this.prevI = i;
            this.i = i + 1;
            if (i >= chunk.length) {
              return EOC;
            }
            var code = chunk.charCodeAt(i);
            this.column++;
            if (code < 55296) {
              if (code >= SPACE || code === TAB) {
                return code;
              }
              switch (code) {
                case NL:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL;
                case CR:
                  if (chunk.charCodeAt(i + 1) === NL) {
                    this.i = i + 2;
                  }
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL_LIKE;
                default:
                  this.fail("disallowed character.");
                  return code;
              }
            }
            if (code > 56319) {
              if (!(code >= 57344 && code <= 65533)) {
                this.fail("disallowed character.");
              }
              return code;
            }
            var final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
            this.i = i + 2;
            if (final > 1114111) {
              this.fail("disallowed character.");
            }
            return final;
          }
          /**
          * Get a single code point out of the current chunk. This updates the current
          * position if we do position tracking.
          *
          * This is the algorithm to use for XML 1.1.
          *
          * @returns {number} The character read.
          */
        }, {
          key: "getCode11",
          value: function getCode11() {
            var chunk = this.chunk, i = this.i;
            this.prevI = i;
            this.i = i + 1;
            if (i >= chunk.length) {
              return EOC;
            }
            var code = chunk.charCodeAt(i);
            this.column++;
            if (code < 55296) {
              if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
                return code;
              }
              switch (code) {
                case NL:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL;
                case CR: {
                  var next = chunk.charCodeAt(i + 1);
                  if (next === NL || next === NEL) {
                    this.i = i + 2;
                  }
                }
                case NEL:
                case LS:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL_LIKE;
                default:
                  this.fail("disallowed character.");
                  return code;
              }
            }
            if (code > 56319) {
              if (!(code >= 57344 && code <= 65533)) {
                this.fail("disallowed character.");
              }
              return code;
            }
            var final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
            this.i = i + 2;
            if (final > 1114111) {
              this.fail("disallowed character.");
            }
            return final;
          }
          /**
          * Like ``getCode`` but with the return value normalized so that ``NL`` is
          * returned for ``NL_LIKE``.
          */
        }, { key: "getCodeNorm", value: function getCodeNorm() {
          var c = this.getCode();
          return c === NL_LIKE ? NL : c;
        } }, {
          key: "unget",
          value: function unget() {
            this.i = this.prevI;
            this.column--;
          }
          /**
          * Capture characters into a buffer until encountering one of a set of
          * characters.
          *
          * @param chars An array of codepoints. Encountering a character in the array
          * ends the capture. (``chars`` may safely contain ``NL``.)
          *
          * @return The character code that made the capture end, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, {
          key: "captureTo",
          value: function captureTo(chars) {
            var start = this.i;
            var chunk = this.chunk;
            while (true) {
              var c = this.getCode();
              var isNLLike = c === NL_LIKE;
              var final = isNLLike ? NL : c;
              if (final === EOC || chars.includes(final)) {
                this.text += chunk.slice(start, this.prevI);
                return final;
              }
              if (isNLLike) {
                this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                start = this.i;
              }
            }
          }
          /**
          * Capture characters into a buffer until encountering a character.
          *
          * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
          * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
          *
          * @return ``true`` if we ran into the character. Otherwise, we ran into the
          * end of the current chunk.
          */
        }, {
          key: "captureToChar",
          value: function captureToChar(char) {
            var start = this.i;
            var chunk = this.chunk;
            while (true) {
              var c = this.getCode();
              switch (c) {
                case NL_LIKE:
                  this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  start = this.i;
                  c = NL;
                  break;
                case EOC:
                  this.text += chunk.slice(start);
                  return false;
              }
              if (c === char) {
                this.text += chunk.slice(start, this.prevI);
                return true;
              }
            }
          }
          /**
          * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
          * this parser.
          *
          * @return The character code that made the test fail, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, {
          key: "captureNameChars",
          value: function captureNameChars() {
            var chunk = this.chunk, start = this.i;
            while (true) {
              var c = this.getCode();
              if (c === EOC) {
                this.name += chunk.slice(start);
                return EOC;
              }
              if (!isNameChar(c)) {
                this.name += chunk.slice(start, this.prevI);
                return c === NL_LIKE ? NL : c;
              }
            }
          }
          /**
          * Skip white spaces.
          *
          * @return The character that ended the skip, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, { key: "skipSpaces", value: function skipSpaces() {
          while (true) {
            var c = this.getCodeNorm();
            if (c === EOC || !isS(c)) {
              return c;
            }
          }
        } }, {
          key: "setXMLVersion",
          value: function setXMLVersion(version) {
            this.currentXMLVersion = version;
            if (version === "1.0") {
              this.isChar = isChar10;
              this.getCode = this.getCode10;
            } else {
              this.isChar = isChar11;
              this.getCode = this.getCode11;
            }
          }
          // STATE ENGINE METHODS
          // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
          // to be sure never to come back to this state later.
        }, { key: "sBegin", value: function sBegin() {
          if (this.chunk.charCodeAt(0) === 65279) {
            this.i++;
            this.column++;
          }
          this.state = S_BEGIN_WHITESPACE;
        } }, { key: "sBeginWhitespace", value: function sBeginWhitespace() {
          var iBefore = this.i;
          var c = this.skipSpaces();
          if (this.prevI !== iBefore) {
            this.xmlDeclPossible = false;
          }
          switch (c) {
            case LESS:
              this.state = S_OPEN_WAKA;
              if (this.text.length !== 0) {
                throw new Error("no-empty text at start");
              }
              break;
            case EOC:
              break;
            default:
              this.unget();
              this.state = S_TEXT;
              this.xmlDeclPossible = false;
          }
        } }, { key: "sDoctype", value: function sDoctype() {
          var _a;
          var c = this.captureTo(DOCTYPE_TERMINATOR);
          switch (c) {
            case GREATER: {
              (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
              this.text = "";
              this.state = S_TEXT;
              this.doctype = true;
              break;
            }
            case EOC:
              break;
            default:
              this.text += String.fromCodePoint(c);
              if (c === OPEN_BRACKET) {
                this.state = S_DTD;
              } else if (isQuote(c)) {
                this.state = S_DOCTYPE_QUOTE;
                this.q = c;
              }
          }
        } }, { key: "sDoctypeQuote", value: function sDoctypeQuote() {
          var q = this.q;
          if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.q = null;
            this.state = S_DOCTYPE;
          }
        } }, { key: "sDTD", value: function sDTD() {
          var c = this.captureTo(DTD_TERMINATOR);
          if (c === EOC) {
            return;
          }
          this.text += String.fromCodePoint(c);
          if (c === CLOSE_BRACKET) {
            this.state = S_DOCTYPE;
          } else if (c === LESS) {
            this.state = S_DTD_OPEN_WAKA;
          } else if (isQuote(c)) {
            this.state = S_DTD_QUOTED;
            this.q = c;
          }
        } }, { key: "sDTDQuoted", value: function sDTDQuoted() {
          var q = this.q;
          if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.state = S_DTD;
            this.q = null;
          }
        } }, { key: "sDTDOpenWaka", value: function sDTDOpenWaka() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          switch (c) {
            case BANG:
              this.state = S_DTD_OPEN_WAKA_BANG;
              this.openWakaBang = "";
              break;
            case QUESTION:
              this.state = S_DTD_PI;
              break;
            default:
              this.state = S_DTD;
          }
        } }, { key: "sDTDOpenWakaBang", value: function sDTDOpenWakaBang() {
          var char = String.fromCodePoint(this.getCodeNorm());
          var owb = this.openWakaBang += char;
          this.text += char;
          if (owb !== "-") {
            this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
            this.openWakaBang = "";
          }
        } }, { key: "sDTDComment", value: function sDTDComment() {
          if (this.captureToChar(MINUS)) {
            this.text += "-";
            this.state = S_DTD_COMMENT_ENDING;
          }
        } }, { key: "sDTDCommentEnding", value: function sDTDCommentEnding() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
        } }, { key: "sDTDCommentEnded", value: function sDTDCommentEnded() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          if (c === GREATER) {
            this.state = S_DTD;
          } else {
            this.fail("malformed comment.");
            this.state = S_DTD_COMMENT;
          }
        } }, { key: "sDTDPI", value: function sDTDPI() {
          if (this.captureToChar(QUESTION)) {
            this.text += "?";
            this.state = S_DTD_PI_ENDING;
          }
        } }, { key: "sDTDPIEnding", value: function sDTDPIEnding() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          if (c === GREATER) {
            this.state = S_DTD;
          }
        } }, { key: "sText", value: function sText() {
          if (this.tags.length !== 0) {
            this.handleTextInRoot();
          } else {
            this.handleTextOutsideRoot();
          }
        } }, { key: "sEntity", value: function sEntity() {
          var start = this.i;
          var chunk = this.chunk;
          loop:
            while (true) {
              switch (this.getCode()) {
                case NL_LIKE:
                  this.entity += "".concat(chunk.slice(start, this.prevI), "\n");
                  start = this.i;
                  break;
                case SEMICOLON: {
                  var entityReturnState = this.entityReturnState;
                  var entity = this.entity + chunk.slice(start, this.prevI);
                  this.state = entityReturnState;
                  var parsed = void 0;
                  if (entity === "") {
                    this.fail("empty entity name.");
                    parsed = "&;";
                  } else {
                    parsed = this.parseEntity(entity);
                    this.entity = "";
                  }
                  if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
                    this.text += parsed;
                  }
                  break loop;
                }
                case EOC:
                  this.entity += chunk.slice(start);
                  break loop;
              }
            }
        } }, { key: "sOpenWaka", value: function sOpenWaka() {
          var c = this.getCode();
          if (isNameStartChar(c)) {
            this.state = S_OPEN_TAG;
            this.unget();
            this.xmlDeclPossible = false;
          } else {
            switch (c) {
              case FORWARD_SLASH:
                this.state = S_CLOSE_TAG;
                this.xmlDeclPossible = false;
                break;
              case BANG:
                this.state = S_OPEN_WAKA_BANG;
                this.openWakaBang = "";
                this.xmlDeclPossible = false;
                break;
              case QUESTION:
                this.state = S_PI_FIRST_CHAR;
                break;
              default:
                this.fail("disallowed character in tag name");
                this.state = S_TEXT;
                this.xmlDeclPossible = false;
            }
          }
        } }, { key: "sOpenWakaBang", value: function sOpenWakaBang() {
          this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
          switch (this.openWakaBang) {
            case "[CDATA[":
              if (!this.sawRoot && !this.reportedTextBeforeRoot) {
                this.fail("text data outside of root node.");
                this.reportedTextBeforeRoot = true;
              }
              if (this.closedRoot && !this.reportedTextAfterRoot) {
                this.fail("text data outside of root node.");
                this.reportedTextAfterRoot = true;
              }
              this.state = S_CDATA;
              this.openWakaBang = "";
              break;
            case "--":
              this.state = S_COMMENT;
              this.openWakaBang = "";
              break;
            case "DOCTYPE":
              this.state = S_DOCTYPE;
              if (this.doctype || this.sawRoot) {
                this.fail("inappropriately located doctype declaration.");
              }
              this.openWakaBang = "";
              break;
            default:
              if (this.openWakaBang.length >= 7) {
                this.fail("incorrect syntax.");
              }
          }
        } }, { key: "sComment", value: function sComment() {
          if (this.captureToChar(MINUS)) {
            this.state = S_COMMENT_ENDING;
          }
        } }, { key: "sCommentEnding", value: function sCommentEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === MINUS) {
            this.state = S_COMMENT_ENDED;
            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
          } else {
            this.text += "-".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
          }
        } }, { key: "sCommentEnded", value: function sCommentEnded() {
          var c = this.getCodeNorm();
          if (c !== GREATER) {
            this.fail("malformed comment.");
            this.text += "--".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
          } else {
            this.state = S_TEXT;
          }
        } }, { key: "sCData", value: function sCData() {
          if (this.captureToChar(CLOSE_BRACKET)) {
            this.state = S_CDATA_ENDING;
          }
        } }, { key: "sCDataEnding", value: function sCDataEnding() {
          var c = this.getCodeNorm();
          if (c === CLOSE_BRACKET) {
            this.state = S_CDATA_ENDING_2;
          } else {
            this.text += "]".concat(String.fromCodePoint(c));
            this.state = S_CDATA;
          }
        } }, {
          key: "sCDataEnding2",
          value: function sCDataEnding2() {
            var _a;
            var c = this.getCodeNorm();
            switch (c) {
              case GREATER: {
                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                this.text = "";
                this.state = S_TEXT;
                break;
              }
              case CLOSE_BRACKET:
                this.text += "]";
                break;
              default:
                this.text += "]]".concat(String.fromCodePoint(c));
                this.state = S_CDATA;
            }
          }
          // We need this separate state to check the first character fo the pi target
          // with this.nameStartCheck which allows less characters than this.nameCheck.
        }, { key: "sPIFirstChar", value: function sPIFirstChar() {
          var c = this.getCodeNorm();
          if (this.nameStartCheck(c)) {
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
          } else if (c === QUESTION || isS(c)) {
            this.fail("processing instruction without a target.");
            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
          } else {
            this.fail("disallowed character in processing instruction name.");
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
          }
        } }, { key: "sPIRest", value: function sPIRest() {
          var chunk = this.chunk, start = this.i;
          while (true) {
            var c = this.getCodeNorm();
            if (c === EOC) {
              this.piTarget += chunk.slice(start);
              return;
            }
            if (!this.nameCheck(c)) {
              this.piTarget += chunk.slice(start, this.prevI);
              var isQuestion = c === QUESTION;
              if (isQuestion || isS(c)) {
                if (this.piTarget === "xml") {
                  if (!this.xmlDeclPossible) {
                    this.fail("an XML declaration must be at the start of the document.");
                  }
                  this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
                } else {
                  this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
                }
              } else {
                this.fail("disallowed character in processing instruction name.");
                this.piTarget += String.fromCodePoint(c);
              }
              break;
            }
          }
        } }, { key: "sPIBody", value: function sPIBody() {
          if (this.text.length === 0) {
            var c = this.getCodeNorm();
            if (c === QUESTION) {
              this.state = S_PI_ENDING;
            } else if (!isS(c)) {
              this.text = String.fromCodePoint(c);
            }
          } else if (this.captureToChar(QUESTION)) {
            this.state = S_PI_ENDING;
          }
        } }, { key: "sPIEnding", value: function sPIEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === GREATER) {
            var piTarget = this.piTarget;
            if (piTarget.toLowerCase() === "xml") {
              this.fail("the XML declaration must appear at the start of the document.");
            }
            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, { target: piTarget, body: this.text });
            this.piTarget = this.text = "";
            this.state = S_TEXT;
          } else if (c === QUESTION) {
            this.text += "?";
          } else {
            this.text += "?".concat(String.fromCodePoint(c));
            this.state = S_PI_BODY;
          }
          this.xmlDeclPossible = false;
        } }, { key: "sXMLDeclNameStart", value: function sXMLDeclNameStart() {
          var c = this.skipSpaces();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            return;
          }
          if (c !== EOC) {
            this.state = S_XML_DECL_NAME;
            this.name = String.fromCodePoint(c);
          }
        } }, { key: "sXMLDeclName", value: function sXMLDeclName() {
          var c = this.captureTo(XML_DECL_NAME_TERMINATOR);
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.name += this.text;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (!(isS(c) || c === EQUAL)) {
            return;
          }
          this.name += this.text;
          this.text = "";
          if (!this.xmlDeclExpects.includes(this.name)) {
            switch (this.name.length) {
              case 0:
                this.fail("did not expect any more name/value pairs.");
                break;
              case 1:
                this.fail("expected the name ".concat(this.xmlDeclExpects[0], "."));
                break;
              default:
                this.fail("expected one of ".concat(this.xmlDeclExpects.join(", ")));
            }
          }
          this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
        } }, { key: "sXMLDeclEq", value: function sXMLDeclEq() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (isS(c)) {
            return;
          }
          if (c !== EQUAL) {
            this.fail("value required.");
          }
          this.state = S_XML_DECL_VALUE_START;
        } }, { key: "sXMLDeclValueStart", value: function sXMLDeclValueStart() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (isS(c)) {
            return;
          }
          if (!isQuote(c)) {
            this.fail("value must be quoted.");
            this.q = SPACE;
          } else {
            this.q = c;
          }
          this.state = S_XML_DECL_VALUE;
        } }, { key: "sXMLDeclValue", value: function sXMLDeclValue() {
          var c = this.captureTo([this.q, QUESTION]);
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (c === EOC) {
            return;
          }
          var value = this.text;
          this.text = "";
          switch (this.name) {
            case "version": {
              this.xmlDeclExpects = ["encoding", "standalone"];
              var version = value;
              this.xmlDecl.version = version;
              if (!/^1\.[0-9]+$/.test(version)) {
                this.fail("version number must match /^1\\.[0-9]+$/.");
              } else if (!this.opt.forceXMLVersion) {
                this.setXMLVersion(version);
              }
              break;
            }
            case "encoding":
              if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
                this.fail("encoding value must match 	/^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
              }
              this.xmlDeclExpects = ["standalone"];
              this.xmlDecl.encoding = value;
              break;
            case "standalone":
              if (value !== "yes" && value !== "no") {
                this.fail('standalone value must match "yes" or "no".');
              }
              this.xmlDeclExpects = [];
              this.xmlDecl.standalone = value;
              break;
          }
          this.name = "";
          this.state = S_XML_DECL_SEPARATOR;
        } }, { key: "sXMLDeclSeparator", value: function sXMLDeclSeparator() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            return;
          }
          if (!isS(c)) {
            this.fail("whitespace required.");
            this.unget();
          }
          this.state = S_XML_DECL_NAME_START;
        } }, { key: "sXMLDeclEnding", value: function sXMLDeclEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === GREATER) {
            if (this.piTarget !== "xml") {
              this.fail("processing instructions are not allowed before root.");
            } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
              this.fail("XML declaration must contain a version.");
            }
            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
            this.name = "";
            this.piTarget = this.text = "";
            this.state = S_TEXT;
          } else {
            this.fail("The character ? is disallowed anywhere in XML declarations.");
          }
          this.xmlDeclPossible = false;
        } }, { key: "sOpenTag", value: function sOpenTag() {
          var _a;
          var c = this.captureNameChars();
          if (c === EOC) {
            return;
          }
          var tag = this.tag = { name: this.name, attributes: /* @__PURE__ */ Object.create(null) };
          this.name = "";
          if (this.xmlnsOpt) {
            this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
          }
          (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
          this.sawRoot = true;
          if (!this.fragmentOpt && this.closedRoot) {
            this.fail("documents may contain only one root.");
          }
          switch (c) {
            case GREATER:
              this.openTag();
              break;
            case FORWARD_SLASH:
              this.state = S_OPEN_TAG_SLASH;
              break;
            default:
              if (!isS(c)) {
                this.fail("disallowed character in tag name.");
              }
              this.state = S_ATTRIB;
          }
        } }, { key: "sOpenTagSlash", value: function sOpenTagSlash() {
          if (this.getCode() === GREATER) {
            this.openSelfClosingTag();
          } else {
            this.fail("forward-slash in opening tag not followed by >.");
            this.state = S_ATTRIB;
          }
        } }, { key: "sAttrib", value: function sAttrib() {
          var c = this.skipSpaces();
          if (c === EOC) {
            return;
          }
          if (isNameStartChar(c)) {
            this.unget();
            this.state = S_ATTRIB_NAME;
          } else if (c === GREATER) {
            this.openTag();
          } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
          } else {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribName", value: function sAttribName() {
          var c = this.captureNameChars();
          if (c === EQUAL) {
            this.state = S_ATTRIB_VALUE;
          } else if (isS(c)) {
            this.state = S_ATTRIB_NAME_SAW_WHITE;
          } else if (c === GREATER) {
            this.fail("attribute without value.");
            this.pushAttrib(this.name, this.name);
            this.name = this.text = "";
            this.openTag();
          } else if (c !== EOC) {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribNameSawWhite", value: function sAttribNameSawWhite() {
          var c = this.skipSpaces();
          switch (c) {
            case EOC:
              return;
            case EQUAL:
              this.state = S_ATTRIB_VALUE;
              break;
            default:
              this.fail("attribute without value.");
              this.text = "";
              this.name = "";
              if (c === GREATER) {
                this.openTag();
              } else if (isNameStartChar(c)) {
                this.unget();
                this.state = S_ATTRIB_NAME;
              } else {
                this.fail("disallowed character in attribute name.");
                this.state = S_ATTRIB;
              }
          }
        } }, { key: "sAttribValue", value: function sAttribValue() {
          var c = this.getCodeNorm();
          if (isQuote(c)) {
            this.q = c;
            this.state = S_ATTRIB_VALUE_QUOTED;
          } else if (!isS(c)) {
            this.fail("unquoted attribute value.");
            this.state = S_ATTRIB_VALUE_UNQUOTED;
            this.unget();
          }
        } }, { key: "sAttribValueQuoted", value: function sAttribValueQuoted() {
          var q = this.q, chunk = this.chunk;
          var start = this.i;
          while (true) {
            switch (this.getCode()) {
              case q:
                this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
                this.name = this.text = "";
                this.q = null;
                this.state = S_ATTRIB_VALUE_CLOSED;
                return;
              case AMP:
                this.text += chunk.slice(start, this.prevI);
                this.state = S_ENTITY;
                this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
                return;
              case NL:
              case NL_LIKE:
              case TAB:
                this.text += "".concat(chunk.slice(start, this.prevI), " ");
                start = this.i;
                break;
              case LESS:
                this.text += chunk.slice(start, this.prevI);
                this.fail("disallowed character.");
                return;
              case EOC:
                this.text += chunk.slice(start);
                return;
            }
          }
        } }, { key: "sAttribValueClosed", value: function sAttribValueClosed() {
          var c = this.getCodeNorm();
          if (isS(c)) {
            this.state = S_ATTRIB;
          } else if (c === GREATER) {
            this.openTag();
          } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
          } else if (isNameStartChar(c)) {
            this.fail("no whitespace between attributes.");
            this.unget();
            this.state = S_ATTRIB_NAME;
          } else {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribValueUnquoted", value: function sAttribValueUnquoted() {
          var c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
          switch (c) {
            case AMP:
              this.state = S_ENTITY;
              this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
              break;
            case LESS:
              this.fail("disallowed character.");
              break;
            case EOC:
              break;
            default:
              if (this.text.includes("]]>")) {
                this.fail('the string "]]>" is disallowed in char data.');
              }
              this.pushAttrib(this.name, this.text);
              this.name = this.text = "";
              if (c === GREATER) {
                this.openTag();
              } else {
                this.state = S_ATTRIB;
              }
          }
        } }, { key: "sCloseTag", value: function sCloseTag() {
          var c = this.captureNameChars();
          if (c === GREATER) {
            this.closeTag();
          } else if (isS(c)) {
            this.state = S_CLOSE_TAG_SAW_WHITE;
          } else if (c !== EOC) {
            this.fail("disallowed character in closing tag.");
          }
        } }, {
          key: "sCloseTagSawWhite",
          value: function sCloseTagSawWhite() {
            switch (this.skipSpaces()) {
              case GREATER:
                this.closeTag();
                break;
              case EOC:
                break;
              default:
                this.fail("disallowed character in closing tag.");
            }
          }
          // END OF STATE ENGINE METHODS
        }, { key: "handleTextInRoot", value: function handleTextInRoot() {
          var start = this.i, forbiddenState = this.forbiddenState;
          var chunk = this.chunk, handler = this.textHandler;
          scanLoop:
            while (true) {
              switch (this.getCode()) {
                case LESS: {
                  this.state = S_OPEN_WAKA;
                  if (handler !== void 0) {
                    var text = this.text;
                    var slice = chunk.slice(start, this.prevI);
                    if (text.length !== 0) {
                      handler(text + slice);
                      this.text = "";
                    } else if (slice.length !== 0) {
                      handler(slice);
                    }
                  }
                  forbiddenState = FORBIDDEN_START;
                  break scanLoop;
                }
                case AMP:
                  this.state = S_ENTITY;
                  this.entityReturnState = S_TEXT;
                  if (handler !== void 0) {
                    this.text += chunk.slice(start, this.prevI);
                  }
                  forbiddenState = FORBIDDEN_START;
                  break scanLoop;
                case CLOSE_BRACKET:
                  switch (forbiddenState) {
                    case FORBIDDEN_START:
                      forbiddenState = FORBIDDEN_BRACKET;
                      break;
                    case FORBIDDEN_BRACKET:
                      forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                      break;
                    case FORBIDDEN_BRACKET_BRACKET:
                      break;
                    default:
                      throw new Error("impossible state");
                  }
                  break;
                case GREATER:
                  if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                    this.fail('the string "]]>" is disallowed in char data.');
                  }
                  forbiddenState = FORBIDDEN_START;
                  break;
                case NL_LIKE:
                  if (handler !== void 0) {
                    this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  }
                  start = this.i;
                  forbiddenState = FORBIDDEN_START;
                  break;
                case EOC:
                  if (handler !== void 0) {
                    this.text += chunk.slice(start);
                  }
                  break scanLoop;
                default:
                  forbiddenState = FORBIDDEN_START;
              }
            }
          this.forbiddenState = forbiddenState;
        } }, { key: "handleTextOutsideRoot", value: function handleTextOutsideRoot() {
          var start = this.i;
          var chunk = this.chunk, handler = this.textHandler;
          var nonSpace = false;
          outRootLoop:
            while (true) {
              var code = this.getCode();
              switch (code) {
                case LESS: {
                  this.state = S_OPEN_WAKA;
                  if (handler !== void 0) {
                    var text = this.text;
                    var slice = chunk.slice(start, this.prevI);
                    if (text.length !== 0) {
                      handler(text + slice);
                      this.text = "";
                    } else if (slice.length !== 0) {
                      handler(slice);
                    }
                  }
                  break outRootLoop;
                }
                case AMP:
                  this.state = S_ENTITY;
                  this.entityReturnState = S_TEXT;
                  if (handler !== void 0) {
                    this.text += chunk.slice(start, this.prevI);
                  }
                  nonSpace = true;
                  break outRootLoop;
                case NL_LIKE:
                  if (handler !== void 0) {
                    this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  }
                  start = this.i;
                  break;
                case EOC:
                  if (handler !== void 0) {
                    this.text += chunk.slice(start);
                  }
                  break outRootLoop;
                default:
                  if (!isS(code)) {
                    nonSpace = true;
                  }
              }
            }
          if (!nonSpace) {
            return;
          }
          if (!this.sawRoot && !this.reportedTextBeforeRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextBeforeRoot = true;
          }
          if (this.closedRoot && !this.reportedTextAfterRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextAfterRoot = true;
          }
        } }, { key: "pushAttribNS", value: function pushAttribNS(name, value) {
          var _a;
          var _this$qname = this.qname(name), prefix = _this$qname.prefix, local = _this$qname.local;
          var attr = { name, prefix, local, value };
          this.attribList.push(attr);
          (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
          if (prefix === "xmlns") {
            var trimmed = value.trim();
            if (this.currentXMLVersion === "1.0" && trimmed === "") {
              this.fail("invalid attempt to undefine prefix in XML 1.0");
            }
            this.topNS[local] = trimmed;
            nsPairCheck(this, local, trimmed);
          } else if (name === "xmlns") {
            var _trimmed = value.trim();
            this.topNS[""] = _trimmed;
            nsPairCheck(this, "", _trimmed);
          }
        } }, {
          key: "pushAttribPlain",
          value: function pushAttribPlain(name, value) {
            var _a;
            var attr = { name, value };
            this.attribList.push(attr);
            (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
          }
          /**
          * End parsing. This performs final well-formedness checks and resets the
          * parser to a clean state.
          *
          * @returns this
          */
        }, {
          key: "end",
          value: function end() {
            var _a, _b;
            if (!this.sawRoot) {
              this.fail("document must contain a root element.");
            }
            var tags = this.tags;
            while (tags.length > 0) {
              var tag = tags.pop();
              this.fail("unclosed tag: ".concat(tag.name));
            }
            if (this.state !== S_BEGIN && this.state !== S_TEXT) {
              this.fail("unexpected end.");
            }
            var text = this.text;
            if (text.length !== 0) {
              (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
              this.text = "";
            }
            this._closed = true;
            (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
            this._init();
            return this;
          }
          /**
          * Resolve a namespace prefix.
          *
          * @param prefix The prefix to resolve.
          *
          * @returns The namespace URI or ``undefined`` if the prefix is not defined.
          */
        }, {
          key: "resolve",
          value: function resolve(prefix) {
            var _a, _b;
            var uri = this.topNS[prefix];
            if (uri !== void 0) {
              return uri;
            }
            var tags = this.tags;
            for (var index2 = tags.length - 1; index2 >= 0; index2--) {
              uri = tags[index2].ns[prefix];
              if (uri !== void 0) {
                return uri;
              }
            }
            uri = this.ns[prefix];
            if (uri !== void 0) {
              return uri;
            }
            return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
          }
          /**
          * Parse a qname into its prefix and local name parts.
          *
          * @param name The name to parse
          *
          * @returns
          */
        }, { key: "qname", value: function qname(name) {
          var colon = name.indexOf(":");
          if (colon === -1) {
            return { prefix: "", local: name };
          }
          var local = name.slice(colon + 1);
          var prefix = name.slice(0, colon);
          if (prefix === "" || local === "" || local.includes(":")) {
            this.fail("malformed name: ".concat(name, "."));
          }
          return { prefix, local };
        } }, { key: "processAttribsNS", value: function processAttribsNS() {
          var _a;
          var attribList = this.attribList;
          var tag = this.tag;
          {
            var _this$qname2 = this.qname(tag.name), prefix = _this$qname2.prefix, local = _this$qname2.local;
            tag.prefix = prefix;
            tag.local = local;
            var uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
            if (prefix !== "") {
              if (prefix === "xmlns") {
                this.fail('tags may not have "xmlns" as prefix.');
              }
              if (uri === "") {
                this.fail("unbound namespace prefix: ".concat(JSON.stringify(prefix), "."));
                tag.uri = prefix;
              }
            }
          }
          if (attribList.length === 0) {
            return;
          }
          var attributes = tag.attributes;
          var seen = /* @__PURE__ */ new Set();
          var _iterator6 = _createForOfIteratorHelper$1(attribList), _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var attr = _step6.value;
              var name = attr.name, _prefix = attr.prefix, _local = attr.local;
              var _uri = void 0;
              var eqname = void 0;
              if (_prefix === "") {
                _uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
                eqname = name;
              } else {
                _uri = this.resolve(_prefix);
                if (_uri === void 0) {
                  this.fail("unbound namespace prefix: ".concat(JSON.stringify(_prefix), "."));
                  _uri = _prefix;
                }
                eqname = "{".concat(_uri, "}").concat(_local);
              }
              if (seen.has(eqname)) {
                this.fail("duplicate attribute: ".concat(eqname, "."));
              }
              seen.add(eqname);
              attr.uri = _uri;
              attributes[name] = attr;
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          this.attribList = [];
        } }, {
          key: "processAttribsPlain",
          value: function processAttribsPlain() {
            var attribList = this.attribList;
            var attributes = this.tag.attributes;
            var _iterator7 = _createForOfIteratorHelper$1(attribList), _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                var _step7$value = _step7.value, name = _step7$value.name, value = _step7$value.value;
                if (attributes[name] !== void 0) {
                  this.fail("duplicate attribute: ".concat(name, "."));
                }
                attributes[name] = value;
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            this.attribList = [];
          }
          /**
          * Handle a complete open tag. This parser code calls this once it has seen
          * the whole tag. This method checks for well-formeness and then emits
          * ``onopentag``.
          */
        }, {
          key: "openTag",
          value: function openTag() {
            var _a;
            this.processAttribs();
            var tags = this.tags;
            var tag = this.tag;
            tag.isSelfClosing = false;
            (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
            tags.push(tag);
            this.state = S_TEXT;
            this.name = "";
          }
          /**
          * Handle a complete self-closing tag. This parser code calls this once it has
          * seen the whole tag. This method checks for well-formeness and then emits
          * ``onopentag`` and ``onclosetag``.
          */
        }, {
          key: "openSelfClosingTag",
          value: function openSelfClosingTag() {
            var _a, _b, _c;
            this.processAttribs();
            var tags = this.tags;
            var tag = this.tag;
            tag.isSelfClosing = true;
            (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
            (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
            var top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
            if (top === null) {
              this.closedRoot = true;
            }
            this.state = S_TEXT;
            this.name = "";
          }
          /**
          * Handle a complete close tag. This parser code calls this once it has seen
          * the whole tag. This method checks for well-formeness and then emits
          * ``onclosetag``.
          */
        }, {
          key: "closeTag",
          value: function closeTag() {
            var tags = this.tags, name = this.name;
            this.state = S_TEXT;
            this.name = "";
            if (name === "") {
              this.fail("weird empty close tag.");
              this.text += "</>";
              return;
            }
            var handler = this.closeTagHandler;
            var l = tags.length;
            while (l-- > 0) {
              var tag = this.tag = tags.pop();
              this.topNS = tag.ns;
              handler === null || handler === void 0 ? void 0 : handler(tag);
              if (tag.name === name) {
                break;
              }
              this.fail("unexpected close tag.");
            }
            if (l === 0) {
              this.closedRoot = true;
            } else if (l < 0) {
              this.fail("unmatched closing tag: ".concat(name, "."));
              this.text += "</".concat(name, ">");
            }
          }
          /**
          * Resolves an entity. Makes any necessary well-formedness checks.
          *
          * @param entity The entity to resolve.
          *
          * @returns The parsed entity.
          */
        }, { key: "parseEntity", value: function parseEntity(entity) {
          if (entity[0] !== "#") {
            var defined = this.ENTITIES[entity];
            if (defined !== void 0) {
              return defined;
            }
            this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
            return "&".concat(entity, ";");
          }
          var num = NaN;
          if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
            num = parseInt(entity.slice(2), 16);
          } else if (/^#[0-9]+$/.test(entity)) {
            num = parseInt(entity.slice(1), 10);
          }
          if (!this.isChar(num)) {
            this.fail("malformed character entity.");
            return "&".concat(entity, ";");
          }
          return String.fromCodePoint(num);
        } }]);
        return SaxesParser2;
      }();
      exports2.SaxesParser = SaxesParser;
    }, { "xmlchars/xml/1.0/ed5": 543, "xmlchars/xml/1.1/ed2": 544, "xmlchars/xmlns/1.0/ed3": 545 }], 497: [function(require2, module2, exports2) {
      var Buffer2 = require2("safe-buffer").Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer2.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer2.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      module2.exports = Hash;
    }, { "safe-buffer": 494 }], 498: [function(require2, module2, exports2) {
      var _exports = module2.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = _exports[algorithm];
        if (!Algorithm)
          throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      _exports.sha = require2("./sha");
      _exports.sha1 = require2("./sha1");
      _exports.sha224 = require2("./sha224");
      _exports.sha256 = require2("./sha256");
      _exports.sha384 = require2("./sha384");
      _exports.sha512 = require2("./sha512");
    }, { "./sha": 499, "./sha1": 500, "./sha224": 501, "./sha256": 502, "./sha384": 503, "./sha512": 504 }], 499: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t2;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha;
    }, { "./hash": 497, "inherits": 440, "safe-buffer": 494 }], 500: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t2;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha1;
    }, { "./hash": 497, "inherits": 440, "safe-buffer": 494 }], 501: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Sha256 = require2("./sha256");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      module2.exports = Sha224;
    }, { "./hash": 497, "./sha256": 502, "inherits": 440, "safe-buffer": 494 }], 502: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h3 = this._h | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 64; ++i)
          W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        for (var j = 0; j < 64; ++j) {
          var T1 = h3 + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h3 = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h3 + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      module2.exports = Sha256;
    }, { "./hash": 497, "inherits": 440, "safe-buffer": 494 }], 503: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var SHA512 = require2("./sha512");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(48);
        function writeInt64BE(h3, l, offset) {
          H.writeInt32BE(h3, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      module2.exports = Sha384;
    }, { "./hash": 497, "./sha512": 504, "inherits": 440, "safe-buffer": 494 }], 504: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer2 = require2("safe-buffer").Buffer;
      var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + getCarry(el, dl) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer2.allocUnsafe(64);
        function writeInt64BE(h3, l, offset) {
          H.writeInt32BE(h3, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      module2.exports = Sha512;
    }, { "./hash": 497, "inherits": 440, "safe-buffer": 494 }], 505: [function(require2, module2, exports2) {
      module2.exports = Stream;
      var EE = require2("events").EventEmitter;
      var inherits = require2("inherits");
      inherits(Stream, EE);
      Stream.Readable = require2("readable-stream/readable.js");
      Stream.Writable = require2("readable-stream/writable.js");
      Stream.Duplex = require2("readable-stream/duplex.js");
      Stream.Transform = require2("readable-stream/transform.js");
      Stream.PassThrough = require2("readable-stream/passthrough.js");
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }, { "events": 422, "inherits": 440, "readable-stream/duplex.js": 507, "readable-stream/passthrough.js": 516, "readable-stream/readable.js": 517, "readable-stream/transform.js": 518, "readable-stream/writable.js": 519 }], 506: [function(require2, module2, exports2) {
      var toString2 = {}.toString;
      module2.exports = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
    }, {}], 507: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 508 }], 508: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      var objectKeys = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module2.exports = Duplex;
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      var Readable = require2("./_stream_readable");
      var Writable = require2("./_stream_writable");
      util.inherits(Duplex, Readable);
      {
        var keys2 = objectKeys(Writable.prototype);
        for (var v = 0; v < keys2.length; v++) {
          var method = keys2[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        pna.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", { get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      }, set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      } });
      Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }, { "./_stream_readable": 510, "./_stream_writable": 512, "core-util-is": 383, "inherits": 440, "process-nextick-args": 466 }], 509: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 511, "core-util-is": 383, "inherits": 440 }], 510: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          var pna = require2("process-nextick-args");
          module2.exports = Readable;
          var isArray = require2("isarray");
          var Duplex;
          Readable.ReadableState = ReadableState;
          require2("events").EventEmitter;
          var EElistenerCount = function EElistenerCount2(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer2 = require2("safe-buffer").Buffer;
          var OurUint8Array = (typeof global2 !== "undefined" ? global2 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer2.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var util = Object.create(require2("core-util-is"));
          util.inherits = require2("inherits");
          var debugUtil = require2("util");
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function debug2() {
            };
          }
          var BufferList = require2("./internal/streams/BufferList");
          var destroyImpl = require2("./internal/streams/destroy");
          var StringDecoder;
          util.inherits(Readable, Stream);
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", { get: function get() {
            if (this._readableState === void 0) {
              return false;
            }
            return this._readableState.destroyed;
          }, set: function set(value) {
            if (!this._readableState) {
              return;
            }
            this._readableState.destroyed = value;
          } });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            this.push(null);
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer2.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit("error", er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit("error", new Error("stream.unshift() after end event"));
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"));
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }
            return needMoreData(state);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            return er;
          }
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            emitReadable(stream);
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              if (state.sync)
                pna.nextTick(emitReadable_, stream);
              else
                emitReadable_(stream);
            }
          }
          function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              pna.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              pna.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", state.awaitDrain);
                  state.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = { hasUnpiped: false };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, { hasUnpiped: false });
              }
              return this;
            }
            var index2 = indexOf(state.pipes, dest);
            if (index2 === -1)
              return this;
            state.pipes.splice(index2, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === "data") {
              if (this._readableState.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              pna.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0");
              stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Readable._fromList = fromList;
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.head.data;
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          }
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              ret = list.shift();
            } else {
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
          }
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function copyFromBuffer(n, list) {
            var ret = Buffer2.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
              state.ended = true;
              pna.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./_stream_duplex": 508, "./internal/streams/BufferList": 513, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, "_process": 467, "core-util-is": 383, "events": 422, "inherits": 440, "isarray": 506, "process-nextick-args": 466, "safe-buffer": 520, "string_decoder/": 521, "util": 188 }], 511: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var Duplex = require2("./_stream_duplex");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
          return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
          _this2.emit("close");
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
    }, { "./_stream_duplex": 508, "core-util-is": 383, "inherits": 440 }], 512: [function(require2, module2, exports2) {
      (function(process2, global2, setImmediate) {
        (function() {
          var pna = require2("process-nextick-args");
          module2.exports = Writable;
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var asyncWrite = !process2.browser && ["v0.10", "v0.9."].indexOf(process2.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
          var Duplex;
          Writable.WritableState = WritableState;
          var util = Object.create(require2("core-util-is"));
          util.inherits = require2("inherits");
          var internalUtil = { deprecate: require2("util-deprecate") };
          var Stream = require2("./internal/streams/stream");
          var Buffer2 = require2("safe-buffer").Buffer;
          var OurUint8Array = (typeof global2 !== "undefined" ? global2 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer2.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          util.inherits(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(object) {
              if (realHasInstance.call(this, object))
                return true;
              if (this !== Writable)
                return false;
              return object && object._writableState instanceof WritableState;
            } });
          } else {
            realHasInstance = function realHasInstance2(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options);
            }
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            stream.emit("error", er);
            pna.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (chunk === null) {
              er = new TypeError("May not write null values to stream");
            } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            if (er) {
              stream.emit("error", er);
              pna.nextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer2.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer2.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              pna.nextTick(cb, er);
              pna.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                asyncWrite(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                stream.emit("error", err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++;
                state.finalCalled = true;
                pna.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                pna.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, "destroyed", { get: function get() {
            if (this._writableState === void 0) {
              return false;
            }
            return this._writableState.destroyed;
          }, set: function set(value) {
            if (!this._writableState) {
              return;
            }
            this._writableState.destroyed = value;
          } });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            this.end();
            cb(err);
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
    }, { "./_stream_duplex": 508, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, "_process": 467, "core-util-is": 383, "inherits": 440, "process-nextick-args": 466, "safe-buffer": 520, "timers": 523, "util-deprecate": 524 }], 513: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Buffer2 = require2("safe-buffer").Buffer;
      var util = require2("util");
      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }
      module2.exports = function() {
        function BufferList() {
          _classCallCheck2(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        return BufferList;
      }();
      if (util && util.inspect && util.inspect.custom) {
        module2.exports.prototype[util.inspect.custom] = function() {
          var obj = util.inspect({ length: this.length });
          return this.constructor.name + " " + obj;
        };
      }
    }, { "safe-buffer": 520, "util": 188 }], 514: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              pna.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              pna.nextTick(emitErrorNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              pna.nextTick(emitErrorNT, _this, err2);
            }
          } else if (cb) {
            cb(err2);
          }
        });
        return this;
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      module2.exports = { destroy, undestroy };
    }, { "process-nextick-args": 466 }], 515: [function(require2, module2, exports2) {
      arguments[4][490][0].apply(exports2, arguments);
    }, { "dup": 490, "events": 422 }], 516: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").PassThrough;
    }, { "./readable": 517 }], 517: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_duplex.js": 508, "./lib/_stream_passthrough.js": 509, "./lib/_stream_readable.js": 510, "./lib/_stream_transform.js": 511, "./lib/_stream_writable.js": 512 }], 518: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").Transform;
    }, { "./readable": 517 }], 519: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 512 }], 520: [function(require2, module2, exports2) {
      arguments[4][217][0].apply(exports2, arguments);
    }, { "buffer": 220, "dup": 217 }], 521: [function(require2, module2, exports2) {
      arguments[4][218][0].apply(exports2, arguments);
    }, { "dup": 218, "safe-buffer": 520 }], 522: [function(require2, module2, exports2) {
      arguments[4][218][0].apply(exports2, arguments);
    }, { "dup": 218, "safe-buffer": 494 }], 523: [function(require2, module2, exports2) {
      (function(setImmediate, clearImmediate) {
        (function() {
          var nextTick2 = require2("process/browser.js").nextTick;
          var apply = Function.prototype.apply;
          var slice = Array.prototype.slice;
          var immediateIds = {};
          var nextImmediateId = 0;
          exports2.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
          };
          exports2.setInterval = function() {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
          };
          exports2.clearTimeout = exports2.clearInterval = function(timeout) {
            timeout.close();
          };
          function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {
          };
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id);
          };
          exports2.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
          };
          exports2.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
          };
          exports2._unrefActive = exports2.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout)
                  item._onTimeout();
              }, msecs);
            }
          };
          exports2.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
            var id = nextImmediateId++;
            var args = arguments.length < 2 ? false : slice.call(arguments, 1);
            immediateIds[id] = true;
            nextTick2(function onNextTick() {
              if (immediateIds[id]) {
                if (args) {
                  fn.apply(null, args);
                } else {
                  fn.call(null);
                }
                exports2.clearImmediate(id);
              }
            });
            return id;
          };
          exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
            delete immediateIds[id];
          };
        }).call(this);
      }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
    }, { "process/browser.js": 467, "timers": 523 }], 524: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          module2.exports = deprecate;
          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg);
                } else if (config("traceDeprecation")) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }
          function config(name) {
            try {
              if (!global2.localStorage)
                return false;
            } catch (_) {
              return false;
            }
            var val = global2.localStorage[name];
            if (null == val)
              return false;
            return String(val).toLowerCase() === "true";
          }
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 525: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }, {}], 526: [function(require2, module2, exports2) {
      module2.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }, {}], 527: [function(require2, module2, exports2) {
      (function(process2, global2) {
        (function() {
          var formatRegExp = /%[sdj%]/g;
          exports2.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(" ");
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x2) {
              if (x2 === "%%")
                return "%";
              if (i >= len)
                return x2;
              switch (x2) {
                case "%s":
                  return String(args[i++]);
                case "%d":
                  return Number(args[i++]);
                case "%j":
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return "[Circular]";
                  }
                default:
                  return x2;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += " " + x;
              } else {
                str += " " + inspect(x);
              }
            }
            return str;
          };
          exports2.deprecate = function(fn, msg) {
            if (isUndefined(global2.process)) {
              return function() {
                return exports2.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process2.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process2.throwDeprecation) {
                  throw new Error(msg);
                } else if (process2.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports2.debuglog = function(set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process2.env.NODE_DEBUG || "";
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                var pid = process2.pid;
                debugs[set] = function() {
                  var msg = exports2.format.apply(exports2, arguments);
                  console.error("%s %d: %s", set, pid, msg);
                };
              } else {
                debugs[set] = function() {
                };
              }
            }
            return debugs[set];
          };
          function inspect(obj, opts) {
            var ctx = { seen: [], stylize: stylizeNoColor };
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              exports2._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports2.inspect = inspect;
          inspect.colors = { "bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39] };
          inspect.styles = {
            "special": "cyan",
            "number": "yellow",
            "boolean": "yellow",
            "undefined": "grey",
            "null": "bold",
            "string": "green",
            "date": "magenta",
            // "name": intentionally not styling
            "regexp": "red"
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
            value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys2 = Object.keys(value);
            var visibleKeys = arrayToHash(keys2);
            if (ctx.showHidden) {
              keys2 = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
              return formatError(value);
            }
            if (keys2.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name + "]", "special");
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), "date");
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = "", array = false, braces = ["{", "}"];
            if (isArray(value)) {
              array = true;
              braces = ["[", "]"];
            }
            if (isFunction(value)) {
              var n = value.name ? ": " + value.name : "";
              base = " [Function" + n + "]";
            }
            if (isRegExp(value)) {
              base = " " + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = " " + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = " " + formatError(value);
            }
            if (keys2.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              } else {
                return ctx.stylize("[Object]", "special");
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
            } else {
              output = keys2.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
              var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return ctx.stylize(simple, "string");
            }
            if (isNumber(value))
              return ctx.stylize("" + value, "number");
            if (isBoolean(value))
              return ctx.stylize("" + value, "boolean");
            if (isNull(value))
              return ctx.stylize("null", "null");
          }
          function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty3(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push("");
              }
            }
            keys2.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize("[Getter/Setter]", "special");
              } else {
                str = ctx.stylize("[Getter]", "special");
              }
            } else {
              if (desc.set) {
                str = ctx.stylize("[Setter]", "special");
              }
            }
            if (!hasOwnProperty3(visibleKeys, key)) {
              name = "[" + key + "]";
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf("\n") > -1) {
                  if (array) {
                    str = str.split("\n").map(function(line) {
                      return "  " + line;
                    }).join("\n").substr(2);
                  } else {
                    str = "\n" + str.split("\n").map(function(line) {
                      return "   " + line;
                    }).join("\n");
                  }
                }
              } else {
                str = ctx.stylize("[Circular]", "special");
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify("" + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, "name");
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, "string");
              }
            }
            return name + ": " + str;
          }
          function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function(prev, cur) {
              if (cur.indexOf("\n") >= 0)
                ;
              return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            }
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
          }
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports2.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports2.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports2.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports2.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports2.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === "string";
          }
          exports2.isString = isString;
          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports2.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports2.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
          }
          exports2.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports2.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
          }
          exports2.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
          }
          exports2.isError = isError;
          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports2.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
            typeof arg === "undefined";
          }
          exports2.isPrimitive = isPrimitive;
          exports2.isBuffer = require2("./support/isBuffer");
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
          }
          var months2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function timestamp() {
            var d = /* @__PURE__ */ new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
            return [d.getDate(), months2[d.getMonth()], time].join(" ");
          }
          exports2.log = function() {
            console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
          };
          exports2.inherits = require2("inherits");
          exports2._extend = function(origin, add) {
            if (!add || !isObject(add))
              return origin;
            var keys2 = Object.keys(add);
            var i = keys2.length;
            while (i--) {
              origin[keys2[i]] = add[keys2[i]];
            }
            return origin;
          };
          function hasOwnProperty3(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./support/isBuffer": 526, "_process": 467, "inherits": 525 }], 528: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      Object.defineProperty(exports2, "v1", { enumerable: true, get: function get() {
        return _v.default;
      } });
      Object.defineProperty(exports2, "v3", { enumerable: true, get: function get() {
        return _v2.default;
      } });
      Object.defineProperty(exports2, "v4", { enumerable: true, get: function get() {
        return _v3.default;
      } });
      Object.defineProperty(exports2, "v5", { enumerable: true, get: function get() {
        return _v4.default;
      } });
      Object.defineProperty(exports2, "NIL", { enumerable: true, get: function get() {
        return _nil.default;
      } });
      Object.defineProperty(exports2, "version", { enumerable: true, get: function get() {
        return _version.default;
      } });
      Object.defineProperty(exports2, "validate", { enumerable: true, get: function get() {
        return _validate.default;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function get() {
        return _stringify.default;
      } });
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function get() {
        return _parse.default;
      } });
      var _v = _interopRequireDefault(require2("./v1.js"));
      var _v2 = _interopRequireDefault(require2("./v3.js"));
      var _v3 = _interopRequireDefault(require2("./v4.js"));
      var _v4 = _interopRequireDefault(require2("./v5.js"));
      var _nil = _interopRequireDefault(require2("./nil.js"));
      var _version = _interopRequireDefault(require2("./version.js"));
      var _validate = _interopRequireDefault(require2("./validate.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      var _parse = _interopRequireDefault(require2("./parse.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }, { "./nil.js": 530, "./parse.js": 531, "./stringify.js": 535, "./v1.js": 536, "./v3.js": 537, "./v4.js": 539, "./v5.js": 540, "./validate.js": 541, "./version.js": 542 }], 529: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      function md5(bytes) {
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Uint8Array(msg.length);
          for (var i = 0; i < msg.length; ++i) {
            bytes[i] = msg.charCodeAt(i);
          }
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        var output = [];
        var length32 = input.length * 32;
        var hexTab = "0123456789abcdef";
        for (var i = 0; i < length32; i += 8) {
          var x = input[i >> 5] >>> i % 32 & 255;
          var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
          output.push(hex);
        }
        return output;
      }
      function getOutputLength(inputLength8) {
        return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
      }
      function wordsToMd5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[getOutputLength(len) - 1] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (var i = 0; i < x.length; i += 16) {
          var olda = a;
          var oldb = b;
          var oldc = c;
          var oldd = d;
          a = md5ff(a, b, c, d, x[i], 7, -680876936);
          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5gg(b, c, d, a, x[i], 20, -373897302);
          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5hh(d, a, b, c, x[i], 11, -358537222);
          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5ii(a, b, c, d, x[i], 6, -198630844);
          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safeAdd(a, olda);
          b = safeAdd(b, oldb);
          c = safeAdd(c, oldc);
          d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
      }
      function bytesToWords(input) {
        if (input.length === 0) {
          return [];
        }
        var length8 = input.length * 8;
        var output = new Uint32Array(getOutputLength(length8));
        for (var i = 0; i < length8; i += 8) {
          output[i >> 5] |= (input[i / 8] & 255) << i % 32;
        }
        return output;
      }
      function safeAdd(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q, a, b, x, s, t2) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t2)), s), b);
      }
      function md5ff(a, b, c, d, x, s, t2) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t2);
      }
      function md5gg(a, b, c, d, x, s, t2) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t2);
      }
      function md5hh(a, b, c, d, x, s, t2) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t2);
      }
      function md5ii(a, b, c, d, x, s, t2) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t2);
      }
      var _default3 = md5;
      exports2.default = _default3;
    }, {}], 530: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _default3 = "00000000-0000-0000-0000-000000000000";
      exports2.default = _default3;
    }, {}], 531: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function parse(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        var v;
        var arr = new Uint8Array(16);
        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
        arr[1] = v >>> 16 & 255;
        arr[2] = v >>> 8 & 255;
        arr[3] = v & 255;
        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
        arr[5] = v & 255;
        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
        arr[7] = v & 255;
        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
        arr[9] = v & 255;
        arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
        arr[11] = v / 4294967296 & 255;
        arr[12] = v >>> 24 & 255;
        arr[13] = v >>> 16 & 255;
        arr[14] = v >>> 8 & 255;
        arr[15] = v & 255;
        return arr;
      }
      var _default3 = parse;
      exports2.default = _default3;
    }, { "./validate.js": 541 }], 532: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _default3 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      exports2.default = _default3;
    }, {}], 533: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = rng;
      var getRandomValues;
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
          if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          }
        }
        return getRandomValues(rnds8);
      }
    }, {}], 534: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      function f(s, x, y, z) {
        switch (s) {
          case 0:
            return x & y ^ ~x & z;
          case 1:
            return x ^ y ^ z;
          case 2:
            return x & y ^ x & z ^ y & z;
          case 3:
            return x ^ y ^ z;
        }
      }
      function ROTL(x, n) {
        return x << n | x >>> 32 - n;
      }
      function sha1(bytes) {
        var K = [1518500249, 1859775393, 2400959708, 3395469782];
        var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = [];
          for (var i = 0; i < msg.length; ++i) {
            bytes.push(msg.charCodeAt(i));
          }
        } else if (!Array.isArray(bytes)) {
          bytes = Array.prototype.slice.call(bytes);
        }
        bytes.push(128);
        var l = bytes.length / 4 + 2;
        var N = Math.ceil(l / 16);
        var M = new Array(N);
        for (var _i13 = 0; _i13 < N; ++_i13) {
          var arr = new Uint32Array(16);
          for (var j = 0; j < 16; ++j) {
            arr[j] = bytes[_i13 * 64 + j * 4] << 24 | bytes[_i13 * 64 + j * 4 + 1] << 16 | bytes[_i13 * 64 + j * 4 + 2] << 8 | bytes[_i13 * 64 + j * 4 + 3];
          }
          M[_i13] = arr;
        }
        M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
        M[N - 1][14] = Math.floor(M[N - 1][14]);
        M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
        for (var _i14 = 0; _i14 < N; ++_i14) {
          var W = new Uint32Array(80);
          for (var t2 = 0; t2 < 16; ++t2) {
            W[t2] = M[_i14][t2];
          }
          for (var _t = 16; _t < 80; ++_t) {
            W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
          }
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d = H[3];
          var e = H[4];
          for (var _t2 = 0; _t2 < 80; ++_t2) {
            var s = Math.floor(_t2 / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
          }
          H[0] = H[0] + a >>> 0;
          H[1] = H[1] + b >>> 0;
          H[2] = H[2] + c >>> 0;
          H[3] = H[3] + d >>> 0;
          H[4] = H[4] + e >>> 0;
        }
        return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
      }
      var _default3 = sha1;
      exports2.default = _default3;
    }, {}], 535: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var byteToHex = [];
      for (var i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      function stringify(arr) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Stringified UUID is invalid");
        }
        return uuid;
      }
      var _default3 = stringify;
      exports2.default = _default3;
    }, { "./validate.js": 541 }], 536: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _rng = _interopRequireDefault(require2("./rng.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || new Array(16);
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = tmh & 255;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = clockseq & 255;
        for (var n = 0; n < 6; ++n) {
          b[i + n] = node[n];
        }
        return buf || (0, _stringify.default)(b);
      }
      var _default3 = v1;
      exports2.default = _default3;
    }, { "./rng.js": 533, "./stringify.js": 535 }], 537: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require2("./v35.js"));
      var _md = _interopRequireDefault(require2("./md5.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v3 = (0, _v.default)("v3", 48, _md.default);
      var _default3 = v3;
      exports2.default = _default3;
    }, { "./md5.js": 529, "./v35.js": 538 }], 538: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = _default3;
      exports2.URL = exports2.DNS = void 0;
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      var _parse = _interopRequireDefault(require2("./parse.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str));
        var bytes = [];
        for (var i = 0; i < str.length; ++i) {
          bytes.push(str.charCodeAt(i));
        }
        return bytes;
      }
      var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports2.DNS = DNS;
      var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports2.URL = URL2;
      function _default3(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          if (typeof value === "string") {
            value = stringToBytes(value);
          }
          if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
          }
          if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          }
          var bytes = new Uint8Array(16 + value.length);
          bytes.set(namespace);
          bytes.set(value, namespace.length);
          bytes = hashfunc(bytes);
          bytes[6] = bytes[6] & 15 | version;
          bytes[8] = bytes[8] & 63 | 128;
          if (buf) {
            offset = offset || 0;
            for (var i = 0; i < 16; ++i) {
              buf[offset + i] = bytes[i];
            }
            return buf;
          }
          return (0, _stringify.default)(bytes);
        }
        try {
          generateUUID.name = name;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL2;
        return generateUUID;
      }
    }, { "./parse.js": 531, "./stringify.js": 535 }], 539: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _rng = _interopRequireDefault(require2("./rng.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (var i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
          }
          return buf;
        }
        return (0, _stringify.default)(rnds);
      }
      var _default3 = v4;
      exports2.default = _default3;
    }, { "./rng.js": 533, "./stringify.js": 535 }], 540: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require2("./v35.js"));
      var _sha = _interopRequireDefault(require2("./sha1.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v5 = (0, _v.default)("v5", 80, _sha.default);
      var _default3 = v5;
      exports2.default = _default3;
    }, { "./sha1.js": 534, "./v35.js": 538 }], 541: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _regex = _interopRequireDefault(require2("./regex.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function validate(uuid) {
        return typeof uuid === "string" && _regex.default.test(uuid);
      }
      var _default3 = validate;
      exports2.default = _default3;
    }, { "./regex.js": 532 }], 542: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function version(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        return parseInt(uuid.substr(14, 1), 16);
      }
      var _default3 = version;
      exports2.default = _default3;
    }, { "./validate.js": 541 }], 543: [function(require2, module2, exports2) {
      /**
      * Character classes and associated utilities for the 5th edition of XML 1.0.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CHAR = "	\n\r ---";
      exports2.S = " 	\r\n";
      exports2.NAME_START_CHAR = ":A-Z_a-z-----------";
      exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9--";
      exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
      exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
      exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
      exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
      exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
      exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      exports2.S_LIST = [SPACE, NL, CR, TAB];
      function isChar(c) {
        return c >= SPACE && c <= 55295 || c === NL || c === CR || c === TAB || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isChar = isChar;
      function isS(c) {
        return c === SPACE || c === NL || c === CR || c === TAB;
      }
      exports2.isS = isS;
      function isNameStartChar(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNameStartChar = isNameStartChar;
      function isNameChar(c) {
        return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNameChar = isNameChar;
    }, {}], 544: [function(require2, module2, exports2) {
      /**
      * Character classes and associated utilities for the 2nd edition of XML 1.1.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CHAR = "---";
      exports2.RESTRICTED_CHAR = "-\b\v\f---";
      exports2.S = " 	\r\n";
      exports2.NAME_START_CHAR = ":A-Z_a-z-----------";
      exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9--";
      exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
      exports2.RESTRICTED_CHAR_RE = new RegExp("^[" + exports2.RESTRICTED_CHAR + "]$", "u");
      exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
      exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
      exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
      exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
      exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      exports2.S_LIST = [SPACE, NL, CR, TAB];
      function isChar(c) {
        return c >= 1 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isChar = isChar;
      function isRestrictedChar(c) {
        return c >= 1 && c <= 8 || c === 11 || c === 12 || c >= 14 && c <= 31 || c >= 127 && c <= 132 || c >= 134 && c <= 159;
      }
      exports2.isRestrictedChar = isRestrictedChar;
      function isCharAndNotRestricted(c) {
        return c === 9 || c === 10 || c === 13 || c > 31 && c < 127 || c === 133 || c > 159 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isCharAndNotRestricted = isCharAndNotRestricted;
      function isS(c) {
        return c === SPACE || c === NL || c === CR || c === TAB;
      }
      exports2.isS = isS;
      function isNameStartChar(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNameStartChar = isNameStartChar;
      function isNameChar(c) {
        return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNameChar = isNameChar;
    }, {}], 545: [function(require2, module2, exports2) {
      /**
      * Character class utilities for XML NS 1.0 edition 3.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NC_NAME_START_CHAR = "A-Z_a-z------------";
      exports2.NC_NAME_CHAR = "-" + exports2.NC_NAME_START_CHAR + ".0-9--";
      exports2.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "]$", "u");
      exports2.NC_NAME_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_CHAR + "]$", "u");
      exports2.NC_NAME_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "][" + exports2.NC_NAME_CHAR + "]*$", "u");
      function isNCNameStartChar(c) {
        return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNCNameStartChar = isNCNameStartChar;
      function isNCNameChar(c) {
        return isNCNameStartChar(c) || c === 45 || c === 46 || c >= 48 && c <= 57 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNCNameChar = isNCNameChar;
    }, {}] }, {}, [15])(15);
  });
})(exceljs);
var exceljsExports = exceljs.exports;
function getUrl(src) {
  if (typeof src === "string") {
    return src;
  } else if (src instanceof Blob) {
    return URL.createObjectURL(src);
  } else if (src instanceof ArrayBuffer) {
    return URL.createObjectURL(new Blob([src]));
  } else if (src instanceof Response) {
    return URL.createObjectURL(src.blob());
  } else {
    return src;
  }
}
function download(_x, _x2) {
  return _download.apply(this, arguments);
}
function _download() {
  _download = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(filename, data) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            if (data) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            if (data instanceof ArrayBuffer) {
              data = new Blob([data]);
            }
            downloadFile(filename, URL.createObjectURL(data));
          case 4:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return _download.apply(this, arguments);
}
function downloadFile(filename, href) {
  var eleLink = document.createElement("a");
  eleLink.download = filename;
  eleLink.style.display = "none";
  eleLink.href = href;
  document.body.appendChild(eleLink);
  eleLink.click();
  document.body.removeChild(eleLink);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G = GsRGB / 12.92;
    else
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B = BsRGB / 12.92;
    else
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h3 = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h3 + ", " + s + "%, " + v + "%)" : "hsva(" + h3 + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h3 = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h3 + ", " + s + "%, " + l + "%)" : "hsla(" + h3 + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h3, s, l = (max + min) / 2;
  if (max == min) {
    h3 = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h3 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h3 = (b - r) / d + 2;
        break;
      case b:
        h3 = (r - g) / d + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s,
    l
  };
}
function hslToRgb(h3, s, l) {
  var r, g, b;
  h3 = bound01(h3, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h3 + 1 / 3);
    g = hue2rgb(p, q, h3);
    b = hue2rgb(p, q, h3 - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h3, s, v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h3 = 0;
  } else {
    switch (max) {
      case r:
        h3 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h3 = (b - r) / d + 2;
        break;
      case b:
        h3 = (r - g) / d + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s,
    v
  };
}
function hsvToRgb(h3, s, v) {
  h3 = bound01(h3, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h3), f = h3 - i, p = v * (1 - s), q = v * (1 - f * s), t2 = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t2, v][mod], g = [t2, v, v, q, p, p][mod], b = [p, p, t2, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h3 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h3 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h3 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h3 = hsv.h, s = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h3,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n, max) {
  if (isOnePointZero(n))
    n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h3) {
  return parseIntFromHex(h3) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
var lodash = { exports: {} };
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
    var htmlUnescapes = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" };
    var stringEscapes = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty3.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
        * Used to detect `data` property values to be HTML-escaped.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "escape": reEscape,
        /**
        * Used to detect code to be evaluated.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "evaluate": reEvaluate,
        /**
        * Used to detect `data` property values to inject.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "interpolate": reInterpolate,
        /**
        * Used to reference the data object in the template text.
        *
        * @memberOf _.templateSettings
        * @type {string}
        */
        "variable": "",
        /**
        * Used to import variables into the compiled template.
        *
        * @memberOf _.templateSettings
        * @type {Object}
        */
        "imports": {
          /**
          * A reference to the `lodash` function.
          *
          * @memberOf _.templateSettings.imports
          * @type {Function}
          */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty3.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty3.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, { "configurable": true, "enumerable": true, "value": value, "writable": true });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty3.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty3.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", { "configurable": true, "enumerable": false, "value": constant(string), "writable": true });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function predicate2(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData2(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData2(func);
        var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData2 = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty3.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty3.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function getTag2(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData2(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill2(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function interceptor2(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({ "func": thru, "args": [reverse], "thisArg": undefined$1 });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function memoized2() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized2.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized2.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, { "leading": leading, "maxWait": wait, "trailing": trailing });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep2(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty3.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty3.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty3.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty3.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty3.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum3(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill2;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep2;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber;
      lodash2.isObject = isObject;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum3;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty3.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({ "size": nativeMin(n, MAX_ARRAY_LENGTH), "type": methodName + (result2.__dir__ < 0 ? "Right" : "") });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({ "iteratee": getIteratee(iteratee2, 3), "type": type });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function interceptor2(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty3.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{ "name": "wrapper", "func": undefined$1 }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
function HexToRgb(str) {
  str = str.replace("#", "");
  var hxs = str.match(/../g);
  for (var i = 0; i < 3; i++)
    hxs[i] = parseInt(hxs[i], 16);
  return hxs;
}
function RgbToHex(a, b, c) {
  var hexs = [a.toString(16), b.toString(16), c.toString(16)];
  for (var i = 0; i < 3; i++)
    if (hexs[i].length == 1)
      hexs[i] = "0" + hexs[i];
  return "#" + hexs.join("");
}
function getDarkColor(color, level) {
  var rgbc = HexToRgb(color);
  for (var i = 0; i < 3; i++)
    rgbc[i] = Math.floor(rgbc[i] * (1 - level));
  return RgbToHex(rgbc[0], rgbc[1], rgbc[2]);
}
function getLightColor(color, level) {
  var rgbc = HexToRgb(color);
  for (var i = 0; i < 3; i++)
    rgbc[i] = Math.floor((255 - rgbc[i]) * level + rgbc[i]);
  return RgbToHex(rgbc[0], rgbc[1], rgbc[2]);
}
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h3 = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
      ordinal: function ordinal(t3) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
        return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      }
    }, m = function m2(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = {
      s: m,
      z: function z(t3) {
        var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      },
      m: function t3(e2, n2) {
        if (e2.date() < n2.date())
          return -t3(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      },
      a: function a2(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      },
      p: function p2(t3) {
        return {
          M: c,
          y: h3,
          w: o,
          d: a,
          D: d,
          h: u,
          m: s,
          s: i,
          ms: r,
          Q: f
        }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      },
      u: function u2(t3) {
        return void 0 === t3;
      }
    }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function S2(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w = function t3(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t3(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function O2(t3, e2) {
      if (S(t3))
        return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t3, e2) {
      return O(t3, {
        locale: e2.$L,
        utc: e2.$u,
        x: e2.$x,
        $offset: e2.$offset
      });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2)
            return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2))
            return /* @__PURE__ */ new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e2) {
        var n2 = O(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return O(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < O(t3);
      }, m2.$g = function(t3, e2, n2) {
        return b.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function l3(t4, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $3 = function $4(t4, e3) {
          return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h3:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $3(v2 + "Hours", 0);
          case u:
            return $3(v2 + "Minutes", 1);
          case s:
            return $3(v2 + "Seconds", 2);
          case i:
            return $3(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h3] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h3) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[b.p(t3)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $3 = b.p(f2), y2 = function y3(t3) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($3 === c)
          return this.set(c, this.$M + r2);
        if ($3 === h3)
          return this.set(h3, this.$y + r2);
        if ($3 === a)
          return y2(1);
        if ($3 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t2, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h4 = function h5(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function d3(t4) {
          return b.s(s2 % 12 || 12, t4, "0");
        }, $3 = f2 || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h4(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h4(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h4(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h4(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $3(s2, u2, true);
              case "A":
                return $3(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $3, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function D3() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h3:
            $3 = D2() / 12;
            break;
          case c:
            $3 = D2();
            break;
          case f:
            $3 = D2() / 3;
            break;
          case o:
            $3 = (g2 - v2) / 6048e5;
            break;
          case a:
            $3 = (g2 - v2) / 864e5;
            break;
          case u:
            $3 = g2 / n;
            break;
          case s:
            $3 = g2 / e;
            break;
          case i:
            $3 = g2 / t2;
            break;
          default:
            $3 = g2;
        }
        return l2 ? $3 : b.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = w(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h3], ["$D", d]].forEach(function(t3) {
      k[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.18.5";
var current_ansi = 1252;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var CS2CP = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
};
var set_ansi = function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1)
    return;
  current_ansi = CS2CP[0] = cp;
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(cp) {
  set_ansi(cp);
};
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
function char_codes(data) {
  var o = [];
  for (var i = 0, len = data.length; i < len; ++i)
    o[i] = data.charCodeAt(i);
  return o;
}
function utf16leread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i)
    o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
  return o.join("");
}
function utf16beread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i)
    o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
  return o.join("");
}
var debom = function(data) {
  var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
  if (c1 == 255 && c2 == 254)
    return utf16leread(data.slice(2));
  if (c1 == 254 && c2 == 255)
    return utf16beread(data.slice(2));
  if (c1 == 65279)
    return data.slice(1);
  return data;
};
var _getchar = function _gc1(x) {
  return String.fromCharCode(x);
};
var _getansi = function _ga1(x) {
  return String.fromCharCode(x);
};
var $cptable;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i = 0; i < input.length; ) {
    c1 = input.charCodeAt(i++);
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i++);
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i++);
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o;
}
function Base64_decode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  input = input.replace(/[^\w\+\/\=]/g, "");
  for (var i = 0; i < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i++));
    e2 = Base64_map.indexOf(input.charAt(i++));
    c1 = e1 << 2 | e2 >> 4;
    o += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i++));
    c2 = (e2 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o += String.fromCharCode(c2);
    }
    e4 = Base64_map.indexOf(input.charAt(i++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o += String.fromCharCode(c3);
    }
  }
  return o;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
}();
var Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs)
      try {
        Buffer.from("foo", "utf8");
      } catch (e) {
        nbfs = true;
      }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function new_raw_buf(len) {
  if (has_buf)
    return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
function new_unsafe_buf(len) {
  if (has_buf)
    return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
var s2a = function s2a2(s) {
  if (has_buf)
    return Buffer_from(s, "binary");
  return s.split("").map(function(x) {
    return x.charCodeAt(0) & 255;
  });
};
function s2ab(s) {
  if (typeof ArrayBuffer === "undefined")
    return s2a(s);
  var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
  for (var i = 0; i != s.length; ++i)
    view[i] = s.charCodeAt(i) & 255;
  return buf;
}
function a2s(data) {
  if (Array.isArray(data))
    return data.map(function(c) {
      return String.fromCharCode(c);
    }).join("");
  var o = [];
  for (var i = 0; i < data.length; ++i)
    o[i] = String.fromCharCode(data[i]);
  return o.join("");
}
function a2u(data) {
  if (typeof Uint8Array === "undefined")
    throw new Error("Unsupported");
  return new Uint8Array(data);
}
function ab2a(data) {
  if (typeof ArrayBuffer == "undefined")
    throw new Error("Unsupported");
  if (data instanceof ArrayBuffer)
    return ab2a(new Uint8Array(data));
  var o = new Array(data.length);
  for (var i = 0; i < data.length; ++i)
    o[i] = data[i];
  return o;
}
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i = 0, maxlen = 0;
    for (i = 0; i < bufs.length; ++i)
      maxlen += bufs[i].length;
    var o = new Uint8Array(maxlen);
    var len = 0;
    for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
      len = bufs[i].length;
      if (bufs[i] instanceof Uint8Array)
        o.set(bufs[i], maxlen);
      else if (typeof bufs[i] == "string") {
        throw "wtf";
      } else
        o.set(new Uint8Array(bufs[i]), maxlen);
    }
    return o;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content) {
  var out = [], widx = 0, L = content.length + 250;
  var o = new_raw_buf(content.length + 255);
  for (var ridx = 0; ridx < content.length; ++ridx) {
    var c = content.charCodeAt(ridx);
    if (c < 128)
      o[widx++] = c;
    else if (c < 2048) {
      o[widx++] = 192 | c >> 6 & 31;
      o[widx++] = 128 | c & 63;
    } else if (c >= 55296 && c < 57344) {
      c = (c & 1023) + 64;
      var d = content.charCodeAt(++ridx) & 1023;
      o[widx++] = 240 | c >> 8 & 7;
      o[widx++] = 128 | c >> 2 & 63;
      o[widx++] = 128 | d >> 6 & 15 | (c & 3) << 4;
      o[widx++] = 128 | d & 63;
    } else {
      o[widx++] = 224 | c >> 12 & 15;
      o[widx++] = 128 | c >> 6 & 63;
      o[widx++] = 128 | c & 63;
    }
    if (widx > L) {
      out.push(o.slice(0, widx));
      widx = 0;
      o = new_raw_buf(65535);
      L = 65530;
    }
  }
  out.push(o.slice(0, widx));
  return bconcat(out);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x) {
  var o = "", i = x.length - 1;
  while (i >= 0)
    o += x.charAt(i--);
  return o;
}
function pad0(v, d) {
  var t2 = "" + v;
  return t2.length >= d ? t2 : fill("0", d - t2.length) + t2;
}
function pad_(v, d) {
  var t2 = "" + v;
  return t2.length >= d ? t2 : fill(" ", d - t2.length) + t2;
}
function rpad_(v, d) {
  var t2 = "" + v;
  return t2.length >= d ? t2 : t2 + fill(" ", d - t2.length);
}
function pad0r1(v, d) {
  var t2 = "" + Math.round(v);
  return t2.length >= d ? t2 : fill("0", d - t2.length) + t2;
}
function pad0r2(v, d) {
  var t2 = "" + v;
  return t2.length >= d ? t2 : fill("0", d - t2.length) + t2;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v, d) {
  if (v > p2_32 || v < -p2_32)
    return pad0r1(v, d);
  var i = Math.round(v);
  return pad0r2(i, d);
}
function SSF_isgeneral(s, i) {
  i = i || 0;
  return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t2) {
  if (!t2)
    t2 = {};
  t2[0] = "General";
  t2[1] = "0";
  t2[2] = "0.00";
  t2[3] = "#,##0";
  t2[4] = "#,##0.00";
  t2[9] = "0%";
  t2[10] = "0.00%";
  t2[11] = "0.00E+00";
  t2[12] = "# ?/?";
  t2[13] = "# ??/??";
  t2[14] = "m/d/yy";
  t2[15] = "d-mmm-yy";
  t2[16] = "d-mmm";
  t2[17] = "mmm-yy";
  t2[18] = "h:mm AM/PM";
  t2[19] = "h:mm:ss AM/PM";
  t2[20] = "h:mm";
  t2[21] = "h:mm:ss";
  t2[22] = "m/d/yy h:mm";
  t2[37] = "#,##0 ;(#,##0)";
  t2[38] = "#,##0 ;[Red](#,##0)";
  t2[39] = "#,##0.00;(#,##0.00)";
  t2[40] = "#,##0.00;[Red](#,##0.00)";
  t2[45] = "mm:ss";
  t2[46] = "[h]:mm:ss";
  t2[47] = "mmss.0";
  t2[48] = "##0.0E+0";
  t2[49] = "@";
  t2[56] = '"/ "hh""mm""ss" "';
  return t2;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"/ "hh""mm""ss" "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x, D, mixed) {
  var sgn = x < 0 ? -1 : 1;
  var B = x * sgn;
  var P_2 = 0, P_1 = 1, P = 0;
  var Q_2 = 1, Q_1 = 0, Q = 0;
  var A = Math.floor(B);
  while (Q_1 < D) {
    A = Math.floor(B);
    P = A * P_1 + P_2;
    Q = A * Q_1 + Q_2;
    if (B - A < 5e-8)
      break;
    B = 1 / (B - A);
    P_2 = P_1;
    P_1 = P;
    Q_2 = Q_1;
    Q_1 = Q;
  }
  if (Q > D) {
    if (Q_1 > D) {
      Q = Q_2;
      P = P_2;
    } else {
      Q = Q_1;
      P = P_1;
    }
  }
  if (!mixed)
    return [0, sgn * P, Q];
  var q = Math.floor(sgn * P / Q);
  return [q, sgn * P - q * Q, Q];
}
function SSF_parse_date_code(v, opts, b2) {
  if (v > 2958465 || v < 0)
    return null;
  var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6)
    out.u = 0;
  if (opts && opts.date1904)
    date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time == 86400) {
      out.T = time = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60)
      --date;
    var d = new Date(1900, 0, 1);
    d.setDate(d.getDate() + date - 1);
    dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
    dow = d.getDay();
    if (date < 60)
      dow = (dow + 6) % 7;
    if (b2)
      dow = SSF_fix_hijri(d, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time % 60;
  time = Math.floor(time / 60);
  out.M = time % 60;
  time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function datenum_local(v, date1904) {
  var epoch = /* @__PURE__ */ v.getTime();
  if (date1904)
    epoch -= 1461 * 24 * 60 * 60 * 1e3;
  else if (v >= SSFbase1904)
    epoch += 24 * 60 * 60 * 1e3;
  return (epoch - (SSFdnthresh + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function SSF_strip_decimal(o) {
  return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(o) {
  if (o.indexOf("E") == -1)
    return o;
  return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(v) {
  var w = v < 0 ? 12 : 11;
  var o = SSF_strip_decimal(v.toFixed(12));
  if (o.length <= w)
    return o;
  o = v.toPrecision(10);
  if (o.length <= w)
    return o;
  return v.toExponential(5);
}
function SSF_large_exp(v) {
  var o = SSF_strip_decimal(v.toFixed(11));
  return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
}
function SSF_general_num(v) {
  var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
  if (V >= -4 && V <= -1)
    o = v.toPrecision(10 + V);
  else if (Math.abs(V) <= 9)
    o = SSF_small_exp(v);
  else if (V === 10)
    o = v.toFixed(10).substr(0, 12);
  else
    o = SSF_large_exp(v);
  return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
}
function SSF_general(v, opts) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "TRUE" : "FALSE";
    case "number":
      return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
    case "undefined":
      return "";
    case "object":
      if (v == null)
        return "";
      if (v instanceof Date)
        return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v);
}
function SSF_fix_hijri(date, o) {
  o[0] -= 581;
  var dow = date.getDay();
  if (date < 60)
    dow = (dow + 6) % 7;
  return dow;
}
function SSF_write_date(type, fmt, val, ss0) {
  var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y = val.y + 543;
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y % 100;
          outl = 2;
          break;
        default:
          out = y % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000")
        throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss"))
        return pad0(val.S, fmt.length);
      if (ss0 >= 2)
        tt = ss0 === 3 ? 1e3 : 100;
      else
        tt = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt * (val.S + val.u));
      if (ss >= 60 * tt)
        ss = 0;
      if (fmt === "s")
        return ss === 0 ? "0" : "" + ss / tt;
      o = pad0(ss, 2 + ss0);
      if (fmt === "ss")
        return o.substr(0, 2);
      return "." + o.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
function commaify(s) {
  var w = 3;
  if (s.length <= w)
    return s;
  var j = s.length % w, o = s.substr(0, j);
  for (; j != s.length; j += w)
    o += (o.length > 0 ? "," : "") + s.substr(j, w);
  return o;
}
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_exp(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee < 0)
      ee += period;
    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
    if (o.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1)
        o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
      else
        o += "E+" + (fakee - ee);
      while (o.substr(0, 2) === "0.") {
        o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
        o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
    });
  } else
    o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
    o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/))
    o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign) {
  var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
}
function write_num_f2(r, aval, sign) {
  return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
}
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o = "", cc;
  for (var i = 0; i != str.length; ++i)
    switch (cc = str.charCodeAt(i)) {
      case 35:
        break;
      case 63:
        o += " ";
        break;
      case 48:
        o += "0";
        break;
      default:
        o += String.fromCharCode(cc);
    }
  return o;
}
function rnd(val, d) {
  var dd = Math.pow(10, d);
  return "" + Math.round(val * dd) / dd;
}
function dec(val, d) {
  var _frac = val - Math.floor(val), dd = Math.pow(10, d);
  if (d < ("" + Math.round(_frac * dd)).length)
    return 0;
  return Math.round(_frac * dd);
}
function carry(val, d) {
  if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
    return 1;
  }
  return 0;
}
function flr(val) {
  if (val < 2147483647 && val > -2147483648)
    return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = pad0r(val, 0);
    if (o === "0")
      o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1))
    return write_num_f1(r, aval, sign);
  if (fmt.match(/^#+0+$/))
    return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign + commaify(pad0r(aval, 0));
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_flt(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = pad0r(val, 0);
    if (fmt.length <= o.length)
      return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri = dec(val, r[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri, r[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify(pad0r(aval, 0));
      return x !== "0" ? sign + x : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_exp2(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee < 0)
      ee += period;
    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
    if (!o.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1)
        o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
      else
        o += "E+" + (fakee - ee);
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
    });
  } else
    o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
    o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/))
    o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = "" + val;
    if (val === 0)
      o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1))
    return write_num_f2(r, aval, sign);
  if (fmt.match(/^#+0+$/))
    return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
    o = o.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign + commaify("" + aval);
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_int(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = "" + val;
    if (fmt.length <= o.length)
      return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify("" + aval);
      return x !== "0" ? sign + x : "";
    default:
      if (fmt.match(/\.[0#?]*$/))
        return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i = 0, j = 0; i < fmt.length; ++i)
    switch (
      /*cc=*/
      fmt.charCodeAt(i)
    ) {
      case 34:
        in_str = !in_str;
        break;
      case 95:
      case 42:
      case 92:
        ++i;
        break;
      case 59:
        out[out.length] = fmt.substr(j, i - j);
        j = i + 1;
    }
  out[out.length] = fmt.substr(j);
  if (in_str === true)
    throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i = 0, c = "", o = "";
  while (i < fmt.length) {
    switch (c = fmt.charAt(i)) {
      case "G":
        if (SSF_isgeneral(fmt, i))
          i += 6;
        i++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i) !== 34 && i < fmt.length;
        ) {
        }
        ++i;
        break;
      case "\\":
        i += 2;
        break;
      case "_":
        i += 2;
        break;
      case "@":
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2")
          return true;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "":
        if (fmt.substr(i, 3).toUpperCase() === "A/P")
          return true;
        if (fmt.substr(i, 5).toUpperCase() === "AM/PM")
          return true;
        if (fmt.substr(i, 5).toUpperCase() === "/")
          return true;
        ++i;
        break;
      case "[":
        o = c;
        while (fmt.charAt(i++) !== "]" && i < fmt.length)
          o += fmt.charAt(i);
        if (o.match(SSF_abstime))
          return true;
        break;
      case ".":
      case "0":
      case "#":
        while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i) === c) {
        }
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
          ++i;
        break;
      case "(":
      case ")":
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
        }
        break;
      case " ":
        ++i;
        break;
      default:
        ++i;
        break;
    }
  }
  return false;
}
function eval_fmt(fmt, v, opts, flen) {
  var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
  var hr = "H";
  while (i < fmt.length) {
    switch (c = fmt.charAt(i)) {
      case "G":
        if (!SSF_isgeneral(fmt, i))
          throw new Error("unrecognized character " + c + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i += 7;
        break;
      case '"':
        for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; )
          o += String.fromCharCode(cc);
        out[out.length] = { t: "t", v: o };
        ++i;
        break;
      case "\\":
        var w = fmt.charAt(++i), t2 = w === "(" || w === ")" ? w : "t";
        out[out.length] = { t: t2, v: w };
        ++i;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v };
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
            if (dt == null)
              return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i, 2) };
          lst = c;
          i += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c = c.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v < 0)
          return "";
        if (dt == null) {
          dt = SSF_parse_date_code(v, opts);
          if (dt == null)
            return "";
        }
        o = c;
        while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c)
          o += c;
        if (c === "m" && lst.toLowerCase() === "h")
          c = "M";
        if (c === "h")
          c = hr;
        out[out.length] = { t: c, v: o };
        lst = c;
        break;
      case "A":
      case "a":
      case "":
        var q = { t: c, v: c };
        if (dt == null)
          dt = SSF_parse_date_code(v, opts);
        if (fmt.substr(i, 3).toUpperCase() === "A/P") {
          if (dt != null)
            q.v = dt.H >= 12 ? "P" : "A";
          q.t = "T";
          hr = "h";
          i += 3;
        } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
          if (dt != null)
            q.v = dt.H >= 12 ? "PM" : "AM";
          q.t = "T";
          i += 5;
          hr = "h";
        } else if (fmt.substr(i, 5).toUpperCase() === "/") {
          if (dt != null)
            q.v = dt.H >= 12 ? "" : "";
          q.t = "T";
          i += 5;
          hr = "h";
        } else {
          q.t = "t";
          ++i;
        }
        if (dt == null && q.t === "T")
          return "";
        out[out.length] = q;
        lst = c;
        break;
      case "[":
        o = c;
        while (fmt.charAt(i++) !== "]" && i < fmt.length)
          o += fmt.charAt(i);
        if (o.slice(-1) !== "]")
          throw 'unterminated "[" block: |' + o + "|";
        if (o.match(SSF_abstime)) {
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts);
            if (dt == null)
              return "";
          }
          out[out.length] = { t: "Z", v: o.toLowerCase() };
          lst = o.charAt(1);
        } else if (o.indexOf("$") > -1) {
          o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt))
            out[out.length] = { t: "t", v: o };
        }
        break;
      case ".":
        if (dt != null) {
          o = c;
          while (++i < fmt.length && (c = fmt.charAt(i)) === "0")
            o += c;
          out[out.length] = { t: "s", v: o };
          break;
        }
      case "0":
      case "#":
        o = c;
        while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1)
          o += c;
        out[out.length] = { t: "n", v: o };
        break;
      case "?":
        o = c;
        while (fmt.charAt(++i) === c)
          o += c;
        out[out.length] = { t: c, v: o };
        lst = c;
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
          ++i;
        break;
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c, v: c };
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o = c;
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1)
          o += fmt.charAt(i);
        out[out.length] = { t: "D", v: o };
        break;
      case " ":
        out[out.length] = { t: c, v: c };
        ++i;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i;
        break;
      default:
        if (",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(c) === -1)
          throw new Error("unrecognized character " + c + " in " + fmt);
        out[out.length] = { t: "t", v: c };
        ++i;
        break;
    }
  }
  var bt = 0, ss0 = 0, ssm;
  for (i = out.length - 1, lst = "t"; i >= 0; --i) {
    switch (out[i].t) {
      case "h":
      case "H":
        out[i].t = hr;
        lst = "h";
        if (bt < 1)
          bt = 1;
        break;
      case "s":
        if (ssm = out[i].v.match(/\.0+$/))
          ss0 = Math.max(ss0, ssm[0].length - 1);
        if (bt < 3)
          bt = 3;
      case "d":
      case "y":
      case "M":
      case "e":
        lst = out[i].t;
        break;
      case "m":
        if (lst === "s") {
          out[i].t = "M";
          if (bt < 2)
            bt = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt < 1 && out[i].v.match(/[Hh]/))
          bt = 1;
        if (bt < 2 && out[i].v.match(/[Mm]/))
          bt = 2;
        if (bt < 3 && out[i].v.match(/[Ss]/))
          bt = 3;
    }
  }
  switch (bt) {
    case 0:
      break;
    case 1:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      if (dt.M >= 60) {
        dt.M = 0;
        ++dt.H;
      }
      break;
    case 2:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      break;
  }
  var nstr = "", jj;
  for (i = 0; i < out.length; ++i) {
    switch (out[i].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i].v = "";
        out[i].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
        out[i].t = "t";
        break;
      case "n":
      case "?":
        jj = i + 1;
        while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
          out[i].v += out[jj].v;
          out[jj] = { v: "", t: ";" };
          ++jj;
        }
        nstr += out[i].v;
        i = jj - 1;
        break;
      case "G":
        out[i].t = "t";
        out[i].v = SSF_general(v, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v < 0 && flen > 1 ? -v : v;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj = ostr.length - 1;
    var decpt = out.length;
    for (i = 0; i < out.length; ++i)
      if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
        decpt = i;
        break;
      }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i = out.length - 1; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1)
          continue;
        if (jj >= out[i].v.length - 1) {
          jj -= out[i].v.length;
          out[i].v = ostr.substr(jj + 1, out[i].v.length);
        } else if (jj < 0)
          out[i].v = "";
        else {
          out[i].v = ostr.substr(0, jj + 1);
          jj = -1;
        }
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj = ostr.indexOf(".") - 1;
      for (i = decpt; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1)
          continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
        vv = out[i].v.substr(j + 1);
        for (; j >= 0; --j) {
          if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#"))
            vv = ostr.charAt(jj--) + vv;
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      jj = ostr.indexOf(".") + 1;
      for (i = decpt; i < out.length; ++i) {
        if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt)
          continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
        vv = out[i].v.substr(0, j);
        for (; j < out[i].v.length; ++j) {
          if (jj < ostr.length)
            vv += ostr.charAt(jj++);
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
    }
  }
  for (i = 0; i < out.length; ++i)
    if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
      myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
      out[i].v = write_num(out[i].t, out[i].v, myv);
      out[i].t = "t";
    }
  var retval = "";
  for (i = 0; i !== out.length; ++i)
    if (out[i] != null)
      retval += out[i].v;
  return retval;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v, rr) {
  if (rr == null)
    return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v == thresh)
        return true;
      break;
    case ">":
      if (v > thresh)
        return true;
      break;
    case "<":
      if (v < thresh)
        return true;
      break;
    case "<>":
      if (v != thresh)
        return true;
      break;
    case ">=":
      if (v >= thresh)
        return true;
      break;
    case "<=":
      if (v <= thresh)
        return true;
      break;
  }
  return false;
}
function choose_fmt(f, v) {
  var fmt = SSF_split_fmt(f);
  var l = fmt.length, lat = fmt[l - 1].indexOf("@");
  if (l < 4 && lat > -1)
    --l;
  if (fmt.length > 4)
    throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v !== "number")
    return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
    return [l, ff];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m2 = fmt[1].match(cfregex2);
    return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
  }
  return [l, ff];
}
function SSF_format(fmt, v, o) {
  if (o == null)
    o = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o.dateNF)
        sfmt = o.dateNF;
      else
        sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o.dateNF)
        sfmt = o.dateNF;
      else
        sfmt = (o.table != null ? o.table : table_fmt)[fmt];
      if (sfmt == null)
        sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null)
        sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0))
    return SSF_general(v, o);
  if (v instanceof Date)
    v = datenum_local(v, o.date1904);
  var f = choose_fmt(sfmt, v);
  if (SSF_isgeneral(f[1]))
    return SSF_general(v, o);
  if (v === true)
    v = "TRUE";
  else if (v === false)
    v = "FALSE";
  else if (v === "" || v == null)
    return "";
  return eval_fmt(f[1], v, o, f[0]);
}
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i = 0; i < 392; ++i) {
      if (table_fmt[i] == void 0) {
        if (idx < 0)
          idx = i;
        continue;
      }
      if (table_fmt[i] == fmt) {
        idx = i;
        break;
      }
    }
    if (idx < 0)
      idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
function SSF_load_table(tbl) {
  for (var i = 0; i != 392; ++i)
    if (tbl[i] !== void 0)
      SSF_load(tbl[i], i);
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSFImplicit = {
  "5": '"$"#,##0_);\\("$"#,##0\\)',
  "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "23": "General",
  "24": "General",
  "25": "General",
  "26": "General",
  "27": "m/d/yy",
  "28": "m/d/yy",
  "29": "m/d/yy",
  "30": "m/d/yy",
  "31": "m/d/yy",
  "32": "h:mm:ss",
  "33": "h:mm:ss",
  "34": "h:mm:ss",
  "35": "h:mm:ss",
  "36": "m/d/yy",
  "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  "50": "m/d/yy",
  "51": "m/d/yy",
  "52": "m/d/yy",
  "53": "m/d/yy",
  "54": "m/d/yy",
  "55": "m/d/yy",
  "56": "m/d/yy",
  "57": "m/d/yy",
  "58": "m/d/yy",
  "59": "0",
  "60": "0.00",
  "61": "#,##0",
  "62": "#,##0.00",
  "63": '"$"#,##0_);\\("$"#,##0\\)',
  "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "67": "0%",
  "68": "0.00%",
  "69": "# ?/?",
  "70": "# ??/??",
  "71": "m/d/yy",
  "72": "m/d/yy",
  "73": "d-mmm-yy",
  "74": "d-mmm",
  "75": "mmm-yy",
  "76": "h:mm",
  "77": "h:mm:ss",
  "78": "m/d/yy h:mm",
  "79": "mm:ss",
  "80": "[h]:mm:ss",
  "81": "mmss.0"
};
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  return new RegExp("^" + fmt + "$");
}
function dateNF_fix(str, dateNF, match) {
  var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
    var v = parseInt(match[i + 1], 10);
    switch (n.toLowerCase().charAt(0)) {
      case "y":
        Y = v;
        break;
      case "d":
        d = v;
        break;
      case "h":
        H = v;
        break;
      case "s":
        S = v;
        break;
      case "m":
        if (H >= 0)
          M = v;
        else
          m = v;
        break;
    }
  });
  if (S >= 0 && M == -1 && m >= 0) {
    M = m;
    m = -1;
  }
  var datestr = ("" + (Y >= 0 ? Y : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
  if (datestr.length == 7)
    datestr = "0" + datestr;
  if (datestr.length == 8)
    datestr = "20" + datestr;
  var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
  if (H == -1 && M == -1 && S == -1)
    return datestr;
  if (Y == -1 && m == -1 && d == -1)
    return timestr;
  return datestr + "T" + timestr;
}
var CRC32 = /* @__PURE__ */ function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c = 0, table = new Array(256);
    for (var n = 0; n != 256; ++n) {
      c = n;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      table[n] = c;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  var T0 = signed_crc_table();
  function slice_by_16_tables(T) {
    var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n = 0; n != 256; ++n)
      table[n] = T[n];
    for (n = 0; n != 256; ++n) {
      v = T[n];
      for (c = 256 + n; c < 4096; c += 256)
        v = table[c] = v >>> 8 ^ T[v & 255];
    }
    var out = [];
    for (n = 1; n != 16; ++n)
      out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
    return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
    var C = seed ^ -1;
    for (var i = 0, L = bstr.length; i < L; )
      C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
    return ~C;
  }
  function crc32_buf(B, seed) {
    var C = seed ^ -1, L = B.length - 15, i = 0;
    for (; i < L; )
      C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
    L += 15;
    while (i < L)
      C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
    return ~C;
  }
  function crc32_str(str, seed) {
    var C = seed ^ -1;
    for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
      c = str.charCodeAt(i++);
      if (c < 128) {
        C = C >>> 8 ^ T0[(C ^ c) & 255];
      } else if (c < 2048) {
        C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
      } else if (c >= 55296 && c < 57344) {
        c = (c & 1023) + 64;
        d = str.charCodeAt(i++) & 1023;
        C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
      } else {
        C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
      }
    }
    return ~C;
  }
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
}();
var CFB = /* @__PURE__ */ function _CFB() {
  var exports = {};
  exports.version = "1.2.1";
  function namecmp(l, r) {
    var L = l.split("/"), R = r.split("/");
    for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
      if (c = L[i2].length - R[i2].length)
        return c;
      if (L[i2] != R[i2])
        return L[i2] < R[i2] ? -1 : 1;
    }
    return L.length - R.length;
  }
  function dirname(p) {
    if (p.charAt(p.length - 1) == "/")
      return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
    var c = p.lastIndexOf("/");
    return c === -1 ? p : p.slice(0, c + 1);
  }
  function filename(p) {
    if (p.charAt(p.length - 1) == "/")
      return filename(p.slice(0, -1));
    var c = p.lastIndexOf("/");
    return c === -1 ? p : p.slice(c + 1);
  }
  function write_dos_date(buf, date) {
    if (typeof date === "string")
      date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d = ymd & 31;
    ymd >>>= 5;
    var m = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m - 1);
    val.setDate(d);
    var S = hms & 31;
    hms >>>= 5;
    var M = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M);
    val.setSeconds(S << 1);
    return val;
  }
  function parse_extra_field(blob) {
    prep_blob(blob, 0);
    var o = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob.l <= blob.length - 4) {
      var type = blob.read_shift(2);
      var sz = blob.read_shift(2), tgt = blob.l + sz;
      var p = {};
      switch (type) {
        case 21589:
          {
            flags = blob.read_shift(1);
            if (flags & 1)
              p.mtime = blob.read_shift(4);
            if (sz > 5) {
              if (flags & 2)
                p.atime = blob.read_shift(4);
              if (flags & 4)
                p.ctime = blob.read_shift(4);
            }
            if (p.mtime)
              p.mt = new Date(p.mtime * 1e3);
          }
          break;
      }
      blob.l = tgt;
      o[type] = p;
    }
    return o;
  }
  var fs;
  function get_fs() {
    return fs || (fs = {});
  }
  function parse(file, options) {
    if (file[0] == 80 && file[1] == 75)
      return parse_zip2(file, options);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
      return parse_mad(file, options);
    if (file.length < 512)
      throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob, 0);
    var mv = check_get_mver(blob);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0)
          return parse_zip2(file, options);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob, mver);
    var dir_cnt = blob.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0)
      throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob.l += 4;
    dir_start = blob.read_shift(4, "i");
    blob.l += 4;
    blob.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob.read_shift(4, "i");
    nmfs = blob.read_shift(4, "i");
    difat_start = blob.read_shift(4, "i");
    difat_sec_cnt = blob.read_shift(4, "i");
    for (var q2 = -1, j = 0; j < 109; ++j) {
      q2 = blob.read_shift(4, "i");
      if (q2 < 0)
        break;
      fat_addrs[j] = q2;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
      sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o = {
      FileIndex,
      FullPaths
    };
    if (options && options.raw)
      o.raw = { header, sectors };
    return o;
  }
  function check_get_mver(blob) {
    if (blob[blob.l] == 80 && blob[blob.l + 1] == 75)
      return [0, 0];
    blob.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob.l += 16;
    var mver = blob.read_shift(2, "u");
    return [blob.read_shift(2, "u"), mver];
  }
  function check_shifts(blob, mver) {
    var shift = 9;
    blob.l += 2;
    switch (shift = blob.read_shift(2)) {
      case 9:
        if (mver != 3)
          throw new Error("Sector Shift: Expected 9 saw " + shift);
        break;
      case 12:
        if (mver != 4)
          throw new Error("Sector Shift: Expected 12 saw " + shift);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
    }
    blob.chk("0600", "Mini Sector Shift: ");
    blob.chk("000000000000", "Reserved: ");
  }
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i2 = 1; i2 < nsectors; ++i2)
      sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  function build_full_paths(FI, FP, Paths) {
    var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
    var dad = [], q2 = [];
    for (; i2 < pl; ++i2) {
      dad[i2] = q2[i2] = i2;
      FP[i2] = Paths[i2];
    }
    for (; j < q2.length; ++j) {
      i2 = q2[j];
      L = FI[i2].L;
      R = FI[i2].R;
      C = FI[i2].C;
      if (dad[i2] === i2) {
        if (L !== -1 && dad[L] !== L)
          dad[i2] = dad[L];
        if (R !== -1 && dad[R] !== R)
          dad[i2] = dad[R];
      }
      if (C !== -1)
        dad[C] = i2;
      if (L !== -1 && i2 != dad[i2]) {
        dad[L] = dad[i2];
        if (q2.lastIndexOf(L) < j)
          q2.push(L);
      }
      if (R !== -1 && i2 != dad[i2]) {
        dad[R] = dad[i2];
        if (q2.lastIndexOf(R) < j)
          q2.push(R);
      }
    }
    for (i2 = 1; i2 < pl; ++i2)
      if (dad[i2] === i2) {
        if (R !== -1 && dad[R] !== R)
          dad[i2] = dad[R];
        else if (L !== -1 && dad[L] !== L)
          dad[i2] = dad[L];
      }
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type === 0)
        continue;
      j = i2;
      if (j != dad[j])
        do {
          j = dad[j];
          FP[i2] = FP[j] + "/" + FP[i2];
        } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
      dad[i2] = -1;
    }
    FP[0] += "/";
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type !== 2)
        FP[i2] += "/";
    }
  }
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size = entry.size;
    var o = [];
    var idx = start;
    while (mini && size > 0 && idx >= 0) {
      o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o.length === 0)
      return new_buf(0);
    return bconcat(o).slice(0, entry.size);
  }
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q2 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0)
        throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m = (ssz >>> 2) - 1;
      if (!sector)
        return;
      for (var i2 = 0; i2 < m; ++i2) {
        if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN)
          break;
        fat_addrs.push(q2);
      }
      sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd)
      chkd = [];
    var modulus = ssz - 1, j = 0, jj = 0;
    for (j = start; j >= 0; ) {
      chkd[j] = true;
      buf[buf.length] = j;
      buf_chain.push(sectors[j]);
      var addr = fat_addrs[Math.floor(j * 4 / ssz)];
      jj = j * 4 & modulus;
      if (ssz < 4 + jj)
        throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
      if (!sectors[addr])
        break;
      j = __readInt32LE(sectors[addr], jj);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
    for (i2 = 0; i2 < sl; ++i2) {
      buf = [];
      k = i2 + dir_start;
      if (k >= sl)
        k -= sl;
      if (chkd[k])
        continue;
      buf_chain = [];
      var seen = [];
      for (j = k; j >= 0; ) {
        seen[j] = true;
        chkd[j] = true;
        buf[buf.length] = j;
        buf_chain.push(sectors[j]);
        var addr = fat_addrs[Math.floor(j * 4 / ssz)];
        jj = j * 4 & modulus;
        if (ssz < 4 + jj)
          throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
        if (!sectors[addr])
          break;
        j = __readInt32LE(sectors[addr], jj);
        if (seen[j])
          break;
      }
      sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i2 = 0, namelen = 0, name;
    for (; i2 < sector.length; i2 += 128) {
      var blob = (
        /*::(*/
        sector.slice(i2, i2 + 128)
      );
      prep_blob(blob, 64);
      namelen = blob.read_shift(2);
      name = __utf16le(blob, 0, namelen - pl);
      Paths.push(name);
      var o = {
        name,
        type: blob.read_shift(1),
        color: blob.read_shift(1),
        L: blob.read_shift(4, "i"),
        R: blob.read_shift(4, "i"),
        C: blob.read_shift(4, "i"),
        clsid: blob.read_shift(16),
        state: blob.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (ctime !== 0)
        o.ct = read_date(blob, blob.l - 8);
      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (mtime !== 0)
        o.mt = read_date(blob, blob.l - 8);
      o.start = blob.read_shift(4, "i");
      o.size = blob.read_shift(4, "i");
      if (o.size < 0 && o.start < 0) {
        o.size = o.type = 0;
        o.start = ENDOFCHAIN;
        o.name = "";
      }
      if (o.type === 5) {
        minifat_store = o.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
          sector_list[minifat_store].name = "!StreamData";
      } else if (o.size >= 4096) {
        o.storage = "fat";
        if (sector_list[o.start] === void 0)
          sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o.start].name = o.name;
        o.content = sector_list[o.start].data.slice(0, o.size);
      } else {
        o.storage = "minifat";
        if (o.size < 0)
          o.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o.content)
        prep_blob(o.content, 0);
      files[name] = o;
      FileIndex.push(o);
    }
  }
  function read_date(blob, offset) {
    return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
  }
  function read_file(filename2, options) {
    get_fs();
    return parse(fs.readFileSync(filename2), options);
  }
  function read(blob, options) {
    var type = options && options.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob))
        type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob, options);
      case "base64":
        return parse(s2a(Base64_decode(blob)), options);
      case "binary":
        return parse(s2a(blob), options);
    }
    return parse(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob,
      options
    );
  }
  function init_cfb(cfb, opts) {
    var o = opts || {}, root = o.root || "Root Entry";
    if (!cfb.FullPaths)
      cfb.FullPaths = [];
    if (!cfb.FileIndex)
      cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length)
      throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root + "/";
      cfb.FileIndex[0] = { name: root, type: 5 };
    }
    if (o.CLSID)
      cfb.FileIndex[0].clsid = o.CLSID;
    seed_cfb(cfb);
  }
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm))
      return;
    var p = new_buf(4);
    p[0] = 55;
    p[1] = p[3] = 50;
    p[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb, f) {
    init_cfb(cfb);
    var gc = false, s = false;
    for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
      var _file = cfb.FileIndex[i2];
      switch (_file.type) {
        case 0:
          if (s)
            gc = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s = true;
          if (isNaN(_file.R * _file.L * _file.C))
            gc = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
            gc = true;
          break;
        default:
          gc = true;
          break;
      }
    }
    if (!gc && !f)
      return;
    var now = new Date(1987, 1, 19), j = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
      fullPaths[cfb.FullPaths[i2]] = true;
      if (cfb.FileIndex[i2].type === 0)
        continue;
      data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var dad = dirname(data[i2][0]);
      s = fullPaths[dad];
      if (!s) {
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now,
          mt: now,
          content: null
        }]);
        fullPaths[dad] = true;
      }
    }
    data.sort(function(x, y) {
      return namecmp(x[0], y[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i2 = 0; i2 < data.length; ++i2) {
      cfb.FullPaths[i2] = data[i2][0];
      cfb.FileIndex[i2] = data[i2][1];
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var elt = cfb.FileIndex[i2];
      var nm = cfb.FullPaths[i2];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i2 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j = i2 + 1; j < data.length; ++j)
          if (dirname(cfb.FullPaths[j]) == nm)
            break;
        elt.C = j >= data.length ? -1 : j;
        for (j = i2 + 1; j < data.length; ++j)
          if (dirname(cfb.FullPaths[j]) == dirname(nm))
            break;
        elt.R = j >= data.length ? -1 : j;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm))
          elt.R = i2 + 1;
        elt.type = 2;
      }
    }
  }
  function _write(cfb, options) {
    var _opts = options || {};
    if (_opts.fileType == "mad")
      return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip2(cfb, _opts);
    }
    var L = function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
        var file2 = cfb2.FileIndex[i3];
        if (!file2.content)
          continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096)
            mini_size += flen2 + 63 >> 6;
          else
            fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
        difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
      return L2;
    }(cfb);
    var o = new_buf(L[7] << 9);
    var i2 = 0, T = 0;
    {
      for (i2 = 0; i2 < 8; ++i2)
        o.write_shift(1, HEADER_SIG[i2]);
      for (i2 = 0; i2 < 8; ++i2)
        o.write_shift(2, 0);
      o.write_shift(2, 62);
      o.write_shift(2, 3);
      o.write_shift(2, 65534);
      o.write_shift(2, 9);
      o.write_shift(2, 6);
      for (i2 = 0; i2 < 3; ++i2)
        o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, L[2]);
      o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
      o.write_shift(4, 0);
      o.write_shift(4, 1 << 12);
      o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[3]);
      o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[1]);
      for (i2 = 0; i2 < 109; ++i2)
        o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
    }
    if (L[1]) {
      for (T = 0; T < L[1]; ++T) {
        for (; i2 < 236 + T * 127; ++i2)
          o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
        o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
      }
    }
    var chainit = function(w) {
      for (T += w; i2 < T - 1; ++i2)
        o.write_shift(-4, i2 + 1);
      if (w) {
        ++i2;
        o.write_shift(-4, ENDOFCHAIN);
      }
    };
    T = i2 = 0;
    for (T += L[1]; i2 < T; ++i2)
      o.write_shift(-4, consts.DIFSECT);
    for (T += L[2]; i2 < T; ++i2)
      o.write_shift(-4, consts.FATSECT);
    chainit(L[3]);
    chainit(L[4]);
    var j = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (flen < 4096)
        continue;
      file.start = T;
      chainit(flen + 511 >> 9);
    }
    chainit(L[6] + 7 >> 3);
    while (o.l & 511)
      o.write_shift(-4, consts.ENDOFCHAIN);
    T = i2 = 0;
    for (j = 0; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (!flen || flen >= 4096)
        continue;
      file.start = T;
      chainit(flen + 63 >> 6);
    }
    while (o.l & 511)
      o.write_shift(-4, consts.ENDOFCHAIN);
    for (i2 = 0; i2 < L[4] << 2; ++i2) {
      var nm = cfb.FullPaths[i2];
      if (!nm || nm.length === 0) {
        for (j = 0; j < 17; ++j)
          o.write_shift(4, 0);
        for (j = 0; j < 3; ++j)
          o.write_shift(4, -1);
        for (j = 0; j < 12; ++j)
          o.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i2];
      if (i2 === 0)
        file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i2 === 0 && _opts.root || file.name;
      flen = 2 * (_nm.length + 1);
      o.write_shift(64, _nm, "utf16le");
      o.write_shift(2, flen);
      o.write_shift(1, file.type);
      o.write_shift(1, file.color);
      o.write_shift(-4, file.L);
      o.write_shift(-4, file.R);
      o.write_shift(-4, file.C);
      if (!file.clsid)
        for (j = 0; j < 4; ++j)
          o.write_shift(4, 0);
      else
        o.write_shift(16, file.clsid, "hex");
      o.write_shift(4, file.state || 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, file.start);
      o.write_shift(4, file.size);
      o.write_shift(4, 0);
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size >= 4096) {
        o.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 511 & -512;
        } else {
          for (j = 0; j < file.size; ++j)
            o.write_shift(1, file.content[j]);
          for (; j & 511; ++j)
            o.write_shift(1, 0);
        }
      }
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 63 & -64;
        } else {
          for (j = 0; j < file.size; ++j)
            o.write_shift(1, file.content[j]);
          for (; j & 63; ++j)
            o.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o.l = o.length;
    } else {
      while (o.l < o.length)
        o.write_shift(1, 0);
    }
    return o;
  }
  function find(cfb, path) {
    var UCFullPaths = cfb.FullPaths.map(function(x) {
      return x.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x) {
      var y = x.split("/");
      return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
    });
    var k = false;
    if (path.charCodeAt(0) === 47) {
      k = true;
      path = UCFullPaths[0].slice(0, -1) + path;
    } else
      k = path.indexOf("/") !== -1;
    var UCPath = path.toUpperCase();
    var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w !== -1)
      return cfb.FileIndex[w];
    var m = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m)
      UCPath = UCPath.replace(chr1, "!");
    for (w = 0; w < UCFullPaths.length; ++w) {
      if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w];
      if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w];
    }
    return null;
  }
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options) {
    get_fs();
    var o = _write(cfb, options);
    fs.writeFileSync(filename2, o);
  }
  function a2s2(o) {
    var out = new Array(o.length);
    for (var i2 = 0; i2 < o.length; ++i2)
      out[i2] = String.fromCharCode(o[i2]);
    return out.join("");
  }
  function write(cfb, options) {
    var o = _write(cfb, options);
    switch (options && options.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options.filename, o);
        return o;
      case "binary":
        return typeof o == "string" ? o : a2s2(o);
      case "base64":
        return Base64_encode(typeof o == "string" ? o : a2s2(o));
      case "buffer":
        if (has_buf)
          return Buffer.isBuffer(o) ? o : Buffer_from(o);
      case "array":
        return typeof o == "string" ? s2a(o) : o;
    }
    return o;
  }
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead)
        _zlib = zlib;
      else
        throw new Error("zlib does not expose bytesRead");
    } catch (e) {
      console.error("cannot use native zlib: " + (e.message || e));
    }
  }
  function _inflateRawSync(payload, usz) {
    if (!_zlib)
      return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n) {
    var t2 = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
    return (t2 >> 16 | t2 >> 8 | t2) & 255;
  }
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q = 0; q < 1 << 8; ++q)
    bitswap8[q] = bit_swap_8(q);
  function bit_swap_n(n, b) {
    var rev = bitswap8[n & 255];
    if (b <= 8)
      return rev >>> 8 - b;
    rev = rev << 8 | bitswap8[n >> 8 & 255];
    if (b <= 16)
      return rev >>> 16 - b;
    rev = rev << 8 | bitswap8[n >> 16 & 255];
    return rev >>> 24 - b;
  }
  function read_bits_2(buf, bl) {
    var w = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w <= 6 ? 0 : buf[h3 + 1] << 8)) >>> w & 3;
  }
  function read_bits_3(buf, bl) {
    var w = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w <= 5 ? 0 : buf[h3 + 1] << 8)) >>> w & 7;
  }
  function read_bits_4(buf, bl) {
    var w = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w <= 4 ? 0 : buf[h3 + 1] << 8)) >>> w & 15;
  }
  function read_bits_5(buf, bl) {
    var w = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w <= 3 ? 0 : buf[h3 + 1] << 8)) >>> w & 31;
  }
  function read_bits_7(buf, bl) {
    var w = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w <= 1 ? 0 : buf[h3 + 1] << 8)) >>> w & 127;
  }
  function read_bits_n(buf, bl, n) {
    var w = bl & 7, h3 = bl >>> 3, f = (1 << n) - 1;
    var v = buf[h3] >>> w;
    if (n < 8 - w)
      return v & f;
    v |= buf[h3 + 1] << 8 - w;
    if (n < 16 - w)
      return v & f;
    v |= buf[h3 + 2] << 16 - w;
    if (n < 24 - w)
      return v & f;
    v |= buf[h3 + 3] << 24 - w;
    return v & f;
  }
  function write_bits_3(buf, bl, v) {
    var w = bl & 7, h3 = bl >>> 3;
    if (w <= 5)
      buf[h3] |= (v & 7) << w;
    else {
      buf[h3] |= v << w & 255;
      buf[h3 + 1] = (v & 7) >> 8 - w;
    }
    return bl + 3;
  }
  function write_bits_1(buf, bl, v) {
    var w = bl & 7, h3 = bl >>> 3;
    v = (v & 1) << w;
    buf[h3] |= v;
    return bl + 1;
  }
  function write_bits_8(buf, bl, v) {
    var w = bl & 7, h3 = bl >>> 3;
    v <<= w;
    buf[h3] |= v & 255;
    v >>>= 8;
    buf[h3 + 1] = v;
    return bl + 8;
  }
  function write_bits_16(buf, bl, v) {
    var w = bl & 7, h3 = bl >>> 3;
    v <<= w;
    buf[h3] |= v & 255;
    v >>>= 8;
    buf[h3 + 1] = v & 255;
    buf[h3 + 2] = v >>> 8;
    return bl + 16;
  }
  function realloc(b, sz) {
    var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
    if (L >= sz)
      return b;
    if (has_buf) {
      var o = new_unsafe_buf(M);
      if (b.copy)
        b.copy(o);
      else
        for (; i2 < b.length; ++i2)
          o[i2] = b[i2];
      return o;
    } else if (use_typed_arrays) {
      var a = new Uint8Array(M);
      if (a.set)
        a.set(b);
      else
        for (; i2 < L; ++i2)
          a[i2] = b[i2];
      return a;
    }
    b.length = M;
    return b;
  }
  function zero_fill_array(n) {
    var o = new Array(n);
    for (var i2 = 0; i2 < n; ++i2)
      o[i2] = 0;
    return o;
  }
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i2 = 0; i2 < 32; ++i2)
      bl_count[i2] = 0;
    for (i2 = L; i2 < MAX; ++i2)
      clens[i2] = 0;
    L = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
    for (i2 = 0; i2 < L; ++i2) {
      bl_count[w = clens[i2]]++;
      if (maxlen < w)
        maxlen = w;
      ctree[i2] = 0;
    }
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2)
      bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2) {
      ccode = clens[i2];
      if (ccode != 0)
        ctree[i2] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
        for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
          cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
      }
    }
    return maxlen;
  }
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i = 0; i < 512; ++i)
      fix_lmap[i] = 0;
    for (i = 0; i < 32; ++i)
      fix_dmap[i] = 0;
  }
  (function() {
    var dlens = [];
    var i2 = 0;
    for (; i2 < 32; i2++)
      dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i2 = 0;
    for (; i2 <= 143; i2++)
      clens.push(8);
    for (; i2 <= 255; i2++)
      clens.push(9);
    for (; i2 <= 279; i2++)
      clens.push(7);
    for (; i2 <= 287; i2++)
      clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j = 0, k = 0;
    for (; j < DST_LN.length - 1; ++j) {
      for (; k < DST_LN[j + 1]; ++k)
        DST_LN_RE[k] = j;
    }
    for (; k < 32768; ++k)
      DST_LN_RE[k] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
      for (; k < LEN_LN[j + 1]; ++k)
        LEN_LN_RE[k] = j;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L = Math.min(65535, data.length - boff);
        var h3 = boff + L == data.length;
        out.write_shift(1, +h3);
        out.write_shift(2, L);
        out.write_shift(2, ~L & 65535);
        while (L-- > 0)
          out[out.l++] = data[boff++];
      }
      return out.l;
    }
    function write_huff_fixed(data, out) {
      var bl = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L < 10) {
          bl = write_bits_3(out, bl, +!!(boff + L == data.length));
          if (bl & 7)
            bl += 8 - (bl & 7);
          out.l = bl / 8 | 0;
          out.write_shift(2, L);
          out.write_shift(2, ~L & 65535);
          while (L-- > 0)
            out[out.l++] = data[boff++];
          bl = out.l * 8;
          continue;
        }
        bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
        var hash = 0;
        while (L-- > 0) {
          var d = data[boff];
          hash = (hash << 5 ^ d) & 32767;
          var match = -1, mlen = 0;
          if (match = addrs[hash]) {
            match |= boff & ~32767;
            if (match > boff)
              match -= 32768;
            if (match < boff)
              while (data[match + mlen] == data[boff + mlen] && mlen < 250)
                ++mlen;
          }
          if (mlen > 2) {
            d = LEN_LN_RE[mlen];
            if (d <= 22)
              bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl, 3);
              bl += 5;
              write_bits_8(out, bl, bitswap8[d - 23] >> 5);
              bl += 3;
            }
            var len_eb = d < 8 ? 0 : d - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl, mlen - LEN_LN[d]);
              bl += len_eb;
            }
            d = DST_LN_RE[boff - match];
            bl = write_bits_8(out, bl, bitswap8[d] >> 3);
            bl -= 3;
            var dst_eb = d < 4 ? 0 : d - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl, boff - match - DST_LN[d]);
              bl += dst_eb;
            }
            for (var q2 = 0; q2 < mlen; ++q2) {
              addrs[hash] = boff & 32767;
              hash = (hash << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L -= mlen - 1;
          } else {
            if (d <= 143)
              d = d + 48;
            else
              bl = write_bits_1(out, bl, 1);
            bl = write_bits_8(out, bl, bitswap8[d]);
            addrs[hash] = boff & 32767;
            ++boff;
          }
        }
        bl = write_bits_8(out, bl, 0) - 1;
      }
      out.l = (bl + 7) / 8 | 0;
      return out.l;
    }
    return function _deflateRaw2(data, out) {
      if (data.length < 8)
        return write_stored(data, out);
      return write_huff_fixed(data, out);
    };
  }();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L = clens.length;
    for (var i2 = 0; i2 < _HCLEN; ++i2) {
      clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
      if (maxlen < w)
        maxlen = w;
      bl_count[w]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2)
      next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2)
      if ((ccode = clens[i2]) != 0)
        ctree[i2] = next_code[ccode]++;
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i2]] >> 8 - cleni;
        for (var j = (1 << 7 - cleni) - 1; j >= 0; --j)
          dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w-- > 0)
            hcodes.push(ccode);
          break;
        case 17:
          w = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w-- > 0)
            hcodes.push(0);
          break;
        case 18:
          w = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w-- > 0)
            hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode)
            maxlen = ccode;
          break;
      }
    }
    var h1 = hcodes.slice(0, _HLIT), h22 = hcodes.slice(_HLIT);
    for (i2 = _HLIT; i2 < 286; ++i2)
      h1[i2] = 0;
    for (i2 = _HDIST; i2 < 30; ++i2)
      h22[i2] = 0;
    dyn_len_1 = build_tree(h1, dyn_lmap, 286);
    dyn_len_2 = build_tree(h22, dyn_dmap, 30);
    return boff;
  }
  function inflate(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7)
          boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0)
          outbuf[woff++] = code;
        else if (code == 256)
          break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5)
            len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz)
      return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate(data, usz);
    payload.l += out[1];
    return out[0];
  }
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined")
        console.error(msg);
    } else
      throw new Error(msg);
  }
  function parse_zip2(file, options) {
    var blob = (
      /*::(*/
      file
    );
    prep_blob(blob, 0);
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o, { root: options.root });
    var i2 = blob.length - 4;
    while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0)
      --i2;
    blob.l = i2 + 4;
    blob.l += 4;
    var fcnt = blob.read_shift(2);
    blob.l += 6;
    var start_cd = blob.read_shift(4);
    blob.l = start_cd;
    for (i2 = 0; i2 < fcnt; ++i2) {
      blob.l += 20;
      var csz = blob.read_shift(4);
      var usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var fcsz = blob.read_shift(2);
      blob.l += 8;
      var offset = blob.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob.slice(blob.l + namelen, blob.l + namelen + efsz)
        /*:: :any)*/
      );
      blob.l += namelen + efsz + fcsz;
      var L = blob.l;
      blob.l = offset + 4;
      parse_local_file(blob, csz, usz, o, EF);
      blob.l = L;
    }
    return o;
  }
  function parse_local_file(blob, csz, usz, o, EF) {
    blob.l += 2;
    var flags = blob.read_shift(2);
    var meth = blob.read_shift(2);
    var date = parse_dos_date(blob);
    if (flags & 8257)
      throw new Error("Unsupported ZIP encryption");
    var crc32 = blob.read_shift(4);
    var _csz = blob.read_shift(4);
    var _usz = blob.read_shift(4);
    var namelen = blob.read_shift(2);
    var efsz = blob.read_shift(2);
    var name = "";
    for (var i2 = 0; i2 < namelen; ++i2)
      name += String.fromCharCode(blob[blob.l++]);
    if (efsz) {
      var ef = parse_extra_field(
        /*::(*/
        blob.slice(blob.l, blob.l + efsz)
        /*:: :any)*/
      );
      if ((ef[21589] || {}).mt)
        date = ef[21589].mt;
      if (((EF || {})[21589] || {}).mt)
        date = EF[21589].mt;
    }
    blob.l += efsz;
    var data = blob.slice(blob.l, blob.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob, _usz);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc32 = blob.read_shift(4);
      if (crc32 == 134695760) {
        crc32 = blob.read_shift(4);
        wrn = true;
      }
      _csz = blob.read_shift(4);
      _usz = blob.read_shift(4);
    }
    if (_csz != csz)
      warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz)
      warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o, name, data, { unsafe: true, mt: date });
  }
  function write_zip2(cfb, options) {
    var _opts = options || {};
    var out = [], cdirs = [];
    var o = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i2 = 0, j = 0;
    var start_cd = 0, fcnt = 0;
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j = 0; j < fp.length; ++j)
        namebuf.write_shift(1, fp.charCodeAt(j) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = CRC32.buf(
        /*::((*/
        fi.content,
        0
      );
      var outbuf = fi.content;
      if (method == 8)
        outbuf = _deflateRawSync(outbuf);
      o = new_buf(30);
      o.write_shift(4, 67324752);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      if (fi.mt)
        write_dos_date(o, fi.mt);
      else
        o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      start_cd += o.length;
      out.push(o);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o = new_buf(46);
      o.write_shift(4, 33639248);
      o.write_shift(2, 0);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, start);
      sz_cd += o.l;
      cdirs.push(o);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o = new_buf(22);
    o.write_shift(4, 101010256);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, fcnt);
    o.write_shift(2, fcnt);
    o.write_shift(4, sz_cd);
    o.write_shift(4, start_cd);
    o.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o]);
  }
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi, fp) {
    if (fi.ctype)
      return fi.ctype;
    var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
    if (m && ContentTypeMap[m[1]])
      return ContentTypeMap[m[1]];
    if (fp) {
      m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m && ContentTypeMap[m[1]])
        return ContentTypeMap[m[1]];
    }
    return "application/octet-stream";
  }
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o = [];
    for (var i2 = 0; i2 < data.length; i2 += 76)
      o.push(data.slice(i2, i2 + 76));
    return o.join("\r\n") + "\r\n";
  }
  function write_quoted_printable(text) {
    var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
      var w = c.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w.length == 1 ? "0" + w : w);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n")
      encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o = [], split = encoded.split("\r\n");
    for (var si = 0; si < split.length; ++si) {
      var str = split[si];
      if (str.length == 0) {
        o.push("");
        continue;
      }
      for (var i2 = 0; i2 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i2, i2 + end);
        if (tmp.charAt(end - 1) == "=")
          end--;
        else if (tmp.charAt(end - 2) == "=")
          end -= 2;
        else if (tmp.charAt(end - 3) == "=")
          end -= 3;
        tmp = str.slice(i2, i2 + end);
        i2 += end;
        if (i2 < str.length)
          tmp += "=";
        o.push(tmp);
      }
    }
    return o.join("\r\n");
  }
  function parse_quoted_printable(data) {
    var o = [];
    for (var di = 0; di < data.length; ++di) {
      var line = data[di];
      while (di <= data.length && line.charAt(line.length - 1) == "=")
        line = line.slice(0, line.length - 1) + data[++di];
      o.push(line);
    }
    for (var oi = 0; oi < o.length; ++oi)
      o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
        return String.fromCharCode(parseInt($$.slice(1), 16));
      });
    return s2a(o.join("\r\n"));
  }
  function parse_mime(cfb, data, root) {
    var fname = "", cte = "", ctype = "", fdata;
    var di = 0;
    for (; di < 10; ++di) {
      var line = data[di];
      if (!line || line.match(/^\s*$/))
        break;
      var m = line.match(/^(.*?):\s*([^\s].*)$/);
      if (m)
        switch (m[1].toLowerCase()) {
          case "content-location":
            fname = m[2].trim();
            break;
          case "content-type":
            ctype = m[2].trim();
            break;
          case "content-transfer-encoding":
            cte = m[2].trim();
            break;
        }
    }
    ++di;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
    if (ctype)
      file.ctype = ctype;
  }
  function parse_mad(file, options) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:")
      throw new Error("Unsupported MAD header");
    var root = options && options.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di = 0, row = "";
    for (di = 0; di < data.length; ++di) {
      row = data[di];
      if (!/^Content-Location:/i.test(row))
        continue;
      row = row.slice(row.indexOf("file"));
      if (!root)
        root = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root.length) == root)
        continue;
      while (root.length > 0) {
        root = root.slice(0, root.length - 1);
        root = root.slice(0, root.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root)
          break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary)
      throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o);
    var start_di, fcnt = 0;
    for (di = 0; di < data.length; ++di) {
      var line = data[di];
      if (line !== boundary && line !== boundary + "--")
        continue;
      if (fcnt++)
        parse_mime(o, data.slice(start_di, di), root);
      start_di = di;
    }
    return o;
  }
  function write_mad(cfb, options) {
    var opts = options || {};
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
        return "_x" + c.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u) {
        return "_u" + u.charCodeAt(0).toString(16) + "_";
      });
      var ca = fi.content;
      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
      var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
      for (var csl = 0; csl <= L; ++csl)
        if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
          ++dispcnt;
      var qp = dispcnt >= L * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  function cfb_new(opts) {
    var o = {};
    init_cfb(o, opts);
    return o;
  }
  function cfb_add(cfb, name, content, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe)
      init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath)
        fpath = name;
      else {
        if (fpath.slice(-1) != "/")
          fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe)
        CFB.utils.cfb_gc(cfb);
    }
    file.content = content;
    file.size = content ? content.length : 0;
    if (opts) {
      if (opts.CLSID)
        file.clsid = opts.CLSID;
      if (opts.mt)
        file.mt = opts.mt;
      if (opts.ct)
        file.ct = opts.ct;
    }
    return file;
  }
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j)
        if (cfb.FileIndex[j] == file) {
          cfb.FileIndex.splice(j, 1);
          cfb.FullPaths.splice(j, 1);
          return true;
        }
    }
    return false;
  }
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j)
        if (cfb.FileIndex[j] == file) {
          cfb.FileIndex[j].name = filename(new_name);
          cfb.FullPaths[j] = new_name;
          return true;
        }
    }
    return false;
  }
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  exports.find = find;
  exports.read = read;
  exports.parse = parse;
  exports.write = write;
  exports.writeFile = write_file;
  exports.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports;
}();
function blobify(data) {
  if (typeof data === "string")
    return s2ab(data);
  if (Array.isArray(data))
    return a2u(data);
  return data;
}
function write_dl(fname, payload, enc) {
  if (typeof Deno !== "undefined") {
    if (enc && typeof payload == "string")
      switch (enc) {
        case "utf8":
          payload = new TextEncoder(enc).encode(payload);
          break;
        case "binary":
          payload = s2ab(payload);
          break;
        default:
          throw new Error("Unsupported encoding " + enc);
      }
    return Deno.writeFileSync(fname, payload);
  }
  var data = enc == "utf8" ? utf8write(payload) : payload;
  if (typeof IE_SaveFile !== "undefined")
    return IE_SaveFile(data, fname);
  if (typeof Blob !== "undefined") {
    var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
    if (typeof navigator !== "undefined" && navigator.msSaveBlob)
      return navigator.msSaveBlob(blob, fname);
    if (typeof saveAs !== "undefined")
      return saveAs(blob, fname);
    if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
      var url = URL.createObjectURL(blob);
      if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return chrome.downloads.download({ url, filename: fname, saveAs: true });
      }
      var a = document.createElement("a");
      if (a.download != null) {
        a.download = fname;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return url;
      }
    }
  }
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
    try {
      var out = File(fname);
      out.open("w");
      out.encoding = "binary";
      if (Array.isArray(payload))
        payload = a2s(payload);
      out.write(payload);
      out.close();
      return payload;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/))
        throw e;
    }
  throw new Error("cannot save file " + fname);
}
function read_binary(path) {
  if (typeof Deno !== "undefined")
    return Deno.readFileSync(path);
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
    try {
      var infile = File(path);
      infile.open("r");
      infile.encoding = "binary";
      var data = infile.read();
      infile.close();
      return data;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/))
        throw e;
    }
  throw new Error("Cannot access file " + path);
}
function keys(o) {
  var ks = Object.keys(o), o2 = [];
  for (var i = 0; i < ks.length; ++i)
    if (Object.prototype.hasOwnProperty.call(o, ks[i]))
      o2.push(ks[i]);
  return o2;
}
function evert_key(obj, key) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    if (o[obj[K[i]][key]] == null)
      o[obj[K[i]][key]] = K[i];
  return o;
}
function evert(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    o[obj[K[i]]] = K[i];
  return o;
}
function evert_num(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    o[obj[K[i]]] = parseInt(K[i], 10);
  return o;
}
function evert_arr(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i) {
    if (o[obj[K[i]]] == null)
      o[obj[K[i]]] = [];
    o[obj[K[i]]].push(K[i]);
  }
  return o;
}
var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function datenum(v, date1904) {
  var epoch = /* @__PURE__ */ v.getTime();
  if (date1904)
    epoch -= 1462 * 24 * 60 * 60 * 1e3;
  var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
}
var refdate = /* @__PURE__ */ new Date();
var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
function numdate(v) {
  var out = /* @__PURE__ */ new Date();
  out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
  if (out.getTimezoneOffset() !== refoffset) {
    out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
  }
  return out;
}
function parse_isodur(s) {
  var sec = 0, mt = 0, time = false;
  var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!m)
    throw new Error("|" + s + "| is not an ISO8601 Duration");
  for (var i = 1; i != m.length; ++i) {
    if (!m[i])
      continue;
    mt = 1;
    if (i > 3)
      time = true;
    switch (m[i].slice(m[i].length - 1)) {
      case "Y":
        throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));
      case "D":
        mt *= 24;
      case "H":
        mt *= 60;
      case "M":
        if (!time)
          throw new Error("Unsupported ISO Duration Field: M");
        else
          mt *= 60;
    }
    sec += mt * parseInt(m[i], 10);
  }
  return sec;
}
var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
function parseDate(str, fixdate) {
  var d = new Date(str);
  if (good_pd) {
    if (fixdate > 0)
      d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3);
    else if (fixdate < 0)
      d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
    return d;
  }
  if (str instanceof Date)
    return str;
  if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
    var s = d.getFullYear();
    if (str.indexOf("" + s) > -1)
      return d;
    d.setFullYear(d.getFullYear() + 100);
    return d;
  }
  var n = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
  var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
  if (str.indexOf("Z") > -1)
    out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
  return out;
}
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254)
        return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255)
        return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined")
    try {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254)
          return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
        if (arr[0] == 254 && arr[1] == 255)
          return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
      }
      var rev = {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": ""
      };
      if (Array.isArray(arr))
        arr = new Uint8Array(arr);
      return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c) {
        return rev[c] || c;
      });
    } catch (e) {
    }
  var o = [];
  for (var i = 0; i != arr.length; ++i)
    o.push(String.fromCharCode(arr[i]));
  return o.join("");
}
function dup(o) {
  if (typeof JSON != "undefined" && !Array.isArray(o))
    return JSON.parse(JSON.stringify(o));
  if (typeof o != "object" || o == null)
    return o;
  if (o instanceof Date)
    return new Date(o.getTime());
  var out = {};
  for (var k in o)
    if (Object.prototype.hasOwnProperty.call(o, k))
      out[k] = dup(o[k]);
  return out;
}
function fill(c, l) {
  var o = "";
  while (o.length < l)
    o += c;
  return o;
}
function fuzzynum(s) {
  var v = Number(s);
  if (!isNaN(v))
    return isFinite(v) ? v : NaN;
  if (!/\d/.test(s))
    return v;
  var wt = 1;
  var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt *= 100;
    return "";
  });
  if (!isNaN(v = Number(ss)))
    return v / wt;
  ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
    wt = -wt;
    return $1;
  });
  if (!isNaN(v = Number(ss)))
    return v / wt;
  return v;
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s) {
  var o = new Date(s), n = /* @__PURE__ */ new Date(NaN);
  var y = o.getYear(), m = o.getMonth(), d = o.getDate();
  if (isNaN(d))
    return n;
  var lower = s.toLowerCase();
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1)
      return n;
  } else if (lower.match(/[a-z]/))
    return n;
  if (y < 0 || y > 8099)
    return n;
  if ((m > 0 || d > 1) && y != 101)
    return o;
  if (s.match(/[^-0-9:,\/\\]/))
    return n;
  return o;
}
var split_regex = /* @__PURE__ */ function() {
  var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
  return function split_regex2(str, re, def) {
    if (safe_split_regex || typeof re == "string")
      return str.split(re);
    var p = str.split(re), o = [p[0]];
    for (var i = 1; i < p.length; ++i) {
      o.push(def);
      o.push(p[i]);
    }
    return o;
  };
}();
function getdatastr(data) {
  if (!data)
    return null;
  if (data.content && data.type)
    return cc2str(data.content, true);
  if (data.data)
    return debom(data.data);
  if (data.asNodeBuffer && has_buf)
    return debom(data.asNodeBuffer().toString("binary"));
  if (data.asBinary)
    return debom(data.asBinary());
  if (data._data && data._data.getContent)
    return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
  return null;
}
function getdatabin(data) {
  if (!data)
    return null;
  if (data.data)
    return char_codes(data.data);
  if (data.asNodeBuffer && has_buf)
    return data.asNodeBuffer();
  if (data._data && data._data.getContent) {
    var o = data._data.getContent();
    if (typeof o == "string")
      return char_codes(o);
    return Array.prototype.slice.call(o);
  }
  if (data.content && data.type)
    return data.content;
  return null;
}
function getdata(data) {
  return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
}
function safegetzipfile(zip, file) {
  var k = zip.FullPaths || keys(zip.files);
  var f = file.toLowerCase().replace(/[\/]/g, "\\"), g = f.replace(/\\/g, "/");
  for (var i = 0; i < k.length; ++i) {
    var n = k[i].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (f == n || g == n)
      return zip.files ? zip.files[k[i]] : zip.FileIndex[i];
  }
  return null;
}
function getzipfile(zip, file) {
  var o = safegetzipfile(zip, file);
  if (o == null)
    throw new Error("Cannot find file " + file + " in zip");
  return o;
}
function getzipdata(zip, file, safe) {
  if (!safe)
    return getdata(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipdata(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipstr(zip, file, safe) {
  if (!safe)
    return getdatastr(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipstr(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipbin(zip, file, safe) {
  if (!safe)
    return getdatabin(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipbin(zip, file);
  } catch (e) {
    return null;
  }
}
function zipentries(zip) {
  var k = zip.FullPaths || keys(zip.files), o = [];
  for (var i = 0; i < k.length; ++i)
    if (k[i].slice(-1) != "/")
      o.push(k[i].replace(/^Root Entry[\/]/, ""));
  return o.sort();
}
function zip_add_file(zip, path, content) {
  if (zip.FullPaths) {
    if (typeof content == "string") {
      var res;
      if (has_buf)
        res = Buffer_from(content);
      else
        res = utf8decode(content);
      return CFB.utils.cfb_add(zip, path, res);
    }
    CFB.utils.cfb_add(zip, path, content);
  } else
    zip.file(path, content);
}
function zip_new() {
  return CFB.utils.cfb_new();
}
function zip_read(d, o) {
  switch (o.type) {
    case "base64":
      return CFB.read(d, { type: "base64" });
    case "binary":
      return CFB.read(d, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(d, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + o.type);
}
function resolve_path(path, base) {
  if (path.charAt(0) == "/")
    return path.slice(1);
  var result = base.split("/");
  if (base.slice(-1) != "/")
    result.pop();
  var target = path.split("/");
  while (target.length !== 0) {
    var step = target.shift();
    if (step === "..")
      result.pop();
    else if (step !== ".")
      result.push(step);
  }
  return result.join("/");
}
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^>]*>/g;
var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(tag, skip_root, skip_LC) {
  var z = {};
  var eq = 0, c = 0;
  for (; eq !== tag.length; ++eq)
    if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13)
      break;
  if (!skip_root)
    z[0] = tag.slice(0, eq);
  if (eq === tag.length)
    return z;
  var m = tag.match(attregexg), j = 0, v = "", i = 0, q = "", cc = "", quot = 1;
  if (m)
    for (i = 0; i != m.length; ++i) {
      cc = m[i];
      for (c = 0; c != cc.length; ++c)
        if (cc.charCodeAt(c) === 61)
          break;
      q = cc.slice(0, c).trim();
      while (cc.charCodeAt(c + 1) == 32)
        ++c;
      quot = (eq = cc.charCodeAt(c + 1)) == 34 || eq == 39 ? 1 : 0;
      v = cc.slice(c + 1 + quot, cc.length - quot);
      for (j = 0; j != q.length; ++j)
        if (q.charCodeAt(j) === 58)
          break;
      if (j === q.length) {
        if (q.indexOf("_") > 0)
          q = q.slice(0, q.indexOf("_"));
        z[q] = v;
        if (!skip_LC)
          z[q.toLowerCase()] = v;
      } else {
        var k = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
        if (z[k] && q.slice(j - 3, j) == "ext")
          continue;
        z[k] = v;
        if (!skip_LC)
          z[k.toLowerCase()] = v;
      }
    }
  return z;
}
function strip_ns(x) {
  return x.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var unescapexml = /* @__PURE__ */ function() {
  var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
  return function unescapexml2(text) {
    var s = text + "", i = s.indexOf("<![CDATA[");
    if (i == -1)
      return s.replace(encregex, function($$, $1) {
        return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
      }).replace(coderegex, function(m, c) {
        return String.fromCharCode(parseInt(c, 16));
      });
    var j = s.indexOf("]]>");
    return unescapexml2(s.slice(0, i)) + s.slice(i + 9, j) + unescapexml2(s.slice(j + 3));
  };
}();
var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
function escapexml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(charegex, function(s2) {
    return "_x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function escapexmltag(text) {
  return escapexml(text).replace(/ /g, "_x0020_");
}
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
    return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function escapexlml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(htmlcharegex, function(s2) {
    return "&#x" + s2.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var entregex = /&#(\d+);/g;
  function entrepl($$, $1) {
    return String.fromCharCode(parseInt($1, 10));
  }
  return function xlml_fixstr2(str) {
    return str.replace(entregex, entrepl);
  };
}();
function xlml_unfixstr(str) {
  return str.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
    case "TRUE":
      return true;
    default:
      return false;
  }
}
function utf8reada(orig) {
  var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
  while (i < orig.length) {
    c = orig.charCodeAt(i++);
    if (c < 128) {
      out += String.fromCharCode(c);
      continue;
    }
    d = orig.charCodeAt(i++);
    if (c > 191 && c < 224) {
      f = (c & 31) << 6;
      f |= d & 63;
      out += String.fromCharCode(f);
      continue;
    }
    e = orig.charCodeAt(i++);
    if (c < 240) {
      out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
      continue;
    }
    f = orig.charCodeAt(i++);
    w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
    out += String.fromCharCode(55296 + (w >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w & 1023));
  }
  return out;
}
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w, i, j = 1, k = 0, ww = 0, c;
  for (i = 0; i < data.length; i += j) {
    j = 1;
    if ((c = data.charCodeAt(i)) < 128)
      w = c;
    else if (c < 224) {
      w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
      j = 2;
    } else if (c < 240) {
      w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
      j = 3;
    } else {
      j = 4;
      w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
      w -= 65536;
      ww = 55296 + (w >>> 10 & 1023);
      w = 56320 + (w & 1023);
    }
    if (ww !== 0) {
      out[k++] = ww & 255;
      out[k++] = ww >>> 8;
      ww = 0;
    }
    out[k++] = w % 256;
    out[k++] = w >>> 8;
  }
  return out.slice(0, k).toString("ucs2");
}
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
var utf8corpus = "foo bar baz";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i = 0, c = 0, d = 0;
  while (i < orig.length) {
    c = orig.charCodeAt(i++);
    switch (true) {
      case c < 128:
        out.push(String.fromCharCode(c));
        break;
      case c < 2048:
        out.push(String.fromCharCode(192 + (c >> 6)));
        out.push(String.fromCharCode(128 + (c & 63)));
        break;
      case (c >= 55296 && c < 57344):
        c -= 55296;
        d = orig.charCodeAt(i++) - 56320 + (c << 10);
        out.push(String.fromCharCode(240 + (d >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c >> 12)));
        out.push(String.fromCharCode(128 + (c >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c & 63)));
    }
  }
  return out.join("");
};
var matchtag = /* @__PURE__ */ function() {
  var mtcache = {};
  return function matchtag2(f, g) {
    var t2 = f + "|" + (g || "");
    if (mtcache[t2])
      return mtcache[t2];
    return mtcache[t2] = new RegExp("<(?:\\w+:)?" + f + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f + ">", g || "");
  };
}();
var htmldecode = /* @__PURE__ */ function() {
  var entities = [
    ["nbsp", " "],
    ["middot", ""],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x) {
    return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
  });
  return function htmldecode2(str) {
    var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
    for (var i = 0; i < entities.length; ++i)
      o = o.replace(entities[i][0], entities[i][1]);
    return o;
  };
}();
var vtregex = /* @__PURE__ */ function() {
  var vt_cache = {};
  return function vt_regex(bt) {
    if (vt_cache[bt] !== void 0)
      return vt_cache[bt];
    return vt_cache[bt] = new RegExp("<(?:vt:)?" + bt + ">([\\s\\S]*?)</(?:vt:)?" + bt + ">", "g");
  };
}();
var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
function parseVector(data, opts) {
  var h3 = parsexmltag(data);
  var matches = data.match(vtregex(h3.baseType)) || [];
  var res = [];
  if (matches.length != h3.size) {
    if (opts.WTF)
      throw new Error("unexpected vector length " + matches.length + " != " + h3.size);
    return res;
  }
  matches.forEach(function(x) {
    var v = x.replace(vtvregex, "").match(vtmregex);
    if (v)
      res.push({ v: utf8read(v[2]), t: v[1] });
  });
  return res;
}
var wtregex = /(^\s|\s$|\n)/;
function writetag(f, g) {
  return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
}
function wxt_helper(h3) {
  return keys(h3).map(function(k) {
    return " " + k + '="' + h3[k] + '"';
  }).join("");
}
function writextag(f, g, h3) {
  return "<" + f + (h3 != null ? wxt_helper(h3) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
}
function write_w3cdtf(d, t2) {
  try {
    return d.toISOString().replace(/\.\d*/, "");
  } catch (e) {
    if (t2)
      throw e;
  }
  return "";
}
function write_vt(s, xlsx) {
  switch (typeof s) {
    case "string":
      var o = writextag("vt:lpwstr", escapexml(s));
      if (xlsx)
        o = o.replace(/&quot;/g, "_x0022_");
      return o;
    case "number":
      return writextag((s | 0) == s ? "vt:i4" : "vt:r8", escapexml(String(s)));
    case "boolean":
      return writextag("vt:bool", s ? "true" : "false");
  }
  if (s instanceof Date)
    return writextag("vt:filetime", write_w3cdtf(s));
  throw new Error("Unable to serialize " + s);
}
function xlml_normalize(d) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(d))
    return d.toString("utf8");
  if (typeof d === "string")
    return d;
  if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array)
    return utf8read(a2s(ab2a(d)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg;
var XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  "dc": "http://purl.org/dc/elements/1.1/",
  "dcterms": "http://purl.org/dc/terms/",
  "dcmitype": "http://purl.org/dc/dcmitype/",
  "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
  "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xsd": "http://www.w3.org/2001/XMLSchema"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
var XLMLNS = {
  "o": "urn:schemas-microsoft-com:office:office",
  "x": "urn:schemas-microsoft-com:office:excel",
  "ss": "urn:schemas-microsoft-com:office:spreadsheet",
  "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  "mv": "http://macVmlSchemaUri",
  "v": "urn:schemas-microsoft-com:vml",
  "html": "http://www.w3.org/TR/REC-html40"
};
function read_double_le(b, idx) {
  var s = 1 - 2 * (b[idx + 7] >>> 7);
  var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
  var m = b[idx + 6] & 15;
  for (var i = 5; i >= 0; --i)
    m = m * 256 + b[idx + i];
  if (e == 2047)
    return m == 0 ? s * Infinity : NaN;
  if (e == 0)
    e = -1022;
  else {
    e -= 1023;
    m += Math.pow(2, 52);
  }
  return s * Math.pow(2, e - 52) * m;
}
function write_double_le(b, v, idx) {
  var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
  var av = bs ? -v : v;
  if (!isFinite(av)) {
    e = 2047;
    m = isNaN(v) ? 26985 : 0;
  } else if (av == 0)
    e = m = 0;
  else {
    e = Math.floor(Math.log(av) / Math.LN2);
    m = av * Math.pow(2, 52 - e);
    if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
      e = -1022;
    } else {
      m -= Math.pow(2, 52);
      e += 1023;
    }
  }
  for (var i = 0; i <= 5; ++i, m /= 256)
    b[idx + i] = m & 255;
  b[idx + 6] = (e & 15) << 4 | m & 15;
  b[idx + 7] = e >> 4 | bs;
}
var ___toBuffer = function(bufs) {
  var x = [], w = 10240;
  for (var i = 0; i < bufs[0].length; ++i)
    if (bufs[0][i])
      for (var j = 0, L = bufs[0][i].length; j < L; j += w)
        x.push.apply(x, bufs[0][i].slice(j, j + w));
  return x;
};
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
    return Buffer.isBuffer(x) ? x : Buffer_from(x);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i += 2)
    ss.push(String.fromCharCode(__readUInt16LE(b, i)));
  return ss.join("").replace(chr0, "");
};
var __utf16le = has_buf ? function(b, s, e) {
  if (!Buffer.isBuffer(b))
    return ___utf16le(b, s, e);
  return b.toString("utf16le", s, e).replace(chr0, "");
} : ___utf16le;
var ___hexlify = function(b, s, l) {
  var ss = [];
  for (var i = s; i < s + l; ++i)
    ss.push(("0" + b[i].toString(16)).slice(-2));
  return ss.join("");
};
var __hexlify = has_buf ? function(b, s, l) {
  return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
} : ___hexlify;
var ___utf8 = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i++)
    ss.push(String.fromCharCode(__readUInt8(b, i)));
  return ss.join("");
};
var __utf8 = has_buf ? function utf8_b(b, s, e) {
  return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
} : ___utf8;
var ___lpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpstr = ___lpstr;
var ___cpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __cpstr = ___cpstr;
var ___lpwstr = function(b, i) {
  var len = 2 * __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpwstr = ___lpwstr;
var ___lpp4 = function lpp4_(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
};
var __lpp4 = ___lpp4;
var ___8lpp4 = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
};
var __8lpp4 = ___8lpp4;
var ___double = function(b, idx) {
  return read_double_le(b, idx);
};
var __double = ___double;
var is_buf = function is_buf_a(a) {
  return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
};
if (has_buf) {
  __lpstr = function lpstr_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___lpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __cpstr = function cpstr_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___cpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __lpwstr = function lpwstr_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___lpwstr(b, i);
    var len = 2 * b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len - 1);
  };
  __lpp4 = function lpp4_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len);
  };
  __8lpp4 = function lpp4_8b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___8lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf8", i + 4, i + 4 + len);
  };
  __double = function double_(b, i) {
    if (Buffer.isBuffer(b))
      return b.readDoubleLE(i);
    return ___double(b, i);
  };
  is_buf = function is_buf_b(a) {
    return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
  };
}
var __readUInt8 = function(b, idx) {
  return b[idx];
};
var __readUInt16LE = function(b, idx) {
  return b[idx + 1] * (1 << 8) + b[idx];
};
var __readInt16LE = function(b, idx) {
  var u = b[idx + 1] * (1 << 8) + b[idx];
  return u < 32768 ? u : (65535 - u + 1) * -1;
};
var __readUInt32LE = function(b, idx) {
  return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
};
var __readInt32LE = function(b, idx) {
  return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
};
var __readInt32BE = function(b, idx) {
  return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
};
function ReadShift(size, t2) {
  var o = "", oI, oR, oo = [], w, vv, i, loc;
  switch (t2) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this))
        o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
      else
        for (i = 0; i < size; ++i) {
          o += String.fromCharCode(__readUInt16LE(this, loc));
          loc += 2;
        }
      size *= 2;
      break;
    case "utf8":
      o = __utf8(this, this.l, this.l + size);
      break;
    case "utf16le":
      size *= 2;
      o = __utf16le(this, this.l, this.l + size);
      break;
    case "wstr":
      return ReadShift.call(this, size, "dbcs");
    case "lpstr-ansi":
      o = __lpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o = __cpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpwstr":
      o = __lpwstr(this, this.l);
      size = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    case "lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __lpp4(this, this.l);
      if (size & 2)
        size += 2;
      break;
    case "8lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __8lpp4(this, this.l);
      if (size & 3)
        size += 4 - (size & 3);
      break;
    case "cstr":
      size = 0;
      o = "";
      while ((w = __readUInt8(this, this.l + size++)) !== 0)
        oo.push(_getchar(w));
      o = oo.join("");
      break;
    case "_wstr":
      size = 0;
      o = "";
      while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
        oo.push(_getchar(w));
        size += 2;
      }
      size += 2;
      o = oo.join("");
      break;
    case "dbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i < size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o = oo.join("");
      size *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i != size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o = oo.join("");
      break;
    default:
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t2 === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t2 === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t2 === "f") {
            if (size == 8)
              oR = __double(this, this.l);
            else
              oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else
            size = 8;
        case 16:
          o = __hexlify(this, this.l, size);
          break;
      }
  }
  this.l += size;
  return o;
}
var __writeUInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
  b[idx + 2] = val >>> 16 & 255;
  b[idx + 3] = val >>> 24 & 255;
};
var __writeInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >> 8 & 255;
  b[idx + 2] = val >> 16 & 255;
  b[idx + 3] = val >> 24 & 255;
};
var __writeUInt16LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
};
function WriteShift(t2, val, f) {
  var size = 0, i = 0;
  if (f === "dbcs") {
    for (i = 0; i != val.length; ++i)
      __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
    size = 2 * val.length;
  } else if (f === "sbcs") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i = 0; i != val.length; ++i)
        this[this.l + i] = val.charCodeAt(i) & 255;
    }
    size = val.length;
  } else if (f === "hex") {
    for (; i < t2; ++i) {
      this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
    }
    return this;
  } else if (f === "utf16le") {
    var end = Math.min(this.l + t2, this.length);
    for (i = 0; i < Math.min(val.length, t2); ++i) {
      var cc = val.charCodeAt(i);
      this[this.l++] = cc & 255;
      this[this.l++] = cc >> 8;
    }
    while (this.l < end)
      this[this.l++] = 0;
    return this;
  } else
    switch (t2) {
      case 1:
        size = 1;
        this[this.l] = val & 255;
        break;
      case 2:
        size = 2;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        break;
      case 3:
        size = 3;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        val >>>= 8;
        this[this.l + 2] = val & 255;
        break;
      case 4:
        size = 4;
        __writeUInt32LE(this, val, this.l);
        break;
      case 8:
        size = 8;
        if (f === "f") {
          write_double_le(this, val, this.l);
          break;
        }
      case 16:
        break;
      case -4:
        size = 4;
        __writeInt32LE(this, val, this.l);
        break;
    }
  this.l += size;
  return this;
}
function CheckField(hexstr, fld) {
  var m = __hexlify(this, this.l, hexstr.length >> 1);
  if (m !== hexstr)
    throw new Error(fld + "Expected " + hexstr + " saw " + m);
  this.l += hexstr.length >> 1;
}
function prep_blob(blob, pos) {
  blob.l = pos;
  blob.read_shift = /*::(*/
  ReadShift;
  blob.chk = CheckField;
  blob.write_shift = WriteShift;
}
function parsenoop(blob, length) {
  blob.l += length;
}
function new_buf(sz) {
  var o = new_raw_buf(sz);
  prep_blob(o, 0);
  return o;
}
function recordhopper(data, cb, opts) {
  if (!data)
    return;
  var tmpbyte, cntbyte, length;
  prep_blob(data, data.l || 0);
  var L = data.length, RT = 0, tgt = 0;
  while (data.l < L) {
    RT = data.read_shift(1);
    if (RT & 128)
      RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
    var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
    tmpbyte = data.read_shift(1);
    length = tmpbyte & 127;
    for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte)
      length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
    tgt = data.l + length;
    var d = R.f && R.f(data, length, opts);
    data.l = tgt;
    if (cb(d, R, RT))
      return;
  }
}
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = function ba_newblk(sz) {
    var o = new_buf(sz);
    prep_blob(o, 0);
    return o;
  };
  var curbuf = newblk(blksz);
  var endbuf = function ba_endbuf() {
    if (!curbuf)
      return;
    if (curbuf.length > curbuf.l) {
      curbuf = curbuf.slice(0, curbuf.l);
      curbuf.l = curbuf.length;
    }
    if (curbuf.length > 0)
      bufs.push(curbuf);
    curbuf = null;
  };
  var next = function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l)
      return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  };
  var end = function ba_end() {
    endbuf();
    return bconcat(bufs);
  };
  var push = function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null)
      curbuf.l = curbuf.length;
    next(blksz);
  };
  return { next, push, end, _bufs: bufs };
}
function write_record(ba, type, payload, length) {
  var t2 = +type, l;
  if (isNaN(t2))
    return;
  if (!length)
    length = XLSBRecordEnum[t2].p || (payload || []).length || 0;
  l = 1 + (t2 >= 128 ? 1 : 0) + 1;
  if (length >= 128)
    ++l;
  if (length >= 16384)
    ++l;
  if (length >= 2097152)
    ++l;
  var o = ba.next(l);
  if (t2 <= 127)
    o.write_shift(1, t2);
  else {
    o.write_shift(1, (t2 & 127) + 128);
    o.write_shift(1, t2 >> 7);
  }
  for (var i = 0; i != 4; ++i) {
    if (length >= 128) {
      o.write_shift(1, (length & 127) + 128);
      length >>= 7;
    } else {
      o.write_shift(1, length);
      break;
    }
  }
  if (
    /*:: length != null &&*/
    length > 0 && is_buf(payload)
  )
    ba.push(payload);
}
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel)
      out.c += tgt.s.c;
    if (out.rRel)
      out.r += tgt.s.r;
  } else {
    if (out.cRel)
      out.c += tgt.c;
    if (out.rRel)
      out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256)
      out.c -= 256;
    while (out.r >= 65536)
      out.r -= 65536;
  }
  return out;
}
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
function encode_cell_xls(c, biff) {
  if (c.cRel && c.c < 0) {
    c = dup(c);
    while (c.c < 0)
      c.c += biff > 8 ? 16384 : 256;
  }
  if (c.rRel && c.r < 0) {
    c = dup(c);
    while (c.r < 0)
      c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s = encode_cell(c);
  if (!c.cRel && c.cRel != null)
    s = fix_col(s);
  if (!c.rRel && c.rRel != null)
    s = fix_row(s);
  return s;
}
function encode_range_xls(r, opts) {
  if (r.s.r == 0 && !r.s.rRel) {
    if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
      return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
    }
  }
  if (r.s.c == 0 && !r.s.cRel) {
    if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
      return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
    }
  }
  return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
}
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
function encode_row(row) {
  return "" + (row + 1);
}
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
function decode_col(colstr) {
  var c = unfix_col(colstr), d = 0, i = 0;
  for (; i !== c.length; ++i)
    d = 26 * d + c.charCodeAt(i) - 64;
  return d - 1;
}
function encode_col(col) {
  if (col < 0)
    throw new Error("invalid column " + col);
  var s = "";
  for (++col; col; col = Math.floor((col - 1) / 26))
    s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s;
}
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
function decode_cell(cstr) {
  var R = 0, C = 0;
  for (var i = 0; i < cstr.length; ++i) {
    var cc = cstr.charCodeAt(i);
    if (cc >= 48 && cc <= 57)
      R = 10 * R + (cc - 48);
    else if (cc >= 65 && cc <= 90)
      C = 26 * C + (cc - 64);
  }
  return { c: C - 1, r: R - 1 };
}
function encode_cell(cell) {
  var col = cell.c + 1;
  var s = "";
  for (; col; col = (col - 1) / 26 | 0)
    s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s + (cell.r + 1);
}
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1)
    return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
function encode_range(cs, ce) {
  if (typeof ce === "undefined" || typeof ce === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string")
    cs = encode_cell(cs);
  if (typeof ce !== "string")
    ce = encode_cell(ce);
  return cs == ce ? cs : cs + ":" + ce;
}
function safe_decode_range(range) {
  var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i = 0, cc = 0;
  var len = range.length;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o.s.c = --idx;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o.s.r = --idx;
  if (i === len || cc != 10) {
    o.e.c = o.s.c;
    o.e.r = o.s.r;
    return o;
  }
  ++i;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o.e.c = --idx;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o.e.r = --idx;
  return o;
}
function safe_format_cell(cell, v) {
  var q = cell.t == "d" && v instanceof Date;
  if (cell.z != null)
    try {
      return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
    } catch (e) {
    }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
  } catch (e) {
    return "" + v;
  }
}
function format_cell(cell, v, o) {
  if (cell == null || cell.t == null || cell.t == "z")
    return "";
  if (cell.w !== void 0)
    return cell.w;
  if (cell.t == "d" && !cell.z && o && o.dateNF)
    cell.z = o.dateNF;
  if (cell.t == "e")
    return BErr[cell.v] || cell.v;
  if (v == void 0)
    return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v);
}
function sheet_to_workbook(sheet, opts) {
  var n = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n] = sheet;
  return { SheetNames: [n], Sheets: sheets };
}
function sheet_add_aoa(_ws, data, opts) {
  var o = opts || {};
  var dense = _ws ? Array.isArray(_ws) : o.dense;
  var ws = _ws || (dense ? [] : {});
  var _R = 0, _C = 0;
  if (ws && o.origin != null) {
    if (typeof o.origin == "number")
      _R = o.origin;
    else {
      var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
    if (!ws["!ref"])
      ws["!ref"] = "A1:A1";
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1)
      range.e.r = _R = _range.e.r + 1;
  }
  for (var R = 0; R != data.length; ++R) {
    if (!data[R])
      continue;
    if (!Array.isArray(data[R]))
      throw new Error("aoa_to_sheet expects an array of arrays");
    for (var C = 0; C != data[R].length; ++C) {
      if (typeof data[R][C] === "undefined")
        continue;
      var cell = { v: data[R][C] };
      var __R = _R + R, __C = _C + C;
      if (range.s.r > __R)
        range.s.r = __R;
      if (range.s.c > __C)
        range.s.c = __C;
      if (range.e.r < __R)
        range.e.r = __R;
      if (range.e.c < __C)
        range.e.c = __C;
      if (data[R][C] && typeof data[R][C] === "object" && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date))
        cell = data[R][C];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R][C][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f)
            cell.t = "n";
          else if (o.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o.sheetStubs)
            continue;
          else
            cell.t = "z";
        } else if (typeof cell.v === "number")
          cell.t = "n";
        else if (typeof cell.v === "boolean")
          cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o.dateNF || table_fmt[14];
          if (o.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else
          cell.t = "s";
      }
      if (dense) {
        if (!ws[__R])
          ws[__R] = [];
        if (ws[__R][__C] && ws[__R][__C].z)
          cell.z = ws[__R][__C].z;
        ws[__R][__C] = cell;
      } else {
        var cell_ref = encode_cell({ c: __C, r: __R });
        if (ws[cell_ref] && ws[cell_ref].z)
          cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (range.s.c < 1e7)
    ws["!ref"] = encode_range(range);
  return ws;
}
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
function write_UInt32LE(x, o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(4, x);
  return o;
}
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLWideString(data, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(4 + 2 * data.length);
  }
  o.write_shift(4, data.length);
  if (data.length > 0)
    o.write_shift(0, data, "dbcs");
  return _null ? o.slice(0, o.l) : o;
}
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
function write_StrRun(run, o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(2, run.ich || 0);
  o.write_shift(2, run.ifnt || 0);
  return o;
}
function parse_RichStr(data, length) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i = 0; i != dwSizeStrRun; ++i)
      rgsStrRun.push(parse_StrRun(data));
    z.r = rgsStrRun;
  } else
    z.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length;
  return z;
}
function write_RichStr(str, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(15 + 4 * str.t.length);
  }
  o.write_shift(1, 0);
  write_XLWideString(str.t, o);
  return _null ? o.slice(0, o.l) : o;
}
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(str, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(23 + 4 * str.t.length);
  }
  o.write_shift(1, 1);
  write_XLWideString(str.t, o);
  o.write_shift(4, 1);
  write_StrRun({ ich: 0, ifnt: 0 }, o);
  return _null ? o.slice(0, o.l) : o;
}
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
function write_XLSBCell(cell, o) {
  if (o == null)
    o = new_buf(8);
  o.write_shift(-4, cell.c);
  o.write_shift(3, cell.iStyleRef || cell.s);
  o.write_shift(1, 0);
  return o;
}
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
function write_XLSBShortCell(cell, o) {
  if (o == null)
    o = new_buf(4);
  o.write_shift(3, cell.iStyleRef || cell.s);
  o.write_shift(1, 0);
  return o;
}
var parse_XLSBCodeName = parse_XLWideString;
var write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLNullableWideString(data, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(127);
  }
  o.write_shift(4, data.length > 0 ? data.length : 4294967295);
  if (data.length > 0)
    o.write_shift(0, data, "dbcs");
  return _null ? o.slice(0, o.l) : o;
}
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
var write_RelID = write_XLNullableWideString;
function parse_RkNumber(data) {
  var b = data.slice(data.l, data.l + 4);
  var fX100 = b[0] & 1, fInt = b[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
function write_RkNumber(data, o) {
  if (o == null)
    o = new_buf(4);
  var fX100 = 0, fInt = 0, d100 = data * 100;
  if (data == (data | 0) && data >= -(1 << 29) && data < 1 << 29) {
    fInt = 1;
  } else if (d100 == (d100 | 0) && d100 >= -(1 << 29) && d100 < 1 << 29) {
    fInt = 1;
    fX100 = 1;
  }
  if (fInt)
    o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
  else
    throw new Error("unsupported RkNumber " + data);
}
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
function write_RfX(r, o) {
  if (!o)
    o = new_buf(16);
  o.write_shift(4, r.s.r);
  o.write_shift(4, r.e.r);
  o.write_shift(4, r.s.c);
  o.write_shift(4, r.e.c);
  return o;
}
var parse_UncheckedRfX = parse_RfX;
var write_UncheckedRfX = write_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8)
    throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
function write_Xnum(data, o) {
  return (o || new_buf(8)).write_shift(8, data, "f");
}
function parse_BrtColor(data) {
  var out = {};
  var d = data.read_shift(1);
  var xColorType = d >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv)
        out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0)
    out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
function write_BrtColor(color, o) {
  if (!o)
    o = new_buf(8);
  if (!color || color.auto) {
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  if (color.index != null) {
    o.write_shift(1, 2);
    o.write_shift(1, color.index);
  } else if (color.theme != null) {
    o.write_shift(1, 6);
    o.write_shift(1, color.theme);
  } else {
    o.write_shift(1, 5);
    o.write_shift(1, 0);
  }
  var nTS = color.tint || 0;
  if (nTS > 0)
    nTS *= 32767;
  else if (nTS < 0)
    nTS *= 32768;
  o.write_shift(2, nTS);
  if (!color.rgb || color.theme != null) {
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
  } else {
    var rgb = color.rgb || "FFFFFF";
    if (typeof rgb == "number")
      rgb = ("000000" + rgb.toString(16)).slice(-6);
    o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
    o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
    o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
    o.write_shift(1, 255);
  }
  return o;
}
function parse_FontFlags(data) {
  var d = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d & 1,
    fItalic: d & 2,
    fUnderline: d & 4,
    fStrikeout: d & 8,
    fOutline: d & 16,
    fShadow: d & 32,
    fCondense: d & 64,
    fExtend: d & 128
  };
  return out;
}
function write_FontFlags(font, o) {
  if (!o)
    o = new_buf(2);
  var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
  o.write_shift(1, grbit);
  o.write_shift(1, 0);
  return o;
}
function parse_ClipboardFormatOrString(o, w) {
  var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
  var m = o.read_shift(4);
  switch (m) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return ClipFmt[o.read_shift(4)] || "";
  }
  if (m > 400)
    throw new Error("Unsupported Clipboard: " + m.toString(16));
  o.l -= 4;
  return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(o) {
  return parse_ClipboardFormatOrString(o, 1);
}
function parse_ClipboardFormatOrUnicodeString(o) {
  return parse_ClipboardFormatOrString(o, 2);
}
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_VARIANT = 12;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var VT_USTR = 81;
var VT_CUSTOM = [VT_STRING, VT_USTR];
var DocSummaryPIDDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Category", t: VT_STRING },
  /*::[*/
  3: { n: "PresentationFormat", t: VT_STRING },
  /*::[*/
  4: { n: "ByteCount", t: VT_I4 },
  /*::[*/
  5: { n: "LineCount", t: VT_I4 },
  /*::[*/
  6: { n: "ParagraphCount", t: VT_I4 },
  /*::[*/
  7: { n: "SlideCount", t: VT_I4 },
  /*::[*/
  8: { n: "NoteCount", t: VT_I4 },
  /*::[*/
  9: { n: "HiddenCount", t: VT_I4 },
  /*::[*/
  10: { n: "MultimediaClipCount", t: VT_I4 },
  /*::[*/
  11: { n: "ScaleCrop", t: VT_BOOL },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: VT_STRING },
  /*::[*/
  15: { n: "Company", t: VT_STRING },
  /*::[*/
  16: { n: "LinksUpToDate", t: VT_BOOL },
  /*::[*/
  17: { n: "CharacterCount", t: VT_I4 },
  /*::[*/
  19: { n: "SharedDoc", t: VT_BOOL },
  /*::[*/
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  /*::[*/
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: VT_BLOB },
  /*::[*/
  26: { n: "ContentType", t: VT_STRING },
  /*::[*/
  27: { n: "ContentStatus", t: VT_STRING },
  /*::[*/
  28: { n: "Language", t: VT_STRING },
  /*::[*/
  29: { n: "Version", t: VT_STRING },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var SummaryPIDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Title", t: VT_STRING },
  /*::[*/
  3: { n: "Subject", t: VT_STRING },
  /*::[*/
  4: { n: "Author", t: VT_STRING },
  /*::[*/
  5: { n: "Keywords", t: VT_STRING },
  /*::[*/
  6: { n: "Comments", t: VT_STRING },
  /*::[*/
  7: { n: "Template", t: VT_STRING },
  /*::[*/
  8: { n: "LastAuthor", t: VT_STRING },
  /*::[*/
  9: { n: "RevNumber", t: VT_STRING },
  /*::[*/
  10: { n: "EditTime", t: VT_FILETIME },
  /*::[*/
  11: { n: "LastPrinted", t: VT_FILETIME },
  /*::[*/
  12: { n: "CreatedDate", t: VT_FILETIME },
  /*::[*/
  13: { n: "ModifiedDate", t: VT_FILETIME },
  /*::[*/
  14: { n: "PageCount", t: VT_I4 },
  /*::[*/
  15: { n: "WordCount", t: VT_I4 },
  /*::[*/
  16: { n: "CharCount", t: VT_I4 },
  /*::[*/
  17: { n: "Thumbnail", t: VT_CF },
  /*::[*/
  18: { n: "Application", t: VT_STRING },
  /*::[*/
  19: { n: "DocSecurity", t: VT_I4 },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var CountryEnum = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
};
var XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(arr) {
  return arr.map(function(x) {
    return [x >> 16 & 255, x >> 8 & 255, x & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
};
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
var CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(data) {
  var ct = new_ct();
  if (!data || !data.match)
    return ct;
  var ctext = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        ctext[y.Extension] = y.ContentType;
        break;
      case "<Override":
        if (ct[ct2type[y.ContentType]] !== void 0)
          ct[ct2type[y.ContentType]].push(y.PartName);
        break;
    }
  });
  if (ct.xmlns !== XMLNS.CT)
    throw new Error("Unknown Namespace: " + ct.xmlns);
  ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
  ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
  ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
  ct.defaults = ctext;
  delete ct.calcchains;
  return ct;
}
function write_ct(ct, opts) {
  var type2ct = evert_arr(ct2type);
  var o = [], v;
  o[o.length] = XML_HEADER;
  o[o.length] = writextag("Types", null, {
    "xmlns": XMLNS.CT,
    "xmlns:xsd": XMLNS.xsd,
    "xmlns:xsi": XMLNS.xsi
  });
  o = o.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(x) {
    return writextag("Default", null, { "Extension": x[0], "ContentType": x[1] });
  }));
  var f1 = function(w) {
    if (ct[w] && ct[w].length > 0) {
      v = ct[w][0];
      o[o.length] = writextag("Override", null, {
        "PartName": (v[0] == "/" ? "" : "/") + v,
        "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
      });
    }
  };
  var f2 = function(w) {
    (ct[w] || []).forEach(function(v2) {
      o[o.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
      });
    });
  };
  var f3 = function(t2) {
    (ct[t2] || []).forEach(function(v2) {
      o[o.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": type2ct[t2][0]
      });
    });
  };
  f1("workbooks");
  f2("sheets");
  f2("charts");
  f3("themes");
  ["strs", "styles"].forEach(f1);
  ["coreprops", "extprops", "custprops"].forEach(f3);
  f3("vba");
  f3("comments");
  f3("threadedcomments");
  f3("drawings");
  f2("metadata");
  f3("people");
  if (o.length > 2) {
    o[o.length] = "</Types>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n = file.lastIndexOf("/");
  return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
}
function parse_rels(data, currentFilePath) {
  var rels = { "!id": {} };
  if (!data)
    return rels;
  if (currentFilePath.charAt(0) !== "/") {
    currentFilePath = "/" + currentFilePath;
  }
  var hash = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    if (y[0] === "<Relationship") {
      var rel = {};
      rel.Type = y.Type;
      rel.Target = y.Target;
      rel.Id = y.Id;
      if (y.TargetMode)
        rel.TargetMode = y.TargetMode;
      var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
      rels[canonictarget] = rel;
      hash[y.Id] = rel;
    }
  });
  rels["!id"] = hash;
  return rels;
}
function write_rels(rels) {
  var o = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    "xmlns": XMLNS.RELS
  })];
  keys(rels["!id"]).forEach(function(rid) {
    o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
  });
  if (o.length > 2) {
    o[o.length] = "</Relationships>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function add_rels(rels, rId, f, type, relobj, targetmode) {
  if (!relobj)
    relobj = {};
  if (!rels["!id"])
    rels["!id"] = {};
  if (!rels["!idx"])
    rels["!idx"] = 1;
  if (rId < 0)
    for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
    }
  rels["!idx"] = rId + 1;
  relobj.Id = "rId" + rId;
  relobj.Type = type;
  relobj.Target = f;
  if (targetmode)
    relobj.TargetMode = targetmode;
  else if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1)
    relobj.TargetMode = "External";
  if (rels["!id"][relobj.Id])
    throw new Error("Cannot rewrite rId " + rId);
  rels["!id"][relobj.Id] = relobj;
  rels[("/" + relobj.Target).replace("//", "/")] = relobj;
  return rId;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(d, opts) {
  var str = xlml_normalize(d);
  var Rn;
  var FEtag;
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3]) {
      case "manifest":
        break;
      case "file-entry":
        FEtag = parsexmltag(Rn[0], false);
        if (FEtag.path == "/" && FEtag.type !== CT_ODS)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (opts && opts.WTF)
          throw Rn;
    }
}
function write_manifest(manifest) {
  var o = [XML_HEADER];
  o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
  o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
  for (var i = 0; i < manifest.length; ++i)
    o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
  o.push("</manifest:manifest>");
  return o.join("");
}
function write_rdf_type(file, res, tag) {
  return [
    '  <rdf:Description rdf:about="' + file + '">\n',
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf_has(base, file) {
  return [
    '  <rdf:Description rdf:about="' + base + '">\n',
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf(rdf) {
  var o = [XML_HEADER];
  o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
  for (var i = 0; i != rdf.length; ++i) {
    o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
    o.push(write_rdf_has("", rdf[i][0]));
  }
  o.push(write_rdf_type("", "Document", "pkg"));
  o.push("</rdf:RDF>");
  return o.join("");
}
function write_meta_ods() {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
var CORE_PROPS_REGEX = /* @__PURE__ */ function() {
  var r = new Array(CORE_PROPS.length);
  for (var i = 0; i < CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i];
    var g = "(?:" + f[0].slice(0, f[0].indexOf(":")) + ":)" + f[0].slice(f[0].indexOf(":") + 1);
    r[i] = new RegExp("<" + g + "[^>]*>([\\s\\S]*?)</" + g + ">");
  }
  return r;
}();
function parse_core_props(data) {
  var p = {};
  data = utf8read(data);
  for (var i = 0; i < CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);
    if (cur != null && cur.length > 0)
      p[f[1]] = unescapexml(cur[1]);
    if (f[2] === "date" && p[f[1]])
      p[f[1]] = parseDate(p[f[1]]);
  }
  return p;
}
function cp_doit(f, g, h3, o, p) {
  if (p[f] != null || g == null || g === "")
    return;
  p[f] = g;
  g = escapexml(g);
  o[o.length] = h3 ? writextag(f, g, h3) : writetag(f, g);
}
function write_core_props(cp, _opts) {
  var opts = _opts || {};
  var o = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], p = {};
  if (!cp && !opts.Props)
    return o.join("");
  if (cp) {
    if (cp.CreatedDate != null)
      cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
    if (cp.ModifiedDate != null)
      cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
  }
  for (var i = 0; i != CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i];
    var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
    if (v === true)
      v = "1";
    else if (v === false)
      v = "0";
    else if (typeof v == "number")
      v = String(v);
    if (v != null)
      cp_doit(f[0], v, null, o, p);
  }
  if (o.length > 2) {
    o[o.length] = "</cp:coreProperties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
var PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function load_props_pairs(HP, TOP, props, opts) {
  var v = [];
  if (typeof HP == "string")
    v = parseVector(HP, opts);
  else
    for (var j = 0; j < HP.length; ++j)
      v = v.concat(HP[j].map(function(hp) {
        return { v: hp };
      }));
  var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
    return x.v;
  }) : TOP;
  var idx = 0, len = 0;
  if (parts.length > 0)
    for (var i = 0; i !== v.length; i += 2) {
      len = +v[i + 1].v;
      switch (v[i].v) {
        case "Worksheets":
        case "":
        case "":
        case " ":
        case "":
        case " ":
        case "Arbeitsbltter":
        case "alma Sayfalar":
        case "Feuilles de calcul":
        case "Fogli di lavoro":
        case "Folhas de clculo":
        case "Planilhas":
        case "Regneark":
        case "Hojas de clculo":
        case "Werkbladen":
          props.Worksheets = len;
          props.SheetNames = parts.slice(idx, idx + len);
          break;
        case "Named Ranges":
        case "Rangos con nombre":
        case "":
        case "Benannte Bereiche":
        case "Navngivne omrder":
          props.NamedRanges = len;
          props.DefinedNames = parts.slice(idx, idx + len);
          break;
        case "Charts":
        case "Diagramme":
          props.Chartsheets = len;
          props.ChartNames = parts.slice(idx, idx + len);
          break;
      }
      idx += len;
    }
}
function parse_ext_props(data, p, opts) {
  var q = {};
  if (!p)
    p = {};
  data = utf8read(data);
  EXT_PROPS.forEach(function(f) {
    var xml = (data.match(matchtag(f[0])) || [])[1];
    switch (f[2]) {
      case "string":
        if (xml)
          p[f[1]] = unescapexml(xml);
        break;
      case "bool":
        p[f[1]] = xml === "true";
        break;
      case "raw":
        var cur = data.match(new RegExp("<" + f[0] + "[^>]*>([\\s\\S]*?)</" + f[0] + ">"));
        if (cur && cur.length > 0)
          q[f[1]] = cur[1];
        break;
    }
  });
  if (q.HeadingPairs && q.TitlesOfParts)
    load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);
  return p;
}
function write_ext_props(cp) {
  var o = [], W = writextag;
  if (!cp)
    cp = {};
  cp.Application = "SheetJS";
  o[o.length] = XML_HEADER;
  o[o.length] = writextag("Properties", null, {
    "xmlns": XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  });
  EXT_PROPS.forEach(function(f) {
    if (cp[f[1]] === void 0)
      return;
    var v;
    switch (f[2]) {
      case "string":
        v = escapexml(String(cp[f[1]]));
        break;
      case "bool":
        v = cp[f[1]] ? "true" : "false";
        break;
    }
    if (v !== void 0)
      o[o.length] = W(f[0], v);
  });
  o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
  o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
    return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
  }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
  if (o.length > 2) {
    o[o.length] = "</Properties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var custregex = /<[^>]+>[^<]*/g;
function parse_cust_props(data, opts) {
  var p = {}, name = "";
  var m = data.match(custregex);
  if (m)
    for (var i = 0; i != m.length; ++i) {
      var x = m[i], y = parsexmltag(x);
      switch (y[0]) {
        case "<?xml":
          break;
        case "<Properties":
          break;
        case "<property":
          name = unescapexml(y.name);
          break;
        case "</property>":
          name = null;
          break;
        default:
          if (x.indexOf("<vt:") === 0) {
            var toks = x.split(">");
            var type = toks[0].slice(4), text = toks[1];
            switch (type) {
              case "lpstr":
              case "bstr":
              case "lpwstr":
                p[name] = unescapexml(text);
                break;
              case "bool":
                p[name] = parsexmlbool(text);
                break;
              case "i1":
              case "i2":
              case "i4":
              case "i8":
              case "int":
              case "uint":
                p[name] = parseInt(text, 10);
                break;
              case "r4":
              case "r8":
              case "decimal":
                p[name] = parseFloat(text);
                break;
              case "filetime":
              case "date":
                p[name] = parseDate(text);
                break;
              case "cy":
              case "error":
                p[name] = unescapexml(text);
                break;
              default:
                if (type.slice(-1) == "/")
                  break;
                if (opts.WTF && typeof console !== "undefined")
                  console.warn("Unexpected", x, type, toks);
            }
          } else if (x.slice(0, 2) === "</")
            ;
          else if (opts.WTF)
            throw new Error(x);
      }
    }
  return p;
}
function write_cust_props(cp) {
  var o = [XML_HEADER, writextag("Properties", null, {
    "xmlns": XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!cp)
    return o.join("");
  var pid = 1;
  keys(cp).forEach(function custprop(k) {
    ++pid;
    o[o.length] = writextag("property", write_vt(cp[k], true), {
      "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      "pid": pid,
      "name": escapexml(k)
    });
  });
  if (o.length > 2) {
    o[o.length] = "</Properties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
var evert_XLMLDPM;
function xlml_set_prop(Props, tag, val) {
  if (!evert_XLMLDPM)
    evert_XLMLDPM = evert(XLMLDocPropsMap);
  tag = evert_XLMLDPM[tag] || tag;
  Props[tag] = val;
}
function xlml_write_docprops(Props, opts) {
  var o = [];
  keys(XLMLDocPropsMap).map(function(m) {
    for (var i = 0; i < CORE_PROPS.length; ++i)
      if (CORE_PROPS[i][1] == m)
        return CORE_PROPS[i];
    for (i = 0; i < EXT_PROPS.length; ++i)
      if (EXT_PROPS[i][1] == m)
        return EXT_PROPS[i];
    throw m;
  }).forEach(function(p) {
    if (Props[p[1]] == null)
      return;
    var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
    switch (p[2]) {
      case "date":
        m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
        break;
    }
    if (typeof m == "number")
      m = String(m);
    else if (m === true || m === false) {
      m = m ? "1" : "0";
    } else if (m instanceof Date)
      m = new Date(m).toISOString().replace(/\.\d*Z/, "");
    o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
  });
  return writextag("DocumentProperties", o.join(""), { xmlns: XLMLNS.o });
}
function xlml_write_custprops(Props, Custprops) {
  var BLACKLIST = ["Worksheets", "SheetNames"];
  var T = "CustomDocumentProperties";
  var o = [];
  if (Props)
    keys(Props).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Props, k))
        return;
      for (var i = 0; i < CORE_PROPS.length; ++i)
        if (k == CORE_PROPS[i][1])
          return;
      for (i = 0; i < EXT_PROPS.length; ++i)
        if (k == EXT_PROPS[i][1])
          return;
      for (i = 0; i < BLACKLIST.length; ++i)
        if (k == BLACKLIST[i])
          return;
      var m = Props[k];
      var t2 = "string";
      if (typeof m == "number") {
        t2 = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t2 = "boolean";
        m = m ? "1" : "0";
      } else
        m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t2 }));
    });
  if (Custprops)
    keys(Custprops).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Custprops, k))
        return;
      if (Props && Object.prototype.hasOwnProperty.call(Props, k))
        return;
      var m = Custprops[k];
      var t2 = "string";
      if (typeof m == "number") {
        t2 = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t2 = "boolean";
        m = m ? "1" : "0";
      } else if (m instanceof Date) {
        t2 = "dateTime.tz";
        m = m.toISOString();
      } else
        m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t2 }));
    });
  return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
}
function parse_FILETIME(blob) {
  var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
  return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function write_FILETIME(time) {
  var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
  var t2 = date.getTime() / 1e3 + 11644473600;
  var l = t2 % Math.pow(2, 32), h3 = (t2 - l) / Math.pow(2, 32);
  l *= 1e7;
  h3 *= 1e7;
  var w = l / Math.pow(2, 32) | 0;
  if (w > 0) {
    l = l % Math.pow(2, 32);
    h3 += w;
  }
  var o = new_buf(8);
  o.write_shift(4, l);
  o.write_shift(4, h3);
  return o;
}
function parse_lpstr(blob, type, pad) {
  var start = blob.l;
  var str = blob.read_shift(0, "lpstr-cp");
  if (pad)
    while (blob.l - start & 3)
      ++blob.l;
  return str;
}
function parse_lpwstr(blob, type, pad) {
  var str = blob.read_shift(0, "lpwstr");
  if (pad)
    blob.l += 4 - (str.length + 1 & 3) & 3;
  return str;
}
function parse_VtStringBase(blob, stringType, pad) {
  if (stringType === 31)
    return parse_lpwstr(blob);
  return parse_lpstr(blob, stringType, pad);
}
function parse_VtString(blob, t2, pad) {
  return parse_VtStringBase(blob, t2, pad === false ? 0 : 4);
}
function parse_VtUnalignedString(blob, t2) {
  if (!t2)
    throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(blob, t2, 0);
}
function parse_VtVecLpwstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i = 0; i != length; ++i) {
    var start = blob.l;
    ret[i] = blob.read_shift(0, "lpwstr").replace(chr0, "");
    if (blob.l - start & 2)
      blob.l += 2;
  }
  return ret;
}
function parse_VtVecUnalignedLpstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i = 0; i != length; ++i)
    ret[i] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
  return ret;
}
function parse_VtHeadingPair(blob) {
  var start = blob.l;
  var headingString = parse_TypedPropertyValue(blob, VT_USTR);
  if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2)
    blob.l += 2;
  var headerParts = parse_TypedPropertyValue(blob, VT_I4);
  return [headingString, headerParts];
}
function parse_VtVecHeadingPairValue(blob) {
  var cElements = blob.read_shift(4);
  var out = [];
  for (var i = 0; i < cElements / 2; ++i)
    out.push(parse_VtHeadingPair(blob));
  return out;
}
function parse_dictionary(blob, CodePage) {
  var cnt = blob.read_shift(4);
  var dict = {};
  for (var j = 0; j != cnt; ++j) {
    var pid = blob.read_shift(4);
    var len = blob.read_shift(4);
    dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
    if (CodePage === 1200 && len % 2)
      blob.l += 2;
  }
  if (blob.l & 3)
    blob.l = blob.l >> 2 + 1 << 2;
  return dict;
}
function parse_BLOB(blob) {
  var size = blob.read_shift(4);
  var bytes = blob.slice(blob.l, blob.l + size);
  blob.l += size;
  if ((size & 3) > 0)
    blob.l += 4 - (size & 3) & 3;
  return bytes;
}
function parse_ClipboardData(blob) {
  var o = {};
  o.Size = blob.read_shift(4);
  blob.l += o.Size + 3 - (o.Size - 1) % 4;
  return o;
}
function parse_TypedPropertyValue(blob, type, _opts) {
  var t2 = blob.read_shift(2), ret, opts = _opts || {};
  blob.l += 2;
  if (type !== VT_VARIANT) {
    if (t2 !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t2 & 65534) == 4126))
      throw new Error("Expected type " + type + " saw " + t2);
  }
  switch (type === VT_VARIANT ? t2 : type) {
    case 2:
      ret = blob.read_shift(2, "i");
      if (!opts.raw)
        blob.l += 2;
      return ret;
    case 3:
      ret = blob.read_shift(4, "i");
      return ret;
    case 11:
      return blob.read_shift(4) !== 0;
    case 19:
      ret = blob.read_shift(4);
      return ret;
    case 30:
      return parse_lpstr(blob, t2, 4).replace(chr0, "");
    case 31:
      return parse_lpwstr(blob);
    case 64:
      return parse_FILETIME(blob);
    case 65:
      return parse_BLOB(blob);
    case 71:
      return parse_ClipboardData(blob);
    case 80:
      return parse_VtString(blob, t2, !opts.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        blob,
        t2
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(blob);
    case 4126:
    case 4127:
      return t2 == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + t2);
  }
}
function write_TypedPropertyValue(type, value) {
  var o = new_buf(4), p = new_buf(4);
  o.write_shift(4, type == 80 ? 31 : type);
  switch (type) {
    case 3:
      p.write_shift(-4, value);
      break;
    case 5:
      p = new_buf(8);
      p.write_shift(8, value, "f");
      break;
    case 11:
      p.write_shift(4, value ? 1 : 0);
      break;
    case 64:
      p = write_FILETIME(value);
      break;
    case 31:
    case 80:
      p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      p.write_shift(4, value.length + 1);
      p.write_shift(0, value, "dbcs");
      while (p.l != p.length)
        p.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
  }
  return bconcat([o, p]);
}
function parse_PropertySet(blob, PIDSI) {
  var start_addr = blob.l;
  var size = blob.read_shift(4);
  var NumProps = blob.read_shift(4);
  var Props = [], i = 0;
  var CodePage = 0;
  var Dictionary = -1, DictObj = {};
  for (i = 0; i != NumProps; ++i) {
    var PropID = blob.read_shift(4);
    var Offset = blob.read_shift(4);
    Props[i] = [PropID, Offset + start_addr];
  }
  Props.sort(function(x, y) {
    return x[1] - y[1];
  });
  var PropH = {};
  for (i = 0; i != NumProps; ++i) {
    if (blob.l !== Props[i][1]) {
      var fail = true;
      if (i > 0 && PIDSI)
        switch (PIDSI[Props[i - 1][0]].t) {
          case 2:
            if (blob.l + 2 === Props[i][1]) {
              blob.l += 2;
              fail = false;
            }
            break;
          case 80:
            if (blob.l <= Props[i][1]) {
              blob.l = Props[i][1];
              fail = false;
            }
            break;
          case 4108:
            if (blob.l <= Props[i][1]) {
              blob.l = Props[i][1];
              fail = false;
            }
            break;
        }
      if ((!PIDSI || i == 0) && blob.l <= Props[i][1]) {
        fail = false;
        blob.l = Props[i][1];
      }
      if (fail)
        throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i);
    }
    if (PIDSI) {
      var piddsi = PIDSI[Props[i][0]];
      PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
      if (piddsi.p === "version")
        PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
      if (piddsi.n == "CodePage")
        switch (PropH[piddsi.n]) {
          case 0:
            PropH[piddsi.n] = 1252;
          case 874:
          case 932:
          case 936:
          case 949:
          case 950:
          case 1250:
          case 1251:
          case 1253:
          case 1254:
          case 1255:
          case 1256:
          case 1257:
          case 1258:
          case 1e4:
          case 1200:
          case 1201:
          case 1252:
          case 65e3:
          case -536:
          case 65001:
          case -535:
            set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
            break;
          default:
            throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
        }
    } else {
      if (Props[i][0] === 1) {
        CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
        set_cp(CodePage);
        if (Dictionary !== -1) {
          var oldpos = blob.l;
          blob.l = Props[Dictionary][1];
          DictObj = parse_dictionary(blob, CodePage);
          blob.l = oldpos;
        }
      } else if (Props[i][0] === 0) {
        if (CodePage === 0) {
          Dictionary = i;
          blob.l = Props[i + 1][1];
          continue;
        }
        DictObj = parse_dictionary(blob, CodePage);
      } else {
        var name = DictObj[Props[i][0]];
        var val;
        switch (blob[blob.l]) {
          case 65:
            blob.l += 4;
            val = parse_BLOB(blob);
            break;
          case 30:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 31:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 3:
            blob.l += 4;
            val = blob.read_shift(4, "i");
            break;
          case 19:
            blob.l += 4;
            val = blob.read_shift(4);
            break;
          case 5:
            blob.l += 4;
            val = blob.read_shift(8, "f");
            break;
          case 11:
            blob.l += 4;
            val = parsebool(blob, 4);
            break;
          case 64:
            blob.l += 4;
            val = parseDate(parse_FILETIME(blob));
            break;
          default:
            throw new Error("unparsed value: " + blob[blob.l]);
        }
        PropH[name] = val;
      }
    }
  }
  blob.l = start_addr + size;
  return PropH;
}
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(val) {
  switch (typeof val) {
    case "boolean":
      return 11;
    case "number":
      return (val | 0) == val ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (val instanceof Date)
        return 64;
      break;
  }
  return -1;
}
function write_PropertySet(entries, RE, PIDSI) {
  var hdr = new_buf(8), piao = [], prop = [];
  var sz = 8, i = 0;
  var pr = new_buf(8), pio = new_buf(8);
  pr.write_shift(4, 2);
  pr.write_shift(4, 1200);
  pio.write_shift(4, 1);
  prop.push(pr);
  piao.push(pio);
  sz += 8 + pr.length;
  if (!RE) {
    pio = new_buf(8);
    pio.write_shift(4, 0);
    piao.unshift(pio);
    var bufs = [new_buf(4)];
    bufs[0].write_shift(4, entries.length);
    for (i = 0; i < entries.length; ++i) {
      var value = entries[i][0];
      pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      pr.write_shift(4, i + 2);
      pr.write_shift(4, value.length + 1);
      pr.write_shift(0, value, "dbcs");
      while (pr.l != pr.length)
        pr.write_shift(1, 0);
      bufs.push(pr);
    }
    pr = bconcat(bufs);
    prop.unshift(pr);
    sz += 8 + pr.length;
  }
  for (i = 0; i < entries.length; ++i) {
    if (RE && !RE[entries[i][0]])
      continue;
    if (XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1)
      continue;
    if (entries[i][1] == null)
      continue;
    var val = entries[i][1], idx = 0;
    if (RE) {
      idx = +RE[entries[i][0]];
      var pinfo = PIDSI[idx];
      if (pinfo.p == "version" && typeof val == "string") {
        var arr = val.split(".");
        val = (+arr[0] << 16) + (+arr[1] || 0);
      }
      pr = write_TypedPropertyValue(pinfo.t, val);
    } else {
      var T = guess_property_type(val);
      if (T == -1) {
        T = 31;
        val = String(val);
      }
      pr = write_TypedPropertyValue(T, val);
    }
    prop.push(pr);
    pio = new_buf(8);
    pio.write_shift(4, !RE ? 2 + i : idx);
    piao.push(pio);
    sz += 8 + pr.length;
  }
  var w = 8 * (prop.length + 1);
  for (i = 0; i < prop.length; ++i) {
    piao[i].write_shift(4, w);
    w += prop[i].length;
  }
  hdr.write_shift(4, sz);
  hdr.write_shift(4, prop.length);
  return bconcat([hdr].concat(piao).concat(prop));
}
function parse_PropertySetStream(file, PIDSI, clsid) {
  var blob = file.content;
  if (!blob)
    return {};
  prep_blob(blob, 0);
  var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
  blob.chk("feff", "Byte Order: ");
  blob.read_shift(2);
  var SystemIdentifier = blob.read_shift(4);
  var CLSID = blob.read_shift(16);
  if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid)
    throw new Error("Bad PropertySet CLSID " + CLSID);
  NumSets = blob.read_shift(4);
  if (NumSets !== 1 && NumSets !== 2)
    throw new Error("Unrecognized #Sets: " + NumSets);
  FMTID0 = blob.read_shift(16);
  Offset0 = blob.read_shift(4);
  if (NumSets === 1 && Offset0 !== blob.l)
    throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
  else if (NumSets === 2) {
    FMTID1 = blob.read_shift(16);
    Offset1 = blob.read_shift(4);
  }
  var PSet0 = parse_PropertySet(blob, PIDSI);
  var rval = { SystemIdentifier };
  for (var y in PSet0)
    rval[y] = PSet0[y];
  rval.FMTID = FMTID0;
  if (NumSets === 1)
    return rval;
  if (Offset1 - blob.l == 2)
    blob.l += 2;
  if (blob.l !== Offset1)
    throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
  var PSet1;
  try {
    PSet1 = parse_PropertySet(blob, null);
  } catch (e) {
  }
  for (y in PSet1)
    rval[y] = PSet1[y];
  rval.FMTID = [FMTID0, FMTID1];
  return rval;
}
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
  var hdr = new_buf(entries2 ? 68 : 48);
  var bufs = [hdr];
  hdr.write_shift(2, 65534);
  hdr.write_shift(2, 0);
  hdr.write_shift(4, 842412599);
  hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
  hdr.write_shift(4, entries2 ? 2 : 1);
  hdr.write_shift(16, clsid, "hex");
  hdr.write_shift(4, entries2 ? 68 : 48);
  var ps0 = write_PropertySet(entries, RE, PIDSI);
  bufs.push(ps0);
  if (entries2) {
    var ps1 = write_PropertySet(entries2, null, null);
    hdr.write_shift(16, clsid2, "hex");
    hdr.write_shift(4, 68 + ps0.length);
    bufs.push(ps1);
  }
  return bconcat(bufs);
}
function parsenoop2(blob, length) {
  blob.read_shift(length);
  return null;
}
function writezeroes(n, o) {
  if (!o)
    o = new_buf(n);
  for (var j = 0; j < n; ++j)
    o.write_shift(1, 0);
  return o;
}
function parslurp(blob, length, cb) {
  var arr = [], target = blob.l + length;
  while (blob.l < target)
    arr.push(cb(blob, target - blob.l));
  if (target !== blob.l)
    throw new Error("Slurp error");
  return arr;
}
function parsebool(blob, length) {
  return blob.read_shift(length) === 1;
}
function writebool(v, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(2, +!!v);
  return o;
}
function parseuint16(blob) {
  return blob.read_shift(2, "u");
}
function writeuint16(v, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(2, v);
  return o;
}
function parseuint16a(blob, length) {
  return parslurp(blob, length, parseuint16);
}
function parse_Bes(blob) {
  var v = blob.read_shift(1), t2 = blob.read_shift(1);
  return t2 === 1 ? v : v === 1;
}
function write_Bes(v, t2, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(1, t2 == "e" ? +v : +!!v);
  o.write_shift(1, t2 == "e" ? 1 : 0);
  return o;
}
function parse_ShortXLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  if (opts && opts.biff >= 8)
    ;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5)
    encoding = "cpstr";
  var o = cch ? blob.read_shift(cch, encoding) : "";
  return o;
}
function parse_XLUnicodeRichExtendedString(blob) {
  var cch = blob.read_shift(2), flags = blob.read_shift(1);
  var fExtSt = flags & 4, fRichSt = flags & 8;
  var width2 = 1 + (flags & 1);
  var cRun = 0, cbExtRst;
  var z = {};
  if (fRichSt)
    cRun = blob.read_shift(2);
  if (fExtSt)
    cbExtRst = blob.read_shift(4);
  var encoding = width2 == 2 ? "dbcs-cont" : "sbcs-cont";
  var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
  if (fRichSt)
    blob.l += 4 * cRun;
  if (fExtSt)
    blob.l += cbExtRst;
  z.t = msg;
  if (!fRichSt) {
    z.raw = "<t>" + z.t + "</t>";
    z.r = z.t;
  }
  return z;
}
function write_XLUnicodeRichExtendedString(xlstr) {
  var str = xlstr.t || "";
  var hdr = new_buf(3 + 0);
  hdr.write_shift(2, str.length);
  hdr.write_shift(1, 0 | 1);
  var otext = new_buf(2 * str.length);
  otext.write_shift(2 * str.length, str, "utf16le");
  var out = [hdr, otext];
  return bconcat(out);
}
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return blob.read_shift(cch, "cpstr");
    if (opts.biff >= 12)
      return blob.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob.read_shift(1);
  if (fHighByte === 0) {
    retval = blob.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
function parse_XLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
function parse_XLUnicodeString2(blob, length, opts) {
  if (opts.biff > 5)
    return parse_XLUnicodeString(blob, length, opts);
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
}
function write_XLUnicodeString(str, opts, o) {
  if (!o)
    o = new_buf(3 + 2 * str.length);
  o.write_shift(2, str.length);
  o.write_shift(1, 1);
  o.write_shift(31, str, "utf16le");
  return o;
}
function parse_ControlInfo(blob) {
  var flags = blob.read_shift(1);
  blob.l++;
  var accel = blob.read_shift(2);
  blob.l += 2;
  return [flags, accel];
}
function parse_URLMoniker(blob) {
  var len = blob.read_shift(4), start = blob.l;
  var extra = false;
  if (len > 24) {
    blob.l += len - 24;
    if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763")
      extra = true;
    blob.l = start;
  }
  var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
  if (extra)
    blob.l += 24;
  return url;
}
function parse_FileMoniker(blob) {
  var cAnti = blob.read_shift(2);
  var preamble = "";
  while (cAnti-- > 0)
    preamble += "../";
  var ansiPath = blob.read_shift(0, "lpstr-ansi");
  blob.l += 2;
  if (blob.read_shift(2) != 57005)
    throw new Error("Bad FileMoniker");
  var sz = blob.read_shift(4);
  if (sz === 0)
    return preamble + ansiPath.replace(/\\/g, "/");
  var bytes = blob.read_shift(4);
  if (blob.read_shift(2) != 3)
    throw new Error("Bad FileMoniker");
  var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
  return preamble + unicodePath;
}
function parse_HyperlinkMoniker(blob, length) {
  var clsid = blob.read_shift(16);
  switch (clsid) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(blob);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(blob);
    default:
      throw new Error("Unsupported Moniker " + clsid);
  }
}
function parse_HyperlinkString(blob) {
  var len = blob.read_shift(4);
  var o = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
  return o;
}
function write_HyperlinkString(str, o) {
  if (!o)
    o = new_buf(6 + str.length * 2);
  o.write_shift(4, 1 + str.length);
  for (var i = 0; i < str.length; ++i)
    o.write_shift(2, str.charCodeAt(i));
  o.write_shift(2, 0);
  return o;
}
function parse_Hyperlink(blob, length) {
  var end = blob.l + length;
  var sVer = blob.read_shift(4);
  if (sVer !== 2)
    throw new Error("Unrecognized streamVersion: " + sVer);
  var flags = blob.read_shift(2);
  blob.l += 2;
  var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
  if (flags & 16)
    displayName = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 128)
    targetFrameName = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 257)
    moniker = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 1)
    oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
  if (flags & 8)
    Loc = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 32)
    guid = blob.read_shift(16);
  if (flags & 64)
    fileTime = parse_FILETIME(
      blob
      /*, 8*/
    );
  blob.l = end;
  var target = targetFrameName || moniker || oleMoniker || "";
  if (target && Loc)
    target += "#" + Loc;
  if (!target)
    target = "#" + Loc;
  if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/")
    target = "file://" + target;
  var out = { Target: target };
  if (guid)
    out.guid = guid;
  if (fileTime)
    out.time = fileTime;
  if (displayName)
    out.Tooltip = displayName;
  return out;
}
function write_Hyperlink(hl) {
  var out = new_buf(512), i = 0;
  var Target = hl.Target;
  if (Target.slice(0, 7) == "file://")
    Target = Target.slice(7);
  var hashidx = Target.indexOf("#");
  var F = hashidx > -1 ? 31 : 23;
  switch (Target.charAt(0)) {
    case "#":
      F = 28;
      break;
    case ".":
      F &= ~2;
      break;
  }
  out.write_shift(4, 2);
  out.write_shift(4, F);
  var data = [8, 6815827, 6619237, 4849780, 83];
  for (i = 0; i < data.length; ++i)
    out.write_shift(4, data[i]);
  if (F == 28) {
    Target = Target.slice(1);
    write_HyperlinkString(Target, out);
  } else if (F & 2) {
    data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (i = 0; i < data.length; ++i)
      out.write_shift(1, parseInt(data[i], 16));
    var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
    out.write_shift(4, 2 * (Pretarget.length + 1));
    for (i = 0; i < Pretarget.length; ++i)
      out.write_shift(2, Pretarget.charCodeAt(i));
    out.write_shift(2, 0);
    if (F & 8)
      write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
  } else {
    data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
    for (i = 0; i < data.length; ++i)
      out.write_shift(1, parseInt(data[i], 16));
    var P = 0;
    while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\")
      ++P;
    out.write_shift(2, P);
    out.write_shift(4, Target.length - 3 * P + 1);
    for (i = 0; i < Target.length - 3 * P; ++i)
      out.write_shift(1, Target.charCodeAt(i + 3 * P) & 255);
    out.write_shift(1, 0);
    out.write_shift(2, 65535);
    out.write_shift(2, 57005);
    for (i = 0; i < 6; ++i)
      out.write_shift(4, 0);
  }
  return out.slice(0, out.l);
}
function parse_LongRGBA(blob) {
  var r = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1);
  return [r, g, b, a];
}
function parse_LongRGB(blob, length) {
  var x = parse_LongRGBA(blob);
  x[3] = 0;
  return x;
}
function parse_XLSCell(blob) {
  var rw = blob.read_shift(2);
  var col = blob.read_shift(2);
  var ixfe = blob.read_shift(2);
  return { r: rw, c: col, ixfe };
}
function write_XLSCell(R, C, ixfe, o) {
  if (!o)
    o = new_buf(6);
  o.write_shift(2, R);
  o.write_shift(2, C);
  o.write_shift(2, ixfe || 0);
  return o;
}
function parse_frtHeader(blob) {
  var rt = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 8;
  return { type: rt, flags };
}
function parse_OptXLUnicodeString(blob, length, opts) {
  return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
}
function parse_XTI(blob, length, opts) {
  var w = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
  return [iSupBook, itabFirst, itabLast];
}
function parse_RkRec(blob) {
  var ixfe = blob.read_shift(2);
  var RK = parse_RkNumber(blob);
  return [ixfe, RK];
}
function parse_AddinUdf(blob, length, opts) {
  blob.l += 4;
  length -= 4;
  var l = blob.l + length;
  var udfName = parse_ShortXLUnicodeString(blob, length, opts);
  var cb = blob.read_shift(2);
  l -= blob.l;
  if (cb !== l)
    throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);
  blob.l += cb;
  return udfName;
}
function parse_Ref8U(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(2);
  var colLast = blob.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
function write_Ref8U(r, o) {
  if (!o)
    o = new_buf(8);
  o.write_shift(2, r.s.r);
  o.write_shift(2, r.e.r);
  o.write_shift(2, r.s.c);
  o.write_shift(2, r.e.c);
  return o;
}
function parse_RefU(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(1);
  var colLast = blob.read_shift(1);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(blob) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 12;
  return [id, ot, flags];
}
function parse_FtNts(blob) {
  var out = {};
  blob.l += 4;
  blob.l += 16;
  out.fSharedNote = blob.read_shift(2);
  blob.l += 4;
  return out;
}
function parse_FtCf(blob) {
  var out = {};
  blob.l += 4;
  blob.cf = blob.read_shift(2);
  return out;
}
function parse_FtSkip(blob) {
  blob.l += 2;
  blob.l += blob.read_shift(2);
}
var FtTab = {
  /*::[*/
  0: parse_FtSkip,
  /* FtEnd */
  /*::[*/
  4: parse_FtSkip,
  /* FtMacro */
  /*::[*/
  5: parse_FtSkip,
  /* FtButton */
  /*::[*/
  6: parse_FtSkip,
  /* FtGmo */
  /*::[*/
  7: parse_FtCf,
  /* FtCf */
  /*::[*/
  8: parse_FtSkip,
  /* FtPioGrbit */
  /*::[*/
  9: parse_FtSkip,
  /* FtPictFmla */
  /*::[*/
  10: parse_FtSkip,
  /* FtCbls */
  /*::[*/
  11: parse_FtSkip,
  /* FtRbo */
  /*::[*/
  12: parse_FtSkip,
  /* FtSbs */
  /*::[*/
  13: parse_FtNts,
  /* FtNts */
  /*::[*/
  14: parse_FtSkip,
  /* FtSbsFmla */
  /*::[*/
  15: parse_FtSkip,
  /* FtGboData */
  /*::[*/
  16: parse_FtSkip,
  /* FtEdoData */
  /*::[*/
  17: parse_FtSkip,
  /* FtRboData */
  /*::[*/
  18: parse_FtSkip,
  /* FtCblsData */
  /*::[*/
  19: parse_FtSkip,
  /* FtLbsData */
  /*::[*/
  20: parse_FtSkip,
  /* FtCblsFmla */
  /*::[*/
  21: parse_FtCmo
};
function parse_FtArray(blob, length) {
  var tgt = blob.l + length;
  var fts = [];
  while (blob.l < tgt) {
    var ft = blob.read_shift(2);
    blob.l -= 2;
    try {
      fts.push(FtTab[ft](blob, tgt - blob.l));
    } catch (e) {
      blob.l = tgt;
      return fts;
    }
  }
  if (blob.l != tgt)
    blob.l = tgt;
  return fts;
}
function parse_BOF(blob, length) {
  var o = { BIFFVer: 0, dt: 0 };
  o.BIFFVer = blob.read_shift(2);
  length -= 2;
  if (length >= 2) {
    o.dt = blob.read_shift(2);
    blob.l -= 2;
  }
  switch (o.BIFFVer) {
    case 1536:
    case 1280:
    case 1024:
    case 768:
    case 512:
    case 2:
    case 7:
      break;
    default:
      if (length > 6)
        throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
  }
  blob.read_shift(length);
  return o;
}
function write_BOF(wb, t2, o) {
  var h3 = 1536, w = 16;
  switch (o.bookType) {
    case "biff8":
      break;
    case "biff5":
      h3 = 1280;
      w = 8;
      break;
    case "biff4":
      h3 = 4;
      w = 6;
      break;
    case "biff3":
      h3 = 3;
      w = 6;
      break;
    case "biff2":
      h3 = 2;
      w = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var out = new_buf(w);
  out.write_shift(2, h3);
  out.write_shift(2, t2);
  if (w > 4)
    out.write_shift(2, 29282);
  if (w > 6)
    out.write_shift(2, 1997);
  if (w > 8) {
    out.write_shift(2, 49161);
    out.write_shift(2, 1);
    out.write_shift(2, 1798);
    out.write_shift(2, 0);
  }
  return out;
}
function parse_InterfaceHdr(blob, length) {
  if (length === 0)
    return 1200;
  if (blob.read_shift(2) !== 1200)
    ;
  return 1200;
}
function parse_WriteAccess(blob, length, opts) {
  if (opts.enc) {
    blob.l += length;
    return "";
  }
  var l = blob.l;
  var UserName = parse_XLUnicodeString2(blob, 0, opts);
  blob.read_shift(length + l - blob.l);
  return UserName;
}
function write_WriteAccess(s, opts) {
  var b8 = !opts || opts.biff == 8;
  var o = new_buf(b8 ? 112 : 54);
  o.write_shift(opts.biff == 8 ? 2 : 1, 7);
  if (b8)
    o.write_shift(1, 0);
  o.write_shift(4, 859007059);
  o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
  while (o.l < o.length)
    o.write_shift(1, b8 ? 0 : 32);
  return o;
}
function parse_WsBool(blob, length, opts) {
  var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
  return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
}
function parse_BoundSheet8(blob, length, opts) {
  var pos = blob.read_shift(4);
  var hidden = blob.read_shift(1) & 3;
  var dt = blob.read_shift(1);
  switch (dt) {
    case 0:
      dt = "Worksheet";
      break;
    case 1:
      dt = "Macrosheet";
      break;
    case 2:
      dt = "Chartsheet";
      break;
    case 6:
      dt = "VBAModule";
      break;
  }
  var name = parse_ShortXLUnicodeString(blob, 0, opts);
  if (name.length === 0)
    name = "Sheet1";
  return { pos, hs: hidden, dt, name };
}
function write_BoundSheet8(data, opts) {
  var w = !opts || opts.biff >= 8 ? 2 : 1;
  var o = new_buf(8 + w * data.name.length);
  o.write_shift(4, data.pos);
  o.write_shift(1, data.hs || 0);
  o.write_shift(1, data.dt);
  o.write_shift(1, data.name.length);
  if (opts.biff >= 8)
    o.write_shift(1, 1);
  o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
  var out = o.slice(0, o.l);
  out.l = o.l;
  return out;
}
function parse_SST(blob, length) {
  var end = blob.l + length;
  var cnt = blob.read_shift(4);
  var ucnt = blob.read_shift(4);
  var strs2 = [];
  for (var i = 0; i != ucnt && blob.l < end; ++i) {
    strs2.push(parse_XLUnicodeRichExtendedString(blob));
  }
  strs2.Count = cnt;
  strs2.Unique = ucnt;
  return strs2;
}
function write_SST(sst, opts) {
  var header = new_buf(8);
  header.write_shift(4, sst.Count);
  header.write_shift(4, sst.Unique);
  var strs2 = [];
  for (var j = 0; j < sst.length; ++j)
    strs2[j] = write_XLUnicodeRichExtendedString(sst[j]);
  var o = bconcat([header].concat(strs2));
  o.parts = [header.length].concat(strs2.map(function(str) {
    return str.length;
  }));
  return o;
}
function parse_ExtSST(blob, length) {
  var extsst = {};
  extsst.dsst = blob.read_shift(2);
  blob.l += length - 2;
  return extsst;
}
function parse_Row(blob) {
  var z = {};
  z.r = blob.read_shift(2);
  z.c = blob.read_shift(2);
  z.cnt = blob.read_shift(2) - z.c;
  var miyRw = blob.read_shift(2);
  blob.l += 4;
  var flags = blob.read_shift(1);
  blob.l += 3;
  if (flags & 7)
    z.level = flags & 7;
  if (flags & 32)
    z.hidden = true;
  if (flags & 64)
    z.hpt = miyRw / 20;
  return z;
}
function parse_ForceFullCalculation(blob) {
  var header = parse_frtHeader(blob);
  if (header.type != 2211)
    throw new Error("Invalid Future Record " + header.type);
  var fullcalc = blob.read_shift(4);
  return fullcalc !== 0;
}
function parse_RecalcId(blob) {
  blob.read_shift(2);
  return blob.read_shift(4);
}
function parse_DefaultRowHeight(blob, length, opts) {
  var f = 0;
  if (!(opts && opts.biff == 2)) {
    f = blob.read_shift(2);
  }
  var miyRw = blob.read_shift(2);
  if (opts && opts.biff == 2) {
    f = 1 - (miyRw >> 15);
    miyRw &= 32767;
  }
  var fl = { Unsynced: f & 1, DyZero: (f & 2) >> 1, ExAsc: (f & 4) >> 2, ExDsc: (f & 8) >> 3 };
  return [fl, miyRw];
}
function parse_Window1(blob) {
  var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
  var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
  var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
  return {
    Pos: [xWn, yWn],
    Dim: [dxWn, dyWn],
    Flags: flags,
    CurTab: iTabCur,
    FirstTab: iTabFirst,
    Selected: ctabSel,
    TabRatio: wTabRatio
  };
}
function write_Window1() {
  var o = new_buf(18);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 29280);
  o.write_shift(2, 17600);
  o.write_shift(2, 56);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 1);
  o.write_shift(2, 500);
  return o;
}
function parse_Window2(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff < 5)
    return {};
  var f = blob.read_shift(2);
  return { RTL: f & 64 };
}
function write_Window2(view) {
  var o = new_buf(18), f = 1718;
  if (view && view.RTL)
    f |= 64;
  o.write_shift(2, f);
  o.write_shift(4, 0);
  o.write_shift(4, 64);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
function parse_Pane() {
}
function parse_Font(blob, length, opts) {
  var o = {
    dyHeight: blob.read_shift(2),
    fl: blob.read_shift(2)
  };
  switch (opts && opts.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      blob.l += 2;
      break;
    default:
      blob.l += 10;
      break;
  }
  o.name = parse_ShortXLUnicodeString(blob, 0, opts);
  return o;
}
function write_Font(data, opts) {
  var name = data.name || "Arial";
  var b5 = opts && opts.biff == 5, w = b5 ? 15 + name.length : 16 + 2 * name.length;
  var o = new_buf(w);
  o.write_shift(2, (data.sz || 12) * 20);
  o.write_shift(4, 0);
  o.write_shift(2, 400);
  o.write_shift(4, 0);
  o.write_shift(2, 0);
  o.write_shift(1, name.length);
  if (!b5)
    o.write_shift(1, 1);
  o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
  return o;
}
function parse_LabelSst(blob) {
  var cell = parse_XLSCell(blob);
  cell.isst = blob.read_shift(4);
  return cell;
}
function write_LabelSst(R, C, v, os) {
  var o = new_buf(10);
  write_XLSCell(R, C, os, o);
  o.write_shift(4, v);
  return o;
}
function parse_Label(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2)
    opts.biff = 5;
  var target = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2)
    blob.l++;
  var str = parse_XLUnicodeString(blob, target - blob.l, opts);
  cell.val = str;
  return cell;
}
function write_Label(R, C, v, os, opts) {
  var b8 = !opts || opts.biff == 8;
  var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
  write_XLSCell(R, C, os, o);
  o.write_shift(2, v.length);
  if (b8)
    o.write_shift(1, 1);
  o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
  return o;
}
function parse_Format(blob, length, opts) {
  var numFmtId = blob.read_shift(2);
  var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
  return [numFmtId, fmtstr];
}
function write_Format(i, f, opts, o) {
  var b5 = opts && opts.biff == 5;
  if (!o)
    o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
  o.write_shift(2, i);
  o.write_shift(b5 ? 1 : 2, f.length);
  if (!b5)
    o.write_shift(1, 1);
  o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
  var out = o.length > o.l ? o.slice(0, o.l) : o;
  if (out.l == null)
    out.l = out.length;
  return out;
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function parse_Dimensions(blob, length, opts) {
  var end = blob.l + length;
  var w = opts.biff == 8 || !opts.biff ? 4 : 2;
  var r = blob.read_shift(w), R = blob.read_shift(w);
  var c = blob.read_shift(2), C = blob.read_shift(2);
  blob.l = end;
  return { s: { r, c }, e: { r: R, c: C } };
}
function write_Dimensions(range, opts) {
  var w = opts.biff == 8 || !opts.biff ? 4 : 2;
  var o = new_buf(2 * w + 6);
  o.write_shift(w, range.s.r);
  o.write_shift(w, range.e.r + 1);
  o.write_shift(2, range.s.c);
  o.write_shift(2, range.e.c + 1);
  o.write_shift(2, 0);
  return o;
}
function parse_RK(blob) {
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrec = parse_RkRec(blob);
  return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
}
function parse_MulRk(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrecs = [];
  while (blob.l < target)
    rkrecs.push(parse_RkRec(blob));
  if (blob.l !== target)
    throw new Error("MulRK read error");
  var lastcol = blob.read_shift(2);
  if (rkrecs.length != lastcol - col + 1)
    throw new Error("MulRK length mismatch");
  return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
}
function parse_MulBlank(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var ixfes = [];
  while (blob.l < target)
    ixfes.push(blob.read_shift(2));
  if (blob.l !== target)
    throw new Error("MulBlank read error");
  var lastcol = blob.read_shift(2);
  if (ixfes.length != lastcol - col + 1)
    throw new Error("MulBlank length mismatch");
  return { r: rw, c: col, C: lastcol, ixfe: ixfes };
}
function parse_CellStyleXF(blob, length, style, opts) {
  var o = {};
  var a = blob.read_shift(4), b = blob.read_shift(4);
  var c = blob.read_shift(4), d = blob.read_shift(2);
  o.patternType = XLSFillPattern[c >> 26];
  if (!opts.cellStyles)
    return o;
  o.alc = a & 7;
  o.fWrap = a >> 3 & 1;
  o.alcV = a >> 4 & 7;
  o.fJustLast = a >> 7 & 1;
  o.trot = a >> 8 & 255;
  o.cIndent = a >> 16 & 15;
  o.fShrinkToFit = a >> 20 & 1;
  o.iReadOrder = a >> 22 & 2;
  o.fAtrNum = a >> 26 & 1;
  o.fAtrFnt = a >> 27 & 1;
  o.fAtrAlc = a >> 28 & 1;
  o.fAtrBdr = a >> 29 & 1;
  o.fAtrPat = a >> 30 & 1;
  o.fAtrProt = a >> 31 & 1;
  o.dgLeft = b & 15;
  o.dgRight = b >> 4 & 15;
  o.dgTop = b >> 8 & 15;
  o.dgBottom = b >> 12 & 15;
  o.icvLeft = b >> 16 & 127;
  o.icvRight = b >> 23 & 127;
  o.grbitDiag = b >> 30 & 3;
  o.icvTop = c & 127;
  o.icvBottom = c >> 7 & 127;
  o.icvDiag = c >> 14 & 127;
  o.dgDiag = c >> 21 & 15;
  o.icvFore = d & 127;
  o.icvBack = d >> 7 & 127;
  o.fsxButton = d >> 14 & 1;
  return o;
}
function parse_XF(blob, length, opts) {
  var o = {};
  o.ifnt = blob.read_shift(2);
  o.numFmtId = blob.read_shift(2);
  o.flags = blob.read_shift(2);
  o.fStyle = o.flags >> 2 & 1;
  length -= 6;
  o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);
  return o;
}
function write_XF(data, ixfeP, opts, o) {
  var b5 = opts && opts.biff == 5;
  if (!o)
    o = new_buf(b5 ? 16 : 20);
  o.write_shift(2, 0);
  if (data.style) {
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, 65524);
  } else {
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, ixfeP << 4);
  }
  var f = 0;
  if (data.numFmtId > 0 && b5)
    f |= 1024;
  o.write_shift(4, f);
  o.write_shift(4, 0);
  if (!b5)
    o.write_shift(4, 0);
  o.write_shift(2, 0);
  return o;
}
function parse_Guts(blob) {
  blob.l += 4;
  var out = [blob.read_shift(2), blob.read_shift(2)];
  if (out[0] !== 0)
    out[0]--;
  if (out[1] !== 0)
    out[1]--;
  if (out[0] > 7 || out[1] > 7)
    throw new Error("Bad Gutters: " + out.join("|"));
  return out;
}
function write_Guts(guts) {
  var o = new_buf(8);
  o.write_shift(4, 0);
  o.write_shift(2, guts[0] ? guts[0] + 1 : 0);
  o.write_shift(2, guts[1] ? guts[1] + 1 : 0);
  return o;
}
function parse_BoolErr(blob, length, opts) {
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2 || length == 9)
    ++blob.l;
  var val = parse_Bes(blob);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function write_BoolErr(R, C, v, os, opts, t2) {
  var o = new_buf(8);
  write_XLSCell(R, C, os, o);
  write_Bes(v, t2, o);
  return o;
}
function parse_Number(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2)
    opts.biff = 5;
  var cell = parse_XLSCell(blob);
  var xnum = parse_Xnum(blob);
  cell.val = xnum;
  return cell;
}
function write_Number(R, C, v, os) {
  var o = new_buf(14);
  write_XLSCell(R, C, os, o);
  write_Xnum(v, o);
  return o;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(blob, length, opts) {
  var end = blob.l + length;
  var ctab = blob.read_shift(2);
  var cch = blob.read_shift(2);
  opts.sbcch = cch;
  if (cch == 1025 || cch == 14849)
    return [cch, ctab];
  if (cch < 1 || cch > 255)
    throw new Error("Unexpected SupBook type: " + cch);
  var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
  var rgst = [];
  while (end > blob.l)
    rgst.push(parse_XLUnicodeString(blob));
  return [cch, ctab, virtPath, rgst];
}
function parse_ExternName(blob, length, opts) {
  var flags = blob.read_shift(2);
  var body;
  var o = {
    fBuiltIn: flags & 1,
    fWantAdvise: flags >>> 1 & 1,
    fWantPict: flags >>> 2 & 1,
    fOle: flags >>> 3 & 1,
    fOleLink: flags >>> 4 & 1,
    cf: flags >>> 5 & 1023,
    fIcon: flags >>> 15 & 1
  };
  if (opts.sbcch === 14849)
    body = parse_AddinUdf(blob, length - 2, opts);
  o.body = body || blob.read_shift(length - 2);
  if (typeof body === "string")
    o.Name = body;
  return o;
}
var XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
function parse_Lbl(blob, length, opts) {
  var target = blob.l + length;
  var flags = blob.read_shift(2);
  var chKey = blob.read_shift(1);
  var cch = blob.read_shift(1);
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var itab = 0;
  if (!opts || opts.biff >= 5) {
    if (opts.biff != 5)
      blob.l += 2;
    itab = blob.read_shift(2);
    if (opts.biff == 5)
      blob.l += 2;
    blob.l += 4;
  }
  var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
  if (flags & 32)
    name = XLSLblBuiltIn[name.charCodeAt(0)];
  var npflen = target - blob.l;
  if (opts && opts.biff == 2)
    --npflen;
  var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
  return {
    chKey,
    Name: name,
    itab,
    rgce
  };
}
function parse_ExternSheet(blob, length, opts) {
  if (opts.biff < 8)
    return parse_BIFF5ExternSheet(blob, length, opts);
  var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0)
    o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  if (blob.l != target)
    throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  return o;
}
function parse_BIFF5ExternSheet(blob, length, opts) {
  if (blob[blob.l + 1] == 3)
    blob[blob.l]++;
  var o = parse_ShortXLUnicodeString(blob, length, opts);
  return o.charCodeAt(0) == 3 ? o.slice(1) : o;
}
function parse_NameCmt(blob, length, opts) {
  if (opts.biff < 8) {
    blob.l += length;
    return;
  }
  var cchName = blob.read_shift(2);
  var cchComment = blob.read_shift(2);
  var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
  var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
  return [name, comment];
}
function parse_ShrFmla(blob, length, opts) {
  var ref2 = parse_RefU(blob);
  blob.l++;
  var cUse = blob.read_shift(1);
  length -= 8;
  return [parse_SharedParsedFormula(blob, length, opts), cUse, ref2];
}
function parse_Array(blob, length, opts) {
  var ref2 = parse_Ref(blob);
  switch (opts.biff) {
    case 2:
      blob.l++;
      length -= 7;
      break;
    case 3:
    case 4:
      blob.l += 2;
      length -= 8;
      break;
    default:
      blob.l += 6;
      length -= 12;
  }
  return [ref2, parse_ArrayParsedFormula(blob, length, opts)];
}
function parse_MTRSettings(blob) {
  var fMTREnabled = blob.read_shift(4) !== 0;
  var fUserSetThreadCount = blob.read_shift(4) !== 0;
  var cUserThreadCount = blob.read_shift(4);
  return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}
function parse_NoteSh(blob, length, opts) {
  if (opts.biff < 8)
    return;
  var row = blob.read_shift(2), col = blob.read_shift(2);
  var flags = blob.read_shift(2), idObj = blob.read_shift(2);
  var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
  if (opts.biff < 8)
    blob.read_shift(1);
  return [{ r: row, c: col }, stAuthor, idObj, flags];
}
function parse_Note(blob, length, opts) {
  return parse_NoteSh(blob, length, opts);
}
function parse_MergeCells(blob, length) {
  var merges = [];
  var cmcs = blob.read_shift(2);
  while (cmcs--)
    merges.push(parse_Ref8U(blob));
  return merges;
}
function write_MergeCells(merges) {
  var o = new_buf(2 + merges.length * 8);
  o.write_shift(2, merges.length);
  for (var i = 0; i < merges.length; ++i)
    write_Ref8U(merges[i], o);
  return o;
}
function parse_Obj(blob, length, opts) {
  if (opts && opts.biff < 8)
    return parse_BIFF5Obj(blob, length, opts);
  var cmo = parse_FtCmo(blob);
  var fts = parse_FtArray(blob, length - 22, cmo[1]);
  return { cmo, ft: fts };
}
var parse_BIFF5OT = {
  8: function(blob, length) {
    var tgt = blob.l + length;
    blob.l += 10;
    var cf = blob.read_shift(2);
    blob.l += 4;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 4;
    var cchName = blob.read_shift(1);
    blob.l += cchName;
    blob.l = tgt;
    return { fmt: cf };
  }
};
function parse_BIFF5Obj(blob, length, opts) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id = blob.read_shift(2);
  var grbit = blob.read_shift(2);
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 6;
  length -= 36;
  var fts = [];
  fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
  return { cmo: [id, ot, grbit], ft: fts };
}
function parse_TxO(blob, length, opts) {
  var s = blob.l;
  var texts = "";
  try {
    blob.l += 4;
    var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
    var controlInfo;
    if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1)
      blob.l += 6;
    else
      controlInfo = parse_ControlInfo(blob, 6, opts);
    var cchText = blob.read_shift(2);
    blob.read_shift(2);
    parseuint16(blob, 2);
    var len = blob.read_shift(2);
    blob.l += len;
    for (var i = 1; i < blob.lens.length - 1; ++i) {
      if (blob.l - s != blob.lens[i])
        throw new Error("TxO: bad continue record");
      var hdr = blob[blob.l];
      var t2 = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
      texts += t2;
      if (texts.length >= (hdr ? cchText : 2 * cchText))
        break;
    }
    if (texts.length !== cchText && texts.length !== cchText * 2) {
      throw new Error("cchText: " + cchText + " != " + texts.length);
    }
    blob.l = s + length;
    return { t: texts };
  } catch (e) {
    blob.l = s + length;
    return { t: texts };
  }
}
function parse_HLink(blob, length) {
  var ref2 = parse_Ref8U(blob);
  blob.l += 16;
  var hlink = parse_Hyperlink(blob, length - 24);
  return [ref2, hlink];
}
function write_HLink(hl) {
  var O = new_buf(24);
  var ref2 = decode_cell(hl[0]);
  O.write_shift(2, ref2.r);
  O.write_shift(2, ref2.r);
  O.write_shift(2, ref2.c);
  O.write_shift(2, ref2.c);
  var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  for (var i = 0; i < 16; ++i)
    O.write_shift(1, parseInt(clsid[i], 16));
  return bconcat([O, write_Hyperlink(hl[1])]);
}
function parse_HLinkTooltip(blob, length) {
  blob.read_shift(2);
  var ref2 = parse_Ref8U(blob);
  var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
  wzTooltip = wzTooltip.replace(chr0, "");
  return [ref2, wzTooltip];
}
function write_HLinkTooltip(hl) {
  var TT = hl[1].Tooltip;
  var O = new_buf(10 + 2 * (TT.length + 1));
  O.write_shift(2, 2048);
  var ref2 = decode_cell(hl[0]);
  O.write_shift(2, ref2.r);
  O.write_shift(2, ref2.r);
  O.write_shift(2, ref2.c);
  O.write_shift(2, ref2.c);
  for (var i = 0; i < TT.length; ++i)
    O.write_shift(2, TT.charCodeAt(i));
  O.write_shift(2, 0);
  return O;
}
function parse_Country(blob) {
  var o = [0, 0], d;
  d = blob.read_shift(2);
  o[0] = CountryEnum[d] || d;
  d = blob.read_shift(2);
  o[1] = CountryEnum[d] || d;
  return o;
}
function write_Country(o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(2, 1);
  o.write_shift(2, 1);
  return o;
}
function parse_ClrtClient(blob) {
  var ccv = blob.read_shift(2);
  var o = [];
  while (ccv-- > 0)
    o.push(parse_LongRGB(blob));
  return o;
}
function parse_Palette(blob) {
  var ccv = blob.read_shift(2);
  var o = [];
  while (ccv-- > 0)
    o.push(parse_LongRGB(blob));
  return o;
}
function parse_XFCRC(blob) {
  blob.l += 2;
  var o = { cxfs: 0, crc: 0 };
  o.cxfs = blob.read_shift(2);
  o.crc = blob.read_shift(4);
  return o;
}
function parse_ColInfo(blob, length, opts) {
  if (!opts.cellStyles)
    return parsenoop(blob, length);
  var w = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob.read_shift(w);
  var colLast = blob.read_shift(w);
  var coldx = blob.read_shift(w);
  var ixfe = blob.read_shift(w);
  var flags = blob.read_shift(2);
  if (w == 2)
    blob.l += 2;
  var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff)
    o.level = flags >> 8 & 7;
  return o;
}
function write_ColInfo(col, idx) {
  var o = new_buf(12);
  o.write_shift(2, idx);
  o.write_shift(2, idx);
  o.write_shift(2, col.width * 256);
  o.write_shift(2, 0);
  var f = 0;
  if (col.hidden)
    f |= 1;
  o.write_shift(1, f);
  f = col.level || 0;
  o.write_shift(1, f);
  o.write_shift(2, 0);
  return o;
}
function parse_Setup(blob, length) {
  var o = {};
  if (length < 32)
    return o;
  blob.l += 16;
  o.header = parse_Xnum(blob);
  o.footer = parse_Xnum(blob);
  blob.l += 2;
  return o;
}
function parse_ShtProps(blob, length, opts) {
  var def = { area: false };
  if (opts.biff != 5) {
    blob.l += length;
    return def;
  }
  var d = blob.read_shift(1);
  blob.l += 3;
  if (d & 16)
    def.area = true;
  return def;
}
function write_RRTabId(n) {
  var out = new_buf(2 * n);
  for (var i = 0; i < n; ++i)
    out.write_shift(2, i + 1);
  return out;
}
var parse_Blank = parse_XLSCell;
var parse_Scl = parseuint16a;
var parse_String = parse_XLUnicodeString;
function parse_ImData(blob) {
  var cf = blob.read_shift(2);
  var env = blob.read_shift(2);
  var lcb = blob.read_shift(4);
  var o = { fmt: cf, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
  blob.l += lcb;
  return o;
}
function parse_BIFF2STR(blob, length, opts) {
  if (opts.biffguess && opts.biff == 5)
    opts.biff = 2;
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var str = parse_XLUnicodeString2(blob, length - 7, opts);
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF2NUM(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = parse_Xnum(blob);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2NUM(r, c, val) {
  var out = new_buf(15);
  write_BIFF2Cell(out, r, c);
  out.write_shift(8, val, "f");
  return out;
}
function parse_BIFF2INT(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = blob.read_shift(2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2INT(r, c, val) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c);
  out.write_shift(2, val);
  return out;
}
function parse_BIFF2STRING(blob) {
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, "sbcs-cont");
}
function parse_BIFF2FONTXTRA(blob, length) {
  blob.l += 6;
  blob.l += 2;
  blob.l += 1;
  blob.l += 3;
  blob.l += 1;
  blob.l += length - 13;
}
function parse_RString(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  var cch = blob.read_shift(2);
  var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
  blob.l = end;
  cell.t = "str";
  cell.val = str;
  return cell;
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
var DBF = /* @__PURE__ */ function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  };
  var dbf_reverse_map = evert({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d = s2a(Base64_decode(buf));
        break;
      case "binary":
        d = s2a(buf);
        break;
      case "buffer":
      case "array":
        d = buf;
        break;
    }
    prep_blob(d, 0);
    var ft = d.read_shift(1);
    var memo = !!(ft & 136);
    var vfp = false, l7 = false;
    switch (ft) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        vfp = true;
        memo = true;
        break;
      case 49:
        vfp = true;
        memo = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        l7 = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + ft.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft == 2)
      nrow = d.read_shift(2);
    d.l += 3;
    if (ft != 2)
      nrow = d.read_shift(4);
    if (nrow > 1048576)
      nrow = 1e6;
    if (ft != 2)
      fpos = d.read_shift(2);
    var rlen = d.read_shift(2);
    var current_cp = opts.codepage || 1252;
    if (ft != 2) {
      d.l += 16;
      d.read_shift(1);
      if (d[d.l] !== 0)
        current_cp = dbf_codepage_map[d[d.l]];
      d.l += 1;
      d.l += 2;
    }
    if (l7)
      d.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d.l < hend && d[d.l] != 13) {
      field = {};
      field.name = $cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
      d.l += ww;
      field.type = String.fromCharCode(d.read_shift(1));
      if (ft != 2 && !l7)
        field.offset = d.read_shift(4);
      field.len = d.read_shift(1);
      if (ft == 2)
        field.offset = d.read_shift(2);
      field.dec = d.read_shift(1);
      if (field.name.length)
        fields.push(field);
      if (ft != 2)
        d.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        case "P":
          if (opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d[d.l] !== 13)
      d.l = fpos - 1;
    if (d.read_shift(1) !== 13)
      throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
    d.l = fpos;
    var R = 0, C = 0;
    out[0] = [];
    for (C = 0; C != fields.length; ++C)
      out[0][C] = fields[C].name;
    while (nrow-- > 0) {
      if (d[d.l] === 42) {
        d.l += rlen;
        continue;
      }
      ++d.l;
      out[++R] = [];
      C = 0;
      for (C = 0; C != fields.length; ++C) {
        var dd = d.slice(d.l, d.l + fields[C].len);
        d.l += fields[C].len;
        prep_blob(dd, 0);
        var s = $cptable.utils.decode(current_cp, dd);
        switch (fields[C].type) {
          case "C":
            if (s.trim().length)
              out[R][C] = s.replace(/\s+$/, "");
            break;
          case "D":
            if (s.length === 8)
              out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8));
            else
              out[R][C] = s;
            break;
          case "F":
            out[R][C] = parseFloat(s.trim());
            break;
          case "+":
          case "I":
            out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
            break;
          case "L":
            switch (s.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R][C] = true;
                break;
              case "N":
              case "F":
                out[R][C] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s + "|");
            }
            break;
          case "M":
            if (!memo)
              throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
            out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
            break;
          case "N":
            s = s.replace(/\u0000/g, "").trim();
            if (s && s != ".")
              out[R][C] = +s || 0;
            break;
          case "@":
            out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
            break;
          case "Y":
            out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R][C] = -dd.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C].len == 8) {
              out[R][C] = dd.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            dd.l += fields[C].len;
            break;
          case "0":
            if (fields[C].name === "_NullFlags")
              break;
          default:
            throw new Error("DBF Unsupported data type " + fields[C].type);
        }
      }
    }
    if (ft != 2) {
      if (d.l < d.length && d[d.l++] != 26)
        throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
    }
    if (opts && opts.sheetRows)
      out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  function dbf_to_sheet(buf, opts) {
    var o = opts || {};
    if (!o.dateNF)
      o.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
    ws["!cols"] = o.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o.DBF;
    return ws;
  }
  function dbf_to_workbook(buf, opts) {
    try {
      return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
    } catch (e) {
      if (opts && opts.WTF)
        throw e;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    var o = opts || {};
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i = 0, j = 0, hcnt = 0, rlen = 1;
    for (i = 0; i < headers.length; ++i) {
      if (((cols[i] || {}).DBF || {}).name) {
        headers[i] = cols[i].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i] == null)
        continue;
      ++hcnt;
      if (typeof headers[i] === "number")
        headers[i] = headers[i].toString(10);
      if (typeof headers[i] !== "string")
        throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
      if (headers.indexOf(headers[i]) !== i) {
        for (j = 0; j < 1024; ++j)
          if (headers.indexOf(headers[i] + "_" + j) == -1) {
            headers[i] += "_" + j;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i = 0; i <= range.e.c - range.s.c; ++i) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j = 0; j < data.length; ++j) {
        if (data[j][i] != null)
          col.push(data[j][i]);
      }
      if (col.length == 0 || headers[i] == null) {
        coltypes[i] = "?";
        continue;
      }
      for (j = 0; j < col.length; ++j) {
        switch (typeof col[j]) {
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250)
        maxlen = 250;
      _guess = ((cols[i] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i].DBF.len > maxlen)
          maxlen = cols[i].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i] = cols[i].DBF.dec;
        maxlen = cols[i].DBF.len;
      }
      colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i];
      coltypes[i] = guess;
    }
    var h3 = ba.next(32);
    h3.write_shift(4, 318902576);
    h3.write_shift(4, data.length);
    h3.write_shift(2, 296 + 32 * hcnt);
    h3.write_shift(2, rlen);
    for (i = 0; i < 4; ++i)
      h3.write_shift(4, 0);
    h3.write_shift(4, 0 | (+dbf_reverse_map[
      /*::String(*/
      current_ansi
      /*::)*/
    ] || 3) << 8);
    for (i = 0, j = 0; i < headers.length; ++i) {
      if (headers[i] == null)
        continue;
      var hf = ba.next(32);
      var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
      hf.write_shift(4, j);
      hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
      hf.write_shift(1, coldecimals[i] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j += colwidths[i] || _RLEN[coltypes[i]] || 0;
    }
    var hb = ba.next(264);
    hb.write_shift(4, 13);
    for (i = 0; i < 65; ++i)
      hb.write_shift(4, 0);
    for (i = 0; i < data.length; ++i) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j = 0; j < headers.length; ++j) {
        if (headers[j] == null)
          continue;
        switch (coltypes[j]) {
          case "L":
            rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i][j] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i][j] == "number")
              _n = data[i][j].toFixed(coldecimals[j] || 0);
            for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt)
              rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i][j])
              rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
            rout.write_shift(1, _s, "sbcs");
            for (hcnt = 0; hcnt < colwidths[j] - _s.length; ++hcnt)
              rout.write_shift(1, 32);
            break;
        }
      }
    }
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
}();
var SYLK = /* @__PURE__ */ function() {
  var sylk_escapes = {
    AA: "",
    BA: "",
    CA: "",
    DA: 195,
    HA: "",
    JA: 197,
    AE: "",
    BE: "",
    CE: "",
    HE: "",
    AI: "",
    BI: "",
    CI: "",
    HI: "",
    AO: "",
    BO: "",
    CO: "",
    DO: 213,
    HO: "",
    AU: "",
    BU: "",
    CU: "",
    HU: "",
    Aa: "",
    Ba: "",
    Ca: "",
    Da: 227,
    Ha: "",
    Ja: 229,
    Ae: "",
    Be: "",
    Ce: "",
    He: "",
    Ai: "",
    Bi: "",
    Ci: "",
    Hi: "",
    Ao: "",
    Bo: "",
    Co: "",
    Do: 245,
    Ho: "",
    Au: "",
    Bu: "",
    Cu: "",
    Hu: "",
    KC: "",
    Kc: "",
    q: "",
    z: "",
    a: "",
    j: "",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  var sylk_char_fn = function(_, $1) {
    var o = sylk_escapes[$1];
    return typeof o == "number" ? _getansi(o) : o;
  };
  var decode_sylk_char = function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  };
  sylk_escapes["|"] = 254;
  function sylk_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return sylk_to_aoa_str(d, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j;
    if (+opts.codepage >= 0)
      set_cp(+opts.codepage);
    for (; ri !== records.length; ++ri) {
      Mval = 0;
      var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
        return x.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0)
        switch (RT) {
          case "ID":
            break;
          case "E":
            break;
          case "B":
            break;
          case "O":
            break;
          case "W":
            break;
          case "P":
            if (record[1].charAt(0) == "P")
              formats.push(rstr.slice(3).replace(/;;/g, ";"));
            break;
          case "C":
            var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "A":
                  break;
                case "X":
                  C = parseInt(record[rj].slice(1)) - 1;
                  C_seen_X = true;
                  break;
                case "Y":
                  R = parseInt(record[rj].slice(1)) - 1;
                  if (!C_seen_X)
                    C = 0;
                  for (j = arr.length; j <= R; ++j)
                    arr[j] = [];
                  break;
                case "K":
                  val = record[rj].slice(1);
                  if (val.charAt(0) === '"')
                    val = val.slice(1, val.length - 1);
                  else if (val === "TRUE")
                    val = true;
                  else if (val === "FALSE")
                    val = false;
                  else if (!isNaN(fuzzynum(val))) {
                    val = fuzzynum(val);
                    if (next_cell_format !== null && fmt_is_date(next_cell_format))
                      val = numdate(val);
                  } else if (!isNaN(fuzzydate(val).getDate())) {
                    val = parseDate(val);
                  }
                  C_seen_K = true;
                  break;
                case "E":
                  C_seen_E = true;
                  var formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                  arr[R][C] = [arr[R][C], formula];
                  break;
                case "S":
                  C_seen_S = true;
                  arr[R][C] = [arr[R][C], "S5S"];
                  break;
                case "G":
                  break;
                case "R":
                  _R = parseInt(record[rj].slice(1)) - 1;
                  break;
                case "C":
                  _C = parseInt(record[rj].slice(1)) - 1;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (C_seen_K) {
              if (arr[R][C] && arr[R][C].length == 2)
                arr[R][C][0] = val;
              else
                arr[R][C] = val;
              next_cell_format = null;
            }
            if (C_seen_S) {
              if (C_seen_E)
                throw new Error("SYLK shared formula cannot have own formula");
              var shrbase = _R > -1 && arr[_R][_C];
              if (!shrbase || !shrbase[1])
                throw new Error("SYLK shared formula cannot find base");
              arr[R][C][1] = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
            }
            break;
          case "F":
            var F_seen = 0;
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "X":
                  C = parseInt(record[rj].slice(1)) - 1;
                  ++F_seen;
                  break;
                case "Y":
                  R = parseInt(record[rj].slice(1)) - 1;
                  for (j = arr.length; j <= R; ++j)
                    arr[j] = [];
                  break;
                case "M":
                  Mval = parseInt(record[rj].slice(1)) / 20;
                  break;
                case "F":
                  break;
                case "G":
                  break;
                case "P":
                  next_cell_format = formats[parseInt(record[rj].slice(1))];
                  break;
                case "S":
                  break;
                case "D":
                  break;
                case "N":
                  break;
                case "W":
                  cw = record[rj].slice(1).split(" ");
                  for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                    Mval = parseInt(cw[2], 10);
                    colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                    process_col(colinfo[j - 1]);
                  }
                  break;
                case "C":
                  C = parseInt(record[rj].slice(1)) - 1;
                  if (!colinfo[C])
                    colinfo[C] = {};
                  break;
                case "R":
                  R = parseInt(record[rj].slice(1)) - 1;
                  if (!rowinfo[R])
                    rowinfo[R] = {};
                  if (Mval > 0) {
                    rowinfo[R].hpt = Mval;
                    rowinfo[R].hpx = pt2px(Mval);
                  } else if (Mval === 0)
                    rowinfo[R].hidden = true;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (F_seen < 1)
              next_cell_format = null;
            break;
          default:
            if (opts && opts.WTF)
              throw new Error("SYLK bad record " + rstr);
        }
    }
    if (rowinfo.length > 0)
      sht["!rows"] = rowinfo;
    if (colinfo.length > 0)
      sht["!cols"] = colinfo;
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return [arr, sht];
  }
  function sylk_to_sheet(d, opts) {
    var aoasht = sylk_to_aoa(d, opts);
    var aoa = aoasht[0], ws = aoasht[1];
    var o = aoa_to_sheet(aoa, opts);
    keys(ws).forEach(function(k) {
      o[k] = ws[k];
    });
    return o;
  }
  function sylk_to_workbook(d, opts) {
    return sheet_to_workbook(sylk_to_sheet(d, opts), opts);
  }
  function write_ws_cell_sylk(cell, ws, R, C) {
    var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
    switch (cell.t) {
      case "n":
        o += cell.v || 0;
        if (cell.f && !cell.F)
          o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
        break;
      case "b":
        o += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o += cell.w || cell.v;
        break;
      case "d":
        o += '"' + (cell.w || cell.v) + '"';
        break;
      case "s":
        o += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o;
  }
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i) {
      var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
      if (col.hidden)
        rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx)
          col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch)
          col.wch = px2char(col.wpx);
        if (typeof col.wch == "number")
          rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ")
        out.push(rec);
    });
  }
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i) {
      var rec = "F;";
      if (row.hidden)
        rec += "M0;";
      else if (row.hpt)
        rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx)
        rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2)
        out.push(rec + "R" + (i + 1));
    });
  }
  function sheet_to_sylk(ws, opts) {
    var preamble = ["ID;PWXL;N;E"], o = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    var RS = "\r\n";
    preamble.push("P;PGeneral");
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"])
      write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"])
      write_ws_rows_sylk(preamble, ws["!rows"]);
    preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
    for (var R = r.s.r; R <= r.e.r; ++R) {
      for (var C = r.s.c; C <= r.e.c; ++C) {
        var coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws[R] || [])[C] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F))
          continue;
        o.push(write_ws_cell_sylk(cell, ws, R, C));
      }
    }
    return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
  }
  return {
    to_workbook: sylk_to_workbook,
    to_sheet: sylk_to_sheet,
    from_sheet: sheet_to_sylk
  };
}();
var DIF = /* @__PURE__ */ function() {
  function dif_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return dif_to_aoa_str(d, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      if (records[ri].trim() === "BOT") {
        arr[++R] = [];
        C = 0;
        continue;
      }
      if (R < 0)
        continue;
      var metadata = records[ri].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri;
      var data = records[ri] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1)
        data += "\n" + records[++ri];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R] = [];
            C = 0;
            continue;
          } else if (data !== "EOD")
            throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE")
            arr[R][C] = true;
          else if (data === "FALSE")
            arr[R][C] = false;
          else if (!isNaN(fuzzynum(value)))
            arr[R][C] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate()))
            arr[R][C] = parseDate(value);
          else
            arr[R][C] = value;
          ++C;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/))
            data = data.slice(2, -1);
          arr[R][C++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD")
        break;
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  function dif_to_workbook(str, opts) {
    return sheet_to_workbook(dif_to_sheet(str, opts), opts);
  }
  var sheet_to_dif = /* @__PURE__ */ function() {
    var push_field = function pf(o, topic, v, n, s) {
      o.push(topic);
      o.push(v + "," + n);
      o.push('"' + s.replace(/"/g, '""') + '"');
    };
    var push_value = function po(o, type, v, s) {
      o.push(type + "," + v);
      o.push(type == 1 ? '"' + s.replace(/"/g, '""') + '"' : s);
    };
    return function sheet_to_dif2(ws) {
      var o = [];
      var r = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      push_field(o, "TABLE", 0, 1, "sheetjs");
      push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1, "");
      push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1, "");
      push_field(o, "DATA", 0, 0, "");
      for (var R = r.s.r; R <= r.e.r; ++R) {
        push_value(o, -1, 0, "BOT");
        for (var C = r.s.c; C <= r.e.c; ++C) {
          var coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws[R] || [])[C] : ws[coord];
          if (!cell) {
            push_value(o, 1, 0, "");
            continue;
          }
          switch (cell.t) {
            case "n":
              var val = cell.w;
              if (!val && cell.v != null)
                val = cell.v;
              if (val == null) {
                if (cell.f && !cell.F)
                  push_value(o, 1, 0, "=" + cell.f);
                else
                  push_value(o, 1, 0, "");
              } else
                push_value(o, 0, val, "V");
              break;
            case "b":
              push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
              break;
            case "s":
              push_value(o, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
              break;
            case "d":
              if (!cell.w)
                cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
              push_value(o, 0, cell.w, "V");
              break;
            default:
              push_value(o, 1, 0, "");
          }
        }
      }
      push_value(o, -1, 0, "EOD");
      var RS = "\r\n";
      var oo = o.join(RS);
      return oo;
    };
  }();
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
}();
var ETH = /* @__PURE__ */ function() {
  function decode(s) {
    return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  function encode(s) {
    return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      var record = records[ri].trim().split(":");
      if (record[0] !== "cell")
        continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R = arr.length; R <= addr.r; ++R)
          if (!arr[R])
            arr[R] = [];
      }
      R = addr.r;
      C = addr.c;
      switch (record[2]) {
        case "t":
          arr[R][C] = decode(record[3]);
          break;
        case "v":
          arr[R][C] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R][C] = +record[4] ? true : false;
              break;
            default:
              arr[R][C] = +record[4];
              break;
          }
          if (record[2] == "vtf")
            arr[R][C] = [arr[R][C], _f];
      }
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function eth_to_sheet(d, opts) {
    return aoa_to_sheet(eth_to_aoa(d, opts), opts);
  }
  function eth_to_workbook(d, opts) {
    return sheet_to_workbook(eth_to_sheet(d, opts), opts);
  }
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"])
      return "";
    var o = [], oo = [], cell, coord = "";
    var r = decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    for (var R = r.s.r; R <= r.e.r; ++R) {
      for (var C = r.s.c; C <= r.e.c; ++C) {
        coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws[R] || [])[C] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z")
          continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t2 = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t2;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t2);
            break;
          case "e":
            continue;
        }
        o.push(oo.join(":"));
      }
    }
    o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
    o.push("valueformat:1:text-wiki");
    return o.join("\n");
  }
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
}();
var PRN = /* @__PURE__ */ function() {
  function set_text_arr(data, arr, R, C, o) {
    if (o.raw)
      arr[R][C] = data;
    else if (data === "")
      ;
    else if (data === "TRUE")
      arr[R][C] = true;
    else if (data === "FALSE")
      arr[R][C] = false;
    else if (!isNaN(fuzzynum(data)))
      arr[R][C] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate()))
      arr[R][C] = parseDate(data);
    else
      arr[R][C] = data;
  }
  function prn_to_aoa_str(f, opts) {
    var o = opts || {};
    var arr = [];
    if (!f || f.length === 0)
      return arr;
    var lines = f.split(/[\r\n]/);
    var L = lines.length - 1;
    while (L >= 0 && lines[L].length === 0)
      --L;
    var start = 10, idx = 0;
    var R = 0;
    for (; R <= L; ++R) {
      idx = lines[R].indexOf(" ");
      if (idx == -1)
        idx = lines[R].length;
      else
        idx++;
      start = Math.max(start, idx);
    }
    for (R = 0; R <= L; ++R) {
      arr[R] = [];
      var C = 0;
      set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
      for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
        set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
    }
    if (o.sheetRows)
      arr = arr.slice(0, o.sheetRows);
    return arr;
  }
  var guess_seps = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  };
  var guess_sep_weights = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc = 0;
    for (; end < str.length; ++end) {
      if ((cc = str.charCodeAt(end)) == 34)
        instr = !instr;
      else if (!instr && cc in guess_seps)
        cnt[cc] = (cnt[cc] || 0) + 1;
    }
    cc = [];
    for (end in cnt)
      if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
    if (!cc.length) {
      cnt = guess_sep_weights;
      for (end in cnt)
        if (Object.prototype.hasOwnProperty.call(cnt, end)) {
          cc.push([cnt[end], end]);
        }
    }
    cc.sort(function(a, b) {
      return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
    });
    return guess_seps[cc.pop()[1]] || 44;
  }
  function dsv_to_sheet_str(str, opts) {
    var o = opts || {};
    var sep = "";
    var ws = o.dense ? [] : {};
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else
        sep = guess_sep(str.slice(0, 1024));
    } else if (o && o.FS)
      sep = o.FS;
    else
      sep = guess_sep(str.slice(0, 1024));
    var R = 0, C = 0, v = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
    str = str.replace(/\r\n/mg, "\n");
    var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
    function finish_cell() {
      var s = str.slice(start, end);
      var cell = {};
      if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"')
        s = s.slice(1, -1).replace(/""/g, '"');
      if (s.length === 0)
        cell.t = "z";
      else if (o.raw) {
        cell.t = "s";
        cell.v = s;
      } else if (s.trim().length === 0) {
        cell.t = "s";
        cell.v = s;
      } else if (s.charCodeAt(0) == 61) {
        if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
          cell.t = "s";
          cell.v = s.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s)) {
          cell.t = "n";
          cell.f = s.slice(1);
        } else {
          cell.t = "s";
          cell.v = s;
        }
      } else if (s == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v = fuzzynum(s))) {
        cell.t = "n";
        if (o.cellText !== false)
          cell.w = s;
        cell.v = v;
      } else if (!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
        cell.z = o.dateNF || table_fmt[14];
        var k = 0;
        if (_re && s.match(_re)) {
          s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
          k = 1;
        }
        if (o.cellDates) {
          cell.t = "d";
          cell.v = parseDate(s, k);
        } else {
          cell.t = "n";
          cell.v = datenum(parseDate(s, k));
        }
        if (o.cellText !== false)
          cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
        if (!o.cellNF)
          delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s;
      }
      if (cell.t == "z")
        ;
      else if (o.dense) {
        if (!ws[R])
          ws[R] = [];
        ws[R][C] = cell;
      } else
        ws[encode_cell({ c: C, r: R })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C)
        range.e.c = C;
      if (range.e.r < R)
        range.e.r = R;
      if (cc == sepcc)
        ++C;
      else {
        C = 0;
        ++R;
        if (o.sheetRows && o.sheetRows <= R)
          return true;
      }
    }
    outer:
      for (; end < str.length; ++end)
        switch (cc = str.charCodeAt(end)) {
          case 34:
            if (startcc === 34)
              instr = !instr;
            break;
          case sepcc:
          case 10:
          case 13:
            if (!instr && finish_cell())
              break outer;
            break;
        }
    if (end - start > 0)
      finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN))
      return dsv_to_sheet_str(str, opts);
    if (opts.FS)
      return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=")
      return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0)
      return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  function prn_to_sheet(d, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d);
        break;
      case "binary":
        str = d;
        break;
      case "buffer":
        if (opts.codepage == 65001)
          str = d.toString("utf8");
        else if (opts.codepage && typeof $cptable !== "undefined")
          str = $cptable.utils.decode(opts.codepage, d);
        else
          str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
        break;
      case "array":
        str = cc2str(d);
        break;
      case "string":
        str = d;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
      str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001)
      str = utf8read(str);
    else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage)
      str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
    if (str.slice(0, 19) == "socialcalc:version:")
      return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  function prn_to_workbook(d, opts) {
    return sheet_to_workbook(prn_to_sheet(d, opts), opts);
  }
  function sheet_to_prn(ws) {
    var o = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R = r.s.r; R <= r.e.r; ++R) {
      var oo = [];
      for (var C = r.s.c; C <= r.e.c; ++C) {
        var coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws[R] || [])[C] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w.length < 10)
          w += " ";
        oo.push(w + (C === 0 ? " " : ""));
      }
      o.push(oo.join(""));
    }
    return o.join("\n");
  }
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
}();
function read_wb_ID(d, opts) {
  var o = opts || {}, OLD_WTF = !!o.WTF;
  o.WTF = true;
  try {
    var out = SYLK.to_workbook(d, o);
    o.WTF = OLD_WTF;
    return out;
  } catch (e) {
    o.WTF = OLD_WTF;
    if (!e.message.match(/SYLK bad record ID/) && OLD_WTF)
      throw e;
    return PRN.to_workbook(d, opts);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function lotushopper(data, cb, opts) {
    if (!data)
      return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R = Enum[RT] || Enum[65535];
      var length = data.read_shift(2);
      var tgt = data.l + length;
      var d = R.f && R.f(data, length, opts);
      data.l = tgt;
      if (cb(d, R, RT))
        return;
    }
  }
  function lotus_to_workbook(d, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  function lotus_to_workbook_buf(d, opts) {
    if (!d)
      return d;
    var o = opts || {};
    var s = o.dense ? [] : {}, n = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o.sheetRows || 0;
    if (d[2] == 0) {
      if (d[3] == 8 || d[3] == 9) {
        if (d.length >= 16 && d[14] == 5 && d[15] === 108)
          throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d[2] == 2) {
      o.Enum = WK1Enum;
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 0:
            o.vers = val;
            if (val >= 4096)
              o.qpro = true;
            break;
          case 6:
            refguess = val;
            break;
          case 204:
            if (val)
              next_n = val;
            break;
          case 222:
            next_n = val;
            break;
          case 15:
          case 51:
            if (!o.qpro)
              val[1].v = val[1].v.slice(1);
          case 13:
          case 14:
          case 16:
            if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o.dateNF || table_fmt[14];
              if (o.cellDates) {
                val[1].t = "d";
                val[1].v = numdate(val[1].v);
              }
            }
            if (o.qpro) {
              if (val[3] > sidx) {
                s["!ref"] = encode_range(refguess);
                sheets[n] = s;
                snames.push(n);
                s = o.dense ? [] : {};
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o.dense ? (s[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null)
                tmpcell.z = val[1].z;
              if (val[1].f != null)
                tmpcell.f = val[1].f;
              break;
            }
            if (o.dense) {
              if (!s[val[0].r])
                s[val[0].r] = [];
              s[val[0].r][val[0].c] = val[1];
            } else
              s[encode_cell(val[0])] = val[1];
            break;
        }
      }, o);
    } else if (d[2] == 26 || d[2] == 14) {
      o.Enum = WK3Enum;
      if (d[2] == 14) {
        o.qpro = true;
        d.l = 0;
      }
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 204:
            n = val;
            break;
          case 22:
            val[1].v = val[1].v.slice(1);
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (val[3] > sidx) {
              s["!ref"] = encode_range(refguess);
              sheets[n] = s;
              snames.push(n);
              s = o.dense ? [] : {};
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows)
              break;
            if (o.dense) {
              if (!s[val[0].r])
                s[val[0].r] = [];
              s[val[0].r][val[0].c] = val[1];
            } else
              s[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c)
              refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r)
              refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3])
              realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx)
              n = val[1];
            break;
        }
      }, o);
    } else
      throw new Error("Unrecognized LOTUS BOF " + d[2]);
    s["!ref"] = encode_range(refguess);
    sheets[next_n || n] = s;
    snames.push(next_n || n);
    if (!realnames.length)
      return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i = 0; i < realnames.length; ++i)
      if (sheets[snames[i]]) {
        rnames.push(realnames[i] || snames[i]);
        osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
      } else {
        rnames.push(realnames[i]);
        osheets[realnames[i]] = { "!ref": "A1" };
      }
    return { SheetNames: rnames, Sheets: osheets };
  }
  function sheet_to_wk1(ws, opts) {
    var o = opts || {};
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    var range = safe_decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var R = range.s.r; R <= max_R; ++R) {
      var rr = encode_row(R);
      for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r)
          cols[C] = encode_col(C);
        var ref2 = cols[C] + rr;
        var cell = dense ? (ws[R] || [])[C] : ws[ref2];
        if (!cell || cell.t == "z")
          continue;
        if (cell.t == "n") {
          if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767)
            write_biff_rec(ba, 13, write_INTEGER(R, C, cell.v));
          else
            write_biff_rec(ba, 14, write_NUMBER(R, C, cell.v));
        } else {
          var str = format_cell(cell);
          write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function book_to_wk3(wb, opts) {
    var o = opts || {};
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb));
    for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i)
      if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"])
        write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
    var wsidx = 0;
    for (i = 0; i < wb.SheetNames.length; ++i) {
      var ws = wb.Sheets[wb.SheetNames[i]];
      if (!ws || !ws["!ref"])
        continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R = range.s.r; R <= max_R; ++R) {
        var rr = encode_row(R);
        for (var C = range.s.c; C <= range.e.c; ++C) {
          if (R === range.s.r)
            cols[C] = encode_col(C);
          var ref2 = cols[C] + rr;
          var cell = dense ? (ws[R] || [])[C] : ws[ref2];
          if (!cell || cell.t == "z")
            continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function write_BOF_WK1(v) {
    var out = new_buf(2);
    out.write_shift(2, v);
    return out;
  }
  function write_BOF_WK3(wb) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i = 0; i < wb.SheetNames.length; ++i) {
      var name = wb.SheetNames[i];
      var ws = wb.Sheets[name];
      if (!ws || !ws["!ref"])
        continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r)
        rows = range.e.r;
      if (cols < range.e.c)
        cols = range.e.c;
    }
    if (rows > 8191)
      rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  function parse_RANGE(blob, length, opts) {
    var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length == 8 && opts.qpro) {
      o.s.c = blob.read_shift(1);
      blob.l++;
      o.s.r = blob.read_shift(2);
      o.e.c = blob.read_shift(1);
      blob.l++;
      o.e.r = blob.read_shift(2);
      return o;
    }
    o.s.c = blob.read_shift(2);
    o.s.r = blob.read_shift(2);
    if (length == 12 && opts.qpro)
      blob.l += 2;
    o.e.c = blob.read_shift(2);
    o.e.r = blob.read_shift(2);
    if (length == 12 && opts.qpro)
      blob.l += 2;
    if (o.s.c == 65535)
      o.s.c = o.e.c = o.s.r = o.e.r = 0;
    return o;
  }
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  function parse_cell(blob, length, opts) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o[0].c = blob.read_shift(1);
      o[3] = blob.read_shift(1);
      o[0].r = blob.read_shift(2);
      blob.l += 2;
    } else {
      o[2] = blob.read_shift(1);
      o[0].c = blob.read_shift(2);
      o[0].r = blob.read_shift(2);
    }
    return o;
  }
  function parse_LABEL(blob, length, opts) {
    var tgt = blob.l + length;
    var o = parse_cell(blob, length, opts);
    o[1].t = "s";
    if (opts.vers == 20768) {
      blob.l++;
      var len = blob.read_shift(1);
      o[1].v = blob.read_shift(len, "utf8");
      return o;
    }
    if (opts.qpro)
      blob.l++;
    o[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o;
  }
  function write_LABEL(R, C, s) {
    var o = new_buf(7 + s.length);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(1, 39);
    for (var i = 0; i < o.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_INTEGER(blob, length, opts) {
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(2, "i");
    return o;
  }
  function write_INTEGER(R, C, v) {
    var o = new_buf(7);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(2, v, "i");
    return o;
  }
  function parse_NUMBER(blob, length, opts) {
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(8, "f");
    return o;
  }
  function write_NUMBER(R, C, v) {
    var o = new_buf(13);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(8, v, "f");
    return o;
  }
  function parse_FORMULA(blob, length, opts) {
    var tgt = blob.l + length;
    var o = parse_cell(blob, length, opts);
    o[1].v = blob.read_shift(8, "f");
    if (opts.qpro)
      blob.l = tgt;
    else {
      var flen = blob.read_shift(2);
      wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
      blob.l += flen;
    }
    return o;
  }
  function wk1_parse_rc(B, V, col) {
    var rel = V & 32768;
    V &= ~32768;
    V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
    return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
  }
  var FuncTab = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob, o) {
    prep_blob(blob, 0);
    var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
    while (blob.l < blob.length) {
      var cc = blob[blob.l++];
      switch (cc) {
        case 0:
          out.push(blob.read_shift(8, "f"));
          break;
        case 1:
          {
            C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            out.push(C + R);
          }
          break;
        case 2:
          {
            var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
            out.push(c + r + ":" + C + R);
          }
          break;
        case 3:
          if (blob.l < blob.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob.read_shift(2));
          break;
        case 6:
          {
            var Z = "";
            while (cc = blob[blob.l++])
              Z += String.fromCharCode(cc);
            out.push('"' + Z.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc < 32 && BinOpTab[cc]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc] + argR);
          } else if (FuncTab[cc]) {
            argc = FuncTab[cc][1];
            if (argc == 69)
              argc = blob[blob.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
          } else if (cc <= 7)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 24)
            return console.error("WK1 unsupported op " + cc.toString(16));
          else if (cc <= 30)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 115)
            return console.error("WK1 unsupported function opcode " + cc.toString(16));
          else
            return console.error("WK1 unrecognized opcode " + cc.toString(16));
      }
    }
    if (out.length == 1)
      o[1].f = "" + out[0];
    else
      console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  function parse_cell_3(blob) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o[0].r = blob.read_shift(2);
    o[3] = blob[blob.l++];
    o[0].c = blob[blob.l++];
    return o;
  }
  function parse_LABEL_16(blob, length) {
    var o = parse_cell_3(blob);
    o[1].t = "s";
    o[1].v = blob.read_shift(length - 4, "cstr");
    return o;
  }
  function write_LABEL_16(R, C, wsidx, s) {
    var o = new_buf(6 + s.length);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C);
    o.write_shift(1, 39);
    for (var i = 0; i < s.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_NUMBER_18(blob, length) {
    var o = parse_cell_3(blob);
    o[1].v = blob.read_shift(2);
    var v = o[1].v >> 1;
    if (o[1].v & 1) {
      switch (v & 7) {
        case 0:
          v = (v >> 3) * 5e3;
          break;
        case 1:
          v = (v >> 3) * 500;
          break;
        case 2:
          v = (v >> 3) / 20;
          break;
        case 3:
          v = (v >> 3) / 200;
          break;
        case 4:
          v = (v >> 3) / 2e3;
          break;
        case 5:
          v = (v >> 3) / 2e4;
          break;
        case 6:
          v = (v >> 3) / 16;
          break;
        case 7:
          v = (v >> 3) / 64;
          break;
      }
    }
    o[1].v = v;
    return o;
  }
  function parse_NUMBER_17(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    var v2 = blob.read_shift(4);
    var e = blob.read_shift(2);
    if (e == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o[1].t = "e";
        o[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o[1].t = "e";
        o[1].v = 42;
      } else
        o[1].v = 0;
      return o;
    }
    var s = e & 32768;
    e = (e & 32767) - 16446;
    o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
    return o;
  }
  function write_NUMBER_17(R, C, wsidx, v) {
    var o = new_buf(14);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C);
    if (v == 0) {
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 65535);
      return o;
    }
    var s = 0, e = 0, v1 = 0, v2 = 0;
    if (v < 0) {
      s = 1;
      v = -v;
    }
    e = Math.log2(v) | 0;
    v /= Math.pow(2, e - 31);
    v2 = v >>> 0;
    if ((v2 & 2147483648) == 0) {
      v /= 2;
      ++e;
      v2 = v >>> 0;
    }
    v -= v2;
    v2 |= 2147483648;
    v2 >>>= 0;
    v *= Math.pow(2, 32);
    v1 = v >>> 0;
    o.write_shift(4, v1);
    o.write_shift(4, v2);
    e += 16383 + (s ? 32768 : 0);
    o.write_shift(2, e);
    return o;
  }
  function parse_FORMULA_19(blob, length) {
    var o = parse_NUMBER_17(blob);
    blob.l += length - 14;
    return o;
  }
  function parse_NUMBER_25(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    o[1].v = v1 >> 6;
    return o;
  }
  function parse_NUMBER_27(blob, length) {
    var o = parse_cell_3(blob);
    var v1 = blob.read_shift(8, "f");
    o[1].v = v1;
    return o;
  }
  function parse_FORMULA_28(blob, length) {
    var o = parse_NUMBER_27(blob);
    blob.l += length - 10;
    return o;
  }
  function parse_SHEETNAMECS(blob, length) {
    return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
  }
  function parse_SHEETNAMELP(blob, length) {
    var len = blob[blob.l++];
    if (len > length - 1)
      len = length - 1;
    var o = "";
    while (o.length < len)
      o += String.fromCharCode(blob[blob.l++]);
    return o;
  }
  function parse_SHEETINFOQP(blob, length, opts) {
    if (!opts.qpro || length < 21)
      return;
    var id = blob.read_shift(1);
    blob.l += 17;
    blob.l += 1;
    blob.l += 2;
    var nm = blob.read_shift(length - 21, "cstr");
    return [id, nm];
  }
  function parse_XFORMAT(blob, length) {
    var o = {}, tgt = blob.l + length;
    while (blob.l < tgt) {
      var dt = blob.read_shift(2);
      if (dt == 14e3) {
        o[dt] = [0, ""];
        o[dt][0] = blob.read_shift(2);
        while (blob[blob.l]) {
          o[dt][1] += String.fromCharCode(blob[blob.l]);
          blob.l++;
        }
        blob.l++;
      }
    }
    return o;
  }
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i = 0; i < name.length; ++i) {
      var cc = name.charCodeAt(i);
      out[out.l++] = cc > 127 ? 95 : cc;
    }
    out[out.l++] = 0;
    return out;
  }
  var WK1Enum = {
    /*::[*/
    0: { n: "BOF", f: parseuint16 },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: parse_RANGE },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: parse_INTEGER },
    /*::[*/
    14: { n: "NUMBER", f: parse_NUMBER },
    /*::[*/
    15: { n: "LABEL", f: parse_LABEL },
    /*::[*/
    16: { n: "FORMULA", f: parse_FORMULA },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: parse_LABEL },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    /*::[*/
    65535: { n: "" }
  };
  var WK3Enum = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: parse_LABEL_16 },
    /*::[*/
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    /*::[*/
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    /*::[*/
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: parse_XFORMAT },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    /*::[*/
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
}();
function parse_rpr(rpr) {
  var font = {}, m = rpr.match(tagregex), i = 0;
  var pass = false;
  if (m)
    for (; i != m.length; ++i) {
      var y = parsexmltag(m[i]);
      switch (y[0].replace(/\w*:/g, "")) {
        case "<condense":
          break;
        case "<extend":
          break;
        case "<shadow":
          if (!y.val)
            break;
        case "<shadow>":
        case "<shadow/>":
          font.shadow = 1;
          break;
        case "</shadow>":
          break;
        case "<charset":
          if (y.val == "1")
            break;
          font.cp = CS2CP[parseInt(y.val, 10)];
          break;
        case "<outline":
          if (!y.val)
            break;
        case "<outline>":
        case "<outline/>":
          font.outline = 1;
          break;
        case "</outline>":
          break;
        case "<rFont":
          font.name = y.val;
          break;
        case "<sz":
          font.sz = y.val;
          break;
        case "<strike":
          if (!y.val)
            break;
        case "<strike>":
        case "<strike/>":
          font.strike = 1;
          break;
        case "</strike>":
          break;
        case "<u":
          if (!y.val)
            break;
          switch (y.val) {
            case "double":
              font.uval = "double";
              break;
            case "singleAccounting":
              font.uval = "single-accounting";
              break;
            case "doubleAccounting":
              font.uval = "double-accounting";
              break;
          }
        case "<u>":
        case "<u/>":
          font.u = 1;
          break;
        case "</u>":
          break;
        case "<b":
          if (y.val == "0")
            break;
        case "<b>":
        case "<b/>":
          font.b = 1;
          break;
        case "</b>":
          break;
        case "<i":
          if (y.val == "0")
            break;
        case "<i>":
        case "<i/>":
          font.i = 1;
          break;
        case "</i>":
          break;
        case "<color":
          if (y.rgb)
            font.color = y.rgb.slice(2, 8);
          break;
        case "<color>":
        case "<color/>":
        case "</color>":
          break;
        case "<family":
          font.family = y.val;
          break;
        case "<family>":
        case "<family/>":
        case "</family>":
          break;
        case "<vertAlign":
          font.valign = y.val;
          break;
        case "<vertAlign>":
        case "<vertAlign/>":
        case "</vertAlign>":
          break;
        case "<scheme":
          break;
        case "<scheme>":
        case "<scheme/>":
        case "</scheme>":
          break;
        case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (y[0].charCodeAt(1) !== 47 && !pass)
            throw new Error("Unrecognized rich format " + y[0]);
      }
    }
  return font;
}
var parse_rs = /* @__PURE__ */ function() {
  var tregex = matchtag("t"), rpregex = matchtag("rPr");
  function parse_r(r) {
    var t2 = r.match(tregex);
    if (!t2)
      return { t: "s", v: "" };
    var o = { t: "s", v: unescapexml(t2[1]) };
    var rpr = r.match(rpregex);
    if (rpr)
      o.s = parse_rpr(rpr[1]);
    return o;
  }
  var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
  return function parse_rs2(rs) {
    return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r) {
      return r.v;
    });
  };
}();
var rs_to_html = /* @__PURE__ */ function parse_rs_factory() {
  var nlregex = /(\r\n|\n)/g;
  function parse_rpr2(font, intro, outro) {
    var style = [];
    if (font.u)
      style.push("text-decoration: underline;");
    if (font.uval)
      style.push("text-underline-style:" + font.uval + ";");
    if (font.sz)
      style.push("font-size:" + font.sz + "pt;");
    if (font.outline)
      style.push("text-effect: outline;");
    if (font.shadow)
      style.push("text-shadow: auto;");
    intro.push('<span style="' + style.join("") + '">');
    if (font.b) {
      intro.push("<b>");
      outro.push("</b>");
    }
    if (font.i) {
      intro.push("<i>");
      outro.push("</i>");
    }
    if (font.strike) {
      intro.push("<s>");
      outro.push("</s>");
    }
    var align = font.valign || "";
    if (align == "superscript" || align == "super")
      align = "sup";
    else if (align == "subscript")
      align = "sub";
    if (align != "") {
      intro.push("<" + align + ">");
      outro.push("</" + align + ">");
    }
    outro.push("</span>");
    return font;
  }
  function r_to_html(r) {
    var terms = [[], r.v, []];
    if (!r.v)
      return "";
    if (r.s)
      parse_rpr2(r.s, terms[0], terms[2]);
    return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
  }
  return function parse_rs2(rs) {
    return rs.map(r_to_html).join("");
  };
}();
var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r>/;
var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function parse_si(x, opts) {
  var html = opts ? opts.cellHTML : true;
  var z = {};
  if (!x)
    return { t: "" };
  if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
    z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""));
    z.r = utf8read(x);
    if (html)
      z.h = escapehtml(z.t);
  } else if (
    /*y = */
    x.match(sirregex)
  ) {
    z.r = utf8read(x);
    z.t = unescapexml(utf8read((x.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")));
    if (html)
      z.h = rs_to_html(parse_rs(z.r));
  }
  return z;
}
var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(data, opts) {
  var s = [], ss = "";
  if (!data)
    return s;
  var sst = data.match(sstr0);
  if (sst) {
    ss = sst[2].replace(sstr1, "").split(sstr2);
    for (var i = 0; i != ss.length; ++i) {
      var o = parse_si(ss[i].trim(), opts);
      if (o != null)
        s[s.length] = o;
    }
    sst = parsexmltag(sst[1]);
    s.Count = sst.count;
    s.Unique = sst.uniqueCount;
  }
  return s;
}
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(sst, opts) {
  if (!opts.bookSST)
    return "";
  var o = [XML_HEADER];
  o[o.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: sst.Count,
    uniqueCount: sst.Unique
  });
  for (var i = 0; i != sst.length; ++i) {
    if (sst[i] == null)
      continue;
    var s = sst[i];
    var sitag = "<si>";
    if (s.r)
      sitag += s.r;
    else {
      sitag += "<t";
      if (!s.t)
        s.t = "";
      if (s.t.match(straywsregex))
        sitag += ' xml:space="preserve"';
      sitag += ">" + escapexml(s.t) + "</t>";
    }
    sitag += "</si>";
    o[o.length] = sitag;
  }
  if (o.length > 2) {
    o[o.length] = "</sst>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
function parse_sst_bin(data, opts) {
  var s = [];
  var pass = false;
  recordhopper(data, function hopper_sst(val, R, RT) {
    switch (RT) {
      case 159:
        s.Count = val[0];
        s.Unique = val[1];
        break;
      case 19:
        s.push(val);
        break;
      case 160:
        return true;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T)
          ;
        if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return s;
}
function write_BrtBeginSst(sst, o) {
  if (!o)
    o = new_buf(8);
  o.write_shift(4, sst.Count);
  o.write_shift(4, sst.Unique);
  return o;
}
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(sst) {
  var ba = buf_array();
  write_record(ba, 159, write_BrtBeginSst(sst));
  for (var i = 0; i < sst.length; ++i)
    write_record(ba, 19, write_BrtSSTItem(sst[i]));
  write_record(
    ba,
    160
    /* BrtEndSst */
  );
  return ba.end();
}
function _JS2ANSI(str) {
  var o = [], oo = str.split("");
  for (var i = 0; i < oo.length; ++i)
    o[i] = oo[i].charCodeAt(0);
  return o;
}
function parse_CRYPTOVersion(blob, length) {
  var o = {};
  o.Major = blob.read_shift(2);
  o.Minor = blob.read_shift(2);
  if (length >= 4)
    blob.l += length - 4;
  return o;
}
function parse_DataSpaceVersionInfo(blob) {
  var o = {};
  o.id = blob.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob, 4);
  o.U = parse_CRYPTOVersion(blob, 4);
  o.W = parse_CRYPTOVersion(blob, 4);
  return o;
}
function parse_DataSpaceMapEntry(blob) {
  var len = blob.read_shift(4);
  var end = blob.l + len - 4;
  var o = {};
  var cnt = blob.read_shift(4);
  var comps = [];
  while (cnt-- > 0)
    comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
  o.name = blob.read_shift(0, "lpp4");
  o.comps = comps;
  if (blob.l != end)
    throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
  return o;
}
function parse_DataSpaceMap(blob) {
  var o = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0)
    o.push(parse_DataSpaceMapEntry(blob));
  return o;
}
function parse_DataSpaceDefinition(blob) {
  var o = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0)
    o.push(blob.read_shift(0, "lpp4"));
  return o;
}
function parse_TransformInfoHeader(blob) {
  var o = {};
  blob.read_shift(4);
  blob.l += 4;
  o.id = blob.read_shift(0, "lpp4");
  o.name = blob.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob, 4);
  o.U = parse_CRYPTOVersion(blob, 4);
  o.W = parse_CRYPTOVersion(blob, 4);
  return o;
}
function parse_Primary(blob) {
  var hdr = parse_TransformInfoHeader(blob);
  hdr.ename = blob.read_shift(0, "8lpp4");
  hdr.blksz = blob.read_shift(4);
  hdr.cmode = blob.read_shift(4);
  if (blob.read_shift(4) != 4)
    throw new Error("Bad !Primary record");
  return hdr;
}
function parse_EncryptionHeader(blob, length) {
  var tgt = blob.l + length;
  var o = {};
  o.Flags = blob.read_shift(4) & 63;
  blob.l += 4;
  o.AlgID = blob.read_shift(4);
  var valid = false;
  switch (o.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      valid = o.Flags == 36;
      break;
    case 26625:
      valid = o.Flags == 4;
      break;
    case 0:
      valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + o.AlgID;
  }
  if (!valid)
    throw new Error("Encryption Flags/AlgID mismatch");
  o.AlgIDHash = blob.read_shift(4);
  o.KeySize = blob.read_shift(4);
  o.ProviderType = blob.read_shift(4);
  blob.l += 8;
  o.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
  blob.l = tgt;
  return o;
}
function parse_EncryptionVerifier(blob, length) {
  var o = {}, tgt = blob.l + length;
  blob.l += 4;
  o.Salt = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  o.Verifier = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  blob.read_shift(4);
  o.VerifierHash = blob.slice(blob.l, tgt);
  blob.l = tgt;
  return o;
}
function parse_EncryptionInfo(blob) {
  var vers = parse_CRYPTOVersion(blob);
  switch (vers.Minor) {
    case 2:
      return [vers.Minor, parse_EncInfoStd(blob)];
    case 3:
      return [vers.Minor, parse_EncInfoExt()];
    case 4:
      return [vers.Minor, parse_EncInfoAgl(blob)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
}
function parse_EncInfoStd(blob) {
  var flags = blob.read_shift(4);
  if ((flags & 63) != 36)
    throw new Error("EncryptionInfo mismatch");
  var sz = blob.read_shift(4);
  var hdr = parse_EncryptionHeader(blob, sz);
  var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
  return { t: "Std", h: hdr, v: verifier };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(blob) {
  var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  blob.l += 4;
  var xml = blob.read_shift(blob.length - blob.l, "utf8");
  var o = {};
  xml.replace(tagregex, function xml_agile(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        KeyData.forEach(function(k) {
          o[k] = y[k];
        });
        break;
      case "<dataIntegrity":
        o.encryptedHmacKey = y.encryptedHmacKey;
        o.encryptedHmacValue = y.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        o.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        o.uri = y.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        o.encs.push(y);
        break;
      default:
        throw y[0];
    }
  });
  return o;
}
function parse_RC4CryptoHeader(blob, length) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  length -= 4;
  if (vers.Minor != 2)
    throw new Error("unrecognized minor version code: " + vers.Minor);
  if (vers.Major > 4 || vers.Major < 2)
    throw new Error("unrecognized major version code: " + vers.Major);
  o.Flags = blob.read_shift(4);
  length -= 4;
  var sz = blob.read_shift(4);
  length -= 4;
  o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
  length -= sz;
  o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
  return o;
}
function parse_RC4Header(blob) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  if (vers.Major != 1 || vers.Minor != 1)
    throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
  o.Salt = blob.read_shift(16);
  o.EncryptedVerifier = blob.read_shift(16);
  o.EncryptedVerifierHash = blob.read_shift(16);
  return o;
}
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i = 1; i != len; ++i)
    PasswordArray[i] = PasswordDecoded[i - 1];
  for (i = len - 1; i >= 0; --i) {
    PasswordByte = PasswordArray[i];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
  var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
  var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
  var Ror = function(Byte) {
    return (Byte / 2 | Byte * 128) & 255;
  };
  var XorRor = function(byte1, byte2) {
    return Ror(byte1 ^ byte2);
  };
  var CreateXorKey_Method1 = function(Password) {
    var XorKey = InitialCode[Password.length - 1];
    var CurrentElement = 104;
    for (var i = Password.length - 1; i >= 0; --i) {
      var Char = Password[i];
      for (var j = 0; j != 7; ++j) {
        if (Char & 64)
          XorKey ^= XorMatrix[CurrentElement];
        Char *= 2;
        --CurrentElement;
      }
    }
    return XorKey;
  };
  return function(password) {
    var Password = _JS2ANSI(password);
    var XorKey = CreateXorKey_Method1(Password);
    var Index = Password.length;
    var ObfuscationArray = new_raw_buf(16);
    for (var i = 0; i != 16; ++i)
      ObfuscationArray[i] = 0;
    var Temp, PasswordLastChar, PadIndex;
    if ((Index & 1) === 1) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
      --Index;
      Temp = XorKey & 255;
      PasswordLastChar = Password[Password.length - 1];
      ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
    }
    while (Index > 0) {
      --Index;
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
    }
    Index = 15;
    PadIndex = 15 - Password.length;
    while (PadIndex > 0) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
      --Index;
      --PadIndex;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      --PadIndex;
    }
    return ObfuscationArray;
  };
}();
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
  if (!O)
    O = Data;
  if (!XorArray)
    XorArray = crypto_CreateXorArray_Method1(password);
  var Index, Value;
  for (Index = 0; Index != Data.length; ++Index) {
    Value = Data[Index];
    Value ^= XorArray[XorArrayIndex];
    Value = (Value >> 5 | Value << 3) & 255;
    O[Index] = Value;
    ++XorArrayIndex;
  }
  return [O, XorArrayIndex, XorArray];
};
var crypto_MakeXorDecryptor = function(password) {
  var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
  return function(Data) {
    var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
    XorArrayIndex = O[1];
    return O[0];
  };
};
function parse_XORObfuscation(blob, length, opts, out) {
  var o = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
  if (opts.password)
    o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
  out.valid = o.verificationBytes === o.verifier;
  if (out.valid)
    out.insitu = crypto_MakeXorDecryptor(opts.password);
  return o;
}
function parse_FilePassHeader(blob, length, oo) {
  var o = oo || {};
  o.Info = blob.read_shift(2);
  blob.l -= 2;
  if (o.Info === 1)
    o.Data = parse_RC4Header(blob);
  else
    o.Data = parse_RC4CryptoHeader(blob, length);
  return o;
}
function parse_FilePass(blob, length, opts) {
  var o = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
  if (o.Type)
    parse_FilePassHeader(blob, length - 2, o);
  else
    parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o);
  return o;
}
var RTF = /* @__PURE__ */ function() {
  function rtf_to_sheet(d, opts) {
    switch (opts.type) {
      case "base64":
        return rtf_to_sheet_str(Base64_decode(d), opts);
      case "binary":
        return rtf_to_sheet_str(d, opts);
      case "buffer":
        return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return rtf_to_sheet_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function rtf_to_sheet_str(str, opts) {
    var o = opts || {};
    var ws = o.dense ? [] : {};
    var rows = str.match(/\\trowd.*?\\row\b/g);
    if (!rows.length)
      throw new Error("RTF missing table");
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
    rows.forEach(function(rowtf, R) {
      if (Array.isArray(ws))
        ws[R] = [];
      var rtfre = /\\\w+\b/g;
      var last_index = 0;
      var res;
      var C = -1;
      while (res = rtfre.exec(rowtf)) {
        switch (res[0]) {
          case "\\cell":
            var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
            if (data[0] == " ")
              data = data.slice(1);
            ++C;
            if (data.length) {
              var cell = { v: data, t: "s" };
              if (Array.isArray(ws))
                ws[R][C] = cell;
              else
                ws[encode_cell({ r: R, c: C })] = cell;
            }
            break;
        }
        last_index = rtfre.lastIndex;
      }
      if (C > range.e.c)
        range.e.c = C;
    });
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function rtf_to_workbook(d, opts) {
    return sheet_to_workbook(rtf_to_sheet(d, opts), opts);
  }
  function sheet_to_rtf(ws) {
    var o = ["{\\rtf1\\ansi"];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R = r.s.r; R <= r.e.r; ++R) {
      o.push("\\trowd\\trautofit1");
      for (var C = r.s.c; C <= r.e.c; ++C)
        o.push("\\cellx" + (C + 1));
      o.push("\\pard\\intbl");
      for (C = r.s.c; C <= r.e.c; ++C) {
        var coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws[R] || [])[C] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F))
          continue;
        o.push(" " + (cell.w || (format_cell(cell), cell.w)));
        o.push("\\cell");
      }
      o.push("\\pard\\intbl\\row");
    }
    return o.join("") + "}";
  }
  return {
    to_workbook: rtf_to_workbook,
    to_sheet: rtf_to_sheet,
    from_sheet: sheet_to_rtf
  };
}();
function hex2RGB(h3) {
  var o = h3.slice(h3[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16)];
}
function rgb2Hex(rgb) {
  for (var i = 0, o = 1; i != 3; ++i)
    o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
  return o.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(rgb) {
  var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
  var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
  if (C === 0)
    return [0, 0, R];
  var H6 = 0, S = 0, L2 = M + m;
  S = C / (L2 > 1 ? 2 - L2 : L2);
  switch (M) {
    case R:
      H6 = ((G - B) / C + 6) % 6;
      break;
    case G:
      H6 = (B - R) / C + 2;
      break;
    case B:
      H6 = (R - G) / C + 4;
      break;
  }
  return [H6 / 6, S, L2 / 2];
}
function hsl2RGB(hsl) {
  var H = hsl[0], S = hsl[1], L = hsl[2];
  var C = S * 2 * (L < 0.5 ? L : 1 - L), m = L - C / 2;
  var rgb = [m, m, m], h6 = 6 * H;
  var X;
  if (S !== 0)
    switch (h6 | 0) {
      case 0:
      case 6:
        X = C * h6;
        rgb[0] += C;
        rgb[1] += X;
        break;
      case 1:
        X = C * (2 - h6);
        rgb[0] += X;
        rgb[1] += C;
        break;
      case 2:
        X = C * (h6 - 2);
        rgb[1] += C;
        rgb[2] += X;
        break;
      case 3:
        X = C * (4 - h6);
        rgb[1] += X;
        rgb[2] += C;
        break;
      case 4:
        X = C * (h6 - 4);
        rgb[2] += C;
        rgb[0] += X;
        break;
      case 5:
        X = C * (6 - h6);
        rgb[2] += X;
        rgb[0] += C;
        break;
    }
  for (var i = 0; i != 3; ++i)
    rgb[i] = Math.round(rgb[i] * 255);
  return rgb;
}
function rgb_tint(hex, tint) {
  if (tint === 0)
    return hex;
  var hsl = rgb2HSL(hex2RGB(hex));
  if (tint < 0)
    hsl[2] = hsl[2] * (1 + tint);
  else
    hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
  return rgb2Hex(hsl2RGB(hsl));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width2) {
  return Math.floor((width2 + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(collw) {
  return char2width(px2char(width2px(collw)));
}
function find_mdw_colw(collw) {
  var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
  if (delta > 5e-3) {
    for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW)
      if (Math.abs(collw - cycle_width(collw)) <= delta) {
        delta = Math.abs(collw - cycle_width(collw));
        _MDW = MDW;
      }
  }
  MDW = _MDW;
}
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth)
    delete coll.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
function pt2px(pt) {
  return pt * PPI / 96;
}
var XLMLPatternTypeMap = {
  "None": "none",
  "Solid": "solid",
  "Gray50": "mediumGray",
  "Gray75": "darkGray",
  "Gray25": "lightGray",
  "HorzStripe": "darkHorizontal",
  "VertStripe": "darkVertical",
  "ReverseDiagStripe": "darkDown",
  "DiagStripe": "darkUp",
  "DiagCross": "darkGrid",
  "ThickDiagCross": "darkTrellis",
  "ThinHorzStripe": "lightHorizontal",
  "ThinVertStripe": "lightVertical",
  "ThinReverseDiagStripe": "lightDown",
  "ThinHorzCross": "lightGrid"
};
function parse_borders(t2, styles, themes, opts) {
  styles.Borders = [];
  var border = {};
  var pass = false;
  (t2[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      case "<border":
      case "<border>":
      case "<border/>":
        border = /*::(*/
        {};
        if (y.diagonalUp)
          border.diagonalUp = parsexmlbool(y.diagonalUp);
        if (y.diagonalDown)
          border.diagonalDown = parsexmlbool(y.diagonalDown);
        styles.Borders.push(border);
        break;
      case "</border>":
        break;
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in borders");
        }
    }
  });
}
function parse_fills(t2, styles, themes, opts) {
  styles.Fills = [];
  var fill2 = {};
  var pass = false;
  (t2[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      case "<fill>":
      case "<fill":
      case "<fill/>":
        fill2 = {};
        styles.Fills.push(fill2);
        break;
      case "</fill>":
        break;
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        styles.Fills.push(fill2);
        fill2 = {};
        break;
      case "<patternFill":
      case "<patternFill>":
        if (y.patternType)
          fill2.patternType = y.patternType;
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      case "<bgColor":
        if (!fill2.bgColor)
          fill2.bgColor = {};
        if (y.indexed)
          fill2.bgColor.indexed = parseInt(y.indexed, 10);
        if (y.theme)
          fill2.bgColor.theme = parseInt(y.theme, 10);
        if (y.tint)
          fill2.bgColor.tint = parseFloat(y.tint);
        if (y.rgb)
          fill2.bgColor.rgb = y.rgb.slice(-6);
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      case "<fgColor":
        if (!fill2.fgColor)
          fill2.fgColor = {};
        if (y.theme)
          fill2.fgColor.theme = parseInt(y.theme, 10);
        if (y.tint)
          fill2.fgColor.tint = parseFloat(y.tint);
        if (y.rgb != null)
          fill2.fgColor.rgb = y.rgb.slice(-6);
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in fills");
        }
    }
  });
}
function parse_fonts(t2, styles, themes, opts) {
  styles.Fonts = [];
  var font = {};
  var pass = false;
  (t2[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        styles.Fonts.push(font);
        font = {};
        break;
      case "<name":
        if (y.val)
          font.name = utf8read(y.val);
        break;
      case "<name/>":
      case "</name>":
        break;
      case "<b":
        font.bold = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<b/>":
        font.bold = 1;
        break;
      case "<i":
        font.italic = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<i/>":
        font.italic = 1;
        break;
      case "<u":
        switch (y.val) {
          case "none":
            font.underline = 0;
            break;
          case "single":
            font.underline = 1;
            break;
          case "double":
            font.underline = 2;
            break;
          case "singleAccounting":
            font.underline = 33;
            break;
          case "doubleAccounting":
            font.underline = 34;
            break;
        }
        break;
      case "<u/>":
        font.underline = 1;
        break;
      case "<strike":
        font.strike = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<strike/>":
        font.strike = 1;
        break;
      case "<outline":
        font.outline = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<outline/>":
        font.outline = 1;
        break;
      case "<shadow":
        font.shadow = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "<condense":
        font.condense = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<condense/>":
        font.condense = 1;
        break;
      case "<extend":
        font.extend = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<extend/>":
        font.extend = 1;
        break;
      case "<sz":
        if (y.val)
          font.sz = +y.val;
        break;
      case "<sz/>":
      case "</sz>":
        break;
      case "<vertAlign":
        if (y.val)
          font.vertAlign = y.val;
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<family":
        if (y.val)
          font.family = parseInt(y.val, 10);
        break;
      case "<family/>":
      case "</family>":
        break;
      case "<scheme":
        if (y.val)
          font.scheme = y.val;
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<charset":
        if (y.val == "1")
          break;
        y.codepage = CS2CP[parseInt(y.val, 10)];
        break;
      case "<color":
        if (!font.color)
          font.color = {};
        if (y.auto)
          font.color.auto = parsexmlbool(y.auto);
        if (y.rgb)
          font.color.rgb = y.rgb.slice(-6);
        else if (y.indexed) {
          font.color.index = parseInt(y.indexed, 10);
          var icv = XLSIcv[font.color.index];
          if (font.color.index == 81)
            icv = XLSIcv[1];
          if (!icv)
            icv = XLSIcv[1];
          font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
        } else if (y.theme) {
          font.color.theme = parseInt(y.theme, 10);
          if (y.tint)
            font.color.tint = parseFloat(y.tint);
          if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
            font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
          }
        }
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in fonts");
        }
    }
  });
}
function parse_numFmts(t2, styles, opts) {
  styles.NumberFmt = [];
  var k = keys(table_fmt);
  for (var i = 0; i < k.length; ++i)
    styles.NumberFmt[k[i]] = table_fmt[k[i]];
  var m = t2[0].match(tagregex);
  if (!m)
    return;
  for (i = 0; i < m.length; ++i) {
    var y = parsexmltag(m[i]);
    switch (strip_ns(y[0])) {
      case "<numFmts":
      case "</numFmts>":
      case "<numFmts/>":
      case "<numFmts>":
        break;
      case "<numFmt":
        {
          var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
          styles.NumberFmt[j] = f;
          if (j > 0) {
            if (j > 392) {
              for (j = 392; j > 60; --j)
                if (styles.NumberFmt[j] == null)
                  break;
              styles.NumberFmt[j] = f;
            }
            SSF_load(f, j);
          }
        }
        break;
      case "</numFmt>":
        break;
      default:
        if (opts.WTF)
          throw new Error("unrecognized " + y[0] + " in numFmts");
    }
  }
}
function write_numFmts(NF) {
  var o = ["<numFmts>"];
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        o[o.length] = writextag("numFmt", null, { numFmtId: i, formatCode: escapexml(NF[i]) });
  });
  if (o.length === 1)
    return "";
  o[o.length] = "</numFmts>";
  o[0] = writextag("numFmts", null, { count: o.length - 2 }).replace("/>", ">");
  return o.join("");
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(t2, styles, opts) {
  styles.CellXf = [];
  var xf;
  var pass = false;
  (t2[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x), i = 0;
    switch (strip_ns(y[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      case "<xf":
      case "<xf/>":
        xf = y;
        delete xf[0];
        for (i = 0; i < cellXF_uint.length; ++i)
          if (xf[cellXF_uint[i]])
            xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
        for (i = 0; i < cellXF_bool.length; ++i)
          if (xf[cellXF_bool[i]])
            xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
        if (styles.NumberFmt && xf.numFmtId > 392) {
          for (i = 392; i > 60; --i)
            if (styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) {
              xf.numFmtId = i;
              break;
            }
        }
        styles.CellXf.push(xf);
        break;
      case "</xf>":
        break;
      case "<alignment":
      case "<alignment/>":
        var alignment = {};
        if (y.vertical)
          alignment.vertical = y.vertical;
        if (y.horizontal)
          alignment.horizontal = y.horizontal;
        if (y.textRotation != null)
          alignment.textRotation = y.textRotation;
        if (y.indent)
          alignment.indent = y.indent;
        if (y.wrapText)
          alignment.wrapText = parsexmlbool(y.wrapText);
        xf.alignment = alignment;
        break;
      case "</alignment>":
        break;
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in cellXfs");
        }
    }
  });
}
function write_cellXfs(cellXfs) {
  var o = [];
  o[o.length] = writextag("cellXfs", null);
  cellXfs.forEach(function(c) {
    o[o.length] = writextag("xf", null, c);
  });
  o[o.length] = "</cellXfs>";
  if (o.length === 2)
    return "";
  o[0] = writextag("cellXfs", null, { count: o.length - 2 }).replace("/>", ">");
  return o.join("");
}
var parse_sty_xml = /* @__PURE__ */ function make_pstyx() {
  var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
  var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
  var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
  var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
  var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function parse_sty_xml2(data, themes, opts) {
    var styles = {};
    if (!data)
      return styles;
    data = data.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var t2;
    if (t2 = data.match(numFmtRegex))
      parse_numFmts(t2, styles, opts);
    if (t2 = data.match(fontsRegex))
      parse_fonts(t2, styles, themes, opts);
    if (t2 = data.match(fillsRegex))
      parse_fills(t2, styles, themes, opts);
    if (t2 = data.match(bordersRegex))
      parse_borders(t2, styles, themes, opts);
    if (t2 = data.match(cellXfRegex))
      parse_cellXfs(t2, styles, opts);
    return styles;
  };
}();
function write_sty_xml(wb, opts) {
  var o = [XML_HEADER, writextag("styleSheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], w;
  if (wb.SSF && (w = write_numFmts(wb.SSF)) != null)
    o[o.length] = w;
  o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
  o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
  o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
  o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
  if (w = write_cellXfs(opts.cellXfs))
    o[o.length] = w;
  o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
  o[o.length] = '<dxfs count="0"/>';
  o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
  if (o.length > 2) {
    o[o.length] = "</styleSheet>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtFmt(data, length) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
function write_BrtFmt(i, f, o) {
  if (!o)
    o = new_buf(6 + 4 * f.length);
  o.write_shift(2, i);
  write_XLWideString(f, o);
  var out = o.length > o.l ? o.slice(0, o.l) : o;
  if (o.l == null)
    o.l = o.length;
  return out;
}
function parse_BrtFont(data, length, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic)
    out.italic = 1;
  if (grbit.fCondense)
    out.condense = 1;
  if (grbit.fExtend)
    out.extend = 1;
  if (grbit.fShadow)
    out.shadow = 1;
  if (grbit.fOutline)
    out.outline = 1;
  if (grbit.fStrikeout)
    out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700)
    out.bold = 1;
  switch (data.read_shift(2)) {
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0)
    out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0)
    out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0)
    out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
function write_BrtFont(font, o) {
  if (!o)
    o = new_buf(25 + 4 * 32);
  o.write_shift(2, font.sz * 20);
  write_FontFlags(font, o);
  o.write_shift(2, font.bold ? 700 : 400);
  var sss = 0;
  if (font.vertAlign == "superscript")
    sss = 1;
  else if (font.vertAlign == "subscript")
    sss = 2;
  o.write_shift(2, sss);
  o.write_shift(1, font.underline || 0);
  o.write_shift(1, font.family || 0);
  o.write_shift(1, font.charset || 0);
  o.write_shift(1, 0);
  write_BrtColor(font.color, o);
  var scheme = 0;
  if (font.scheme == "major")
    scheme = 1;
  if (font.scheme == "minor")
    scheme = 2;
  o.write_shift(1, scheme);
  write_XLWideString(font.name, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
var rev_XLSBFillPTNames;
var parse_BrtFill = parsenoop;
function write_BrtFill(fill2, o) {
  if (!o)
    o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
  if (!rev_XLSBFillPTNames)
    rev_XLSBFillPTNames = evert(XLSBFillPTNames);
  var fls = rev_XLSBFillPTNames[fill2.patternType];
  if (fls == null)
    fls = 40;
  o.write_shift(4, fls);
  var j = 0;
  if (fls != 40) {
    write_BrtColor({ auto: 1 }, o);
    write_BrtColor({ auto: 1 }, o);
    for (; j < 12; ++j)
      o.write_shift(4, 0);
  } else {
    for (; j < 4; ++j)
      o.write_shift(4, 0);
    for (; j < 12; ++j)
      o.write_shift(4, 0);
  }
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtXF(data, length) {
  var tgt = data.l + length;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
function write_BrtXF(data, ixfeP, o) {
  if (!o)
    o = new_buf(16);
  o.write_shift(2, ixfeP || 0);
  o.write_shift(2, data.numFmtId || 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  var flow = 0;
  o.write_shift(1, flow);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  return o;
}
function write_Blxf(data, o) {
  if (!o)
    o = new_buf(10);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
var parse_BrtBorder = parsenoop;
function write_BrtBorder(border, o) {
  if (!o)
    o = new_buf(51);
  o.write_shift(1, 0);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtStyle(style, o) {
  if (!o)
    o = new_buf(12 + 4 * 10);
  o.write_shift(4, style.xfId);
  o.write_shift(2, 1);
  o.write_shift(1, +style.builtinId);
  o.write_shift(1, 0);
  write_XLNullableWideString(style.name || "", o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
  var o = new_buf(4 + 256 * 2 * 4);
  o.write_shift(4, cnt);
  write_XLNullableWideString(defTableStyle, o);
  write_XLNullableWideString(defPivotStyle, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_sty_bin(data, themes, opts) {
  var styles = {};
  styles.NumberFmt = [];
  for (var y in table_fmt)
    styles.NumberFmt[y] = table_fmt[y];
  styles.CellXf = [];
  styles.Fonts = [];
  var state = [];
  var pass = false;
  recordhopper(data, function hopper_sty(val, R, RT) {
    switch (RT) {
      case 44:
        styles.NumberFmt[val[0]] = val[1];
        SSF_load(val[1], val[0]);
        break;
      case 43:
        styles.Fonts.push(val);
        if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
          val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
        }
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        if (state[state.length - 1] == 617) {
          styles.CellXf.push(val);
        }
        break;
      case 48:
      case 507:
      case 572:
      case 475:
        break;
      case 1171:
      case 2102:
      case 1130:
      case 512:
      case 2095:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T > 0)
          state.push(RT);
        else if (R.T < 0)
          state.pop();
        else if (!pass || opts.WTF && state[state.length - 1] != 37)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return styles;
}
function write_FMTS_bin(ba, NF) {
  if (!NF)
    return;
  var cnt = 0;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        ++cnt;
  });
  if (cnt == 0)
    return;
  write_record(ba, 615, write_UInt32LE(cnt));
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        write_record(ba, 44, write_BrtFmt(i, NF[i]));
  });
  write_record(
    ba,
    616
    /* BrtEndFmts */
  );
}
function write_FONTS_bin(ba) {
  var cnt = 1;
  write_record(ba, 611, write_UInt32LE(cnt));
  write_record(ba, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2,
    scheme: "minor"
  }));
  write_record(
    ba,
    612
    /* BrtEndFonts */
  );
}
function write_FILLS_bin(ba) {
  var cnt = 2;
  write_record(ba, 603, write_UInt32LE(cnt));
  write_record(ba, 45, write_BrtFill({ patternType: "none" }));
  write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
  write_record(
    ba,
    604
    /* BrtEndFills */
  );
}
function write_BORDERS_bin(ba) {
  var cnt = 1;
  write_record(ba, 613, write_UInt32LE(cnt));
  write_record(ba, 46, write_BrtBorder());
  write_record(
    ba,
    614
    /* BrtEndBorders */
  );
}
function write_CELLSTYLEXFS_bin(ba) {
  var cnt = 1;
  write_record(ba, 626, write_UInt32LE(cnt));
  write_record(ba, 47, write_BrtXF({
    numFmtId: 0,
    fontId: 0,
    fillId: 0,
    borderId: 0
  }, 65535));
  write_record(
    ba,
    627
    /* BrtEndCellStyleXFs */
  );
}
function write_CELLXFS_bin(ba, data) {
  write_record(ba, 617, write_UInt32LE(data.length));
  data.forEach(function(c) {
    write_record(ba, 47, write_BrtXF(c, 0));
  });
  write_record(
    ba,
    618
    /* BrtEndCellXFs */
  );
}
function write_STYLES_bin(ba) {
  var cnt = 1;
  write_record(ba, 619, write_UInt32LE(cnt));
  write_record(ba, 48, write_BrtStyle({
    xfId: 0,
    builtinId: 0,
    name: "Normal"
  }));
  write_record(
    ba,
    620
    /* BrtEndStyles */
  );
}
function write_DXFS_bin(ba) {
  var cnt = 0;
  write_record(ba, 505, write_UInt32LE(cnt));
  write_record(
    ba,
    506
    /* BrtEndDXFs */
  );
}
function write_TABLESTYLES_bin(ba) {
  var cnt = 0;
  write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
  write_record(
    ba,
    509
    /* BrtEndTableStyles */
  );
}
function write_sty_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    278
    /* BrtBeginStyleSheet */
  );
  write_FMTS_bin(ba, wb.SSF);
  write_FONTS_bin(ba);
  write_FILLS_bin(ba);
  write_BORDERS_bin(ba);
  write_CELLSTYLEXFS_bin(ba);
  write_CELLXFS_bin(ba, opts.cellXfs);
  write_STYLES_bin(ba);
  write_DXFS_bin(ba);
  write_TABLESTYLES_bin(ba);
  write_record(
    ba,
    279
    /* BrtEndStyleSheet */
  );
  return ba.end();
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(t2, themes, opts) {
  themes.themeElements.clrScheme = [];
  var color = {};
  (t2[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      case "<a:srgbClr":
        color.rgb = y.val;
        break;
      case "<a:sysClr":
        color.rgb = y.lastClr;
        break;
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        if (y[0].charAt(1) === "/") {
          themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;
          color = {};
        } else {
          color.name = y[0].slice(3, y[0].length - 1);
        }
        break;
      default:
        if (opts && opts.WTF)
          throw new Error("Unrecognized " + y[0] + " in clrScheme");
    }
  });
}
function parse_fontScheme() {
}
function parse_fmtScheme() {
}
var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function parse_themeElements(data, themes, opts) {
  themes.themeElements = {};
  var t2;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", clrsregex, parse_clrScheme],
    /* fontScheme CT_FontScheme */
    ["fontScheme", fntsregex, parse_fontScheme],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", fmtsregex, parse_fmtScheme]
  ].forEach(function(m) {
    if (!(t2 = data.match(m[1])))
      throw new Error(m[0] + " not found in themeElements");
    m[2](t2, themes, opts);
  });
}
var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function parse_theme_xml(data, opts) {
  if (!data || data.length === 0)
    data = write_theme();
  var t2;
  var themes = {};
  if (!(t2 = data.match(themeltregex)))
    throw new Error("themeElements not found in theme");
  parse_themeElements(t2[0], themes, opts);
  themes.raw = data;
  return themes;
}
function write_theme(Themes, opts) {
  if (opts && opts.themeXLSX)
    return opts.themeXLSX;
  if (Themes && typeof Themes.raw == "string")
    return Themes.raw;
  var o = [XML_HEADER];
  o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o[o.length] = "<a:themeElements>";
  o[o.length] = '<a:clrScheme name="Office">';
  o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o[o.length] = "</a:clrScheme>";
  o[o.length] = '<a:fontScheme name="Office">';
  o[o.length] = "<a:majorFont>";
  o[o.length] = '<a:latin typeface="Cambria"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface=" "/>';
  o[o.length] = '<a:font script="Hang" typeface=" "/>';
  o[o.length] = '<a:font script="Hans" typeface=""/>';
  o[o.length] = '<a:font script="Hant" typeface=""/>';
  o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:majorFont>";
  o[o.length] = "<a:minorFont>";
  o[o.length] = '<a:latin typeface="Calibri"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface=" "/>';
  o[o.length] = '<a:font script="Hang" typeface=" "/>';
  o[o.length] = '<a:font script="Hans" typeface=""/>';
  o[o.length] = '<a:font script="Hant" typeface=""/>';
  o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:minorFont>";
  o[o.length] = "</a:fontScheme>";
  o[o.length] = '<a:fmtScheme name="Office">';
  o[o.length] = "<a:fillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:fillStyleLst>";
  o[o.length] = "<a:lnStyleLst>";
  o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = "</a:lnStyleLst>";
  o[o.length] = "<a:effectStyleLst>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "</a:effectStyleLst>";
  o[o.length] = "<a:bgFillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:bgFillStyleLst>";
  o[o.length] = "</a:fmtScheme>";
  o[o.length] = "</a:themeElements>";
  o[o.length] = "<a:objectDefaults>";
  o[o.length] = "<a:spDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o[o.length] = "</a:spDef>";
  o[o.length] = "<a:lnDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o[o.length] = "</a:lnDef>";
  o[o.length] = "</a:objectDefaults>";
  o[o.length] = "<a:extraClrSchemeLst/>";
  o[o.length] = "</a:theme>";
  return o.join("");
}
function parse_Theme(blob, length, opts) {
  var end = blob.l + length;
  var dwThemeVersion = blob.read_shift(4);
  if (dwThemeVersion === 124226)
    return;
  if (!opts.cellStyles) {
    blob.l = end;
    return;
  }
  var data = blob.slice(blob.l);
  blob.l = end;
  var zip;
  try {
    zip = zip_read(data, { type: "array" });
  } catch (e) {
    return;
  }
  var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
  if (!themeXML)
    return;
  return parse_theme_xml(themeXML, opts);
}
function parse_ColorTheme(blob) {
  return blob.read_shift(4);
}
function parse_FullColorExt(blob) {
  var o = {};
  o.xclrType = blob.read_shift(2);
  o.nTintShade = blob.read_shift(2);
  switch (o.xclrType) {
    case 0:
      blob.l += 4;
      break;
    case 1:
      o.xclrValue = parse_IcvXF(blob, 4);
      break;
    case 2:
      o.xclrValue = parse_LongRGBA(blob);
      break;
    case 3:
      o.xclrValue = parse_ColorTheme(blob);
      break;
    case 4:
      blob.l += 4;
      break;
  }
  blob.l += 8;
  return o;
}
function parse_IcvXF(blob, length) {
  return parsenoop(blob, length);
}
function parse_XFExtGradient(blob, length) {
  return parsenoop(blob, length);
}
function parse_ExtProp(blob) {
  var extType = blob.read_shift(2);
  var cb = blob.read_shift(2) - 4;
  var o = [extType];
  switch (extType) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      o[1] = parse_FullColorExt(blob);
      break;
    case 6:
      o[1] = parse_XFExtGradient(blob, cb);
      break;
    case 14:
    case 15:
      o[1] = blob.read_shift(cb === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
  }
  return o;
}
function parse_XFExt(blob, length) {
  var end = blob.l + length;
  blob.l += 2;
  var ixfe = blob.read_shift(2);
  blob.l += 2;
  var cexts = blob.read_shift(2);
  var ext = [];
  while (cexts-- > 0)
    ext.push(parse_ExtProp(blob, end - blob.l));
  return { ixfe, ext };
}
function update_xfext(xf, xfext) {
  xfext.forEach(function(xfe) {
    switch (xfe[0]) {
    }
  });
}
function parse_BrtMdtinfo(data, length) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
function write_BrtMdtinfo(data) {
  var o = new_buf(12 + 2 * data.name.length);
  o.write_shift(4, data.flags);
  o.write_shift(4, data.version);
  write_XLWideString(data.name, o);
  return o.slice(0, o.l);
}
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
function write_BrtMdb(mdb) {
  var o = new_buf(4 + 8 * mdb.length);
  o.write_shift(4, mdb.length);
  for (var i = 0; i < mdb.length; ++i) {
    o.write_shift(4, mdb[i][0]);
    o.write_shift(4, mdb[i][1]);
  }
  return o;
}
function write_BrtBeginEsfmd(cnt, name) {
  var o = new_buf(8 + 2 * name.length);
  o.write_shift(4, cnt);
  write_XLWideString(name, o);
  return o.slice(0, o.l);
}
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
function write_BrtBeginEsmdb(cnt, cm) {
  var o = new_buf(8);
  o.write_shift(4, cnt);
  o.write_shift(4, cm ? 1 : 0);
  return o;
}
function parse_xlmeta_bin(data, name, _opts) {
  var out = { Types: [], Cell: [], Value: [] };
  var opts = _opts || {};
  var state = [];
  var pass = false;
  var metatype = 2;
  recordhopper(data, function(val, R, RT) {
    switch (RT) {
      case 335:
        out.Types.push({ name: val.name });
        break;
      case 51:
        val.forEach(function(r) {
          if (metatype == 1)
            out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });
        });
        break;
      case 337:
        metatype = val ? 1 : 0;
        break;
      case 338:
        metatype = 2;
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_xlmeta_bin() {
  var ba = buf_array();
  write_record(ba, 332);
  write_record(ba, 334, write_UInt32LE(1));
  write_record(ba, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  }));
  write_record(ba, 336);
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
  write_record(ba, 52);
  write_record(ba, 35, write_UInt32LE(514));
  write_record(ba, 4096, write_UInt32LE(0));
  write_record(ba, 4097, writeuint16(1));
  write_record(ba, 36);
  write_record(ba, 53);
  write_record(ba, 340);
  write_record(ba, 337, write_BrtBeginEsmdb(1, true));
  write_record(ba, 51, write_BrtMdb([[1, 0]]));
  write_record(ba, 338);
  write_record(ba, 333);
  return ba.end();
}
function parse_xlmeta_xml(data, name, opts) {
  var out = { Types: [], Cell: [], Value: [] };
  if (!data)
    return out;
  var pass = false;
  var metatype = 2;
  var lastmeta;
  data.replace(tagregex, function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        out.Types.push({ name: y.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var j = 0; j < out.Types.length; ++j)
          if (out.Types[j].name == y.name)
            lastmeta = out.Types[j];
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        if (metatype == 1)
          out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });
        else if (metatype == 0)
          out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        metatype = 1;
        break;
      case "</cellMetadata>":
        metatype = 2;
        break;
      case "<valueMetadata":
        metatype = 0;
        break;
      case "</valueMetadata>":
        metatype = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<rvb":
        if (!lastmeta)
          break;
        if (!lastmeta.offsets)
          lastmeta.offsets = [];
        lastmeta.offsets.push(+y.i);
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in metadata");
    }
    return x;
  });
  return out;
}
function write_xlmeta_xml() {
  var o = [XML_HEADER];
  o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
  return o.join("");
}
function parse_cc_xml(data) {
  var d = [];
  if (!data)
    return d;
  var i = 1;
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<?xml":
        break;
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      case "<c":
        delete y[0];
        if (y.i)
          i = y.i;
        else
          y.i = i;
        d.push(y);
        break;
    }
  });
  return d;
}
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2)
    out.l = "1";
  if (flags & 8)
    out.a = "1";
  return out;
}
function parse_cc_bin(data, name, opts) {
  var out = [];
  recordhopper(data, function hopper_cc(val, R, RT) {
    switch (RT) {
      case 63:
        out.push(val);
        break;
      default:
        if (R.T)
          ;
        else
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(data, rel, name, _opts) {
  if (!data)
    return data;
  var opts = _opts || {};
  var pass = false;
  recordhopper(data, function xlink_parse(val, R, RT) {
    switch (RT) {
      case 359:
      case 363:
      case 364:
      case 366:
      case 367:
      case 368:
      case 369:
      case 370:
      case 371:
      case 472:
      case 577:
      case 578:
      case 579:
      case 580:
      case 581:
      case 582:
      case 583:
      case 584:
      case 585:
      case 586:
      case 587:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
}
function parse_drawing(data, rels) {
  if (!data)
    return "??";
  var id = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return rels["!id"][id].Target;
}
var _shapeid = 1024;
function write_comments_vml(rId, comments) {
  var csize = [21600, 21600];
  var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
  var o = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" }),
    writextag("v:shapetype", [
      writextag("v:stroke", null, { joinstyle: "miter" }),
      writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: csize.join(","), path: bbox })
  ];
  while (_shapeid < rId * 1e3)
    _shapeid += 1e3;
  comments.forEach(function(x) {
    var c = decode_cell(x[0]);
    var fillopts = (
      /*::(*/
      { "color2": "#BEFF82", "type": "gradient" }
    );
    if (fillopts.type == "gradient")
      fillopts.angle = "-180";
    var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
    var fillxml = writextag("v:fill", fillparm, fillopts);
    var shadata = { on: "t", "obscured": "t" };
    ++_shapeid;
    o = o.concat([
      "<v:shape" + wxt_helper({
        id: "_x0000_s" + _shapeid,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      fillxml,
      writextag("v:shadow", null, shadata),
      writextag("v:path", null, { "o:connecttype": "none" }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
      /* Part 4 19.4.2.3 Anchor (Anchor) */
      writetag("x:Anchor", [c.c + 1, 0, c.r + 1, 0, c.c + 3, 20, c.r + 5, 20].join(",")),
      writetag("x:AutoFill", "False"),
      writetag("x:Row", String(c.r)),
      writetag("x:Column", String(c.c)),
      x[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ]);
  });
  o.push("</xml>");
  return o.join("");
}
function sheet_insert_comments(sheet, comments, threaded, people) {
  var dense = Array.isArray(sheet);
  var cell;
  comments.forEach(function(comment) {
    var r = decode_cell(comment.ref);
    if (dense) {
      if (!sheet[r.r])
        sheet[r.r] = [];
      cell = sheet[r.r][r.c];
    } else
      cell = sheet[comment.ref];
    if (!cell) {
      cell = { t: "z" };
      if (dense)
        sheet[r.r][r.c] = cell;
      else
        sheet[comment.ref] = cell;
      var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
      if (range.s.r > r.r)
        range.s.r = r.r;
      if (range.e.r < r.r)
        range.e.r = r.r;
      if (range.s.c > r.c)
        range.s.c = r.c;
      if (range.e.c < r.c)
        range.e.c = r.c;
      var encoded = encode_range(range);
      if (encoded !== sheet["!ref"])
        sheet["!ref"] = encoded;
    }
    if (!cell.c)
      cell.c = [];
    var o = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
    if (comment.h)
      o.h = comment.h;
    for (var i = cell.c.length - 1; i >= 0; --i) {
      if (!threaded && cell.c[i].T)
        return;
      if (threaded && !cell.c[i].T)
        cell.c.splice(i, 1);
    }
    if (threaded && people)
      for (i = 0; i < people.length; ++i) {
        if (o.a == people[i].id) {
          o.a = people[i].name || o.a;
          break;
        }
      }
    cell.c.push(o);
  });
}
function parse_comments_xml(data, opts) {
  if (data.match(/<(?:\w+:)?comments *\/>/))
    return [];
  var authors = [];
  var commentList = [];
  var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  if (authtag && authtag[1])
    authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
      if (x === "" || x.trim() === "")
        return;
      var a = x.match(/<(?:\w+:)?author[^>]*>(.*)/);
      if (a)
        authors.push(a[1]);
    });
  var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  if (cmnttag && cmnttag[1])
    cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
      if (x === "" || x.trim() === "")
        return;
      var cm = x.match(/<(?:\w+:)?comment[^>]*>/);
      if (!cm)
        return;
      var y = parsexmltag(cm[0]);
      var comment = { author: y.authorId && authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid };
      var cell = decode_cell(y.ref);
      if (opts.sheetRows && opts.sheetRows <= cell.r)
        return;
      var textMatch = x.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
      var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
      comment.r = rt.r;
      if (rt.r == "<t></t>")
        rt.t = rt.h = "";
      comment.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      if (opts.cellHTML)
        comment.h = rt.h;
      commentList.push(comment);
    });
  return commentList;
}
function write_comments_xml(data) {
  var o = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
  var iauthor = [];
  o.push("<authors>");
  data.forEach(function(x) {
    x[1].forEach(function(w) {
      var a = escapexml(w.a);
      if (iauthor.indexOf(a) == -1) {
        iauthor.push(a);
        o.push("<author>" + a + "</author>");
      }
      if (w.T && w.ID && iauthor.indexOf("tc=" + w.ID) == -1) {
        iauthor.push("tc=" + w.ID);
        o.push("<author>tc=" + w.ID + "</author>");
      }
    });
  });
  if (iauthor.length == 0) {
    iauthor.push("SheetJ5");
    o.push("<author>SheetJ5</author>");
  }
  o.push("</authors>");
  o.push("<commentList>");
  data.forEach(function(d) {
    var lastauthor = 0, ts = [];
    if (d[1][0] && d[1][0].T && d[1][0].ID)
      lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
    else
      d[1].forEach(function(c) {
        if (c.a)
          lastauthor = iauthor.indexOf(escapexml(c.a));
        ts.push(c.t || "");
      });
    o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
    if (ts.length <= 1)
      o.push(writetag("t", escapexml(ts[0] || "")));
    else {
      var t2 = "Comment:\n    " + ts[0] + "\n";
      for (var i = 1; i < ts.length; ++i)
        t2 += "Reply:\n    " + ts[i] + "\n";
      o.push(writetag("t", escapexml(t2)));
    }
    o.push("</text></comment>");
  });
  o.push("</commentList>");
  if (o.length > 2) {
    o[o.length] = "</comments>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_tcmnt_xml(data, opts) {
  var out = [];
  var pass = false, comment = {}, tidx = 0;
  data.replace(tagregex, function xml_tcmnt(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      case "<threadedComment":
        comment = { author: y.personId, guid: y.id, ref: y.ref, T: 1 };
        break;
      case "</threadedComment>":
        if (comment.t != null)
          out.push(comment);
        break;
      case "<text>":
      case "<text":
        tidx = idx + x.length;
        break;
      case "</text>":
        comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        break;
      case "<mentions":
      case "<mentions>":
        pass = true;
        break;
      case "</mentions>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function write_tcmnt_xml(comments, people, opts) {
  var o = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  comments.forEach(function(carr) {
    var rootid = "";
    (carr[1] || []).forEach(function(c, idx) {
      if (!c.T) {
        delete c.ID;
        return;
      }
      if (c.a && people.indexOf(c.a) == -1)
        people.push(c.a);
      var tcopts = {
        ref: carr[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
      };
      if (idx == 0)
        rootid = tcopts.id;
      else
        tcopts.parentId = rootid;
      c.ID = tcopts.id;
      if (c.a)
        tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
      o.push(writextag("threadedComment", writetag("text", c.t || ""), tcopts));
    });
  });
  o.push("</ThreadedComments>");
  return o.join("");
}
function parse_people_xml(data, opts) {
  var out = [];
  var pass = false;
  data.replace(tagregex, function xml_tcmnt(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<personList":
        break;
      case "</personList>":
        break;
      case "<person":
        out.push({ name: y.displayname, id: y.id });
        break;
      case "</person>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function write_people_xml(people) {
  var o = [XML_HEADER, writextag("personList", null, {
    "xmlns": XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  people.forEach(function(person, idx) {
    o.push(writextag("person", null, {
      displayName: person,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
      userId: person,
      providerId: "None"
    }));
  });
  o.push("</personList>");
  return o.join("");
}
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
function write_BrtBeginComment(data, o) {
  if (o == null)
    o = new_buf(36);
  o.write_shift(4, data[1].iauthor);
  write_UncheckedRfX(data[0], o);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(data) {
  return write_XLWideString(data.slice(0, 54));
}
function parse_comments_bin(data, opts) {
  var out = [];
  var authors = [];
  var c = {};
  var pass = false;
  recordhopper(data, function hopper_cmnt(val, R, RT) {
    switch (RT) {
      case 632:
        authors.push(val);
        break;
      case 635:
        c = val;
        break;
      case 637:
        c.t = val.t;
        c.h = val.h;
        c.r = val.r;
        break;
      case 636:
        c.author = authors[c.iauthor];
        delete c.iauthor;
        if (opts.sheetRows && c.rfx && opts.sheetRows <= c.rfx.r)
          break;
        if (!c.t)
          c.t = "";
        delete c.rfx;
        out.push(c);
        break;
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_comments_bin(data) {
  var ba = buf_array();
  var iauthor = [];
  write_record(
    ba,
    628
    /* BrtBeginComments */
  );
  write_record(
    ba,
    630
    /* BrtBeginCommentAuthors */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c) {
      if (iauthor.indexOf(c.a) > -1)
        return;
      iauthor.push(c.a.slice(0, 54));
      write_record(ba, 632, write_BrtCommentAuthor(c.a));
    });
  });
  write_record(
    ba,
    631
    /* BrtEndCommentAuthors */
  );
  write_record(
    ba,
    633
    /* BrtBeginCommentList */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c) {
      c.iauthor = iauthor.indexOf(c.a);
      var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
      write_record(ba, 635, write_BrtBeginComment([range, c]));
      if (c.t && c.t.length > 0)
        write_record(ba, 637, write_BrtCommentText(c));
      write_record(
        ba,
        636
        /* BrtEndComment */
      );
      delete c.iauthor;
    });
  });
  write_record(
    ba,
    634
    /* BrtEndCommentList */
  );
  write_record(
    ba,
    629
    /* BrtEndComments */
  );
  return ba.end();
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(cfb) {
  var newcfb = CFB.utils.cfb_new({ root: "R" });
  cfb.FullPaths.forEach(function(p, i) {
    if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/))
      return;
    var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
  });
  return CFB.write(newcfb);
}
function fill_vba_xls(cfb, vba) {
  vba.FullPaths.forEach(function(p, i) {
    if (i == 0)
      return;
    var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
    if (newpath.slice(-1) !== "/")
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
  });
}
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0)
      rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0)
      cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel)
      C += rcbase.c;
    else
      --C;
    if (rRel)
      R += rcbase.r;
    else
      --R;
    return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
  }
  return function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  };
}();
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var a1_to_rc = /* @__PURE__ */ function() {
  return function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c = decode_col($3) - ($2 ? 0 : base.c);
      var r = decode_row($5) - ($4 ? 0 : base.r);
      var R = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
      var C = c == 0 ? "" : !$2 ? "[" + c + "]" : c + 1;
      return $1 + "R" + R + "C" + C;
    });
  };
}();
function shift_formula_str(f, delta) {
  return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
function shift_formula_xlsx(f, range, cell) {
  var r = decode_range(range), s = r.s, c = decode_cell(cell);
  var delta = { r: c.r - s.r, c: c.c - s.c };
  return shift_formula_str(f, delta);
}
function fuzzyfmla(f) {
  if (f.length == 1)
    return false;
  return true;
}
function _xlfn(f) {
  return f.replace(/_xlfn\./g, "");
}
function parseread1(blob) {
  blob.l += 1;
  return;
}
function parse_ColRelU(blob, length) {
  var c = blob.read_shift(length == 1 ? 1 : 2);
  return [c & 16383, c >> 14 & 1, c >> 15 & 1];
}
function parse_RgceArea(blob, length, opts) {
  var w = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return parse_RgceArea_BIFF2(blob);
    else if (opts.biff == 12)
      w = 4;
  }
  var r = blob.read_shift(w), R = blob.read_shift(w);
  var c = parse_ColRelU(blob, 2);
  var C = parse_ColRelU(blob, 2);
  return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
}
function parse_RgceArea_BIFF2(blob) {
  var r = parse_ColRelU(blob, 2), R = parse_ColRelU(blob, 2);
  var c = blob.read_shift(1);
  var C = blob.read_shift(1);
  return { s: { r: r[0], c, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
}
function parse_RgceAreaRel(blob, length, opts) {
  if (opts.biff < 8)
    return parse_RgceArea_BIFF2(blob);
  var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var c = parse_ColRelU(blob, 2);
  var C = parse_ColRelU(blob, 2);
  return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
}
function parse_RgceLoc(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5)
    return parse_RgceLoc_BIFF2(blob);
  var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c = parse_ColRelU(blob, 2);
  return { r, c: c[0], cRel: c[1], rRel: c[2] };
}
function parse_RgceLoc_BIFF2(blob) {
  var r = parse_ColRelU(blob, 2);
  var c = blob.read_shift(1);
  return { r: r[0], c, cRel: r[1], rRel: r[2] };
}
function parse_RgceElfLoc(blob) {
  var r = blob.read_shift(2);
  var c = blob.read_shift(2);
  return { r, c: c & 255, fQuoted: !!(c & 16384), cRel: c >> 15, rRel: c >> 15 };
}
function parse_RgceLocRel(blob, length, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5)
    return parse_RgceLocRel_BIFF2(blob);
  var r = blob.read_shift(biff >= 12 ? 4 : 2);
  var cl = blob.read_shift(2);
  var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
  cl &= 16383;
  if (rRel == 1)
    while (r > 524287)
      r -= 1048576;
  if (cRel == 1)
    while (cl > 8191)
      cl = cl - 16384;
  return { r, c: cl, cRel, rRel };
}
function parse_RgceLocRel_BIFF2(blob) {
  var rl = blob.read_shift(2);
  var c = blob.read_shift(1);
  var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
  rl &= 16383;
  if (rRel == 1 && rl >= 8192)
    rl = rl - 16384;
  if (cRel == 1 && c >= 128)
    c = c - 256;
  return { r: rl, c, cRel, rRel };
}
function parse_PtgArea(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
function parse_PtgArea3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2, "i");
  var w = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
  var area = parse_RgceArea(blob, w, opts);
  return [type, ixti, area];
}
function parse_PtgAreaErr(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
function parse_PtgAreaErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
  blob.l += w;
  return [type, ixti];
}
function parse_PtgAreaN(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob, length - 1, opts);
  return [type, area];
}
function parse_PtgArray(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
function parse_PtgAttrBaxcel(blob) {
  var bitSemi = blob[blob.l + 1] & 1;
  var bitBaxcel = 1;
  blob.l += 4;
  return [bitSemi, bitBaxcel];
}
function parse_PtgAttrChoose(blob, length, opts) {
  blob.l += 2;
  var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o = [];
  for (var i = 0; i <= offset; ++i)
    o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o;
}
function parse_PtgAttrGoto(blob, length, opts) {
  var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(blob, length, opts) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(blob) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(2)];
}
function parse_PtgAttrSemi(blob, length, opts) {
  var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
function parse_PtgAttrSpaceType(blob) {
  var type = blob.read_shift(1), cch = blob.read_shift(1);
  return [type, cch];
}
function parse_PtgAttrSpace(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgAttrSpaceSemi(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgRef(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRefN(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLocRel(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRef3d(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var ixti = blob.read_shift(2);
  if (opts && opts.biff == 5)
    blob.l += 12;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, ixti, loc];
}
function parse_PtgFunc(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
function parse_PtgFuncVar(blob, length, opts) {
  var type = blob[blob.l++];
  var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
function parsetab(blob) {
  return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
}
function parse_PtgAttrSum(blob, length, opts) {
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
function parse_PtgExp(blob, length, opts) {
  blob.l++;
  if (opts && opts.biff == 12)
    return [blob.read_shift(4, "i"), 0];
  var row = blob.read_shift(2);
  var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
function parse_PtgErr(blob) {
  blob.l++;
  return BErr[blob.read_shift(1)];
}
function parse_PtgInt(blob) {
  blob.l++;
  return blob.read_shift(2);
}
function parse_PtgBool(blob) {
  blob.l++;
  return blob.read_shift(1) !== 0;
}
function parse_PtgNum(blob) {
  blob.l++;
  return parse_Xnum(blob);
}
function parse_PtgStr(blob, length, opts) {
  blob.l++;
  return parse_ShortXLUnicodeString(blob, length - 1, opts);
}
function parse_SerAr(blob, biff) {
  var val = [blob.read_shift(1)];
  if (biff == 12)
    switch (val[0]) {
      case 2:
        val[0] = 4;
        break;
      case 4:
        val[0] = 16;
        break;
      case 0:
        val[0] = 1;
        break;
      case 1:
        val[0] = 2;
        break;
    }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
      if (biff != 12)
        blob.l += 7;
      break;
    case 37:
    case 16:
      val[1] = BErr[blob[blob.l]];
      blob.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
function parse_PtgExtraMem(blob, cce, opts) {
  var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i = 0; i != count; ++i)
    out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
  return out;
}
function parse_PtgExtraArray(blob, length, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob.read_shift(4);
    cols = blob.read_shift(4);
  } else {
    cols = 1 + blob.read_shift(1);
    rows = 1 + blob.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0)
      cols = 256;
  }
  for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
    for (var j = 0; j != cols; ++j)
      o[i][j] = parse_SerAr(blob, opts.biff);
  return o;
}
function parse_PtgName(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var w = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob.read_shift(w);
  switch (opts.biff) {
    case 2:
      blob.l += 5;
      break;
    case 3:
    case 4:
      blob.l += 8;
      break;
    case 5:
      blob.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
function parse_PtgNameX(blob, length, opts) {
  if (opts.biff == 5)
    return parse_PtgNameX_BIFF5(blob);
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2);
  var nameindex = blob.read_shift(4);
  return [type, ixti, nameindex];
}
function parse_PtgNameX_BIFF5(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2, "i");
  blob.l += 8;
  var nameindex = blob.read_shift(2);
  blob.l += 12;
  return [type, ixti, nameindex];
}
function parse_PtgMemArea(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgMemFunc(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgRefErr(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += 4;
  if (opts.biff < 8)
    blob.l--;
  if (opts.biff == 12)
    blob.l += 2;
  return [type];
}
function parse_PtgRefErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w = 4;
  if (opts)
    switch (opts.biff) {
      case 5:
        w = 15;
        break;
      case 12:
        w = 6;
        break;
    }
  blob.l += w;
  return [type, ixti];
}
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob, length, opts) {
  blob.l += 2;
  return [parse_RgceElfLoc(blob)];
}
function parse_PtgElfNoop(blob) {
  blob.l += 6;
  return [];
}
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob) {
  blob.l += 2;
  return [parseuint16(blob), blob.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob) {
  blob.l += 2;
  var ixti = blob.read_shift(2);
  var flags = blob.read_shift(2);
  var idx = blob.read_shift(4);
  var c = blob.read_shift(2);
  var C = blob.read_shift(2);
  var rt = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt, idx, c, C };
}
function parse_PtgSxName(blob) {
  blob.l += 2;
  return [blob.read_shift(4)];
}
function parse_PtgSheet(blob, length, opts) {
  blob.l += 5;
  blob.l += 2;
  blob.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
function parse_PtgEndSheet(blob, length, opts) {
  blob.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgMemNoMemN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgAttrNoop(blob) {
  blob.l += 4;
  return [0, 0];
}
var PtgTypes = {
  /*::[*/
  1: { n: "PtgExp", f: parse_PtgExp },
  /*::[*/
  2: { n: "PtgTbl", f: parse_PtgTbl },
  /*::[*/
  3: { n: "PtgAdd", f: parseread1 },
  /*::[*/
  4: { n: "PtgSub", f: parseread1 },
  /*::[*/
  5: { n: "PtgMul", f: parseread1 },
  /*::[*/
  6: { n: "PtgDiv", f: parseread1 },
  /*::[*/
  7: { n: "PtgPower", f: parseread1 },
  /*::[*/
  8: { n: "PtgConcat", f: parseread1 },
  /*::[*/
  9: { n: "PtgLt", f: parseread1 },
  /*::[*/
  10: { n: "PtgLe", f: parseread1 },
  /*::[*/
  11: { n: "PtgEq", f: parseread1 },
  /*::[*/
  12: { n: "PtgGe", f: parseread1 },
  /*::[*/
  13: { n: "PtgGt", f: parseread1 },
  /*::[*/
  14: { n: "PtgNe", f: parseread1 },
  /*::[*/
  15: { n: "PtgIsect", f: parseread1 },
  /*::[*/
  16: { n: "PtgUnion", f: parseread1 },
  /*::[*/
  17: { n: "PtgRange", f: parseread1 },
  /*::[*/
  18: { n: "PtgUplus", f: parseread1 },
  /*::[*/
  19: { n: "PtgUminus", f: parseread1 },
  /*::[*/
  20: { n: "PtgPercent", f: parseread1 },
  /*::[*/
  21: { n: "PtgParen", f: parseread1 },
  /*::[*/
  22: { n: "PtgMissArg", f: parseread1 },
  /*::[*/
  23: { n: "PtgStr", f: parse_PtgStr },
  /*::[*/
  26: { n: "PtgSheet", f: parse_PtgSheet },
  /*::[*/
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  /*::[*/
  28: { n: "PtgErr", f: parse_PtgErr },
  /*::[*/
  29: { n: "PtgBool", f: parse_PtgBool },
  /*::[*/
  30: { n: "PtgInt", f: parse_PtgInt },
  /*::[*/
  31: { n: "PtgNum", f: parse_PtgNum },
  /*::[*/
  32: { n: "PtgArray", f: parse_PtgArray },
  /*::[*/
  33: { n: "PtgFunc", f: parse_PtgFunc },
  /*::[*/
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  /*::[*/
  35: { n: "PtgName", f: parse_PtgName },
  /*::[*/
  36: { n: "PtgRef", f: parse_PtgRef },
  /*::[*/
  37: { n: "PtgArea", f: parse_PtgArea },
  /*::[*/
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  /*::[*/
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  /*::[*/
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  /*::[*/
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  /*::[*/
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  /*::[*/
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  /*::[*/
  44: { n: "PtgRefN", f: parse_PtgRefN },
  /*::[*/
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  /*::[*/
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  /*::[*/
  57: { n: "PtgNameX", f: parse_PtgNameX },
  /*::[*/
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  /*::[*/
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  /*::[*/
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  /*::[*/
  255: {}
};
var PtgDupes = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var Ptg18 = {
  /*::[*/
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  /*::[*/
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  /*::[*/
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  /*::[*/
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  /*::[*/
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  /*::[*/
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  /*::[*/
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  /*::[*/
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  /*::[*/
  25: { n: "PtgList", f: parse_PtgList },
  /*::[*/
  29: { n: "PtgSxName", f: parse_PtgSxName },
  /*::[*/
  255: {}
};
var Ptg19 = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  /*::[*/
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  /*::[*/
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  /*::[*/
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  /*::[*/
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  /*::[*/
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  /*::[*/
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  /*::[*/
  255: {}
};
function parse_RgbExtra(blob, length, rgce, opts) {
  if (opts.biff < 8)
    return parsenoop(blob, length);
  var target = blob.l + length;
  var o = [];
  for (var i = 0; i !== rgce.length; ++i) {
    switch (rgce[i][0]) {
      case "PtgArray":
        rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
        o.push(rgce[i][1]);
        break;
      case "PtgMemArea":
        rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
        o.push(rgce[i][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i][1][1] = blob.read_shift(4);
          o.push(rgce[i][1]);
        }
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i][0];
    }
  }
  length = target - blob.l;
  if (length !== 0)
    o.push(parsenoop(blob, length));
  return o;
}
function parse_Rgce(blob, length, opts) {
  var target = blob.l + length;
  var R, id, ptgs = [];
  while (target != blob.l) {
    length = target - blob.l;
    id = blob[blob.l];
    R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
    if (id === 24 || id === 25)
      R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
    if (!R || !R.f) {
      parsenoop(blob, length);
    } else {
      ptgs.push([R.n, R.f(blob, length, opts)]);
    }
  }
  return ptgs;
}
function stringify_array(f) {
  var o = [];
  for (var i = 0; i < f.length; ++i) {
    var x = f[i], r = [];
    for (var j = 0; j < x.length; ++j) {
      var y = x[j];
      if (y)
        switch (y[0]) {
          case 2:
            r.push('"' + y[1].replace(/"/g, '""') + '"');
            break;
          default:
            r.push(y[1]);
        }
      else
        r.push("");
    }
    o.push(r.join(","));
  }
  return o.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2))
    throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname))
    return "'" + sname + "'";
  return sname;
}
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks)
    return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti]))
    return supbooks.SheetNames[ixti];
  if (!supbooks.XTI)
    return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4)
      ixti -= 65536;
    if (ixti < 0)
      ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI)
    return "SH33TJSERR1";
  var o = "";
  if (opts.biff > 8)
    switch (supbooks[XTI[0]][0]) {
      case 357:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 358:
        if (opts.SID != null)
          return supbooks.SheetNames[opts.SID];
        return "SH33TJSSAME" + supbooks[XTI[0]][0];
      case 355:
      default:
        return "SH33TJSSRC" + supbooks[XTI[0]][0];
    }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    default:
      if (!supbooks[XTI[0]][0][3])
        return "SH33TJSERR2";
      o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  );
  var stack = [], e1, e2, c, ixti = 0, nameidx = 0, r, sname = "";
  if (!formula[0] || !formula[0][0])
    return "";
  var last_sp = -1, sp = "";
  for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
    var f = formula[0][ff];
    switch (f[0]) {
      case "PtgUminus":
        stack.push("-" + stack.pop());
        break;
      case "PtgUplus":
        stack.push("+" + stack.pop());
        break;
      case "PtgPercent":
        stack.push(stack.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        e1 = stack.pop();
        e2 = stack.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e2 = e2 + sp;
          last_sp = -1;
        }
        stack.push(e2 + PtgBinOp[f[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + ":" + e1);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c = shift_cell_xls(f[1][1], _range, opts);
        stack.push(encode_cell_xls(c, biff));
        break;
      case "PtgRefN":
        c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
        stack.push(encode_cell_xls(c, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f[1][1];
        c = shift_cell_xls(f[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_cell_xls(c, biff));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var argc = f[1][0], func = f[1][1];
        if (!argc)
          argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack.slice(-argc);
        stack.length -= argc;
        if (func === "User")
          func = args.shift();
        stack.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack.push(f[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack.push(String(f[1]));
        break;
      case "PtgStr":
        stack.push('"' + f[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea":
        r = shift_range_xls(f[1][1], _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f[1][1];
        r = f[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_range_xls(r, opts));
        break;
      case "PtgAttrSum":
        stack.push("SUM(" + stack.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn)
          name = name.slice(6);
        stack.push(name);
        break;
      case "PtgNameX":
        var bookidx = f[1][1];
        nameidx = f[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0)
            bookidx = -bookidx;
          if (supbooks[bookidx])
            externbook = supbooks[bookidx][nameidx];
        } else {
          var o = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849)
            ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else
            o = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx])
            o += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx])
            o += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1])
              o = ixtidata[nameidx - 1];
            else
              o += "SH33TJSERRX";
          }
          stack.push(o);
          break;
        }
        if (!externbook)
          externbook = { Name: "SH33TJSERRY" };
        stack.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack.push(lp + stack.pop() + rp);
        break;
      case "PtgRefErr":
        stack.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack.push("#REF!");
        break;
      case "PtgExp":
        c = { c: f[1][1], r: f[1][0] };
        var q = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c)]) {
          var parsedf = supbooks.sharedf[encode_cell(c)];
          stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e2 = supbooks.arrayf[e1];
            if (c.c < e2[0].s.c || c.c > e2[0].e.c)
              continue;
            if (c.r < e2[0].s.r || c.r > e2[0].e.r)
              continue;
            stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd)
            stack.push(
              /*::String(*/
              f[1]
              /*::)*/
            );
        }
        break;
      case "PtgArray":
        stack.push("{" + stringify_array(
          /*::(*/
          f[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        last_sp = ff;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack.push("");
        break;
      case "PtgAreaErr":
        stack.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack.push("#REF!");
        break;
      case "PtgList":
        stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
        f = formula[0][last_sp];
        var _left = true;
        switch (f[1][0]) {
          case 4:
            _left = false;
          case 0:
            sp = fill(" ", f[1][1]);
            break;
          case 5:
            _left = false;
          case 1:
            sp = fill("\r", f[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF)
              throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
        }
        stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack.length > 1 && opts.WTF)
    throw new Error("bad formula stack");
  return stack[0];
}
function parse_ArrayParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535)
    return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len)
    rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_XLSCellParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535)
    return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len)
    rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_NameParsedFormula(blob, length, opts, cce) {
  var target = blob.l + length;
  var rgce = parse_Rgce(blob, cce, opts);
  var rgcb;
  if (target !== blob.l)
    rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
  return [rgce, rgcb];
}
function parse_SharedParsedFormula(blob, length, opts) {
  var target = blob.l + length;
  var rgcb, cce = blob.read_shift(2);
  var rgce = parse_Rgce(blob, cce, opts);
  if (cce == 65535)
    return [[], parsenoop(blob, length - 2)];
  if (length !== cce + 2)
    rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
  return [rgce, rgcb];
}
function parse_FormulaValue(blob) {
  var b;
  if (__readUInt16LE(blob, blob.l + 6) !== 65535)
    return [parse_Xnum(blob), "n"];
  switch (blob[blob.l]) {
    case 0:
      blob.l += 8;
      return ["String", "s"];
    case 1:
      b = blob[blob.l + 2] === 1;
      blob.l += 8;
      return [b, "b"];
    case 2:
      b = blob[blob.l + 2];
      blob.l += 8;
      return [b, "e"];
    case 3:
      blob.l += 8;
      return ["", "s"];
  }
  return [];
}
function write_FormulaValue(value) {
  if (value == null) {
    var o = new_buf(8);
    o.write_shift(1, 3);
    o.write_shift(1, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 65535);
    return o;
  } else if (typeof value == "number")
    return write_Xnum(value);
  return write_Xnum(0);
}
function parse_Formula(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2)
    ++blob.l;
  var val = parse_FormulaValue(blob);
  var flags = blob.read_shift(1);
  if (opts.biff != 2) {
    blob.read_shift(1);
    if (opts.biff >= 5) {
      blob.read_shift(4);
    }
  }
  var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
  return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
}
function write_Formula(cell, R, C, opts, os) {
  var o1 = write_XLSCell(R, C, os);
  var o2 = write_FormulaValue(cell.v);
  var o3 = new_buf(6);
  var flags = 1 | 32;
  o3.write_shift(2, flags);
  o3.write_shift(4, 0);
  var bf = new_buf(cell.bf.length);
  for (var i = 0; i < cell.bf.length; ++i)
    bf[i] = cell.bf[i];
  var out = bconcat([o1, o2, o3, bf]);
  return out;
}
function parse_XLSBParsedFormula(data, length, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb = data.read_shift(4);
  var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  return [rgce, rgcb];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(f) {
  if (f.slice(0, 3) == "of:")
    f = f.slice(3);
  if (f.charCodeAt(0) == 61) {
    f = f.slice(1);
    if (f.charCodeAt(0) == 61)
      f = f.slice(1);
  }
  f = f.replace(/COM\.MICROSOFT\./g, "");
  f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
    return $1.replace(/\./g, "");
  });
  f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
  return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function csf_to_ods_formula(f) {
  var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return o.replace(/;/g, "|").replace(/,/g, ";");
}
function ods_to_csf_3D(r) {
  var a = r.split(":");
  var s = a[0].split(".")[0];
  return [s, a[0].split(".")[1] + (a.length > 1 ? ":" + (a[1].split(".")[1] || a[1].split(".")[0]) : "")];
}
function csf_to_ods_3D(r) {
  return r.replace(/\./, "!");
}
var strs = {};
var _ssfopts = {};
var browser_has_Map = typeof Map !== "undefined";
function get_sst_id(sst, str, rev) {
  var i = 0, len = sst.length;
  if (rev) {
    if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
      var revarr = browser_has_Map ? rev.get(str) : rev[str];
      for (; i < revarr.length; ++i) {
        if (sst[revarr[i]].t === str) {
          sst.Count++;
          return revarr[i];
        }
      }
    }
  } else
    for (; i < len; ++i) {
      if (sst[i].t === str) {
        sst.Count++;
        return i;
      }
    }
  sst[len] = { t: str };
  sst.Count++;
  sst.Unique++;
  if (rev) {
    if (browser_has_Map) {
      if (!rev.has(str))
        rev.set(str, []);
      rev.get(str).push(len);
    } else {
      if (!Object.prototype.hasOwnProperty.call(rev, str))
        rev[str] = [];
      rev[str].push(len);
    }
  }
  return len;
}
function col_obj_w(C, col) {
  var p = { min: C + 1, max: C + 1 };
  var wch = -1;
  if (col.MDW)
    MDW = col.MDW;
  if (col.width != null)
    p.customWidth = 1;
  else if (col.wpx != null)
    wch = px2char(col.wpx);
  else if (col.wch != null)
    wch = col.wch;
  if (wch > -1) {
    p.width = char2width(wch);
    p.customWidth = 1;
  } else if (col.width != null)
    p.width = col.width;
  if (col.hidden)
    p.hidden = true;
  if (col.level != null) {
    p.outlineLevel = p.level = col.level;
  }
  return p;
}
function default_margins(margins, mode) {
  if (!margins)
    return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml")
    defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null)
    margins.left = defs[0];
  if (margins.right == null)
    margins.right = defs[1];
  if (margins.top == null)
    margins.top = defs[2];
  if (margins.bottom == null)
    margins.bottom = defs[3];
  if (margins.header == null)
    margins.header = defs[4];
  if (margins.footer == null)
    margins.footer = defs[5];
}
function get_cell_style(styles, cell, opts) {
  var z = opts.revssf[cell.z != null ? cell.z : "General"];
  var i = 60, len = styles.length;
  if (z == null && opts.ssf) {
    for (; i < 392; ++i)
      if (opts.ssf[i] == null) {
        SSF_load(cell.z, i);
        opts.ssf[i] = cell.z;
        opts.revssf[cell.z] = z = i;
        break;
      }
  }
  for (i = 0; i != len; ++i)
    if (styles[i].numFmtId === z)
      return i;
  styles[len] = {
    numFmtId: z,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  };
  return len;
}
function safe_format(p, fmtid, fillid, opts, themes, styles) {
  try {
    if (opts.cellNF)
      p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
  if (p.t === "z" && !opts.cellStyles)
    return;
  if (p.t === "d" && typeof p.v === "string")
    p.v = parseDate(p.v);
  if ((!opts || opts.cellText !== false) && p.t !== "z")
    try {
      if (table_fmt[fmtid] == null)
        SSF_load(SSFImplicit[fmtid] || "General", fmtid);
      if (p.t === "e")
        p.w = p.w || BErr[p.v];
      else if (fmtid === 0) {
        if (p.t === "n") {
          if ((p.v | 0) === p.v)
            p.w = p.v.toString(10);
          else
            p.w = SSF_general_num(p.v);
        } else if (p.t === "d") {
          var dd = datenum(p.v);
          if ((dd | 0) === dd)
            p.w = dd.toString(10);
          else
            p.w = SSF_general_num(dd);
        } else if (p.v === void 0)
          return "";
        else
          p.w = SSF_general(p.v, _ssfopts);
      } else if (p.t === "d")
        p.w = SSF_format(fmtid, datenum(p.v), _ssfopts);
      else
        p.w = SSF_format(fmtid, p.v, _ssfopts);
    } catch (e) {
      if (opts.WTF)
        throw e;
    }
  if (!opts.cellStyles)
    return;
  if (fillid != null)
    try {
      p.s = styles.Fills[fillid];
      if (p.s.fgColor && p.s.fgColor.theme && !p.s.fgColor.rgb) {
        p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
        if (opts.WTF)
          p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;
      }
      if (p.s.bgColor && p.s.bgColor.theme) {
        p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
        if (opts.WTF)
          p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;
      }
    } catch (e) {
      if (opts.WTF && styles.Fills)
        throw e;
    }
}
function check_ws(ws, sname, i) {
  if (ws && ws["!ref"]) {
    var range = safe_decode_range(ws["!ref"]);
    if (range.e.c < range.s.c || range.e.r < range.s.r)
      throw new Error("Bad range (" + i + "): " + ws["!ref"]);
  }
}
function parse_ws_xml_dim(ws, s) {
  var d = safe_decode_range(s);
  if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0)
    ws["!ref"] = encode_range(d);
}
var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
var sheetdataregex = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;
var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/mg;
var dimregex = /"(\w*:\w*)"/;
var colregex = /<(?:\w:)?col\b[^>]*[\/]?>/g;
var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
var sheetprregex = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;
var sheetprregex2 = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;
var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = opts.dense ? [] : {};
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var data1 = "", data2 = "";
  var mtch = data.match(sheetdataregex);
  if (mtch) {
    data1 = data.slice(0, mtch.index);
    data2 = data.slice(mtch.index + mtch[0].length);
  } else
    data1 = data2 = data;
  var sheetPr = data1.match(sheetprregex);
  if (sheetPr)
    parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  else if (sheetPr = data1.match(sheetprregex2))
    parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s, wb, idx);
  var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (ridx > 0) {
    var ref2 = data1.slice(ridx, ridx + 50).match(dimregex);
    if (ref2)
      parse_ws_xml_dim(s, ref2[1]);
  }
  var svs = data1.match(svsregex);
  if (svs && svs[1])
    parse_ws_xml_sheetviews(svs[1], wb);
  var columns = [];
  if (opts.cellStyles) {
    var cols = data1.match(colregex);
    if (cols)
      parse_ws_xml_cols(columns, cols);
  }
  if (mtch)
    parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles);
  var afilter = data2.match(afregex);
  if (afilter)
    s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
  var merges = [];
  var _merge = data2.match(mergecregex);
  if (_merge)
    for (ridx = 0; ridx != _merge.length; ++ridx)
      merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
  var hlink = data2.match(hlinkregex);
  if (hlink)
    parse_ws_xml_hlinks(s, hlink, rels);
  var margins = data2.match(marginregex);
  if (margins)
    s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
  if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r)
    s["!ref"] = encode_range(refguess);
  if (opts.sheetRows > 0 && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r)
        tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r)
        tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c)
        tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c)
        tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (columns.length > 0)
    s["!cols"] = columns;
  if (merges.length > 0)
    s["!merges"] = merges;
  return s;
}
function write_ws_xml_merges(merges) {
  if (merges.length === 0)
    return "";
  var o = '<mergeCells count="' + merges.length + '">';
  for (var i = 0; i != merges.length; ++i)
    o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
  return o + "</mergeCells>";
}
function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
  var data = parsexmltag(sheetPr);
  if (!wb.Sheets[idx])
    wb.Sheets[idx] = {};
  if (data.codeName)
    wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
}
function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {
  parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s, wb, idx);
}
function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
  var needed = false;
  var props = {}, payload = null;
  if (opts.bookType !== "xlsx" && wb.vbaraw) {
    var cname = wb.SheetNames[idx];
    try {
      if (wb.Workbook)
        cname = wb.Workbook.Sheets[idx].CodeName || cname;
    } catch (e) {
    }
    needed = true;
    props.codeName = utf8write(escapexml(cname));
  }
  if (ws && ws["!outline"]) {
    var outlineprops = { summaryBelow: 1, summaryRight: 1 };
    if (ws["!outline"].above)
      outlineprops.summaryBelow = 0;
    if (ws["!outline"].left)
      outlineprops.summaryRight = 0;
    payload = (payload || "") + writextag("outlinePr", null, outlineprops);
  }
  if (!needed && !payload)
    return;
  o[o.length] = writextag("sheetPr", payload, props);
}
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
var sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(sp) {
  var o = { sheet: 1 };
  sheetprot_deffalse.forEach(function(n) {
    if (sp[n] != null && sp[n])
      o[n] = "1";
  });
  sheetprot_deftrue.forEach(function(n) {
    if (sp[n] != null && !sp[n])
      o[n] = "0";
  });
  if (sp.password)
    o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
  return writextag("sheetProtection", null, o);
}
function parse_ws_xml_hlinks(s, data, rels) {
  var dense = Array.isArray(s);
  for (var i = 0; i != data.length; ++i) {
    var val = parsexmltag(utf8read(data[i]), true);
    if (!val.ref)
      return;
    var rel = ((rels || {})["!id"] || [])[val.id];
    if (rel) {
      val.Target = rel.Target;
      if (val.location)
        val.Target += "#" + unescapexml(val.location);
    } else {
      val.Target = "#" + unescapexml(val.location);
      rel = { Target: val.Target, TargetMode: "Internal" };
    }
    val.Rel = rel;
    if (val.tooltip) {
      val.Tooltip = val.tooltip;
      delete val.tooltip;
    }
    var rng = safe_decode_range(val.ref);
    for (var R = rng.s.r; R <= rng.e.r; ++R)
      for (var C = rng.s.c; C <= rng.e.c; ++C) {
        var addr = encode_cell({ c: C, r: R });
        if (dense) {
          if (!s[R])
            s[R] = [];
          if (!s[R][C])
            s[R][C] = { t: "z", v: void 0 };
          s[R][C].l = val;
        } else {
          if (!s[addr])
            s[addr] = { t: "z", v: void 0 };
          s[addr].l = val;
        }
      }
  }
}
function parse_ws_xml_margins(margin) {
  var o = {};
  ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {
    if (margin[k])
      o[k] = parseFloat(margin[k]);
  });
  return o;
}
function write_ws_xml_margins(margin) {
  default_margins(margin);
  return writextag("pageMargins", null, margin);
}
function parse_ws_xml_cols(columns, cols) {
  var seencol = false;
  for (var coli = 0; coli != cols.length; ++coli) {
    var coll = parsexmltag(cols[coli], true);
    if (coll.hidden)
      coll.hidden = parsexmlbool(coll.hidden);
    var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
    if (coll.outlineLevel)
      coll.level = +coll.outlineLevel || 0;
    delete coll.min;
    delete coll.max;
    coll.width = +coll.width;
    if (!seencol && coll.width) {
      seencol = true;
      find_mdw_colw(coll.width);
    }
    process_col(coll);
    while (colm <= colM)
      columns[colm++] = dup(coll);
  }
}
function write_ws_xml_cols(ws, cols) {
  var o = ["<cols>"], col;
  for (var i = 0; i != cols.length; ++i) {
    if (!(col = cols[i]))
      continue;
    o[o.length] = writextag("col", null, col_obj_w(i, col));
  }
  o[o.length] = "</cols>";
  return o.join("");
}
function parse_ws_xml_autofilter(data) {
  var o = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
  return o;
}
function write_ws_xml_autofilter(data, ws, wb, idx) {
  var ref2 = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names2 = wb.Workbook.Names;
  var range = decode_range(ref2);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref2 = encode_range(range);
  }
  for (var i = 0; i < names2.length; ++i) {
    var name = names2[i];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref2;
    break;
  }
  if (i == names2.length)
    names2.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref2 });
  return writextag("autoFilter", null, { ref: ref2 });
}
var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
function parse_ws_xml_sheetviews(data, wb) {
  if (!wb.Views)
    wb.Views = [{}];
  (data.match(sviewregex) || []).forEach(function(r, i) {
    var tag = parsexmltag(r);
    if (!wb.Views[i])
      wb.Views[i] = {};
    if (+tag.zoomScale)
      wb.Views[i].zoom = +tag.zoomScale;
    if (parsexmlbool(tag.rightToLeft))
      wb.Views[i].RTL = true;
  });
}
function write_ws_xml_sheetviews(ws, opts, idx, wb) {
  var sview = { workbookViewId: "0" };
  if ((((wb || {}).Workbook || {}).Views || [])[0])
    sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
  return writextag("sheetViews", writextag("sheetView", null, sview), {});
}
function write_ws_xml_cell(cell, ref2, ws, opts) {
  if (cell.c)
    ws["!comments"].push([ref2, cell.c]);
  if (cell.v === void 0 && typeof cell.f !== "string" || cell.t === "z" && !cell.f)
    return "";
  var vv = "";
  var oldt = cell.t, oldv = cell.v;
  if (cell.t !== "z")
    switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "n":
        vv = "" + cell.v;
        break;
      case "e":
        vv = BErr[cell.v];
        break;
      case "d":
        if (opts && opts.cellDates)
          vv = parseDate(cell.v, -1).toISOString();
        else {
          cell = dup(cell);
          cell.t = "n";
          vv = "" + (cell.v = datenum(parseDate(cell.v)));
        }
        if (typeof cell.z === "undefined")
          cell.z = table_fmt[14];
        break;
      default:
        vv = cell.v;
        break;
    }
  var v = writetag("v", escapexml(vv)), o = { r: ref2 };
  var os = get_cell_style(opts.cellXfs, cell, opts);
  if (os !== 0)
    o.s = os;
  switch (cell.t) {
    case "n":
      break;
    case "d":
      o.t = "d";
      break;
    case "b":
      o.t = "b";
      break;
    case "e":
      o.t = "e";
      break;
    case "z":
      break;
    default:
      if (cell.v == null) {
        delete cell.t;
        break;
      }
      if (cell.v.length > 32767)
        throw new Error("Text length must not exceed 32767 characters");
      if (opts && opts.bookSST) {
        v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
        o.t = "s";
        break;
      }
      o.t = "str";
      break;
  }
  if (cell.t != oldt) {
    cell.t = oldt;
    cell.v = oldv;
  }
  if (typeof cell.f == "string" && cell.f) {
    var ff = cell.F && cell.F.slice(0, ref2.length) == ref2 ? { t: "array", ref: cell.F } : null;
    v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
  }
  if (cell.l)
    ws["!links"].push([ref2, cell.l]);
  if (cell.D)
    o.cm = 1;
  return writextag("c", v, o);
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
  var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
  var refregex = /ref=["']([^"']*)["']/;
  var match_v = matchtag("v"), match_f = matchtag("f");
  return function parse_ws_xml_data2(sdata, s, opts, guess, themes, styles) {
    var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p;
    var tag, tagr = 0, tagc = 0;
    var sstr, ftag;
    var fmtid = 0, fillid = 0;
    var do_format = Array.isArray(styles.CellXf), cf;
    var arrayf = [];
    var sharedf = [];
    var dense = Array.isArray(s);
    var rows = [], rowobj = {}, rowrite = false;
    var sheetStubs = !!opts.sheetStubs;
    for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
      x = marr[mt].trim();
      var xlen = x.length;
      if (xlen === 0)
        continue;
      var rstarti = 0;
      outa:
        for (ri = 0; ri < xlen; ++ri)
          switch (
            /*x.charCodeAt(ri)*/
            x[ri]
          ) {
            case ">":
              if (
                /*x.charCodeAt(ri-1) != 47*/
                x[ri - 1] != "/"
              ) {
                ++ri;
                break outa;
              }
              if (opts && opts.cellStyles) {
                tag = parsexmltag(x.slice(rstarti, ri), true);
                tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
                tagc = -1;
                if (opts.sheetRows && opts.sheetRows < tagr)
                  continue;
                rowobj = {};
                rowrite = false;
                if (tag.ht) {
                  rowrite = true;
                  rowobj.hpt = parseFloat(tag.ht);
                  rowobj.hpx = pt2px(rowobj.hpt);
                }
                if (tag.hidden == "1") {
                  rowrite = true;
                  rowobj.hidden = true;
                }
                if (tag.outlineLevel != null) {
                  rowrite = true;
                  rowobj.level = +tag.outlineLevel;
                }
                if (rowrite)
                  rows[tagr - 1] = rowobj;
              }
              break;
            case "<":
              rstarti = ri;
              break;
          }
      if (rstarti >= ri)
        break;
      tag = parsexmltag(x.slice(rstarti, ri), true);
      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
      tagc = -1;
      if (opts.sheetRows && opts.sheetRows < tagr)
        continue;
      if (guess.s.r > tagr - 1)
        guess.s.r = tagr - 1;
      if (guess.e.r < tagr - 1)
        guess.e.r = tagr - 1;
      if (opts && opts.cellStyles) {
        rowobj = {};
        rowrite = false;
        if (tag.ht) {
          rowrite = true;
          rowobj.hpt = parseFloat(tag.ht);
          rowobj.hpx = pt2px(rowobj.hpt);
        }
        if (tag.hidden == "1") {
          rowrite = true;
          rowobj.hidden = true;
        }
        if (tag.outlineLevel != null) {
          rowrite = true;
          rowobj.level = +tag.outlineLevel;
        }
        if (rowrite)
          rows[tagr - 1] = rowobj;
      }
      cells = x.slice(ri).split(cellregex);
      for (var rslice = 0; rslice != cells.length; ++rslice)
        if (cells[rslice].trim().charAt(0) != "<")
          break;
      cells = cells.slice(rslice);
      for (ri = 0; ri != cells.length; ++ri) {
        x = cells[ri].trim();
        if (x.length === 0)
          continue;
        cref = x.match(rregex);
        idx = ri;
        i = 0;
        cc = 0;
        x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
        if (cref != null && cref.length === 2) {
          idx = 0;
          d = cref[1];
          for (i = 0; i != d.length; ++i) {
            if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26)
              break;
            idx = 26 * idx + cc;
          }
          --idx;
          tagc = idx;
        } else
          ++tagc;
        for (i = 0; i != x.length; ++i)
          if (x.charCodeAt(i) === 62)
            break;
        ++i;
        tag = parsexmltag(x.slice(0, i), true);
        if (!tag.r)
          tag.r = encode_cell({ r: tagr - 1, c: tagc });
        d = x.slice(i);
        p = { t: "" };
        if ((cref = d.match(match_v)) != null && /*::cref != null && */
        cref[1] !== "")
          p.v = unescapexml(cref[1]);
        if (opts.cellFormula) {
          if ((cref = d.match(match_f)) != null && /*::cref != null && */
          cref[1] !== "") {
            p.f = unescapexml(utf8read(cref[1])).replace(/\r\n/g, "\n");
            if (!opts.xlfn)
              p.f = _xlfn(p.f);
            if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="array"') > -1
            ) {
              p.F = (d.match(refregex) || [])[1];
              if (p.F.indexOf(":") > -1)
                arrayf.push([safe_decode_range(p.F), p.F]);
            } else if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="shared"') > -1
            ) {
              ftag = parsexmltag(cref[0]);
              var ___f = unescapexml(utf8read(cref[1]));
              if (!opts.xlfn)
                ___f = _xlfn(___f);
              sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
            }
          } else if (cref = d.match(/<f[^>]*\/>/)) {
            ftag = parsexmltag(cref[0]);
            if (sharedf[ftag.si])
              p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
          }
          var _tag = decode_cell(tag.r);
          for (i = 0; i < arrayf.length; ++i)
            if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) {
              if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c)
                p.F = arrayf[i][1];
            }
        }
        if (tag.t == null && p.v === void 0) {
          if (p.f || p.F) {
            p.v = 0;
            p.t = "n";
          } else if (!sheetStubs)
            continue;
          else
            p.t = "z";
        } else
          p.t = tag.t || "n";
        if (guess.s.c > tagc)
          guess.s.c = tagc;
        if (guess.e.c < tagc)
          guess.e.c = tagc;
        switch (p.t) {
          case "n":
            if (p.v == "" || p.v == null) {
              if (!sheetStubs)
                continue;
              p.t = "z";
            } else
              p.v = parseFloat(p.v);
            break;
          case "s":
            if (typeof p.v == "undefined") {
              if (!sheetStubs)
                continue;
              p.t = "z";
            } else {
              sstr = strs[parseInt(p.v, 10)];
              p.v = sstr.t;
              p.r = sstr.r;
              if (opts.cellHTML)
                p.h = sstr.h;
            }
            break;
          case "str":
            p.t = "s";
            p.v = p.v != null ? utf8read(p.v) : "";
            if (opts.cellHTML)
              p.h = escapehtml(p.v);
            break;
          case "inlineStr":
            cref = d.match(isregex);
            p.t = "s";
            if (cref != null && (sstr = parse_si(cref[1]))) {
              p.v = sstr.t;
              if (opts.cellHTML)
                p.h = sstr.h;
            } else
              p.v = "";
            break;
          case "b":
            p.v = parsexmlbool(p.v);
            break;
          case "d":
            if (opts.cellDates)
              p.v = parseDate(p.v, 1);
            else {
              p.v = datenum(parseDate(p.v, 1));
              p.t = "n";
            }
            break;
          case "e":
            if (!opts || opts.cellText !== false)
              p.w = p.v;
            p.v = RBErr[p.v];
            break;
        }
        fmtid = fillid = 0;
        cf = null;
        if (do_format && tag.s !== void 0) {
          cf = styles.CellXf[tag.s];
          if (cf != null) {
            if (cf.numFmtId != null)
              fmtid = cf.numFmtId;
            if (opts.cellStyles) {
              if (cf.fillId != null)
                fillid = cf.fillId;
            }
          }
        }
        safe_format(p, fmtid, fillid, opts, themes, styles);
        if (opts.cellDates && do_format && p.t == "n" && fmt_is_date(table_fmt[fmtid])) {
          p.t = "d";
          p.v = numdate(p.v);
        }
        if (tag.cm && opts.xlmeta) {
          var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
          if (cm && cm.type == "XLDAPR")
            p.D = true;
        }
        if (dense) {
          var _r = decode_cell(tag.r);
          if (!s[_r.r])
            s[_r.r] = [];
          s[_r.r][_r.c] = p;
        } else
          s[tag.r] = p;
      }
    }
    if (rows.length > 0)
      s["!rows"] = rows;
  };
}();
function write_ws_xml_data(ws, opts, idx, wb) {
  var o = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref2, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
  var dense = Array.isArray(ws);
  var params = { r: rr }, row, height2 = -1;
  for (C = range.s.c; C <= range.e.c; ++C)
    cols[C] = encode_col(C);
  for (R = range.s.r; R <= range.e.r; ++R) {
    r = [];
    rr = encode_row(R);
    for (C = range.s.c; C <= range.e.c; ++C) {
      ref2 = cols[C] + rr;
      var _cell2 = dense ? (ws[R] || [])[C] : ws[ref2];
      if (_cell2 === void 0)
        continue;
      if ((cell = write_ws_xml_cell(_cell2, ref2, ws, opts)) != null)
        r.push(cell);
    }
    if (r.length > 0 || rows && rows[R]) {
      params = { r: rr };
      if (rows && rows[R]) {
        row = rows[R];
        if (row.hidden)
          params.hidden = 1;
        height2 = -1;
        if (row.hpx)
          height2 = px2pt(row.hpx);
        else if (row.hpt)
          height2 = row.hpt;
        if (height2 > -1) {
          params.ht = height2;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
      }
      o[o.length] = writextag("row", r.join(""), params);
    }
  }
  if (rows)
    for (; R < rows.length; ++R) {
      if (rows && rows[R]) {
        params = { r: R + 1 };
        row = rows[R];
        if (row.hidden)
          params.hidden = 1;
        height2 = -1;
        if (row.hpx)
          height2 = px2pt(row.hpx);
        else if (row.hpt)
          height2 = row.hpt;
        if (height2 > -1) {
          params.ht = height2;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
        o[o.length] = writextag("row", "", params);
      }
    }
  return o.join("");
}
function write_ws_xml(idx, opts, wb, rels) {
  var o = [XML_HEADER, writextag("worksheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })];
  var s = wb.SheetNames[idx], sidx = 0, rdata = "";
  var ws = wb.Sheets[s];
  if (ws == null)
    ws = {};
  var ref2 = ws["!ref"] || "A1";
  var range = safe_decode_range(ref2);
  if (range.e.c > 16383 || range.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + ref2 + " exceeds format limit A1:XFD1048576");
    range.e.c = Math.min(range.e.c, 16383);
    range.e.r = Math.min(range.e.c, 1048575);
    ref2 = encode_range(range);
  }
  if (!rels)
    rels = {};
  ws["!comments"] = [];
  var _drawing = [];
  write_ws_xml_sheetpr(ws, wb, idx, opts, o);
  o[o.length] = writextag("dimension", null, { "ref": ref2 });
  o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
  if (opts.sheetFormat)
    o[o.length] = writextag("sheetFormatPr", null, {
      defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
      baseColWidth: opts.sheetFormat.baseColWidth || "10",
      outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
    });
  if (ws["!cols"] != null && ws["!cols"].length > 0)
    o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
  o[sidx = o.length] = "<sheetData/>";
  ws["!links"] = [];
  if (ws["!ref"] != null) {
    rdata = write_ws_xml_data(ws, opts);
    if (rdata.length > 0)
      o[o.length] = rdata;
  }
  if (o.length > sidx + 1) {
    o[o.length] = "</sheetData>";
    o[sidx] = o[sidx].replace("/>", ">");
  }
  if (ws["!protect"])
    o[o.length] = write_ws_xml_protection(ws["!protect"]);
  if (ws["!autofilter"] != null)
    o[o.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
  if (ws["!merges"] != null && ws["!merges"].length > 0)
    o[o.length] = write_ws_xml_merges(ws["!merges"]);
  var relc = -1, rel, rId = -1;
  if (
    /*::(*/
    ws["!links"].length > 0
  ) {
    o[o.length] = "<hyperlinks>";
    ws["!links"].forEach(function(l) {
      if (!l[1].Target)
        return;
      rel = { "ref": l[0] };
      if (l[1].Target.charAt(0) != "#") {
        rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);
        rel["r:id"] = "rId" + rId;
      }
      if ((relc = l[1].Target.indexOf("#")) > -1)
        rel.location = escapexml(l[1].Target.slice(relc + 1));
      if (l[1].Tooltip)
        rel.tooltip = escapexml(l[1].Tooltip);
      o[o.length] = writextag("hyperlink", null, rel);
    });
    o[o.length] = "</hyperlinks>";
  }
  delete ws["!links"];
  if (ws["!margins"] != null)
    o[o.length] = write_ws_xml_margins(ws["!margins"]);
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref2 }));
  if (_drawing.length > 0) {
    rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
    o[o.length] = writextag("drawing", null, { "r:id": "rId" + rId });
    ws["!drawing"] = _drawing;
  }
  if (ws["!comments"].length > 0) {
    rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    o[o.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
    ws["!legacy"] = rId;
  }
  if (o.length > 1) {
    o[o.length] = "</worksheet>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtRowHdr(data, length) {
  var z = {};
  var tgt = data.l + length;
  z.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7)
    z.level = flags & 7;
  if (flags & 16)
    z.hidden = true;
  if (flags & 32)
    z.hpt = miyRw / 20;
  return z;
}
function write_BrtRowHdr(R, range, ws) {
  var o = new_buf(17 + 8 * 16);
  var row = (ws["!rows"] || [])[R] || {};
  o.write_shift(4, R);
  o.write_shift(4, 0);
  var miyRw = 320;
  if (row.hpx)
    miyRw = px2pt(row.hpx) * 20;
  else if (row.hpt)
    miyRw = row.hpt * 20;
  o.write_shift(2, miyRw);
  o.write_shift(1, 0);
  var flags = 0;
  if (row.level)
    flags |= row.level;
  if (row.hidden)
    flags |= 16;
  if (row.hpx || row.hpt)
    flags |= 32;
  o.write_shift(1, flags);
  o.write_shift(1, 0);
  var ncolspan = 0, lcs = o.l;
  o.l += 4;
  var caddr = { r: R, c: 0 };
  for (var i = 0; i < 16; ++i) {
    if (range.s.c > i + 1 << 10 || range.e.c < i << 10)
      continue;
    var first = -1, last = -1;
    for (var j = i << 10; j < i + 1 << 10; ++j) {
      caddr.c = j;
      var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
      if (cell) {
        if (first < 0)
          first = j;
        last = j;
      }
    }
    if (first < 0)
      continue;
    ++ncolspan;
    o.write_shift(4, first);
    o.write_shift(4, last);
  }
  var l = o.l;
  o.l = lcs;
  o.write_shift(4, ncolspan);
  o.l = l;
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_row_header(ba, ws, range, R) {
  var o = write_BrtRowHdr(R, range, ws);
  if (o.length > 17 || (ws["!rows"] || [])[R])
    write_record(ba, 0, o);
}
var parse_BrtWsDim = parse_UncheckedRfX;
var write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(data, length) {
  var z = {};
  var f = data[data.l];
  ++data.l;
  z.above = !(f & 64);
  z.left = !(f & 128);
  data.l += 18;
  z.name = parse_XLSBCodeName(data);
  return z;
}
function write_BrtWsProp(str, outl, o) {
  if (o == null)
    o = new_buf(84 + 4 * str.length);
  var f = 192;
  if (outl) {
    if (outl.above)
      f &= ~64;
    if (outl.left)
      f &= ~128;
  }
  o.write_shift(1, f);
  for (var i = 1; i < 3; ++i)
    o.write_shift(1, 0);
  write_BrtColor({ auto: 1 }, o);
  o.write_shift(-4, -1);
  o.write_shift(-4, -1);
  write_XLSBCodeName(str, o);
  return o.slice(0, o.l);
}
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
function write_BrtCellBlank(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  return write_XLSBCell(ncell, o);
}
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
function write_BrtShortBlank(cell, ncell, o) {
  if (o == null)
    o = new_buf(4);
  return write_XLSBShortCell(ncell, o);
}
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtCellBool(cell, ncell, o) {
  if (o == null)
    o = new_buf(9);
  write_XLSBCell(ncell, o);
  o.write_shift(1, cell.v ? 1 : 0);
  return o;
}
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtShortBool(cell, ncell, o) {
  if (o == null)
    o = new_buf(5);
  write_XLSBShortCell(ncell, o);
  o.write_shift(1, cell.v ? 1 : 0);
  return o;
}
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtCellError(cell, ncell, o) {
  if (o == null)
    o = new_buf(9);
  write_XLSBCell(ncell, o);
  o.write_shift(1, cell.v);
  return o;
}
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtShortError(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  o.write_shift(1, cell.v);
  o.write_shift(2, 0);
  o.write_shift(1, 0);
  return o;
}
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtCellIsst(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBCell(ncell, o);
  o.write_shift(4, ncell.v);
  return o;
}
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtShortIsst(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  o.write_shift(4, ncell.v);
  return o;
}
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtCellReal(cell, ncell, o) {
  if (o == null)
    o = new_buf(16);
  write_XLSBCell(ncell, o);
  write_Xnum(cell.v, o);
  return o;
}
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtShortReal(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBShortCell(ncell, o);
  write_Xnum(cell.v, o);
  return o;
}
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtCellRk(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBCell(ncell, o);
  write_RkNumber(cell.v, o);
  return o;
}
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtShortRk(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  write_RkNumber(cell.v, o);
  return o;
}
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtCellSt(cell, ncell, o) {
  if (o == null)
    o = new_buf(12 + 4 * cell.v.length);
  write_XLSBCell(ncell, o);
  write_XLWideString(cell.v, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtShortSt(cell, ncell, o) {
  if (o == null)
    o = new_buf(8 + 4 * cell.v.length);
  write_XLSBShortCell(ncell, o);
  write_XLWideString(cell.v, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtFmlaBool(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaError(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaNum(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaString(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
var parse_BrtMergeCell = parse_UncheckedRfX;
var write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(cnt, o) {
  if (o == null)
    o = new_buf(4);
  o.write_shift(4, cnt);
  return o;
}
function parse_BrtHLink(data, length) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip2 = parse_XLWideString(data);
  var display = parse_XLWideString(data);
  data.l = end;
  var o = { rfx, relId, loc, display };
  if (tooltip2)
    o.Tooltip = tooltip2;
  return o;
}
function write_BrtHLink(l, rId) {
  var o = new_buf(50 + 4 * (l[1].Target.length + (l[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(l[0]), e: decode_cell(l[0]) }, o);
  write_RelID("rId" + rId, o);
  var locidx = l[1].Target.indexOf("#");
  var loc = locidx == -1 ? "" : l[1].Target.slice(locidx + 1);
  write_XLWideString(loc || "", o);
  write_XLWideString(l[1].Tooltip || "", o);
  write_XLWideString("", o);
  return o.slice(0, o.l);
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o = [rfx];
  o[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o[1] = formula;
  } else
    data.l = end;
  return o;
}
function parse_BrtShrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var o = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o[1] = formula;
    data.l = end;
  } else
    data.l = end;
  return o;
}
function write_BrtColInfo(C, col, o) {
  if (o == null)
    o = new_buf(18);
  var p = col_obj_w(C, col);
  o.write_shift(-4, C);
  o.write_shift(-4, C);
  o.write_shift(4, (p.width || 10) * 256);
  o.write_shift(
    4,
    0
    /*ixfe*/
  );
  var flags = 0;
  if (col.hidden)
    flags |= 1;
  if (typeof p.width == "number")
    flags |= 2;
  if (col.level)
    flags |= col.level << 8;
  o.write_shift(2, flags);
  return o;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k) {
    margins[k] = parse_Xnum(data);
  });
  return margins;
}
function write_BrtMargins(margins, o) {
  if (o == null)
    o = new_buf(6 * 8);
  default_margins(margins);
  BrtMarginKeys.forEach(function(k) {
    write_Xnum(margins[k], o);
  });
  return o;
}
function parse_BrtBeginWsView(data) {
  var f = data.read_shift(2);
  data.l += 28;
  return { RTL: f & 32 };
}
function write_BrtBeginWsView(ws, Workbook, o) {
  if (o == null)
    o = new_buf(30);
  var f = 924;
  if ((((Workbook || {}).Views || [])[0] || {}).RTL)
    f |= 32;
  o.write_shift(2, f);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 100);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(4, 0);
  return o;
}
function write_BrtCellIgnoreEC(ref2) {
  var o = new_buf(24);
  o.write_shift(4, 4);
  o.write_shift(4, 1);
  write_UncheckedRfX(ref2, o);
  return o;
}
function write_BrtSheetProtection(sp, o) {
  if (o == null)
    o = new_buf(16 * 4 + 2);
  o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
  o.write_shift(4, 1);
  [
    ["objects", false],
    // fObjects
    ["scenarios", false],
    // fScenarios
    ["formatCells", true],
    // fFormatCells
    ["formatColumns", true],
    // fFormatColumns
    ["formatRows", true],
    // fFormatRows
    ["insertColumns", true],
    // fInsertColumns
    ["insertRows", true],
    // fInsertRows
    ["insertHyperlinks", true],
    // fInsertHyperlinks
    ["deleteColumns", true],
    // fDeleteColumns
    ["deleteRows", true],
    // fDeleteRows
    ["selectLockedCells", false],
    // fSelLockedCells
    ["sort", true],
    // fSort
    ["autoFilter", true],
    // fAutoFilter
    ["pivotTables", true],
    // fPivotTables
    ["selectUnlockedCells", false]
    // fSelUnlockedCells
  ].forEach(function(n) {
    if (n[1])
      o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
    else
      o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
  });
  return o;
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {
  if (!data)
    return data;
  var opts = _opts || {};
  if (!rels)
    rels = { "!id": {} };
  var s = opts.dense ? [] : {};
  var ref2;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var pass = false, end = false;
  var row, p, cf, R, C, addr, sstr, rr, cell;
  var merges = [];
  opts.biff = 12;
  opts["!row"] = 0;
  var ai = 0, af = false;
  var arrayf = [];
  var sharedf = {};
  var supbooks = opts.supbooks || /*::(*/
  wb.supbooks || [[]];
  supbooks.sharedf = sharedf;
  supbooks.arrayf = arrayf;
  supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
    return x.name;
  });
  if (!opts.supbooks) {
    opts.supbooks = supbooks;
    if (wb.Names)
      for (var i = 0; i < wb.Names.length; ++i)
        supbooks[0][i + 1] = wb.Names[i];
  }
  var colinfo = [], rowinfo = [];
  var seencol = false;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var cm;
  recordhopper(data, function ws_parse(val, RR, RT) {
    if (end)
      return;
    switch (RT) {
      case 148:
        ref2 = val;
        break;
      case 0:
        row = val;
        if (opts.sheetRows && opts.sheetRows <= row.r)
          end = true;
        rr = encode_row(R = row.r);
        opts["!row"] = row.r;
        if (val.hidden || val.hpt || val.level != null) {
          if (val.hpt)
            val.hpx = pt2px(val.hpt);
          rowinfo[val.r] = val;
        }
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 62:
        p = { t: val[2] };
        switch (val[2]) {
          case "n":
            p.v = val[1];
            break;
          case "s":
            sstr = strs[val[1]];
            p.v = sstr.t;
            p.r = sstr.r;
            break;
          case "b":
            p.v = val[1] ? true : false;
            break;
          case "e":
            p.v = val[1];
            if (opts.cellText !== false)
              p.w = BErr[p.v];
            break;
          case "str":
            p.t = "s";
            p.v = val[1];
            break;
          case "is":
            p.t = "s";
            p.v = val[1].t;
            break;
        }
        if (cf = styles.CellXf[val[0].iStyleRef])
          safe_format(p, cf.numFmtId, null, opts, themes, styles);
        C = val[0].c == -1 ? C + 1 : val[0].c;
        if (opts.dense) {
          if (!s[R])
            s[R] = [];
          s[R][C] = p;
        } else
          s[encode_col(C) + rr] = p;
        if (opts.cellFormula) {
          af = false;
          for (ai = 0; ai < arrayf.length; ++ai) {
            var aii = arrayf[ai];
            if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
              if (C >= aii[0].s.c && C <= aii[0].e.c) {
                p.F = encode_range(aii[0]);
                af = true;
              }
            }
          }
          if (!af && val.length > 3)
            p.f = val[3];
        }
        if (refguess.s.r > row.r)
          refguess.s.r = row.r;
        if (refguess.s.c > C)
          refguess.s.c = C;
        if (refguess.e.r < row.r)
          refguess.e.r = row.r;
        if (refguess.e.c < C)
          refguess.e.c = C;
        if (opts.cellDates && cf && p.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
          var _d = SSF_parse_date_code(p.v);
          if (_d) {
            p.t = "d";
            p.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
          }
        }
        if (cm) {
          if (cm.type == "XLDAPR")
            p.D = true;
          cm = void 0;
        }
        break;
      case 1:
      case 12:
        if (!opts.sheetStubs || pass)
          break;
        p = { t: "z", v: void 0 };
        C = val[0].c == -1 ? C + 1 : val[0].c;
        if (opts.dense) {
          if (!s[R])
            s[R] = [];
          s[R][C] = p;
        } else
          s[encode_col(C) + rr] = p;
        if (refguess.s.r > row.r)
          refguess.s.r = row.r;
        if (refguess.s.c > C)
          refguess.s.c = C;
        if (refguess.e.r < row.r)
          refguess.e.r = row.r;
        if (refguess.e.c < C)
          refguess.e.c = C;
        if (cm) {
          if (cm.type == "XLDAPR")
            p.D = true;
          cm = void 0;
        }
        break;
      case 176:
        merges.push(val);
        break;
      case 49:
        {
          cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
        }
        break;
      case 494:
        var rel = rels["!id"][val.relId];
        if (rel) {
          val.Target = rel.Target;
          if (val.loc)
            val.Target += "#" + val.loc;
          val.Rel = rel;
        } else if (val.relId == "") {
          val.Target = "#" + val.loc;
        }
        for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R)
          for (C = val.rfx.s.c; C <= val.rfx.e.c; ++C) {
            if (opts.dense) {
              if (!s[R])
                s[R] = [];
              if (!s[R][C])
                s[R][C] = { t: "z", v: void 0 };
              s[R][C].l = val;
            } else {
              addr = encode_cell({ c: C, r: R });
              if (!s[addr])
                s[addr] = { t: "z", v: void 0 };
              s[addr].l = val;
            }
          }
        break;
      case 426:
        if (!opts.cellFormula)
          break;
        arrayf.push(val);
        cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
        cell.F = encode_range(val[0]);
        break;
      case 427:
        if (!opts.cellFormula)
          break;
        sharedf[encode_cell(val[0].s)] = val[1];
        cell = opts.dense ? s[R][C] : s[encode_col(C) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
        break;
      case 60:
        if (!opts.cellStyles)
          break;
        while (val.e >= val.s) {
          colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
          if (!seencol) {
            seencol = true;
            find_mdw_colw(val.w / 256);
          }
          process_col(colinfo[val.e + 1]);
        }
        break;
      case 161:
        s["!autofilter"] = { ref: encode_range(val) };
        break;
      case 476:
        s["!margins"] = val;
        break;
      case 147:
        if (!wb.Sheets[idx])
          wb.Sheets[idx] = {};
        if (val.name)
          wb.Sheets[idx].CodeName = val.name;
        if (val.above || val.left)
          s["!outline"] = { above: val.above, left: val.left };
        break;
      case 137:
        if (!wb.Views)
          wb.Views = [{}];
        if (!wb.Views[0])
          wb.Views[0] = {};
        if (val.RTL)
          wb.Views[0].RTL = true;
        break;
      case 485:
        break;
      case 64:
      case 1053:
        break;
      case 151:
        break;
      case 152:
      case 175:
      case 644:
      case 625:
      case 562:
      case 396:
      case 1112:
      case 1146:
      case 471:
      case 1050:
      case 649:
      case 1105:
      case 589:
      case 607:
      case 564:
      case 1055:
      case 168:
      case 174:
      case 1180:
      case 499:
      case 507:
      case 550:
      case 171:
      case 167:
      case 1177:
      case 169:
      case 1181:
      case 551:
      case 552:
      case 661:
      case 639:
      case 478:
      case 537:
      case 477:
      case 536:
      case 1103:
      case 680:
      case 1104:
      case 1024:
      case 663:
      case 535:
      case 678:
      case 504:
      case 1043:
      case 428:
      case 170:
      case 3072:
      case 50:
      case 2070:
      case 1045:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        pass = true;
        break;
      case 38:
        pass = false;
        break;
      default:
        if (RR.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  delete opts.supbooks;
  delete opts["!row"];
  if (!s["!ref"] && (refguess.s.r < 2e6 || ref2 && (ref2.e.r > 0 || ref2.e.c > 0 || ref2.s.r > 0 || ref2.s.c > 0)))
    s["!ref"] = encode_range(ref2 || refguess);
  if (opts.sheetRows && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r)
        tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r)
        tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c)
        tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c)
        tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (merges.length > 0)
    s["!merges"] = merges;
  if (colinfo.length > 0)
    s["!cols"] = colinfo;
  if (rowinfo.length > 0)
    s["!rows"] = rowinfo;
  return s;
}
function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {
  if (cell.v === void 0)
    return false;
  var vv = "";
  switch (cell.t) {
    case "b":
      vv = cell.v ? "1" : "0";
      break;
    case "d":
      cell = dup(cell);
      cell.z = cell.z || table_fmt[14];
      cell.v = datenum(parseDate(cell.v));
      cell.t = "n";
      break;
    case "n":
    case "e":
      vv = "" + cell.v;
      break;
    default:
      vv = cell.v;
      break;
  }
  var o = { r: R, c: C };
  o.s = get_cell_style(opts.cellXfs, cell, opts);
  if (cell.l)
    ws["!links"].push([encode_cell(o), cell.l]);
  if (cell.c)
    ws["!comments"].push([encode_cell(o), cell.c]);
  switch (cell.t) {
    case "s":
    case "str":
      if (opts.bookSST) {
        vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
        o.t = "s";
        o.v = vv;
        if (last_seen)
          write_record(ba, 18, write_BrtShortIsst(cell, o));
        else
          write_record(ba, 7, write_BrtCellIsst(cell, o));
      } else {
        o.t = "str";
        if (last_seen)
          write_record(ba, 17, write_BrtShortSt(cell, o));
        else
          write_record(ba, 6, write_BrtCellSt(cell, o));
      }
      return true;
    case "n":
      if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
        if (last_seen)
          write_record(ba, 13, write_BrtShortRk(cell, o));
        else
          write_record(ba, 2, write_BrtCellRk(cell, o));
      } else {
        if (last_seen)
          write_record(ba, 16, write_BrtShortReal(cell, o));
        else
          write_record(ba, 5, write_BrtCellReal(cell, o));
      }
      return true;
    case "b":
      o.t = "b";
      if (last_seen)
        write_record(ba, 15, write_BrtShortBool(cell, o));
      else
        write_record(ba, 4, write_BrtCellBool(cell, o));
      return true;
    case "e":
      o.t = "e";
      if (last_seen)
        write_record(ba, 14, write_BrtShortError(cell, o));
      else
        write_record(ba, 3, write_BrtCellError(cell, o));
      return true;
  }
  if (last_seen)
    write_record(ba, 12, write_BrtShortBlank(cell, o));
  else
    write_record(ba, 1, write_BrtCellBlank(cell, o));
  return true;
}
function write_CELLTABLE(ba, ws, idx, opts) {
  var range = safe_decode_range(ws["!ref"] || "A1"), ref2, rr = "", cols = [];
  write_record(
    ba,
    145
    /* BrtBeginSheetData */
  );
  var dense = Array.isArray(ws);
  var cap = range.e.r;
  if (ws["!rows"])
    cap = Math.max(range.e.r, ws["!rows"].length - 1);
  for (var R = range.s.r; R <= cap; ++R) {
    rr = encode_row(R);
    write_row_header(ba, ws, range, R);
    var last_seen = false;
    if (R <= range.e.r)
      for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r)
          cols[C] = encode_col(C);
        ref2 = cols[C] + rr;
        var cell = dense ? (ws[R] || [])[C] : ws[ref2];
        if (!cell) {
          last_seen = false;
          continue;
        }
        last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);
      }
  }
  write_record(
    ba,
    146
    /* BrtEndSheetData */
  );
}
function write_MERGECELLS(ba, ws) {
  if (!ws || !ws["!merges"])
    return;
  write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
  ws["!merges"].forEach(function(m) {
    write_record(ba, 176, write_BrtMergeCell(m));
  });
  write_record(
    ba,
    178
    /* BrtEndMergeCells */
  );
}
function write_COLINFOS(ba, ws) {
  if (!ws || !ws["!cols"])
    return;
  write_record(
    ba,
    390
    /* BrtBeginColInfos */
  );
  ws["!cols"].forEach(function(m, i) {
    if (m)
      write_record(ba, 60, write_BrtColInfo(i, m));
  });
  write_record(
    ba,
    391
    /* BrtEndColInfos */
  );
}
function write_IGNOREECS(ba, ws) {
  if (!ws || !ws["!ref"])
    return;
  write_record(
    ba,
    648
    /* BrtBeginCellIgnoreECs */
  );
  write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
  write_record(
    ba,
    650
    /* BrtEndCellIgnoreECs */
  );
}
function write_HLINKS(ba, ws, rels) {
  ws["!links"].forEach(function(l) {
    if (!l[1].Target)
      return;
    var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);
    write_record(ba, 494, write_BrtHLink(l, rId));
  });
  delete ws["!links"];
}
function write_LEGACYDRAWING(ba, ws, idx, rels) {
  if (ws["!comments"].length > 0) {
    var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    write_record(ba, 551, write_RelID("rId" + rId));
    ws["!legacy"] = rId;
  }
}
function write_AUTOFILTER(ba, ws, wb, idx) {
  if (!ws["!autofilter"])
    return;
  var data = ws["!autofilter"];
  var ref2 = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names2 = wb.Workbook.Names;
  var range = decode_range(ref2);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref2 = encode_range(range);
  }
  for (var i = 0; i < names2.length; ++i) {
    var name = names2[i];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref2;
    break;
  }
  if (i == names2.length)
    names2.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref2 });
  write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref2)));
  write_record(
    ba,
    162
    /* BrtEndAFilter */
  );
}
function write_WSVIEWS2(ba, ws, Workbook) {
  write_record(
    ba,
    133
    /* BrtBeginWsViews */
  );
  {
    write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
    write_record(
      ba,
      138
      /* BrtEndWsView */
    );
  }
  write_record(
    ba,
    134
    /* BrtEndWsViews */
  );
}
function write_SHEETPROTECT(ba, ws) {
  if (!ws["!protect"])
    return;
  write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
}
function write_ws_bin(idx, opts, wb, rels) {
  var ba = buf_array();
  var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  var c = s;
  try {
    if (wb && wb.Workbook)
      c = wb.Workbook.Sheets[idx].CodeName || c;
  } catch (e) {
  }
  var r = safe_decode_range(ws["!ref"] || "A1");
  if (r.e.c > 16383 || r.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    r.e.c = Math.min(r.e.c, 16383);
    r.e.r = Math.min(r.e.c, 1048575);
  }
  ws["!links"] = [];
  ws["!comments"] = [];
  write_record(
    ba,
    129
    /* BrtBeginSheet */
  );
  if (wb.vbaraw || ws["!outline"])
    write_record(ba, 147, write_BrtWsProp(c, ws["!outline"]));
  write_record(ba, 148, write_BrtWsDim(r));
  write_WSVIEWS2(ba, ws, wb.Workbook);
  write_COLINFOS(ba, ws);
  write_CELLTABLE(ba, ws, idx, opts);
  write_SHEETPROTECT(ba, ws);
  write_AUTOFILTER(ba, ws, wb, idx);
  write_MERGECELLS(ba, ws);
  write_HLINKS(ba, ws, rels);
  if (ws["!margins"])
    write_record(ba, 476, write_BrtMargins(ws["!margins"]));
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    write_IGNOREECS(ba, ws);
  write_LEGACYDRAWING(ba, ws, idx, rels);
  write_record(
    ba,
    130
    /* BrtEndSheet */
  );
  return ba.end();
}
function parse_Cache(data) {
  var col = [];
  var num = data.match(/^<c:numCache>/);
  var f;
  (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(pt) {
    var q = pt.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    if (!q)
      return;
    col[+q[1]] = num ? +q[2] : q[2];
  });
  var nf = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  (data.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(F) {
    f = F.replace(/<.*?>/g, "");
  });
  return [col, nf, f];
}
function parse_chart(data, name, opts, rels, wb, csheet) {
  var cs = csheet || { "!type": "chart" };
  if (!data)
    return csheet;
  var C = 0, R = 0, col = "A";
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc) {
    var cache2 = parse_Cache(nc);
    refguess.s.r = refguess.s.c = 0;
    refguess.e.c = C;
    col = encode_col(C);
    cache2[0].forEach(function(n, i) {
      cs[col + encode_row(i)] = { t: "n", v: n, z: cache2[1] };
      R = i;
    });
    if (refguess.e.r < R)
      refguess.e.r = R;
    ++C;
  });
  if (C > 0)
    cs["!ref"] = encode_range(refguess);
  return cs;
}
function parse_cs_xml(data, opts, idx, rels, wb) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var m;
  var sheetPr = data.match(sheetprregex);
  if (sheetPr)
    parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  if (m = data.match(/drawing r:id="(.*?)"/))
    s["!rel"] = m[1];
  if (rels["!id"][s["!rel"]])
    s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
function parse_BrtCsProp(data, length) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
function parse_cs_bin(data, opts, idx, rels, wb) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var pass = false;
  recordhopper(data, function cs_parse(val, R, RT) {
    switch (RT) {
      case 550:
        s["!rel"] = val;
        break;
      case 651:
        if (!wb.Sheets[idx])
          wb.Sheets[idx] = {};
        if (val.name)
          wb.Sheets[idx].CodeName = val.name;
        break;
      case 562:
      case 652:
      case 669:
      case 679:
      case 551:
      case 552:
      case 476:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T > 0)
          ;
        else if (R.T < 0)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  if (rels["!id"][s["!rel"]])
    s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
var WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", true, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", false, "bool"],
  ["showHorizontalScroll", true, "bool"],
  ["showSheetTabs", true, "bool"],
  ["showVerticalScroll", true, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
];
var SheetDef = [
  //['state', 'visible']
];
var CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(target, defaults) {
  for (var j = 0; j != target.length; ++j) {
    var w = target[j];
    for (var i = 0; i != defaults.length; ++i) {
      var z = defaults[i];
      if (w[z[0]] == null)
        w[z[0]] = z[1];
      else
        switch (z[2]) {
          case "bool":
            if (typeof w[z[0]] == "string")
              w[z[0]] = parsexmlbool(w[z[0]]);
            break;
          case "int":
            if (typeof w[z[0]] == "string")
              w[z[0]] = parseInt(w[z[0]], 10);
            break;
        }
    }
  }
}
function push_defaults(target, defaults) {
  for (var i = 0; i != defaults.length; ++i) {
    var z = defaults[i];
    if (target[z[0]] == null)
      target[z[0]] = z[1];
    else
      switch (z[2]) {
        case "bool":
          if (typeof target[z[0]] == "string")
            target[z[0]] = parsexmlbool(target[z[0]]);
          break;
        case "int":
          if (typeof target[z[0]] == "string")
            target[z[0]] = parseInt(target[z[0]], 10);
          break;
      }
  }
}
function parse_wb_defaults(wb) {
  push_defaults(wb.WBProps, WBPropsDef);
  push_defaults(wb.CalcPr, CalcPrDef);
  push_defaults_array(wb.WBView, WBViewDef);
  push_defaults_array(wb.Sheets, SheetDef);
  _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
}
function safe1904(wb) {
  if (!wb.Workbook)
    return "false";
  if (!wb.Workbook.WBProps)
    return "false";
  return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
}
var badchars = /* @__PURE__ */ "][*?/\\".split("");
function check_ws_name(n, safe) {
  if (n.length > 31) {
    if (safe)
      return false;
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var _good = true;
  badchars.forEach(function(c) {
    if (n.indexOf(c) == -1)
      return;
    if (!safe)
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    _good = false;
  });
  return _good;
}
function check_wb_names(N, S, codes) {
  N.forEach(function(n, i) {
    check_ws_name(n);
    for (var j = 0; j < i; ++j)
      if (n == N[j])
        throw new Error("Duplicate Sheet Name: " + n);
    if (codes) {
      var cn = S && S[i] && S[i].CodeName || n;
      if (cn.charCodeAt(0) == 95 && cn.length > 22)
        throw new Error("Bad Code Name: Worksheet" + cn);
    }
  });
}
function check_wb(wb) {
  if (!wb || !wb.SheetNames || !wb.Sheets)
    throw new Error("Invalid Workbook");
  if (!wb.SheetNames.length)
    throw new Error("Workbook is empty");
  var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
  check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
  for (var i = 0; i < wb.SheetNames.length; ++i)
    check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(data, opts) {
  if (!data)
    throw new Error("Could not find file");
  var wb = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  );
  var pass = false, xmlns = "xmlns";
  var dname = {}, dnstart = 0;
  data.replace(tagregex, function xml_wb(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<workbook":
        if (x.match(wbnsregex))
          xmlns = "xmlns" + x.match(/<(\w+):/)[1];
        wb.xmlns = y[xmlns];
        break;
      case "</workbook>":
        break;
      case "<fileVersion":
        delete y[0];
        wb.AppVersion = y;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(w) {
          if (y[w[0]] == null)
            return;
          switch (w[2]) {
            case "bool":
              wb.WBProps[w[0]] = parsexmlbool(y[w[0]]);
              break;
            case "int":
              wb.WBProps[w[0]] = parseInt(y[w[0]], 10);
              break;
            default:
              wb.WBProps[w[0]] = y[w[0]];
          }
        });
        if (y.codeName)
          wb.WBProps.CodeName = utf8read(y.codeName);
        break;
      case "</workbookPr>":
        break;
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      case "<workbookView":
      case "<workbookView/>":
        delete y[0];
        wb.WBView.push(y);
        break;
      case "</workbookView>":
        break;
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      case "<sheet":
        switch (y.state) {
          case "hidden":
            y.Hidden = 1;
            break;
          case "veryHidden":
            y.Hidden = 2;
            break;
          default:
            y.Hidden = 0;
        }
        delete y.state;
        y.name = unescapexml(utf8read(y.name));
        delete y[0];
        wb.Sheets.push(y);
        break;
      case "</sheet>":
        break;
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      case "<functionGroup":
        break;
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      case "<externalReference":
        break;
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        pass = true;
        break;
      case "</definedNames>":
        pass = false;
        break;
      case "<definedName":
        {
          dname = {};
          dname.Name = utf8read(y.name);
          if (y.comment)
            dname.Comment = y.comment;
          if (y.localSheetId)
            dname.Sheet = +y.localSheetId;
          if (parsexmlbool(y.hidden || "0"))
            dname.Hidden = true;
          dnstart = idx + x.length;
        }
        break;
      case "</definedName>":
        {
          dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
          wb.Names.push(dname);
        }
        break;
      case "<definedName/>":
        break;
      case "<calcPr":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "<calcPr/>":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "</calcPr>":
        break;
      case "<oleSize":
        break;
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      case "<pivotCache":
        break;
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      case "<smartTagType":
        break;
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      case "<webPublishObject":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<revisionPtr":
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in workbook");
    }
    return x;
  });
  if (XMLNS_main.indexOf(wb.xmlns) === -1)
    throw new Error("Unknown Namespace: " + wb.xmlns);
  parse_wb_defaults(wb);
  return wb;
}
function write_wb_xml(wb) {
  var o = [XML_HEADER];
  o[o.length] = writextag("workbook", null, {
    "xmlns": XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
  var workbookPr = { codeName: "ThisWorkbook" };
  if (wb.Workbook && wb.Workbook.WBProps) {
    WBPropsDef.forEach(function(x) {
      if (wb.Workbook.WBProps[x[0]] == null)
        return;
      if (wb.Workbook.WBProps[x[0]] == x[1])
        return;
      workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
    });
    if (wb.Workbook.WBProps.CodeName) {
      workbookPr.codeName = wb.Workbook.WBProps.CodeName;
      delete workbookPr.CodeName;
    }
  }
  o[o.length] = writextag("workbookPr", null, workbookPr);
  var sheets = wb.Workbook && wb.Workbook.Sheets || [];
  var i = 0;
  if (sheets && sheets[0] && !!sheets[0].Hidden) {
    o[o.length] = "<bookViews>";
    for (i = 0; i != wb.SheetNames.length; ++i) {
      if (!sheets[i])
        break;
      if (!sheets[i].Hidden)
        break;
    }
    if (i == wb.SheetNames.length)
      i = 0;
    o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
    o[o.length] = "</bookViews>";
  }
  o[o.length] = "<sheets>";
  for (i = 0; i != wb.SheetNames.length; ++i) {
    var sht = { name: escapexml(wb.SheetNames[i].slice(0, 31)) };
    sht.sheetId = "" + (i + 1);
    sht["r:id"] = "rId" + (i + 1);
    if (sheets[i])
      switch (sheets[i].Hidden) {
        case 1:
          sht.state = "hidden";
          break;
        case 2:
          sht.state = "veryHidden";
          break;
      }
    o[o.length] = writextag("sheet", null, sht);
  }
  o[o.length] = "</sheets>";
  if (write_names) {
    o[o.length] = "<definedNames>";
    if (wb.Workbook && wb.Workbook.Names)
      wb.Workbook.Names.forEach(function(n) {
        var d = { name: n.Name };
        if (n.Comment)
          d.comment = n.Comment;
        if (n.Sheet != null)
          d.localSheetId = "" + n.Sheet;
        if (n.Hidden)
          d.hidden = "1";
        if (!n.Ref)
          return;
        o[o.length] = writextag("definedName", escapexml(n.Ref), d);
      });
    o[o.length] = "</definedNames>";
  }
  if (o.length > 2) {
    o[o.length] = "</workbook>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtBundleSh(data, length) {
  var z = {};
  z.Hidden = data.read_shift(4);
  z.iTabID = data.read_shift(4);
  z.strRelID = parse_RelID(data);
  z.name = parse_XLWideString(data);
  return z;
}
function write_BrtBundleSh(data, o) {
  if (!o)
    o = new_buf(127);
  o.write_shift(4, data.Hidden);
  o.write_shift(4, data.iTabID);
  write_RelID(data.strRelID, o);
  write_XLWideString(data.name.slice(0, 31), o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtWbProp(data, length) {
  var o = {};
  var flags = data.read_shift(4);
  o.defaultThemeVersion = data.read_shift(4);
  var strName = length > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0)
    o.CodeName = strName;
  o.autoCompressPictures = !!(flags & 65536);
  o.backupFile = !!(flags & 64);
  o.checkCompatibility = !!(flags & 4096);
  o.date1904 = !!(flags & 1);
  o.filterPrivacy = !!(flags & 8);
  o.hidePivotFieldList = !!(flags & 1024);
  o.promptedSolutions = !!(flags & 16);
  o.publishItems = !!(flags & 2048);
  o.refreshAllConnections = !!(flags & 262144);
  o.saveExternalLinkValues = !!(flags & 128);
  o.showBorderUnselectedTables = !!(flags & 4);
  o.showInkAnnotation = !!(flags & 32);
  o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o.showPivotChartFilter = !!(flags & 32768);
  o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o;
}
function write_BrtWbProp(data, o) {
  if (!o)
    o = new_buf(72);
  var flags = 0;
  if (data) {
    if (data.filterPrivacy)
      flags |= 8;
  }
  o.write_shift(4, flags);
  o.write_shift(4, 0);
  write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
  return o.slice(0, o.l);
}
function parse_BrtFRTArchID$(data, length) {
  var o = {};
  data.read_shift(4);
  o.ArchID = data.read_shift(4);
  data.l += length - 8;
  return o;
}
function parse_BrtName(data, length, opts) {
  var end = data.l + length;
  data.l += 4;
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  var comment = parse_XLNullableWideString(data);
  data.l = end;
  var out = { Name: name, Ptg: formula };
  if (itab < 268435455)
    out.Sheet = itab;
  if (comment)
    out.Comment = comment;
  return out;
}
function parse_wb_bin(data, opts) {
  var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
  var state = [];
  var pass = false;
  if (!opts)
    opts = {};
  opts.biff = 12;
  var Names = [];
  var supbooks = [[]];
  supbooks.SheetNames = [];
  supbooks.XTI = [];
  XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
  recordhopper(data, function hopper_wb(val, R, RT) {
    switch (RT) {
      case 156:
        supbooks.SheetNames.push(val.name);
        wb.Sheets.push(val);
        break;
      case 153:
        wb.WBProps = val;
        break;
      case 39:
        if (val.Sheet != null)
          opts.SID = val.Sheet;
        val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
        delete opts.SID;
        delete val.Ptg;
        Names.push(val);
        break;
      case 1036:
        break;
      case 357:
      case 358:
      case 355:
      case 667:
        if (!supbooks[0].length)
          supbooks[0] = [RT, val];
        else
          supbooks.push([RT, val]);
        supbooks[supbooks.length - 1].XTI = [];
        break;
      case 362:
        if (supbooks.length === 0) {
          supbooks[0] = [];
          supbooks[0].XTI = [];
        }
        supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
        supbooks.XTI = supbooks.XTI.concat(val);
        break;
      case 361:
        break;
      case 2071:
      case 158:
      case 143:
      case 664:
      case 353:
        break;
      case 3072:
      case 3073:
      case 534:
      case 677:
      case 157:
      case 610:
      case 2050:
      case 155:
      case 548:
      case 676:
      case 128:
      case 665:
      case 2128:
      case 2125:
      case 549:
      case 2053:
      case 596:
      case 2076:
      case 2075:
      case 2082:
      case 397:
      case 154:
      case 1117:
      case 553:
      case 2091:
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      case 16:
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  parse_wb_defaults(wb);
  wb.Names = Names;
  wb.supbooks = supbooks;
  return wb;
}
function write_BUNDLESHS(ba, wb) {
  write_record(
    ba,
    143
    /* BrtBeginBundleShs */
  );
  for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
    var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
    var d = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
    write_record(ba, 156, write_BrtBundleSh(d));
  }
  write_record(
    ba,
    144
    /* BrtEndBundleShs */
  );
}
function write_BrtFileVersion(data, o) {
  if (!o)
    o = new_buf(127);
  for (var i = 0; i != 4; ++i)
    o.write_shift(4, 0);
  write_XLWideString("SheetJS", o);
  write_XLWideString(XLSX.version, o);
  write_XLWideString(XLSX.version, o);
  write_XLWideString("7262", o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtBookView(idx, o) {
  if (!o)
    o = new_buf(29);
  o.write_shift(-4, 0);
  o.write_shift(-4, 460);
  o.write_shift(4, 28800);
  o.write_shift(4, 17600);
  o.write_shift(4, 500);
  o.write_shift(4, idx);
  o.write_shift(4, idx);
  var flags = 120;
  o.write_shift(1, flags);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BOOKVIEWS(ba, wb) {
  if (!wb.Workbook || !wb.Workbook.Sheets)
    return;
  var sheets = wb.Workbook.Sheets;
  var i = 0, vistab = -1, hidden = -1;
  for (; i < sheets.length; ++i) {
    if (!sheets[i] || !sheets[i].Hidden && vistab == -1)
      vistab = i;
    else if (sheets[i].Hidden == 1 && hidden == -1)
      hidden = i;
  }
  if (hidden > vistab)
    return;
  write_record(
    ba,
    135
    /* BrtBeginBookViews */
  );
  write_record(ba, 158, write_BrtBookView(vistab));
  write_record(
    ba,
    136
    /* BrtEndBookViews */
  );
}
function write_wb_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    131
    /* BrtBeginBook */
  );
  write_record(ba, 128, write_BrtFileVersion());
  write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
  write_BOOKVIEWS(ba, wb);
  write_BUNDLESHS(ba, wb);
  write_record(
    ba,
    132
    /* BrtEndBook */
  );
  return ba.end();
}
function parse_wb(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_wb_bin(data, opts);
  return parse_wb_xml(data, opts);
}
function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin")
    return parse_ws_bin(data, opts, idx, rels, wb, themes, styles);
  return parse_ws_xml(data, opts, idx, rels, wb, themes, styles);
}
function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin")
    return parse_cs_bin(data, opts, idx, rels, wb);
  return parse_cs_xml(data, opts, idx, rels, wb);
}
function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin")
    return parse_ms_bin();
  return parse_ms_xml();
}
function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin")
    return parse_ds_bin();
  return parse_ds_xml();
}
function parse_sty(data, name, themes, opts) {
  if (name.slice(-4) === ".bin")
    return parse_sty_bin(data, themes, opts);
  return parse_sty_xml(data, themes, opts);
}
function parse_theme(data, name, opts) {
  return parse_theme_xml(data, opts);
}
function parse_sst(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_sst_bin(data, opts);
  return parse_sst_xml(data, opts);
}
function parse_cmnt(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_comments_bin(data, opts);
  return parse_comments_xml(data, opts);
}
function parse_cc(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_cc_bin(data);
  return parse_cc_xml(data);
}
function parse_xlink(data, rel, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_xlink_bin(data, rel, name, opts);
  return parse_xlink_xml();
}
function parse_xlmeta(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_xlmeta_bin(data, name, opts);
  return parse_xlmeta_xml(data, name, opts);
}
function write_wb(wb, name, opts) {
  return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb);
}
function write_ws(data, name, opts, wb, rels) {
  return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
}
function write_sty(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
}
function write_sst(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
}
function write_cmnt(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data);
}
function write_xlmeta(name) {
  return (name.slice(-4) === ".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
}
var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(tag, skip_root) {
  var words = tag.split(/\s+/);
  var z = [];
  if (!skip_root)
    z[0] = words[0];
  if (words.length === 1)
    return z;
  var m = tag.match(attregexg2), y, j, w, i;
  if (m)
    for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1)
        z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:")
          w = "xmlns" + y[1].slice(6);
        else
          w = y[1].slice(j + 1);
        z[w] = y[2].slice(1, y[2].length - 1);
      }
    }
  return z;
}
function xlml_parsexmltagobj(tag) {
  var words = tag.split(/\s+/);
  var z = {};
  if (words.length === 1)
    return z;
  var m = tag.match(attregexg2), y, j, w, i;
  if (m)
    for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1)
        z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:")
          w = "xmlns" + y[1].slice(6);
        else
          w = y[1].slice(j + 1);
        z[w] = y[2].slice(1, y[2].length - 1);
      }
    }
  return z;
}
var XLMLFormatMap;
function xlml_format(format, value) {
  var fmt = XLMLFormatMap[format] || unescapexml(format);
  if (fmt === "General")
    return SSF_general(value);
  return SSF_format(fmt, value);
}
function xlml_set_custprop(Custprops, key, cp, val) {
  var oval = val;
  switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      oval = parsexmlbool(val);
      break;
    case "i2":
    case "int":
      oval = parseInt(val, 10);
      break;
    case "r4":
    case "float":
      oval = parseFloat(val);
      break;
    case "date":
    case "dateTime.tz":
      oval = parseDate(val);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + cp[0]);
  }
  Custprops[unescapexml(key)] = oval;
}
function safe_format_xlml(cell, nf, o) {
  if (cell.t === "z")
    return;
  if (!o || o.cellText !== false)
    try {
      if (cell.t === "e") {
        cell.w = cell.w || BErr[cell.v];
      } else if (nf === "General") {
        if (cell.t === "n") {
          if ((cell.v | 0) === cell.v)
            cell.w = cell.v.toString(10);
          else
            cell.w = SSF_general_num(cell.v);
        } else
          cell.w = SSF_general(cell.v);
      } else
        cell.w = xlml_format(nf || "General", cell.v);
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  try {
    var z = XLMLFormatMap[nf] || nf || "General";
    if (o.cellNF)
      cell.z = z;
    if (o.cellDates && cell.t == "n" && fmt_is_date(z)) {
      var _d = SSF_parse_date_code(cell.v);
      if (_d) {
        cell.t = "d";
        cell.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
      }
    }
  } catch (e) {
    if (o.WTF)
      throw e;
  }
}
function process_style_xlml(styles, stag, opts) {
  if (opts.cellStyles) {
    if (stag.Interior) {
      var I = stag.Interior;
      if (I.Pattern)
        I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
    }
  }
  styles[stag.ID] = stag;
}
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o) {
  var nf = "General", sid = cell.StyleID, S = {};
  o = o || {};
  var interiors = [];
  var i = 0;
  if (sid === void 0 && row)
    sid = row.StyleID;
  if (sid === void 0 && csty)
    sid = csty.StyleID;
  while (styles[sid] !== void 0) {
    if (styles[sid].nf)
      nf = styles[sid].nf;
    if (styles[sid].Interior)
      interiors.push(styles[sid].Interior);
    if (!styles[sid].Parent)
      break;
    sid = styles[sid].Parent;
  }
  switch (data.Type) {
    case "Boolean":
      cell.t = "b";
      cell.v = parsexmlbool(xml);
      break;
    case "String":
      cell.t = "s";
      cell.r = xlml_fixstr(unescapexml(xml));
      cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<.*?>/g, "") : cell.r;
      break;
    case "DateTime":
      if (xml.slice(-1) != "Z")
        xml += "Z";
      cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
      if (cell.v !== cell.v)
        cell.v = unescapexml(xml);
      else if (cell.v < 60)
        cell.v = cell.v - 1;
      if (!nf || nf == "General")
        nf = "yyyy-mm-dd";
    case "Number":
      if (cell.v === void 0)
        cell.v = +xml;
      if (!cell.t)
        cell.t = "n";
      break;
    case "Error":
      cell.t = "e";
      cell.v = RBErr[xml];
      if (o.cellText !== false)
        cell.w = xml;
      break;
    default:
      if (xml == "" && ss == "") {
        cell.t = "z";
      } else {
        cell.t = "s";
        cell.v = xlml_fixstr(ss || xml);
      }
      break;
  }
  safe_format_xlml(cell, nf, o);
  if (o.cellFormula !== false) {
    if (cell.Formula) {
      var fstr = unescapexml(cell.Formula);
      if (fstr.charCodeAt(0) == 61)
        fstr = fstr.slice(1);
      cell.f = rc_to_a1(fstr, base);
      delete cell.Formula;
      if (cell.ArrayRange == "RC")
        cell.F = rc_to_a1("RC:RC", base);
      else if (cell.ArrayRange) {
        cell.F = rc_to_a1(cell.ArrayRange, base);
        arrayf.push([safe_decode_range(cell.F), cell.F]);
      }
    } else {
      for (i = 0; i < arrayf.length; ++i)
        if (base.r >= arrayf[i][0].s.r && base.r <= arrayf[i][0].e.r) {
          if (base.c >= arrayf[i][0].s.c && base.c <= arrayf[i][0].e.c)
            cell.F = arrayf[i][1];
        }
    }
  }
  if (o.cellStyles) {
    interiors.forEach(function(x) {
      if (!S.patternType && x.patternType)
        S.patternType = x.patternType;
    });
    cell.s = S;
  }
  if (cell.StyleID !== void 0)
    cell.ixfe = cell.StyleID;
}
function xlml_clean_comment(comment) {
  comment.t = comment.v || "";
  comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  comment.v = comment.w = comment.ixfe = void 0;
}
function parse_xlml_xml(d, _opts) {
  var opts = _opts || {};
  make_ssf();
  var str = debom(xlml_normalize(d));
  if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
    str = utf8read(str);
  }
  var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
  opening = opening.replace(/".*?"/g, "");
  if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
    var _o = dup(opts);
    _o.type = "string";
    return PRN.to_workbook(str, _o);
  }
  if (opening.indexOf("<?xml") == -1)
    ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
      if (opening.indexOf("<" + tag) >= 0)
        ishtml = true;
    });
  if (ishtml)
    return html_to_workbook(str, opts);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "Fixed": table_fmt[2],
    "Standard": table_fmt[4],
    "Percent": table_fmt[10],
    "Scientific": table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var Rn;
  var state = [], tmp;
  var sheets = {}, sheetnames = [], cursheet = opts.dense ? [] : {}, sheetname = "";
  var cell = {}, row = {};
  var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
  var c = 0, r = 0;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var styles = {}, stag = {};
  var ss = "", fidx = 0;
  var merges = [];
  var Props = {}, Custprops = {}, pidx = 0, cp = [];
  var comments = [], comment = {};
  var cstys = [], csty, seencol = false;
  var arrayf = [];
  var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
  var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "");
  var raw_Rn3 = "";
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
      case "data":
        if (raw_Rn3 == "data") {
          if (Rn[1] === "/") {
            if ((tmp = state.pop())[0] !== Rn[3])
              throw new Error("Bad state: " + tmp.join("|"));
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
            state.push([Rn[3], true]);
          break;
        }
        if (state[state.length - 1][1])
          break;
        if (Rn[1] === "/")
          parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
          "comment" ? comment : cell, { c, r }, styles, cstys[c], row, arrayf, opts);
        else {
          ss = "";
          dtag = xlml_parsexmltag(Rn[0]);
          didx = Rn.index + Rn[0].length;
        }
        break;
      case "cell":
        if (Rn[1] === "/") {
          if (comments.length > 0)
            cell.c = comments;
          if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== void 0) {
            if (opts.dense) {
              if (!cursheet[r])
                cursheet[r] = [];
              cursheet[r][c] = cell;
            } else
              cursheet[encode_col(c) + encode_row(r)] = cell;
          }
          if (cell.HRef) {
            cell.l = { Target: unescapexml(cell.HRef) };
            if (cell.HRefScreenTip)
              cell.l.Tooltip = cell.HRefScreenTip;
            delete cell.HRef;
            delete cell.HRefScreenTip;
          }
          if (cell.MergeAcross || cell.MergeDown) {
            cc = c + (parseInt(cell.MergeAcross, 10) | 0);
            rr = r + (parseInt(cell.MergeDown, 10) | 0);
            merges.push({ s: { c, r }, e: { c: cc, r: rr } });
          }
          if (!opts.sheetStubs) {
            if (cell.MergeAcross)
              c = cc + 1;
            else
              ++c;
          } else if (cell.MergeAcross || cell.MergeDown) {
            for (var cma = c; cma <= cc; ++cma) {
              for (var cmd = r; cmd <= rr; ++cmd) {
                if (cma > c || cmd > r) {
                  if (opts.dense) {
                    if (!cursheet[cmd])
                      cursheet[cmd] = [];
                    cursheet[cmd][cma] = { t: "z" };
                  } else
                    cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
                }
              }
            }
            c = cc + 1;
          } else
            ++c;
        } else {
          cell = xlml_parsexmltagobj(Rn[0]);
          if (cell.Index)
            c = +cell.Index - 1;
          if (c < refguess.s.c)
            refguess.s.c = c;
          if (c > refguess.e.c)
            refguess.e.c = c;
          if (Rn[0].slice(-2) === "/>")
            ++c;
          comments = [];
        }
        break;
      case "row":
        if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
          if (r < refguess.s.r)
            refguess.s.r = r;
          if (r > refguess.e.r)
            refguess.e.r = r;
          if (Rn[0].slice(-2) === "/>") {
            row = xlml_parsexmltag(Rn[0]);
            if (row.Index)
              r = +row.Index - 1;
          }
          c = 0;
          ++r;
        } else {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index)
            r = +row.Index - 1;
          rowobj = {};
          if (row.AutoFitHeight == "0" || row.Height) {
            rowobj.hpx = parseInt(row.Height, 10);
            rowobj.hpt = px2pt(rowobj.hpx);
            rowinfo[r] = rowobj;
          }
          if (row.Hidden == "1") {
            rowobj.hidden = true;
            rowinfo[r] = rowobj;
          }
        }
        break;
      case "worksheet":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
          sheetnames.push(sheetname);
          if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
            cursheet["!ref"] = encode_range(refguess);
            if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
              cursheet["!fullref"] = cursheet["!ref"];
              refguess.e.r = opts.sheetRows - 1;
              cursheet["!ref"] = encode_range(refguess);
            }
          }
          if (merges.length)
            cursheet["!merges"] = merges;
          if (cstys.length > 0)
            cursheet["!cols"] = cstys;
          if (rowinfo.length > 0)
            cursheet["!rows"] = rowinfo;
          sheets[sheetname] = cursheet;
        } else {
          refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
          r = c = 0;
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          sheetname = unescapexml(tmp.Name);
          cursheet = opts.dense ? [] : {};
          merges = [];
          arrayf = [];
          rowinfo = [];
          wsprops = { name: sheetname, Hidden: 0 };
          Workbook.Sheets.push(wsprops);
        }
        break;
      case "table":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].slice(-2) == "/>")
          break;
        else {
          state.push([Rn[3], false]);
          cstys = [];
          seencol = false;
        }
        break;
      case "style":
        if (Rn[1] === "/")
          process_style_xlml(styles, stag, opts);
        else
          stag = xlml_parsexmltag(Rn[0]);
        break;
      case "numberformat":
        stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
        if (XLMLFormatMap[stag.nf])
          stag.nf = XLMLFormatMap[stag.nf];
        for (var ssfidx = 0; ssfidx != 392; ++ssfidx)
          if (table_fmt[ssfidx] == stag.nf)
            break;
        if (ssfidx == 392) {
          for (ssfidx = 57; ssfidx != 392; ++ssfidx)
            if (table_fmt[ssfidx] == null) {
              SSF_load(stag.nf, ssfidx);
              break;
            }
        }
        break;
      case "column":
        if (state[state.length - 1][0] !== /*'Table'*/
        "table")
          break;
        csty = xlml_parsexmltag(Rn[0]);
        if (csty.Hidden) {
          csty.hidden = true;
          delete csty.Hidden;
        }
        if (csty.Width)
          csty.wpx = parseInt(csty.Width, 10);
        if (!seencol && csty.wpx > 10) {
          seencol = true;
          MDW = DEF_MDW;
          for (var _col = 0; _col < cstys.length; ++_col)
            if (cstys[_col])
              process_col(cstys[_col]);
        }
        if (seencol)
          process_col(csty);
        cstys[csty.Index - 1 || cstys.length] = csty;
        for (var i = 0; i < +csty.Span; ++i)
          cstys[cstys.length] = dup(csty);
        break;
      case "namedrange":
        if (Rn[1] === "/")
          break;
        if (!Workbook.Names)
          Workbook.Names = [];
        var _NamedRange = parsexmltag(Rn[0]);
        var _DefinedName = {
          Name: _NamedRange.Name,
          Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
        };
        if (Workbook.Sheets.length > 0)
          _DefinedName.Sheet = Workbook.Sheets.length - 1;
        Workbook.Names.push(_DefinedName);
        break;
      case "namedcell":
        break;
      case "b":
        break;
      case "i":
        break;
      case "u":
        break;
      case "s":
        break;
      case "em":
        break;
      case "h2":
        break;
      case "h3":
        break;
      case "sub":
        break;
      case "sup":
        break;
      case "span":
        break;
      case "alignment":
        break;
      case "borders":
        break;
      case "border":
        break;
      case "font":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          ss += str.slice(fidx, Rn.index);
        else
          fidx = Rn.index + Rn[0].length;
        break;
      case "interior":
        if (!opts.cellStyles)
          break;
        stag.Interior = xlml_parsexmltag(Rn[0]);
        break;
      case "protection":
        break;
      case "author":
      case "title":
      case "description":
      case "created":
      case "keywords":
      case "subject":
      case "category":
      case "company":
      case "lastauthor":
      case "lastsaved":
      case "lastprinted":
      case "version":
      case "revision":
      case "totaltime":
      case "hyperlinkbase":
      case "manager":
      case "contentstatus":
      case "identifier":
      case "language":
      case "appname":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
        else
          pidx = Rn.index + Rn[0].length;
        break;
      case "paragraphs":
        break;
      case "styles":
      case "workbook":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else
          state.push([Rn[3], false]);
        break;
      case "comment":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
          xlml_clean_comment(comment);
          comments.push(comment);
        } else {
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          comment = { a: tmp.Author };
        }
        break;
      case "autofilter":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          var AutoFilter2 = xlml_parsexmltag(Rn[0]);
          cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter2.Range).replace(/\$/g, "") };
          state.push([Rn[3], true]);
        }
        break;
      case "name":
        break;
      case "datavalidation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else {
          if (Rn[0].charAt(Rn[0].length - 2) !== "/")
            state.push([Rn[3], true]);
        }
        break;
      case "pixelsperinch":
        break;
      case "componentoptions":
      case "documentproperties":
      case "customdocumentproperties":
      case "officedocumentsettings":
      case "pivottable":
      case "pivotcache":
      case "names":
      case "mapinfo":
      case "pagebreaks":
      case "querytable":
      case "sorting":
      case "schema":
      case "conditionalformatting":
      case "smarttagtype":
      case "smarttags":
      case "excelworkbook":
      case "workbookoptions":
      case "worksheetoptions":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], true]);
        break;
      case "null":
        break;
      default:
        if (state.length == 0 && Rn[3] == "document")
          return parse_fods(str, opts);
        if (state.length == 0 && Rn[3] == "uof")
          return parse_fods(str, opts);
        var seen = true;
        switch (state[state.length - 1][0]) {
          case "officedocumentsettings":
            switch (Rn[3]) {
              case "allowpng":
                break;
              case "removepersonalinformation":
                break;
              case "downloadcomponents":
                break;
              case "locationofcomponents":
                break;
              case "colors":
                break;
              case "color":
                break;
              case "index":
                break;
              case "rgb":
                break;
              case "targetscreensize":
                break;
              case "readonlyrecommended":
                break;
              default:
                seen = false;
            }
            break;
          case "componentoptions":
            switch (Rn[3]) {
              case "toolbar":
                break;
              case "hideofficelogo":
                break;
              case "spreadsheetautofit":
                break;
              case "label":
                break;
              case "caption":
                break;
              case "maxheight":
                break;
              case "maxwidth":
                break;
              case "nextsheetnumber":
                break;
              default:
                seen = false;
            }
            break;
          case "excelworkbook":
            switch (Rn[3]) {
              case "date1904":
                Workbook.WBProps.date1904 = true;
                break;
              case "windowheight":
                break;
              case "windowwidth":
                break;
              case "windowtopx":
                break;
              case "windowtopy":
                break;
              case "tabratio":
                break;
              case "protectstructure":
                break;
              case "protectwindow":
                break;
              case "protectwindows":
                break;
              case "activesheet":
                break;
              case "displayinknotes":
                break;
              case "firstvisiblesheet":
                break;
              case "supbook":
                break;
              case "sheetname":
                break;
              case "sheetindex":
                break;
              case "sheetindexfirst":
                break;
              case "sheetindexlast":
                break;
              case "dll":
                break;
              case "acceptlabelsinformulas":
                break;
              case "donotsavelinkvalues":
                break;
              case "iteration":
                break;
              case "maxiterations":
                break;
              case "maxchange":
                break;
              case "path":
                break;
              case "xct":
                break;
              case "count":
                break;
              case "selectedsheets":
                break;
              case "calculation":
                break;
              case "uncalced":
                break;
              case "startupprompt":
                break;
              case "crn":
                break;
              case "externname":
                break;
              case "formula":
                break;
              case "colfirst":
                break;
              case "collast":
                break;
              case "wantadvise":
                break;
              case "boolean":
                break;
              case "error":
                break;
              case "text":
                break;
              case "ole":
                break;
              case "noautorecover":
                break;
              case "publishobjects":
                break;
              case "donotcalculatebeforesave":
                break;
              case "number":
                break;
              case "refmoder1c1":
                break;
              case "embedsavesmarttags":
                break;
              default:
                seen = false;
            }
            break;
          case "workbookoptions":
            switch (Rn[3]) {
              case "owcversion":
                break;
              case "height":
                break;
              case "width":
                break;
              default:
                seen = false;
            }
            break;
          case "worksheetoptions":
            switch (Rn[3]) {
              case "visible":
                if (Rn[0].slice(-2) === "/>")
                  ;
                else if (Rn[1] === "/")
                  switch (str.slice(pidx, Rn.index)) {
                    case "SheetHidden":
                      wsprops.Hidden = 1;
                      break;
                    case "SheetVeryHidden":
                      wsprops.Hidden = 2;
                      break;
                  }
                else
                  pidx = Rn.index + Rn[0].length;
                break;
              case "header":
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin))
                  cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
                break;
              case "footer":
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin))
                  cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
                break;
              case "pagemargins":
                var pagemargins = parsexmltag(Rn[0]);
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+pagemargins.Top))
                  cursheet["!margins"].top = +pagemargins.Top;
                if (!isNaN(+pagemargins.Left))
                  cursheet["!margins"].left = +pagemargins.Left;
                if (!isNaN(+pagemargins.Right))
                  cursheet["!margins"].right = +pagemargins.Right;
                if (!isNaN(+pagemargins.Bottom))
                  cursheet["!margins"].bottom = +pagemargins.Bottom;
                break;
              case "displayrighttoleft":
                if (!Workbook.Views)
                  Workbook.Views = [];
                if (!Workbook.Views[0])
                  Workbook.Views[0] = {};
                Workbook.Views[0].RTL = true;
                break;
              case "freezepanes":
                break;
              case "frozennosplit":
                break;
              case "splithorizontal":
              case "splitvertical":
                break;
              case "donotdisplaygridlines":
                break;
              case "activerow":
                break;
              case "activecol":
                break;
              case "toprowbottompane":
                break;
              case "leftcolumnrightpane":
                break;
              case "unsynced":
                break;
              case "print":
                break;
              case "printerrors":
                break;
              case "panes":
                break;
              case "scale":
                break;
              case "pane":
                break;
              case "number":
                break;
              case "layout":
                break;
              case "pagesetup":
                break;
              case "selected":
                break;
              case "protectobjects":
                break;
              case "enableselection":
                break;
              case "protectscenarios":
                break;
              case "validprinterinfo":
                break;
              case "horizontalresolution":
                break;
              case "verticalresolution":
                break;
              case "numberofcopies":
                break;
              case "activepane":
                break;
              case "toprowvisible":
                break;
              case "leftcolumnvisible":
                break;
              case "fittopage":
                break;
              case "rangeselection":
                break;
              case "papersizeindex":
                break;
              case "pagelayoutzoom":
                break;
              case "pagebreakzoom":
                break;
              case "filteron":
                break;
              case "fitwidth":
                break;
              case "fitheight":
                break;
              case "commentslayout":
                break;
              case "zoom":
                break;
              case "lefttoright":
                break;
              case "gridlines":
                break;
              case "allowsort":
                break;
              case "allowfilter":
                break;
              case "allowinsertrows":
                break;
              case "allowdeleterows":
                break;
              case "allowinsertcols":
                break;
              case "allowdeletecols":
                break;
              case "allowinserthyperlinks":
                break;
              case "allowformatcells":
                break;
              case "allowsizecols":
                break;
              case "allowsizerows":
                break;
              case "nosummaryrowsbelowdetail":
                if (!cursheet["!outline"])
                  cursheet["!outline"] = {};
                cursheet["!outline"].above = true;
                break;
              case "tabcolorindex":
                break;
              case "donotdisplayheadings":
                break;
              case "showpagelayoutzoom":
                break;
              case "nosummarycolumnsrightdetail":
                if (!cursheet["!outline"])
                  cursheet["!outline"] = {};
                cursheet["!outline"].left = true;
                break;
              case "blackandwhite":
                break;
              case "donotdisplayzeros":
                break;
              case "displaypagebreak":
                break;
              case "rowcolheadings":
                break;
              case "donotdisplayoutline":
                break;
              case "noorientation":
                break;
              case "allowusepivottables":
                break;
              case "zeroheight":
                break;
              case "viewablerange":
                break;
              case "selection":
                break;
              case "protectcontents":
                break;
              default:
                seen = false;
            }
            break;
          case "pivottable":
          case "pivotcache":
            switch (Rn[3]) {
              case "immediateitemsondrop":
                break;
              case "showpagemultipleitemlabel":
                break;
              case "compactrowindent":
                break;
              case "location":
                break;
              case "pivotfield":
                break;
              case "orientation":
                break;
              case "layoutform":
                break;
              case "layoutsubtotallocation":
                break;
              case "layoutcompactrow":
                break;
              case "position":
                break;
              case "pivotitem":
                break;
              case "datatype":
                break;
              case "datafield":
                break;
              case "sourcename":
                break;
              case "parentfield":
                break;
              case "ptlineitems":
                break;
              case "ptlineitem":
                break;
              case "countofsameitems":
                break;
              case "item":
                break;
              case "itemtype":
                break;
              case "ptsource":
                break;
              case "cacheindex":
                break;
              case "consolidationreference":
                break;
              case "filename":
                break;
              case "reference":
                break;
              case "nocolumngrand":
                break;
              case "norowgrand":
                break;
              case "blanklineafteritems":
                break;
              case "hidden":
                break;
              case "subtotal":
                break;
              case "basefield":
                break;
              case "mapchilditems":
                break;
              case "function":
                break;
              case "refreshonfileopen":
                break;
              case "printsettitles":
                break;
              case "mergelabels":
                break;
              case "defaultversion":
                break;
              case "refreshname":
                break;
              case "refreshdate":
                break;
              case "refreshdatecopy":
                break;
              case "versionlastrefresh":
                break;
              case "versionlastupdate":
                break;
              case "versionupdateablemin":
                break;
              case "versionrefreshablemin":
                break;
              case "calculation":
                break;
              default:
                seen = false;
            }
            break;
          case "pagebreaks":
            switch (Rn[3]) {
              case "colbreaks":
                break;
              case "colbreak":
                break;
              case "rowbreaks":
                break;
              case "rowbreak":
                break;
              case "colstart":
                break;
              case "colend":
                break;
              case "rowend":
                break;
              default:
                seen = false;
            }
            break;
          case "autofilter":
            switch (Rn[3]) {
              case "autofiltercolumn":
                break;
              case "autofiltercondition":
                break;
              case "autofilterand":
                break;
              case "autofilteror":
                break;
              default:
                seen = false;
            }
            break;
          case "querytable":
            switch (Rn[3]) {
              case "id":
                break;
              case "autoformatfont":
                break;
              case "autoformatpattern":
                break;
              case "querysource":
                break;
              case "querytype":
                break;
              case "enableredirections":
                break;
              case "refreshedinxl9":
                break;
              case "urlstring":
                break;
              case "htmltables":
                break;
              case "connection":
                break;
              case "commandtext":
                break;
              case "refreshinfo":
                break;
              case "notitles":
                break;
              case "nextid":
                break;
              case "columninfo":
                break;
              case "overwritecells":
                break;
              case "donotpromptforfile":
                break;
              case "textwizardsettings":
                break;
              case "source":
                break;
              case "number":
                break;
              case "decimal":
                break;
              case "thousandseparator":
                break;
              case "trailingminusnumbers":
                break;
              case "formatsettings":
                break;
              case "fieldtype":
                break;
              case "delimiters":
                break;
              case "tab":
                break;
              case "comma":
                break;
              case "autoformatname":
                break;
              case "versionlastedit":
                break;
              case "versionlastrefresh":
                break;
              default:
                seen = false;
            }
            break;
          case "datavalidation":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              case "cellrangelist":
                break;
              default:
                seen = false;
            }
            break;
          case "sorting":
          case "conditionalformatting":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "cellrangelist":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              default:
                seen = false;
            }
            break;
          case "mapinfo":
          case "schema":
          case "data":
            switch (Rn[3]) {
              case "map":
                break;
              case "entry":
                break;
              case "range":
                break;
              case "xpath":
                break;
              case "field":
                break;
              case "xsdtype":
                break;
              case "filteron":
                break;
              case "aggregate":
                break;
              case "elementtype":
                break;
              case "attributetype":
                break;
              case "schema":
              case "element":
              case "complextype":
              case "datatype":
              case "all":
              case "attribute":
              case "extends":
                break;
              case "row":
                break;
              default:
                seen = false;
            }
            break;
          case "smarttags":
            break;
          default:
            seen = false;
            break;
        }
        if (seen)
          break;
        if (Rn[3].match(/!\[CDATA/))
          break;
        if (!state[state.length - 1][1])
          throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
        if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
        "customdocumentproperties") {
          if (Rn[0].slice(-2) === "/>")
            break;
          else if (Rn[1] === "/")
            xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
          else {
            cp = Rn;
            pidx = Rn.index + Rn[0].length;
          }
          break;
        }
        if (opts.WTF)
          throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
    }
  var out = {};
  if (!opts.bookSheets && !opts.bookProps)
    out.Sheets = sheets;
  out.SheetNames = sheetnames;
  out.Workbook = Workbook;
  out.SSF = dup(table_fmt);
  out.Props = Props;
  out.Custprops = Custprops;
  return out;
}
function parse_xlml(data, opts) {
  fix_read_opts(opts = opts || {});
  switch (opts.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(data), opts);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(data, opts);
    case "array":
      return parse_xlml_xml(a2s(data), opts);
  }
}
function write_props_xlml(wb, opts) {
  var o = [];
  if (wb.Props)
    o.push(xlml_write_docprops(wb.Props, opts));
  if (wb.Custprops)
    o.push(xlml_write_custprops(wb.Props, wb.Custprops));
  return o.join("");
}
function write_wb_xlml() {
  return "";
}
function write_sty_xlml(wb, opts) {
  var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  opts.cellXfs.forEach(function(xf, id) {
    var payload = [];
    payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
    var o = (
      /*::(*/
      { "ss:ID": "s" + (21 + id) }
    );
    styles.push(writextag("Style", payload.join(""), o));
  });
  return writextag("Styles", styles.join(""));
}
function write_name_xlml(n) {
  return writextag("NamedRange", null, { "ss:Name": n.Name, "ss:RefersTo": "=" + a1_to_rc(n.Ref, { r: 0, c: 0 }) });
}
function write_names_xlml(wb) {
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names2 = wb.Workbook.Names;
  var out = [];
  for (var i = 0; i < names2.length; ++i) {
    var n = names2[i];
    if (n.Sheet != null)
      continue;
    if (n.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n));
  }
  return writextag("Names", out.join(""));
}
function write_ws_xlml_names(ws, opts, idx, wb) {
  if (!ws)
    return "";
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names2 = wb.Workbook.Names;
  var out = [];
  for (var i = 0; i < names2.length; ++i) {
    var n = names2[i];
    if (n.Sheet != idx)
      continue;
    if (n.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n));
  }
  return out.join("");
}
function write_ws_xlml_wsopts(ws, opts, idx, wb) {
  if (!ws)
    return "";
  var o = [];
  if (ws["!margins"]) {
    o.push("<PageSetup>");
    if (ws["!margins"].header)
      o.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
    if (ws["!margins"].footer)
      o.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
    o.push(writextag("PageMargins", null, {
      "x:Bottom": ws["!margins"].bottom || "0.75",
      "x:Left": ws["!margins"].left || "0.7",
      "x:Right": ws["!margins"].right || "0.7",
      "x:Top": ws["!margins"].top || "0.75"
    }));
    o.push("</PageSetup>");
  }
  if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
    if (wb.Workbook.Sheets[idx].Hidden)
      o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var i = 0; i < idx; ++i)
        if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden)
          break;
      if (i == idx)
        o.push("<Selected/>");
    }
  }
  if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL)
    o.push("<DisplayRightToLeft/>");
  if (ws["!protect"]) {
    o.push(writetag("ProtectContents", "True"));
    if (ws["!protect"].objects)
      o.push(writetag("ProtectObjects", "True"));
    if (ws["!protect"].scenarios)
      o.push(writetag("ProtectScenarios", "True"));
    if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells)
      o.push(writetag("EnableSelection", "NoSelection"));
    else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells)
      o.push(writetag("EnableSelection", "UnlockedCells"));
    [
      ["formatCells", "AllowFormatCells"],
      ["formatColumns", "AllowSizeCols"],
      ["formatRows", "AllowSizeRows"],
      ["insertColumns", "AllowInsertCols"],
      ["insertRows", "AllowInsertRows"],
      ["insertHyperlinks", "AllowInsertHyperlinks"],
      ["deleteColumns", "AllowDeleteCols"],
      ["deleteRows", "AllowDeleteRows"],
      ["sort", "AllowSort"],
      ["autoFilter", "AllowFilter"],
      ["pivotTables", "AllowUsePivotTables"]
    ].forEach(function(x) {
      if (ws["!protect"][x[0]])
        o.push("<" + x[1] + "/>");
    });
  }
  if (o.length == 0)
    return "";
  return writextag("WorksheetOptions", o.join(""), { xmlns: XLMLNS.x });
}
function write_ws_xlml_comment(comments) {
  return comments.map(function(c) {
    var t2 = xlml_unfixstr(c.t || "");
    var d = writextag("ss:Data", t2, { "xmlns": "http://www.w3.org/TR/REC-html40" });
    return writextag("Comment", d, { "ss:Author": c.a });
  }).join("");
}
function write_ws_xlml_cell(cell, ref2, ws, opts, idx, wb, addr) {
  if (!cell || cell.v == void 0 && cell.f == void 0)
    return "";
  var attr = {};
  if (cell.f)
    attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
  if (cell.F && cell.F.slice(0, ref2.length) == ref2) {
    var end = decode_cell(cell.F.slice(ref2.length + 1));
    attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
  }
  if (cell.l && cell.l.Target) {
    attr["ss:HRef"] = escapexml(cell.l.Target);
    if (cell.l.Tooltip)
      attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
  }
  if (ws["!merges"]) {
    var marr = ws["!merges"];
    for (var mi = 0; mi != marr.length; ++mi) {
      if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r)
        continue;
      if (marr[mi].e.c > marr[mi].s.c)
        attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
      if (marr[mi].e.r > marr[mi].s.r)
        attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
    }
  }
  var t2 = "", p = "";
  switch (cell.t) {
    case "z":
      if (!opts.sheetStubs)
        return "";
      break;
    case "n":
      t2 = "Number";
      p = String(cell.v);
      break;
    case "b":
      t2 = "Boolean";
      p = cell.v ? "1" : "0";
      break;
    case "e":
      t2 = "Error";
      p = BErr[cell.v];
      break;
    case "d":
      t2 = "DateTime";
      p = new Date(cell.v).toISOString();
      if (cell.z == null)
        cell.z = cell.z || table_fmt[14];
      break;
    case "s":
      t2 = "String";
      p = escapexlml(cell.v || "");
      break;
  }
  var os = get_cell_style(opts.cellXfs, cell, opts);
  attr["ss:StyleID"] = "s" + (21 + os);
  attr["ss:Index"] = addr.c + 1;
  var _v = cell.v != null ? p : "";
  var m = cell.t == "z" ? "" : '<Data ss:Type="' + t2 + '">' + _v + "</Data>";
  if ((cell.c || []).length > 0)
    m += write_ws_xlml_comment(cell.c);
  return writextag("Cell", m, attr);
}
function write_ws_xlml_row(R, row) {
  var o = '<Row ss:Index="' + (R + 1) + '"';
  if (row) {
    if (row.hpt && !row.hpx)
      row.hpx = pt2px(row.hpt);
    if (row.hpx)
      o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
    if (row.hidden)
      o += ' ss:Hidden="1"';
  }
  return o + ">";
}
function write_ws_xlml_table(ws, opts, idx, wb) {
  if (!ws["!ref"])
    return "";
  var range = safe_decode_range(ws["!ref"]);
  var marr = ws["!merges"] || [], mi = 0;
  var o = [];
  if (ws["!cols"])
    ws["!cols"].forEach(function(n, i) {
      process_col(n);
      var w = !!n.width;
      var p = col_obj_w(i, n);
      var k = { "ss:Index": i + 1 };
      if (w)
        k["ss:Width"] = width2px(p.width);
      if (n.hidden)
        k["ss:Hidden"] = "1";
      o.push(writextag("Column", null, k));
    });
  var dense = Array.isArray(ws);
  for (var R = range.s.r; R <= range.e.r; ++R) {
    var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
    for (var C = range.s.c; C <= range.e.c; ++C) {
      var skip = false;
      for (mi = 0; mi != marr.length; ++mi) {
        if (marr[mi].s.c > C)
          continue;
        if (marr[mi].s.r > R)
          continue;
        if (marr[mi].e.c < C)
          continue;
        if (marr[mi].e.r < R)
          continue;
        if (marr[mi].s.c != C || marr[mi].s.r != R)
          skip = true;
        break;
      }
      if (skip)
        continue;
      var addr = { r: R, c: C };
      var ref2 = encode_cell(addr), cell = dense ? (ws[R] || [])[C] : ws[ref2];
      row.push(write_ws_xlml_cell(cell, ref2, ws, opts, idx, wb, addr));
    }
    row.push("</Row>");
    if (row.length > 2)
      o.push(row.join(""));
  }
  return o.join("");
}
function write_ws_xlml(idx, opts, wb) {
  var o = [];
  var s = wb.SheetNames[idx];
  var ws = wb.Sheets[s];
  var t2 = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
  if (t2.length > 0)
    o.push("<Names>" + t2 + "</Names>");
  t2 = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
  if (t2.length > 0)
    o.push("<Table>" + t2 + "</Table>");
  o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
  return o.join("");
}
function write_xlml(wb, opts) {
  if (!opts)
    opts = {};
  if (!wb.SSF)
    wb.SSF = dup(table_fmt);
  if (wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  }
  var d = [];
  d.push(write_props_xlml(wb, opts));
  d.push(write_wb_xlml());
  d.push("");
  d.push("");
  for (var i = 0; i < wb.SheetNames.length; ++i)
    d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i]) }));
  d[2] = write_sty_xlml(wb, opts);
  d[3] = write_names_xlml(wb);
  return XML_HEADER + writextag("Workbook", d.join(""), {
    "xmlns": XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
function parse_compobj(obj) {
  var v = {};
  var o = obj.content;
  o.l = 28;
  v.AnsiUserType = o.read_shift(0, "lpstr-ansi");
  v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
  if (o.length - o.l <= 4)
    return v;
  var m = o.read_shift(4);
  if (m == 0 || m > 40)
    return v;
  o.l -= 4;
  v.Reserved1 = o.read_shift(0, "lpstr-ansi");
  if (o.length - o.l <= 4)
    return v;
  m = o.read_shift(4);
  if (m !== 1907505652)
    return v;
  v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
  m = o.read_shift(4);
  if (m == 0 || m > 40)
    return v;
  o.l -= 4;
  v.Reserved2 = o.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(RecordType, R, blob, length, opts) {
  var l = length;
  var bufs = [];
  var d = blob.slice(blob.l, blob.l + l);
  if (opts && opts.enc && opts.enc.insitu && d.length > 0)
    switch (RecordType) {
      case 9:
      case 521:
      case 1033:
      case 2057:
      case 47:
      case 405:
      case 225:
      case 406:
      case 312:
      case 404:
      case 10:
        break;
      case 133:
        break;
      default:
        opts.enc.insitu(d);
    }
  bufs.push(d);
  blob.l += l;
  var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
  var start = 0;
  while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
    l = __readUInt16LE(blob, blob.l + 2);
    start = blob.l + 4;
    if (nextrt == 2066)
      start += 4;
    else if (nextrt == 2165 || nextrt == 2175) {
      start += 12;
    }
    d = blob.slice(start, blob.l + 4 + l);
    bufs.push(d);
    blob.l += 4 + l;
    next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
  }
  var b = bconcat(bufs);
  prep_blob(b, 0);
  var ll = 0;
  b.lens = [];
  for (var j = 0; j < bufs.length; ++j) {
    b.lens.push(ll);
    ll += bufs[j].length;
  }
  if (b.length < length)
    throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " < " + length;
  return R.f(b, b.length, opts);
}
function safe_format_xf(p, opts, date1904) {
  if (p.t === "z")
    return;
  if (!p.XF)
    return;
  var fmtid = 0;
  try {
    fmtid = p.z || p.XF.numFmtId || 0;
    if (opts.cellNF)
      p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
  if (!opts || opts.cellText !== false)
    try {
      if (p.t === "e") {
        p.w = p.w || BErr[p.v];
      } else if (fmtid === 0 || fmtid == "General") {
        if (p.t === "n") {
          if ((p.v | 0) === p.v)
            p.w = p.v.toString(10);
          else
            p.w = SSF_general_num(p.v);
        } else
          p.w = SSF_general(p.v);
      } else
        p.w = SSF_format(fmtid, p.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
    } catch (e) {
      if (opts.WTF)
        throw e;
    }
  if (opts.cellDates && fmtid && p.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
    var _d = SSF_parse_date_code(p.v);
    if (_d) {
      p.t = "d";
      p.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
    }
  }
}
function make_cell(val, ixfe, t2) {
  return { v: val, ixfe, t: t2 };
}
function parse_workbook(blob, options) {
  var wb = { opts: {} };
  var Sheets = {};
  var out = options.dense ? [] : {};
  var Directory = {};
  var range = {};
  var last_formula = null;
  var sst = [];
  var cur_sheet = "";
  var Preamble = {};
  var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
  var sharedf = {};
  var arrayf = [];
  var temp_val;
  var country;
  var XFs = [];
  var palette = [];
  var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
  var get_rgb = function getrgb(icv) {
    if (icv < 8)
      return XLSIcv[icv];
    if (icv < 64)
      return palette[icv - 8] || XLSIcv[icv];
    return XLSIcv[icv];
  };
  var process_cell_style = function pcs(cell, line, options2) {
    var xfd = line.XF.data;
    if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles)
      return;
    line.s = {};
    line.s.patternType = xfd.patternType;
    var t2;
    if (t2 = rgb2Hex(get_rgb(xfd.icvFore))) {
      line.s.fgColor = { rgb: t2 };
    }
    if (t2 = rgb2Hex(get_rgb(xfd.icvBack))) {
      line.s.bgColor = { rgb: t2 };
    }
  };
  var addcell = function addcell2(cell, line, options2) {
    if (file_depth > 1)
      return;
    if (options2.sheetRows && cell.r >= options2.sheetRows)
      return;
    if (options2.cellStyles && line.XF && line.XF.data)
      process_cell_style(cell, line, options2);
    delete line.ixfe;
    delete line.XF;
    lastcell = cell;
    last_cell = encode_cell(cell);
    if (!range || !range.s || !range.e)
      range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    if (cell.r < range.s.r)
      range.s.r = cell.r;
    if (cell.c < range.s.c)
      range.s.c = cell.c;
    if (cell.r + 1 > range.e.r)
      range.e.r = cell.r + 1;
    if (cell.c + 1 > range.e.c)
      range.e.c = cell.c + 1;
    if (options2.cellFormula && line.f) {
      for (var afi = 0; afi < arrayf.length; ++afi) {
        if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r)
          continue;
        if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r)
          continue;
        line.F = encode_range(arrayf[afi][0]);
        if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r)
          delete line.f;
        if (line.f)
          line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
        break;
      }
    }
    {
      if (options2.dense) {
        if (!out[cell.r])
          out[cell.r] = [];
        out[cell.r][cell.c] = line;
      } else
        out[last_cell] = line;
    }
  };
  var opts = {
    enc: false,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf,
    // shared formulae by address
    arrayf,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!options && !!options.cellStyles,
    WTF: !!options && !!options.wtf
  };
  if (options.password)
    opts.password = options.password;
  var themes;
  var merges = [];
  var objects = [];
  var colinfo = [], rowinfo = [];
  var seencol = false;
  var supbooks = [];
  supbooks.SheetNames = opts.snames;
  supbooks.sharedf = opts.sharedf;
  supbooks.arrayf = opts.arrayf;
  supbooks.names = [];
  supbooks.XTI = [];
  var last_RT = 0;
  var file_depth = 0;
  var BIFF2Fmt = 0, BIFF2FmtTable = [];
  var FilterDatabases = [];
  var last_lbl;
  opts.codepage = 1200;
  set_cp(1200);
  var seen_codepage = false;
  while (blob.l < blob.length - 1) {
    var s = blob.l;
    var RecordType = blob.read_shift(2);
    if (RecordType === 0 && last_RT === 10)
      break;
    var length = blob.l === blob.length ? 0 : blob.read_shift(2);
    var R = XLSRecordEnum[RecordType];
    if (R && R.f) {
      if (options.bookSheets) {
        if (last_RT === 133 && RecordType !== 133)
          break;
      }
      last_RT = RecordType;
      if (R.r === 2 || R.r == 12) {
        var rt = blob.read_shift(2);
        length -= 2;
        if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType)
          throw new Error("rt mismatch: " + rt + "!=" + RecordType);
        if (R.r == 12) {
          blob.l += 10;
          length -= 10;
        }
      }
      var val = {};
      if (RecordType === 10)
        val = /*::(*/
        R.f(blob, length, opts);
      else
        val = /*::(*/
        slurp(RecordType, R, blob, length, opts);
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1)
        continue;
      switch (RecordType) {
        case 34:
          wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
          break;
        case 134:
          wb.opts.WriteProtect = true;
          break;
        case 47:
          if (!opts.enc)
            blob.l = 0;
          opts.enc = val;
          if (!options.password)
            throw new Error("File is password-protected");
          if (val.valid == null)
            throw new Error("Encryption scheme unsupported");
          if (!val.valid)
            throw new Error("Password is incorrect");
          break;
        case 92:
          opts.lastuser = val;
          break;
        case 66:
          var cpval = Number(val);
          switch (cpval) {
            case 21010:
              cpval = 1200;
              break;
            case 32768:
              cpval = 1e4;
              break;
            case 32769:
              cpval = 1252;
              break;
          }
          set_cp(opts.codepage = cpval);
          seen_codepage = true;
          break;
        case 317:
          opts.rrtabid = val;
          break;
        case 25:
          opts.winlocked = val;
          break;
        case 439:
          wb.opts["RefreshAll"] = val;
          break;
        case 12:
          wb.opts["CalcCount"] = val;
          break;
        case 16:
          wb.opts["CalcDelta"] = val;
          break;
        case 17:
          wb.opts["CalcIter"] = val;
          break;
        case 13:
          wb.opts["CalcMode"] = val;
          break;
        case 14:
          wb.opts["CalcPrecision"] = val;
          break;
        case 95:
          wb.opts["CalcSaveRecalc"] = val;
          break;
        case 15:
          opts.CalcRefMode = val;
          break;
        case 2211:
          wb.opts.FullCalc = val;
          break;
        case 129:
          if (val.fDialog)
            out["!type"] = "dialog";
          if (!val.fBelow)
            (out["!outline"] || (out["!outline"] = {})).above = true;
          if (!val.fRight)
            (out["!outline"] || (out["!outline"] = {})).left = true;
          break;
        case 224:
          XFs.push(val);
          break;
        case 430:
          supbooks.push([val]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          supbooks[supbooks.length - 1].push(val);
          break;
        case 24:
        case 536:
          last_lbl = {
            Name: val.Name,
            Ref: stringify_formula(val.rgce, range, null, supbooks, opts)
          };
          if (val.itab > 0)
            last_lbl.Sheet = val.itab - 1;
          supbooks.names.push(last_lbl);
          if (!supbooks[0]) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].push(val);
          if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
            if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
              FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
          }
          break;
        case 22:
          opts.ExternCount = val;
          break;
        case 23:
          if (supbooks.length == 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
          supbooks.XTI = supbooks.XTI.concat(val);
          break;
        case 2196:
          if (opts.biff < 8)
            break;
          if (last_lbl != null)
            last_lbl.Comment = val[1];
          break;
        case 18:
          out["!protect"] = val;
          break;
        case 19:
          if (val !== 0 && opts.WTF)
            console.error("Password verifier: " + val);
          break;
        case 133:
          {
            Directory[val.pos] = val;
            opts.snames.push(val.name);
          }
          break;
        case 10:
          {
            if (--file_depth)
              break;
            if (range.e) {
              if (range.e.r > 0 && range.e.c > 0) {
                range.e.r--;
                range.e.c--;
                out["!ref"] = encode_range(range);
                if (options.sheetRows && options.sheetRows <= range.e.r) {
                  var tmpri = range.e.r;
                  range.e.r = options.sheetRows - 1;
                  out["!fullref"] = out["!ref"];
                  out["!ref"] = encode_range(range);
                  range.e.r = tmpri;
                }
                range.e.r++;
                range.e.c++;
              }
              if (merges.length > 0)
                out["!merges"] = merges;
              if (objects.length > 0)
                out["!objects"] = objects;
              if (colinfo.length > 0)
                out["!cols"] = colinfo;
              if (rowinfo.length > 0)
                out["!rows"] = rowinfo;
              Workbook.Sheets.push(wsprops);
            }
            if (cur_sheet === "")
              Preamble = out;
            else
              Sheets[cur_sheet] = out;
            out = options.dense ? [] : {};
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (opts.biff === 8)
              opts.biff = {
                /*::[*/
                9: 2,
                /*::[*/
                521: 3,
                /*::[*/
                1033: 4
              }[RecordType] || {
                /*::[*/
                512: 2,
                /*::[*/
                768: 3,
                /*::[*/
                1024: 4,
                /*::[*/
                1280: 5,
                /*::[*/
                1536: 8,
                /*::[*/
                2: 2,
                /*::[*/
                7: 2
              }[val.BIFFVer] || 8;
            opts.biffguess = val.BIFFVer == 0;
            if (val.BIFFVer == 0 && val.dt == 4096) {
              opts.biff = 5;
              seen_codepage = true;
              set_cp(opts.codepage = 28591);
            }
            if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16)
              opts.biff = 2;
            if (file_depth++)
              break;
            out = options.dense ? [] : {};
            if (opts.biff < 8 && !seen_codepage) {
              seen_codepage = true;
              set_cp(opts.codepage = options.codepage || 1252);
            }
            if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
              if (cur_sheet === "")
                cur_sheet = "Sheet1";
              range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var fakebs8 = { pos: blob.l - length, name: cur_sheet };
              Directory[fakebs8.pos] = fakebs8;
              opts.snames.push(cur_sheet);
            } else
              cur_sheet = (Directory[s] || { name: "" }).name;
            if (val.dt == 32)
              out["!type"] = "chart";
            if (val.dt == 64)
              out["!type"] = "macro";
            merges = [];
            objects = [];
            opts.arrayf = arrayf = [];
            colinfo = [];
            rowinfo = [];
            seencol = false;
            wsprops = { Hidden: (Directory[s] || { hs: 0 }).hs, name: cur_sheet };
          }
          break;
        case 515:
        case 3:
        case 2:
          {
            if (out["!type"] == "chart") {
              if (options.dense ? (out[val.r] || [])[val.c] : out[encode_cell({ c: val.c, r: val.r })])
                ++val.c;
            }
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 5:
        case 517:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 638:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 189:
          {
            for (var j = val.c; j <= val.C; ++j) {
              var ixfe = val.rkrec[j - val.c][0];
              temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j - val.c][1], t: "n" };
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (val.val == "String") {
              last_formula = val;
              break;
            }
            temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
            temp_val.XF = XFs[temp_val.ixfe];
            if (options.cellFormula) {
              var _f = val.formula;
              if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                var _fe = encode_cell({ r: _fr, c: _fc });
                if (sharedf[_fe])
                  temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                else
                  temp_val.F = ((options.dense ? (out[_fr] || [])[_fc] : out[_fe]) || {}).F;
              } else
                temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
            }
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell(val.cell, temp_val, options);
            last_formula = val;
          }
          break;
        case 7:
        case 519:
          {
            if (last_formula) {
              last_formula.val = val;
              temp_val = make_cell(val, last_formula.cell.ixfe, "s");
              temp_val.XF = XFs[temp_val.ixfe];
              if (options.cellFormula) {
                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell(last_formula.cell, temp_val, options);
              last_formula = null;
            } else
              throw new Error("String record expects Formula");
          }
          break;
        case 33:
        case 545:
          {
            arrayf.push(val);
            var _arraystart = encode_cell(val[0].s);
            cc = options.dense ? (out[val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
            if (options.cellFormula && cc) {
              if (!last_formula)
                break;
              if (!_arraystart || !cc)
                break;
              cc.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
              cc.F = encode_range(val[0]);
            }
          }
          break;
        case 1212:
          {
            if (!options.cellFormula)
              break;
            if (last_cell) {
              if (!last_formula)
                break;
              sharedf[encode_cell(last_formula.cell)] = val[0];
              cc = options.dense ? (out[last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
              (cc || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
            }
          }
          break;
        case 253:
          temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
          if (sst[val.isst].h)
            temp_val.h = sst[val.isst].h;
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0)
            temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 513:
          if (options.sheetStubs) {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 190:
          if (options.sheetStubs) {
            for (var _j = val.c; _j <= val.C; ++_j) {
              var _ixfe = val.ixfe[_j - val.c];
              temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: _j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 214:
        case 516:
        case 4:
          temp_val = make_cell(val.val, val.ixfe, "s");
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0)
            temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 0:
        case 512:
          {
            if (file_depth === 1)
              range = val;
          }
          break;
        case 252:
          {
            sst = val;
          }
          break;
        case 1054:
          {
            if (opts.biff == 4) {
              BIFF2FmtTable[BIFF2Fmt++] = val[1];
              for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx)
                if (table_fmt[b4idx] == val[1])
                  break;
              if (b4idx >= 163)
                SSF_load(val[1], BIFF2Fmt + 163);
            } else
              SSF_load(val[1], val[0]);
          }
          break;
        case 30:
          {
            BIFF2FmtTable[BIFF2Fmt++] = val;
            for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx)
              if (table_fmt[b2idx] == val)
                break;
            if (b2idx >= 163)
              SSF_load(val, BIFF2Fmt + 163);
          }
          break;
        case 229:
          merges = merges.concat(val);
          break;
        case 93:
          objects[val.cmo[0]] = opts.lastobj = val;
          break;
        case 438:
          opts.lastobj.TxO = val;
          break;
        case 127:
          opts.lastobj.ImData = val;
          break;
        case 440:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc)
                  cc.l = val[1];
              }
          }
          break;
        case 2048:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc && cc.l)
                  cc.l.Tooltip = val[1];
              }
          }
          break;
        case 28:
          {
            if (opts.biff <= 5 && opts.biff >= 2)
              break;
            cc = options.dense ? (out[val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
            var noteobj = objects[val[2]];
            if (!cc) {
              if (options.dense) {
                if (!out[val[0].r])
                  out[val[0].r] = [];
                cc = out[val[0].r][val[0].c] = { t: "z" };
              } else {
                cc = out[encode_cell(val[0])] = { t: "z" };
              }
              range.e.r = Math.max(range.e.r, val[0].r);
              range.s.r = Math.min(range.s.r, val[0].r);
              range.e.c = Math.max(range.e.c, val[0].c);
              range.s.c = Math.min(range.s.c, val[0].c);
            }
            if (!cc.c)
              cc.c = [];
            cmnt = { a: val[1], t: noteobj.TxO.t };
            cc.c.push(cmnt);
          }
          break;
        case 2173:
          update_xfext(XFs[val.ixfe], val.ext);
          break;
        case 125:
          {
            if (!opts.cellStyles)
              break;
            while (val.e >= val.s) {
              colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
              if (!seencol) {
                seencol = true;
                find_mdw_colw(val.w / 256);
              }
              process_col(colinfo[val.e + 1]);
            }
          }
          break;
        case 520:
          {
            var rowobj = {};
            if (val.level != null) {
              rowinfo[val.r] = rowobj;
              rowobj.level = val.level;
            }
            if (val.hidden) {
              rowinfo[val.r] = rowobj;
              rowobj.hidden = true;
            }
            if (val.hpt) {
              rowinfo[val.r] = rowobj;
              rowobj.hpt = val.hpt;
              rowobj.hpx = pt2px(val.hpt);
            }
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          if (!out["!margins"])
            default_margins(out["!margins"] = {});
          out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
          break;
        case 161:
          if (!out["!margins"])
            default_margins(out["!margins"] = {});
          out["!margins"].header = val.header;
          out["!margins"].footer = val.footer;
          break;
        case 574:
          if (val.RTL)
            Workbook.Views[0].RTL = true;
          break;
        case 146:
          palette = val;
          break;
        case 2198:
          themes = val;
          break;
        case 140:
          country = val;
          break;
        case 442:
          {
            if (!cur_sheet)
              Workbook.WBProps.CodeName = val || "ThisWorkbook";
            else
              wsprops.CodeName = val || wsprops.name;
          }
          break;
      }
    } else {
      if (!R)
        console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
      blob.l += length;
    }
  }
  wb.SheetNames = keys(Directory).sort(function(a, b) {
    return Number(a) - Number(b);
  }).map(function(x) {
    return Directory[x].name;
  });
  if (!options.bookSheets)
    wb.Sheets = Sheets;
  if (!wb.SheetNames.length && Preamble["!ref"]) {
    wb.SheetNames.push("Sheet1");
    if (wb.Sheets)
      wb.Sheets["Sheet1"] = Preamble;
  } else
    wb.Preamble = Preamble;
  if (wb.Sheets)
    FilterDatabases.forEach(function(r, i) {
      wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r;
    });
  wb.Strings = sst;
  wb.SSF = dup(table_fmt);
  if (opts.enc)
    wb.Encryption = opts.enc;
  if (themes)
    wb.Themes = themes;
  wb.Metadata = {};
  if (country !== void 0)
    wb.Metadata.Country = country;
  if (supbooks.names.length > 0)
    Workbook.Names = supbooks.names;
  wb.Workbook = Workbook;
  return wb;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(cfb, props, o) {
  var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
  if (DSI && DSI.size > 0)
    try {
      var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
      for (var d in DocSummary)
        props[d] = DocSummary[d];
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  var SI = CFB.find(cfb, "/!SummaryInformation");
  if (SI && SI.size > 0)
    try {
      var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
      for (var s in Summary)
        if (props[s] == null)
          props[s] = Summary[s];
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  if (props.HeadingPairs && props.TitlesOfParts) {
    load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
    delete props.HeadingPairs;
    delete props.TitlesOfParts;
  }
}
function write_xls_props(wb, cfb) {
  var DSEntries = [], SEntries = [], CEntries = [];
  var i = 0, Keys;
  var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
  var SummaryRE = evert_key(SummaryPIDSI, "n");
  if (wb.Props) {
    Keys = keys(wb.Props);
    for (i = 0; i < Keys.length; ++i)
      (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
  }
  if (wb.Custprops) {
    Keys = keys(wb.Custprops);
    for (i = 0; i < Keys.length; ++i)
      if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i]))
        (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
  }
  var CEntries2 = [];
  for (i = 0; i < CEntries.length; ++i) {
    if (XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1)
      continue;
    if (CEntries[i][1] == null)
      continue;
    CEntries2.push(CEntries[i]);
  }
  if (SEntries.length)
    CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
  if (DSEntries.length || CEntries2.length)
    CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
}
function parse_xlscfb(cfb, options) {
  if (!options)
    options = {};
  fix_read_opts(options);
  reset_cp();
  if (options.codepage)
    set_ansi(options.codepage);
  var CompObj, WB;
  if (cfb.FullPaths) {
    if (CFB.find(cfb, "/encryption"))
      throw new Error("File is password-protected");
    CompObj = CFB.find(cfb, "!CompObj");
    WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
  } else {
    switch (options.type) {
      case "base64":
        cfb = s2a(Base64_decode(cfb));
        break;
      case "binary":
        cfb = s2a(cfb);
        break;
      case "buffer":
        break;
      case "array":
        if (!Array.isArray(cfb))
          cfb = Array.prototype.slice.call(cfb);
        break;
    }
    prep_blob(cfb, 0);
    WB = { content: cfb };
  }
  var WorkbookP;
  var _data;
  if (CompObj)
    parse_compobj(CompObj);
  if (options.bookProps && !options.bookSheets)
    WorkbookP = {};
  else {
    var T = has_buf ? "buffer" : "array";
    if (WB && WB.content)
      WorkbookP = parse_workbook(WB.content, options);
    else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content)
      WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
    else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content)
      WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
    else if ((_data = CFB.find(cfb, "MN0")) && _data.content)
      throw new Error("Unsupported Works 4 for Mac file");
    else
      throw new Error("Cannot find Workbook stream");
    if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir"))
      WorkbookP.vbaraw = make_vba_xls(cfb);
  }
  var props = {};
  if (cfb.FullPaths)
    parse_xls_props(
      /*::((*/
      cfb,
      props,
      options
    );
  WorkbookP.Props = WorkbookP.Custprops = props;
  if (options.bookFiles)
    WorkbookP.cfb = cfb;
  return WorkbookP;
}
function write_xlscfb(wb, opts) {
  var o = opts || {};
  var cfb = CFB.utils.cfb_new({ root: "R" });
  var wbpath = "/Workbook";
  switch (o.bookType || "xls") {
    case "xls":
      o.bookType = "biff8";
    case "xla":
      if (!o.bookType)
        o.bookType = "xla";
    case "biff8":
      wbpath = "/Workbook";
      o.biff = 8;
      break;
    case "biff5":
      wbpath = "/Book";
      o.biff = 5;
      break;
    default:
      throw new Error("invalid type " + o.bookType + " for XLS CFB");
  }
  CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
  if (o.biff == 8 && (wb.Props || wb.Custprops))
    write_xls_props(wb, cfb);
  if (o.biff == 8 && wb.vbaraw)
    fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
  return cfb;
}
var XLSBRecordEnum = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
var XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: parse_String
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /*::[*/
  29282: {}
};
function write_biff_rec(ba, type, payload, length) {
  var t2 = type;
  if (isNaN(t2))
    return;
  var len = length || (payload || []).length || 0;
  var o = ba.next(4);
  o.write_shift(2, t2);
  o.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  )
    ba.push(payload);
}
function write_biff_continue(ba, type, payload, length) {
  var len = length || (payload || []).length || 0;
  if (len <= 8224)
    return write_biff_rec(ba, type, payload, len);
  var t2 = type;
  if (isNaN(t2))
    return;
  var parts = payload.parts || [], sidx = 0;
  var i = 0, w = 0;
  while (w + (parts[sidx] || 8224) <= 8224) {
    w += parts[sidx] || 8224;
    sidx++;
  }
  var o = ba.next(4);
  o.write_shift(2, t2);
  o.write_shift(2, w);
  ba.push(payload.slice(i, i + w));
  i += w;
  while (i < len) {
    o = ba.next(4);
    o.write_shift(2, 60);
    w = 0;
    while (w + (parts[sidx] || 8224) <= 8224) {
      w += parts[sidx] || 8224;
      sidx++;
    }
    o.write_shift(2, w);
    ba.push(payload.slice(i, i + w));
    i += w;
  }
}
function write_BIFF2Cell(out, r, c) {
  if (!out)
    out = new_buf(7);
  out.write_shift(2, r);
  out.write_shift(2, c);
  out.write_shift(2, 0);
  out.write_shift(1, 0);
  return out;
}
function write_BIFF2BERR(r, c, val, t2) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c);
  write_Bes(val, t2 || "b", out);
  return out;
}
function write_BIFF2LABEL(r, c, val) {
  var out = new_buf(8 + 2 * val.length);
  write_BIFF2Cell(out, r, c);
  out.write_shift(1, val.length);
  out.write_shift(val.length, val, "sbcs");
  return out.l < out.length ? out.slice(0, out.l) : out;
}
function write_ws_biff2_cell(ba, cell, R, C) {
  if (cell.v != null)
    switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        if (v == (v | 0) && v >= 0 && v < 65536)
          write_biff_rec(ba, 2, write_BIFF2INT(R, C, v));
        else
          write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v));
        return;
      case "b":
      case "e":
        write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
        return;
      case "s":
      case "str":
        write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, (cell.v || "").slice(0, 255)));
        return;
    }
  write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
}
function write_ws_biff2(ba, ws, idx, opts) {
  var dense = Array.isArray(ws);
  var range = safe_decode_range(ws["!ref"] || "A1"), ref2, rr = "", cols = [];
  if (range.e.c > 255 || range.e.r > 16383) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, 16383);
    ref2 = encode_range(range);
  }
  for (var R = range.s.r; R <= range.e.r; ++R) {
    rr = encode_row(R);
    for (var C = range.s.c; C <= range.e.c; ++C) {
      if (R === range.s.r)
        cols[C] = encode_col(C);
      ref2 = cols[C] + rr;
      var cell = dense ? (ws[R] || [])[C] : ws[ref2];
      if (!cell)
        continue;
      write_ws_biff2_cell(ba, cell, R, C);
    }
  }
}
function write_biff2_buf(wb, opts) {
  var o = opts || {};
  var ba = buf_array();
  var idx = 0;
  for (var i = 0; i < wb.SheetNames.length; ++i)
    if (wb.SheetNames[i] == o.sheet)
      idx = i;
  if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet)
    throw new Error("Sheet not found: " + o.sheet);
  write_biff_rec(ba, o.biff == 4 ? 1033 : o.biff == 3 ? 521 : 9, write_BOF(wb, 16, o));
  write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o);
  write_biff_rec(ba, 10);
  return ba.end();
}
function write_FONTS_biff8(ba, data, opts) {
  write_biff_rec(ba, 49, write_Font({
    sz: 12,
    color: { theme: 1 },
    name: "Arial",
    family: 2,
    scheme: "minor"
  }, opts));
}
function write_FMTS_biff8(ba, NF, opts) {
  if (!NF)
    return;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        write_biff_rec(ba, 1054, write_Format(i, NF[i], opts));
  });
}
function write_FEAT(ba, ws) {
  var o = new_buf(19);
  o.write_shift(4, 2151);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 3);
  o.write_shift(1, 1);
  o.write_shift(4, 0);
  write_biff_rec(ba, 2151, o);
  o = new_buf(39);
  o.write_shift(4, 2152);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 3);
  o.write_shift(1, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 1);
  o.write_shift(4, 4);
  o.write_shift(2, 0);
  write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
  o.write_shift(4, 4);
  write_biff_rec(ba, 2152, o);
}
function write_CELLXFS_biff8(ba, opts) {
  for (var i = 0; i < 16; ++i)
    write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
  opts.cellXfs.forEach(function(c) {
    write_biff_rec(ba, 224, write_XF(c, 0, opts));
  });
}
function write_ws_biff8_hlinks(ba, ws) {
  for (var R = 0; R < ws["!links"].length; ++R) {
    var HL = ws["!links"][R];
    write_biff_rec(ba, 440, write_HLink(HL));
    if (HL[1].Tooltip)
      write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
  }
  delete ws["!links"];
}
function write_ws_cols_biff8(ba, cols) {
  if (!cols)
    return;
  var cnt = 0;
  cols.forEach(function(col, idx) {
    if (++cnt <= 256 && col) {
      write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
    }
  });
}
function write_ws_biff8_cell(ba, cell, R, C, opts) {
  var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
  if (cell.v == null && !cell.bf) {
    write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    return;
  }
  if (cell.bf)
    write_biff_rec(ba, 6, write_Formula(cell, R, C, opts, os));
  else
    switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        write_biff_rec(ba, 515, write_Number(R, C, v, os));
        break;
      case "b":
      case "e":
        write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
        break;
      case "s":
      case "str":
        if (opts.bookSST) {
          var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
          write_biff_rec(ba, 253, write_LabelSst(R, C, isst, os));
        } else
          write_biff_rec(ba, 516, write_Label(R, C, (cell.v || "").slice(0, 255), os, opts));
        break;
      default:
        write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    }
}
function write_ws_biff8(idx, opts, wb) {
  var ba = buf_array();
  var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  var _WB = (wb || {}).Workbook || {};
  var _sheet = (_WB.Sheets || [])[idx] || {};
  var dense = Array.isArray(ws);
  var b8 = opts.biff == 8;
  var ref2, rr = "", cols = [];
  var range = safe_decode_range(ws["!ref"] || "A1");
  var MAX_ROWS = b8 ? 65536 : 16384;
  if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
  }
  write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
  write_biff_rec(ba, 13, writeuint16(1));
  write_biff_rec(ba, 12, writeuint16(100));
  write_biff_rec(ba, 15, writebool(true));
  write_biff_rec(ba, 17, writebool(false));
  write_biff_rec(ba, 16, write_Xnum(1e-3));
  write_biff_rec(ba, 95, writebool(true));
  write_biff_rec(ba, 42, writebool(false));
  write_biff_rec(ba, 43, writebool(false));
  write_biff_rec(ba, 130, writeuint16(1));
  write_biff_rec(ba, 128, write_Guts([0, 0]));
  write_biff_rec(ba, 131, writebool(false));
  write_biff_rec(ba, 132, writebool(false));
  if (b8)
    write_ws_cols_biff8(ba, ws["!cols"]);
  write_biff_rec(ba, 512, write_Dimensions(range, opts));
  if (b8)
    ws["!links"] = [];
  for (var R = range.s.r; R <= range.e.r; ++R) {
    rr = encode_row(R);
    for (var C = range.s.c; C <= range.e.c; ++C) {
      if (R === range.s.r)
        cols[C] = encode_col(C);
      ref2 = cols[C] + rr;
      var cell = dense ? (ws[R] || [])[C] : ws[ref2];
      if (!cell)
        continue;
      write_ws_biff8_cell(ba, cell, R, C, opts);
      if (b8 && cell.l)
        ws["!links"].push([ref2, cell.l]);
    }
  }
  var cname = _sheet.CodeName || _sheet.name || s;
  if (b8)
    write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
  if (b8 && (ws["!merges"] || []).length)
    write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
  if (b8)
    write_ws_biff8_hlinks(ba, ws);
  write_biff_rec(ba, 442, write_XLUnicodeString(cname));
  if (b8)
    write_FEAT(ba, ws);
  write_biff_rec(
    ba,
    10
    /* EOF */
  );
  return ba.end();
}
function write_biff8_global(wb, bufs, opts) {
  var A = buf_array();
  var _WB = (wb || {}).Workbook || {};
  var _sheets = _WB.Sheets || [];
  var _wb = (
    /*::((*/
    _WB.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  );
  var b8 = opts.biff == 8, b5 = opts.biff == 5;
  write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
  if (opts.bookType == "xla")
    write_biff_rec(
      A,
      135
      /* Addin */
    );
  write_biff_rec(A, 225, b8 ? writeuint16(1200) : null);
  write_biff_rec(A, 193, writezeroes(2));
  if (b5)
    write_biff_rec(
      A,
      191
      /* ToolbarHdr */
    );
  if (b5)
    write_biff_rec(
      A,
      192
      /* ToolbarEnd */
    );
  write_biff_rec(
    A,
    226
    /* InterfaceEnd */
  );
  write_biff_rec(A, 92, write_WriteAccess("SheetJS", opts));
  write_biff_rec(A, 66, writeuint16(b8 ? 1200 : 1252));
  if (b8)
    write_biff_rec(A, 353, writeuint16(0));
  if (b8)
    write_biff_rec(
      A,
      448
      /* Excel9File */
    );
  write_biff_rec(A, 317, write_RRTabId(wb.SheetNames.length));
  if (b8 && wb.vbaraw)
    write_biff_rec(
      A,
      211
      /* ObProj */
    );
  if (b8 && wb.vbaraw) {
    var cname = _wb.CodeName || "ThisWorkbook";
    write_biff_rec(A, 442, write_XLUnicodeString(cname));
  }
  write_biff_rec(A, 156, writeuint16(17));
  write_biff_rec(A, 25, writebool(false));
  write_biff_rec(A, 18, writebool(false));
  write_biff_rec(A, 19, writeuint16(0));
  if (b8)
    write_biff_rec(A, 431, writebool(false));
  if (b8)
    write_biff_rec(A, 444, writeuint16(0));
  write_biff_rec(A, 61, write_Window1());
  write_biff_rec(A, 64, writebool(false));
  write_biff_rec(A, 141, writeuint16(0));
  write_biff_rec(A, 34, writebool(safe1904(wb) == "true"));
  write_biff_rec(A, 14, writebool(true));
  if (b8)
    write_biff_rec(A, 439, writebool(false));
  write_biff_rec(A, 218, writeuint16(0));
  write_FONTS_biff8(A, wb, opts);
  write_FMTS_biff8(A, wb.SSF, opts);
  write_CELLXFS_biff8(A, opts);
  if (b8)
    write_biff_rec(A, 352, writebool(false));
  var a = A.end();
  var C = buf_array();
  if (b8)
    write_biff_rec(C, 140, write_Country());
  if (b8 && opts.Strings)
    write_biff_continue(C, 252, write_SST(opts.Strings));
  write_biff_rec(
    C,
    10
    /* EOF */
  );
  var c = C.end();
  var B = buf_array();
  var blen = 0, j = 0;
  for (j = 0; j < wb.SheetNames.length; ++j)
    blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
  var start = a.length + blen + c.length;
  for (j = 0; j < wb.SheetNames.length; ++j) {
    var _sheet = _sheets[j] || {};
    write_biff_rec(B, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j] }, opts));
    start += bufs[j].length;
  }
  var b = B.end();
  if (blen != b.length)
    throw new Error("BS8 " + blen + " != " + b.length);
  var out = [];
  if (a.length)
    out.push(a);
  if (b.length)
    out.push(b);
  if (c.length)
    out.push(c);
  return bconcat(out);
}
function write_biff8_buf(wb, opts) {
  var o = opts || {};
  var bufs = [];
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    o.revssf = evert_num(wb.SSF);
    o.revssf[wb.SSF[65535]] = 0;
    o.ssf = wb.SSF;
  }
  o.Strings = /*::((*/
  [];
  o.Strings.Count = 0;
  o.Strings.Unique = 0;
  fix_write_opts(o);
  o.cellXfs = [];
  get_cell_style(o.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  for (var i = 0; i < wb.SheetNames.length; ++i)
    bufs[bufs.length] = write_ws_biff8(i, o, wb);
  bufs.unshift(write_biff8_global(wb, bufs, o));
  return bconcat(bufs);
}
function write_biff_buf(wb, opts) {
  for (var i = 0; i <= wb.SheetNames.length; ++i) {
    var ws = wb.Sheets[wb.SheetNames[i]];
    if (!ws || !ws["!ref"])
      continue;
    var range = decode_range(ws["!ref"]);
    if (range.e.c > 255) {
      if (typeof console != "undefined" && console.error)
        console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var o = opts || {};
  switch (o.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(wb, opts);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(wb, opts);
  }
  throw new Error("invalid type " + o.bookType + " for BIFF");
}
function html_to_sheet(str, _opts) {
  var opts = _opts || {};
  var ws = opts.dense ? [] : {};
  str = str.replace(/<!--.*?-->/g, "");
  var mtch = str.match(/<table/i);
  if (!mtch)
    throw new Error("Invalid HTML: could not find <table>");
  var mtch2 = str.match(/<\/table/i);
  var i = mtch.index, j = mtch2 && mtch2.index || str.length;
  var rows = split_regex(str.slice(i, j), /(:?<tr[^>]*>)/i, "<tr>");
  var R = -1, C = 0, RS = 0, CS = 0;
  var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
  var merges = [];
  for (i = 0; i < rows.length; ++i) {
    var row = rows[i].trim();
    var hd = row.slice(0, 3).toLowerCase();
    if (hd == "<tr") {
      ++R;
      if (opts.sheetRows && opts.sheetRows <= R) {
        --R;
        break;
      }
      C = 0;
      continue;
    }
    if (hd != "<td" && hd != "<th")
      continue;
    var cells = row.split(/<\/t[dh]>/i);
    for (j = 0; j < cells.length; ++j) {
      var cell = cells[j].trim();
      if (!cell.match(/<t[dh]/i))
        continue;
      var m = cell, cc = 0;
      while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1)
        m = m.slice(cc + 1);
      for (var midx = 0; midx < merges.length; ++midx) {
        var _merge = merges[midx];
        if (_merge.s.c == C && _merge.s.r < R && R <= _merge.e.r) {
          C = _merge.e.c + 1;
          midx = -1;
        }
      }
      var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
      CS = tag.colspan ? +tag.colspan : 1;
      if ((RS = +tag.rowspan) > 1 || CS > 1)
        merges.push({ s: { r: R, c: C }, e: { r: R + (RS || 1) - 1, c: C + CS - 1 } });
      var _t = tag.t || tag["data-t"] || "";
      if (!m.length) {
        C += CS;
        continue;
      }
      m = htmldecode(m);
      if (range.s.r > R)
        range.s.r = R;
      if (range.e.r < R)
        range.e.r = R;
      if (range.s.c > C)
        range.s.c = C;
      if (range.e.c < C)
        range.e.c = C;
      if (!m.length) {
        C += CS;
        continue;
      }
      var o = { t: "s", v: m };
      if (opts.raw || !m.trim().length || _t == "s")
        ;
      else if (m === "TRUE")
        o = { t: "b", v: true };
      else if (m === "FALSE")
        o = { t: "b", v: false };
      else if (!isNaN(fuzzynum(m)))
        o = { t: "n", v: fuzzynum(m) };
      else if (!isNaN(fuzzydate(m).getDate())) {
        o = { t: "d", v: parseDate(m) };
        if (!opts.cellDates)
          o = { t: "n", v: datenum(o.v) };
        o.z = opts.dateNF || table_fmt[14];
      }
      if (opts.dense) {
        if (!ws[R])
          ws[R] = [];
        ws[R][C] = o;
      } else
        ws[encode_cell({ r: R, c: C })] = o;
      C += CS;
    }
  }
  ws["!ref"] = encode_range(range);
  if (merges.length)
    ws["!merges"] = merges;
  return ws;
}
function make_html_row(ws, r, R, o) {
  var M = ws["!merges"] || [];
  var oo = [];
  for (var C = r.s.c; C <= r.e.c; ++C) {
    var RS = 0, CS = 0;
    for (var j = 0; j < M.length; ++j) {
      if (M[j].s.r > R || M[j].s.c > C)
        continue;
      if (M[j].e.r < R || M[j].e.c < C)
        continue;
      if (M[j].s.r < R || M[j].s.c < C) {
        RS = -1;
        break;
      }
      RS = M[j].e.r - M[j].s.r + 1;
      CS = M[j].e.c - M[j].s.c + 1;
      break;
    }
    if (RS < 0)
      continue;
    var coord = encode_cell({ r: R, c: C });
    var cell = o.dense ? (ws[R] || [])[C] : ws[coord];
    var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
    var sp = {};
    if (RS > 1)
      sp.rowspan = RS;
    if (CS > 1)
      sp.colspan = CS;
    if (o.editable)
      w = '<span contenteditable="true">' + w + "</span>";
    else if (cell) {
      sp["data-t"] = cell && cell.t || "z";
      if (cell.v != null)
        sp["data-v"] = cell.v;
      if (cell.z != null)
        sp["data-z"] = cell.z;
      if (cell.l && (cell.l.Target || "#").charAt(0) != "#")
        w = '<a href="' + cell.l.Target + '">' + w + "</a>";
    }
    sp.id = (o.id || "sjs") + "-" + coord;
    oo.push(writextag("td", w, sp));
  }
  var preamble = "<tr>";
  return preamble + oo.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var HTML_END = "</body></html>";
function html_to_workbook(str, opts) {
  var mtch = str.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!mtch || mtch.length == 0)
    throw new Error("Invalid HTML: could not find <table>");
  if (mtch.length == 1)
    return sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
  var wb = book_new();
  mtch.forEach(function(s, idx) {
    book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx + 1));
  });
  return wb;
}
function make_html_preamble(ws, R, o) {
  var out = [];
  return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
}
function sheet_to_html(ws, opts) {
  var o = opts || {};
  var header = o.header != null ? o.header : HTML_BEGIN;
  var footer = o.footer != null ? o.footer : HTML_END;
  var out = [header];
  var r = decode_range(ws["!ref"]);
  o.dense = Array.isArray(ws);
  out.push(make_html_preamble(ws, r, o));
  for (var R = r.s.r; R <= r.e.r; ++R)
    out.push(make_html_row(ws, r, R, o));
  out.push("</table>" + footer);
  return out.join("");
}
function parse_text_p(text) {
  var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
    return Array(parseInt($1, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
  var v = unescapexml(fixed.replace(/<[^>]*>/g, ""));
  return [v];
}
var number_formats_ods = {
  /* ods name: [short ssf fmt, long ssf fmt] */
  day: ["d", "dd"],
  month: ["m", "mm"],
  year: ["y", "yy"],
  hours: ["h", "hh"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  "am-pm": ["A/P", "AM/PM"],
  "day-of-week": ["ddd", "dddd"],
  era: ["e", "ee"],
  /* there is no native representation of LO "Q" format */
  quarter: ["\\Qm", 'm\\"th quarter"']
};
function parse_content_xml(d, _opts) {
  var opts = _opts || {};
  var str = xlml_normalize(d);
  var state = [], tmp;
  var tag;
  var NFtag = { name: "" }, NF = "", pidx = 0;
  var sheetag;
  var rowtag;
  var Sheets = {}, SheetNames = [];
  var ws = opts.dense ? [] : {};
  var Rn, q;
  var ctag = { value: "" };
  var textp = "", textpidx = 0;
  var textR = [];
  var R = -1, C = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
  var row_ol = 0;
  var number_format_map = {};
  var merges = [], mrange = {}, mR = 0, mC = 0;
  var rowinfo = [], rowpeat = 1, colpeat = 1;
  var arrayf = [];
  var WB = { Names: [] };
  var atag = {};
  var _Ref = ["", ""];
  var comments = [], comment = {};
  var creator = "", creatoridx = 0;
  var isstub = false, intable = false;
  var i = 0;
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
      case "table":
      case "":
        if (Rn[1] === "/") {
          if (range.e.c >= range.s.c && range.e.r >= range.s.r)
            ws["!ref"] = encode_range(range);
          else
            ws["!ref"] = "A1:A1";
          if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
            ws["!fullref"] = ws["!ref"];
            range.e.r = opts.sheetRows - 1;
            ws["!ref"] = encode_range(range);
          }
          if (merges.length)
            ws["!merges"] = merges;
          if (rowinfo.length)
            ws["!rows"] = rowinfo;
          sheetag.name = sheetag[""] || sheetag.name;
          if (typeof JSON !== "undefined")
            JSON.stringify(sheetag);
          SheetNames.push(sheetag.name);
          Sheets[sheetag.name] = ws;
          intable = false;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          sheetag = parsexmltag(Rn[0], false);
          R = C = -1;
          range.s.r = range.s.c = 1e7;
          range.e.r = range.e.c = 0;
          ws = opts.dense ? [] : {};
          merges = [];
          rowinfo = [];
          intable = true;
        }
        break;
      case "table-row-group":
        if (Rn[1] === "/")
          --row_ol;
        else
          ++row_ol;
        break;
      case "table-row":
      case "":
        if (Rn[1] === "/") {
          R += rowpeat;
          rowpeat = 1;
          break;
        }
        rowtag = parsexmltag(Rn[0], false);
        if (rowtag[""])
          R = rowtag[""] - 1;
        else if (R == -1)
          R = 0;
        rowpeat = +rowtag["number-rows-repeated"] || 1;
        if (rowpeat < 10) {
          for (i = 0; i < rowpeat; ++i)
            if (row_ol > 0)
              rowinfo[R + i] = { level: row_ol };
        }
        C = -1;
        break;
      case "covered-table-cell":
        if (Rn[1] !== "/")
          ++C;
        if (opts.sheetStubs) {
          if (opts.dense) {
            if (!ws[R])
              ws[R] = [];
            ws[R][C] = { t: "z" };
          } else
            ws[encode_cell({ r: R, c: C })] = { t: "z" };
        }
        textp = "";
        textR = [];
        break;
      case "table-cell":
      case "":
        if (Rn[0].charAt(Rn[0].length - 2) === "/") {
          ++C;
          ctag = parsexmltag(Rn[0], false);
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
          q = {
            t: "z",
            v: null
            /*:: , z:null, w:"",c:[]*/
          };
          if (ctag.formula && opts.cellFormula != false)
            q.f = ods_to_csf_formula(unescapexml(ctag.formula));
          if ((ctag[""] || ctag["value-type"]) == "string") {
            q.t = "s";
            q.v = unescapexml(ctag["string-value"] || "");
            if (opts.dense) {
              if (!ws[R])
                ws[R] = [];
              ws[R][C] = q;
            } else {
              ws[encode_cell({ r: R, c: C })] = q;
            }
          }
          C += colpeat - 1;
        } else if (Rn[1] !== "/") {
          ++C;
          textp = "";
          textpidx = 0;
          textR = [];
          colpeat = 1;
          var rptR = rowpeat ? R + rowpeat - 1 : R;
          if (C > range.e.c)
            range.e.c = C;
          if (C < range.s.c)
            range.s.c = C;
          if (R < range.s.r)
            range.s.r = R;
          if (rptR > range.e.r)
            range.e.r = rptR;
          ctag = parsexmltag(Rn[0], false);
          comments = [];
          comment = {};
          q = {
            t: ctag[""] || ctag["value-type"],
            v: null
            /*:: , z:null, w:"",c:[]*/
          };
          if (opts.cellFormula) {
            if (ctag.formula)
              ctag.formula = unescapexml(ctag.formula);
            if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
              mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
              mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
              mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
              q.F = encode_range(mrange);
              arrayf.push([mrange, q.F]);
            }
            if (ctag.formula)
              q.f = ods_to_csf_formula(ctag.formula);
            else
              for (i = 0; i < arrayf.length; ++i)
                if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) {
                  if (C >= arrayf[i][0].s.c && C <= arrayf[i][0].e.c)
                    q.F = arrayf[i][1];
                }
          }
          if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
            mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
            mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
            mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
            merges.push(mrange);
          }
          if (ctag["number-columns-repeated"])
            colpeat = parseInt(ctag["number-columns-repeated"], 10);
          switch (q.t) {
            case "boolean":
              q.t = "b";
              q.v = parsexmlbool(ctag["boolean-value"]);
              break;
            case "float":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "percentage":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "currency":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "date":
              q.t = "d";
              q.v = parseDate(ctag["date-value"]);
              if (!opts.cellDates) {
                q.t = "n";
                q.v = datenum(q.v);
              }
              q.z = "m/d/yy";
              break;
            case "time":
              q.t = "n";
              q.v = parse_isodur(ctag["time-value"]) / 86400;
              if (opts.cellDates) {
                q.t = "d";
                q.v = numdate(q.v);
              }
              q.z = "HH:MM:SS";
              break;
            case "number":
              q.t = "n";
              q.v = parseFloat(ctag[""]);
              break;
            default:
              if (q.t === "string" || q.t === "text" || !q.t) {
                q.t = "s";
                if (ctag["string-value"] != null) {
                  textp = unescapexml(ctag["string-value"]);
                  textR = [];
                }
              } else
                throw new Error("Unsupported value type " + q.t);
          }
        } else {
          isstub = false;
          if (q.t === "s") {
            q.v = textp || "";
            if (textR.length)
              q.R = textR;
            isstub = textpidx == 0;
          }
          if (atag.Target)
            q.l = atag;
          if (comments.length > 0) {
            q.c = comments;
            comments = [];
          }
          if (textp && opts.cellText !== false)
            q.w = textp;
          if (isstub) {
            q.t = "z";
            delete q.v;
          }
          if (!isstub || opts.sheetStubs) {
            if (!(opts.sheetRows && opts.sheetRows <= R)) {
              for (var rpt = 0; rpt < rowpeat; ++rpt) {
                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                if (opts.dense) {
                  if (!ws[R + rpt])
                    ws[R + rpt] = [];
                  ws[R + rpt][C] = rpt == 0 ? q : dup(q);
                  while (--colpeat > 0)
                    ws[R + rpt][C + colpeat] = dup(q);
                } else {
                  ws[encode_cell({ r: R + rpt, c: C })] = q;
                  while (--colpeat > 0)
                    ws[encode_cell({ r: R + rpt, c: C + colpeat })] = dup(q);
                }
                if (range.e.c <= C)
                  range.e.c = C;
              }
            }
          }
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
          C += colpeat - 1;
          colpeat = 0;
          q = {
            /*:: t:"", v:null, z:null, w:"",c:[]*/
          };
          textp = "";
          textR = [];
        }
        atag = {};
        break;
      case "document":
      case "document-content":
      case "":
      case "spreadsheet":
      case "":
      case "scripts":
      case "styles":
      case "font-face-decls":
      case "master-styles":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], true]);
        break;
      case "annotation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
          comment.t = textp;
          if (textR.length)
            comment.R = textR;
          comment.a = creator;
          comments.push(comment);
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          state.push([Rn[3], false]);
        }
        creator = "";
        creatoridx = 0;
        textp = "";
        textpidx = 0;
        textR = [];
        break;
      case "creator":
        if (Rn[1] === "/") {
          creator = str.slice(creatoridx, Rn.index);
        } else
          creatoridx = Rn.index + Rn[0].length;
        break;
      case "meta":
      case "":
      case "settings":
      case "config-item-set":
      case "config-item-map-indexed":
      case "config-item-map-entry":
      case "config-item-map-named":
      case "shapes":
      case "frame":
      case "text-box":
      case "image":
      case "data-pilot-tables":
      case "list-style":
      case "form":
      case "dde-links":
      case "event-listeners":
      case "chart":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], false]);
        textp = "";
        textpidx = 0;
        textR = [];
        break;
      case "scientific-number":
        break;
      case "currency-symbol":
        break;
      case "currency-style":
        break;
      case "number-style":
      case "percentage-style":
      case "date-style":
      case "time-style":
        if (Rn[1] === "/") {
          number_format_map[NFtag.name] = NF;
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          NF = "";
          NFtag = parsexmltag(Rn[0], false);
          state.push([Rn[3], true]);
        }
        break;
      case "script":
        break;
      case "libraries":
        break;
      case "automatic-styles":
        break;
      case "default-style":
      case "page-layout":
        break;
      case "style":
        break;
      case "map":
        break;
      case "font-face":
        break;
      case "paragraph-properties":
        break;
      case "table-properties":
        break;
      case "table-column-properties":
        break;
      case "table-row-properties":
        break;
      case "table-cell-properties":
        break;
      case "number":
        switch (state[state.length - 1][0]) {
          case "time-style":
          case "date-style":
            tag = parsexmltag(Rn[0], false);
            NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
            break;
        }
        break;
      case "fraction":
        break;
      case "day":
      case "month":
      case "year":
      case "era":
      case "day-of-week":
      case "week-of-year":
      case "quarter":
      case "hours":
      case "minutes":
      case "seconds":
      case "am-pm":
        switch (state[state.length - 1][0]) {
          case "time-style":
          case "date-style":
            tag = parsexmltag(Rn[0], false);
            NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
            break;
        }
        break;
      case "boolean-style":
        break;
      case "boolean":
        break;
      case "text-style":
        break;
      case "text":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          switch (state[state.length - 1][0]) {
            case "number-style":
            case "date-style":
            case "time-style":
              NF += str.slice(pidx, Rn.index);
              break;
          }
        else
          pidx = Rn.index + Rn[0].length;
        break;
      case "named-range":
        tag = parsexmltag(Rn[0], false);
        _Ref = ods_to_csf_3D(tag["cell-range-address"]);
        var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
        if (intable)
          nrange.Sheet = SheetNames.length;
        WB.Names.push(nrange);
        break;
      case "text-content":
        break;
      case "text-properties":
        break;
      case "embedded-text":
        break;
      case "body":
      case "":
        break;
      case "forms":
        break;
      case "table-column":
        break;
      case "table-header-rows":
        break;
      case "table-rows":
        break;
      case "table-column-group":
        break;
      case "table-header-columns":
        break;
      case "table-columns":
        break;
      case "null-date":
        break;
      case "graphic-properties":
        break;
      case "calculation-settings":
        break;
      case "named-expressions":
        break;
      case "label-range":
        break;
      case "label-ranges":
        break;
      case "named-expression":
        break;
      case "sort":
        break;
      case "sort-by":
        break;
      case "sort-groups":
        break;
      case "tab":
        break;
      case "line-break":
        break;
      case "span":
        break;
      case "p":
      case "":
        if (["master-styles"].indexOf(state[state.length - 1][0]) > -1)
          break;
        if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
          var ptp = parse_text_p(str.slice(textpidx, Rn.index));
          textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
        } else {
          parsexmltag(Rn[0], false);
          textpidx = Rn.index + Rn[0].length;
        }
        break;
      case "s":
        break;
      case "database-range":
        if (Rn[1] === "/")
          break;
        try {
          _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
          Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
        } catch (e) {
        }
        break;
      case "date":
        break;
      case "object":
        break;
      case "title":
      case "":
        break;
      case "desc":
        break;
      case "binary-data":
        break;
      case "table-source":
        break;
      case "scenario":
        break;
      case "iteration":
        break;
      case "content-validations":
        break;
      case "content-validation":
        break;
      case "help-message":
        break;
      case "error-message":
        break;
      case "database-ranges":
        break;
      case "filter":
        break;
      case "filter-and":
        break;
      case "filter-or":
        break;
      case "filter-condition":
        break;
      case "list-level-style-bullet":
        break;
      case "list-level-style-number":
        break;
      case "list-level-properties":
        break;
      case "sender-firstname":
      case "sender-lastname":
      case "sender-initials":
      case "sender-title":
      case "sender-position":
      case "sender-email":
      case "sender-phone-private":
      case "sender-fax":
      case "sender-company":
      case "sender-phone-work":
      case "sender-street":
      case "sender-city":
      case "sender-postal-code":
      case "sender-country":
      case "sender-state-or-province":
      case "author-name":
      case "author-initials":
      case "chapter":
      case "file-name":
      case "template-name":
      case "sheet-name":
        break;
      case "event-listener":
        break;
      case "initial-creator":
      case "creation-date":
      case "print-date":
      case "generator":
      case "document-statistic":
      case "user-defined":
      case "editing-duration":
      case "editing-cycles":
        break;
      case "config-item":
        break;
      case "page-number":
        break;
      case "page-count":
        break;
      case "time":
        break;
      case "cell-range-source":
        break;
      case "detective":
        break;
      case "operation":
        break;
      case "highlighted-range":
        break;
      case "data-pilot-table":
      case "source-cell-range":
      case "source-service":
      case "data-pilot-field":
      case "data-pilot-level":
      case "data-pilot-subtotals":
      case "data-pilot-subtotal":
      case "data-pilot-members":
      case "data-pilot-member":
      case "data-pilot-display-info":
      case "data-pilot-sort-info":
      case "data-pilot-layout-info":
      case "data-pilot-field-reference":
      case "data-pilot-groups":
      case "data-pilot-group":
      case "data-pilot-group-member":
        break;
      case "rect":
        break;
      case "dde-connection-decls":
      case "dde-connection-decl":
      case "dde-link":
      case "dde-source":
        break;
      case "properties":
        break;
      case "property":
        break;
      case "a":
        if (Rn[1] !== "/") {
          atag = parsexmltag(Rn[0], false);
          if (!atag.href)
            break;
          atag.Target = unescapexml(atag.href);
          delete atag.href;
          if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
            _Ref = ods_to_csf_3D(atag.Target.slice(1));
            atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
          } else if (atag.Target.match(/^\.\.[\\\/]/))
            atag.Target = atag.Target.slice(3);
        }
        break;
      case "table-protection":
        break;
      case "data-pilot-grand-total":
        break;
      case "office-document-common-attrs":
        break;
      default:
        switch (Rn[2]) {
          case "dc:":
          case "calcext:":
          case "loext:":
          case "ooo:":
          case "chartooo:":
          case "draw:":
          case "style:":
          case "chart:":
          case "form:":
          case "uof:":
          case ":":
          case ":":
            break;
          default:
            if (opts.WTF)
              throw new Error(Rn);
        }
    }
  var out = {
    Sheets,
    SheetNames,
    Workbook: WB
  };
  if (opts.bookSheets)
    delete /*::(*/
    out.Sheets;
  return out;
}
function parse_ods(zip, opts) {
  opts = opts || {};
  if (safegetzipfile(zip, "META-INF/manifest.xml"))
    parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
  var content = getzipstr(zip, "content.xml");
  if (!content)
    throw new Error("Missing content.xml in ODS / UOF file");
  var wb = parse_content_xml(utf8read(content), opts);
  if (safegetzipfile(zip, "meta.xml"))
    wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
  return wb;
}
function parse_fods(data, opts) {
  return parse_content_xml(data, opts);
}
var write_styles_ods = /* @__PURE__ */ function() {
  var master_styles = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join("");
  var payload = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + master_styles + "</office:document-styles>";
  return function wso() {
    return XML_HEADER + payload;
  };
}();
var write_content_ods = /* @__PURE__ */ function() {
  var write_text_p = function(text) {
    return escapexml(text).replace(/  +/g, function($$) {
      return '<text:s text:c="' + $$.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  };
  var null_cell_xml = "          <table:table-cell />\n";
  var covered_cell_xml = "          <table:covered-table-cell/>\n";
  var write_ws2 = function(ws, wb, i) {
    var o = [];
    o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
    var R = 0, C = 0, range = decode_range(ws["!ref"] || "A1");
    var marr = ws["!merges"] || [], mi = 0;
    var dense = Array.isArray(ws);
    if (ws["!cols"]) {
      for (C = 0; C <= range.e.c; ++C)
        o.push("        <table:table-column" + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : "") + "></table:table-column>\n");
    }
    var H = "", ROWS = ws["!rows"] || [];
    for (R = 0; R < range.s.r; ++R) {
      H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
      o.push("        <table:table-row" + H + "></table:table-row>\n");
    }
    for (; R <= range.e.r; ++R) {
      H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
      o.push("        <table:table-row" + H + ">\n");
      for (C = 0; C < range.s.c; ++C)
        o.push(null_cell_xml);
      for (; C <= range.e.c; ++C) {
        var skip = false, ct = {}, textp = "";
        for (mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c > C)
            continue;
          if (marr[mi].s.r > R)
            continue;
          if (marr[mi].e.c < C)
            continue;
          if (marr[mi].e.r < R)
            continue;
          if (marr[mi].s.c != C || marr[mi].s.r != R)
            skip = true;
          ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
          ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
          break;
        }
        if (skip) {
          o.push(covered_cell_xml);
          continue;
        }
        var ref2 = encode_cell({ r: R, c: C }), cell = dense ? (ws[R] || [])[C] : ws[ref2];
        if (cell && cell.f) {
          ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
          if (cell.F) {
            if (cell.F.slice(0, ref2.length) == ref2) {
              var _Fref = decode_range(cell.F);
              ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
              ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
            }
          }
        }
        if (!cell) {
          o.push(null_cell_xml);
          continue;
        }
        switch (cell.t) {
          case "b":
            textp = cell.v ? "TRUE" : "FALSE";
            ct["office:value-type"] = "boolean";
            ct["office:boolean-value"] = cell.v ? "true" : "false";
            break;
          case "n":
            textp = cell.w || String(cell.v || 0);
            ct["office:value-type"] = "float";
            ct["office:value"] = cell.v || 0;
            break;
          case "s":
          case "str":
            textp = cell.v == null ? "" : cell.v;
            ct["office:value-type"] = "string";
            break;
          case "d":
            textp = cell.w || parseDate(cell.v).toISOString();
            ct["office:value-type"] = "date";
            ct["office:date-value"] = parseDate(cell.v).toISOString();
            ct["table:style-name"] = "ce1";
            break;
          default:
            o.push(null_cell_xml);
            continue;
        }
        var text_p = write_text_p(textp);
        if (cell.l && cell.l.Target) {
          var _tgt = cell.l.Target;
          _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
          if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/))
            _tgt = "../" + _tgt;
          text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
        }
        o.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
      }
      o.push("        </table:table-row>\n");
    }
    o.push("      </table:table>\n");
    return o.join("");
  };
  var write_automatic_styles_ods = function(o, wb) {
    o.push(" <office:automatic-styles>\n");
    o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
    o.push('   <number:month number:style="long"/>\n');
    o.push("   <number:text>/</number:text>\n");
    o.push('   <number:day number:style="long"/>\n');
    o.push("   <number:text>/</number:text>\n");
    o.push("   <number:year/>\n");
    o.push("  </number:date-style>\n");
    var cidx = 0;
    wb.SheetNames.map(function(n) {
      return wb.Sheets[n];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!cols"]) {
        for (var C = 0; C < ws["!cols"].length; ++C)
          if (ws["!cols"][C]) {
            var colobj = ws["!cols"][C];
            if (colobj.width == null && colobj.wpx == null && colobj.wch == null)
              continue;
            process_col(colobj);
            colobj.ods = cidx;
            var w = ws["!cols"][C].wpx + "px";
            o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
            o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/>\n');
            o.push("  </style:style>\n");
            ++cidx;
          }
      }
    });
    var ridx = 0;
    wb.SheetNames.map(function(n) {
      return wb.Sheets[n];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!rows"]) {
        for (var R = 0; R < ws["!rows"].length; ++R)
          if (ws["!rows"][R]) {
            ws["!rows"][R].ods = ridx;
            var h3 = ws["!rows"][R].hpx + "px";
            o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
            o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h3 + '"/>\n');
            o.push("  </style:style>\n");
            ++ridx;
          }
      }
    });
    o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
    o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
    o.push("  </style:style>\n");
    o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
    o.push(" </office:automatic-styles>\n");
  };
  return function wcx(wb, opts) {
    var o = [XML_HEADER];
    var attr = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    });
    var fods = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    if (opts.bookType == "fods") {
      o.push("<office:document" + attr + fods + ">\n");
      o.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
    } else
      o.push("<office:document-content" + attr + ">\n");
    write_automatic_styles_ods(o, wb);
    o.push("  <office:body>\n");
    o.push("    <office:spreadsheet>\n");
    for (var i = 0; i != wb.SheetNames.length; ++i)
      o.push(write_ws2(wb.Sheets[wb.SheetNames[i]], wb, i));
    o.push("    </office:spreadsheet>\n");
    o.push("  </office:body>\n");
    if (opts.bookType == "fods")
      o.push("</office:document>");
    else
      o.push("</office:document-content>");
    return o.join("");
  };
}();
function write_ods(wb, opts) {
  if (opts.bookType == "fods")
    return write_content_ods(wb, opts);
  var zip = zip_new();
  var f = "";
  var manifest = [];
  var rdf = [];
  f = "mimetype";
  zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");
  f = "content.xml";
  zip_add_file(zip, f, write_content_ods(wb, opts));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "ContentFile"]);
  f = "styles.xml";
  zip_add_file(zip, f, write_styles_ods(wb, opts));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "StylesFile"]);
  f = "meta.xml";
  zip_add_file(zip, f, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  ));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "MetadataFile"]);
  f = "manifest.rdf";
  zip_add_file(zip, f, write_rdf(
    rdf
    /*, opts*/
  ));
  manifest.push([f, "application/rdf+xml"]);
  f = "META-INF/manifest.xml";
  zip_add_file(zip, f, write_manifest(
    manifest
    /*, opts*/
  ));
  return zip;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function u8str(u8) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
}
function stru8(str) {
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
}
function u8contains(body, search) {
  outer:
    for (var L = 0; L <= body.length - search.length; ++L) {
      for (var j = 0; j < search.length; ++j)
        if (body[L + j] != search[j])
          continue outer;
      return true;
    }
  return false;
}
function u8concat(u8a) {
  var len = u8a.reduce(function(acc, x) {
    return acc + x.length;
  }, 0);
  var out = new Uint8Array(len);
  var off = 0;
  u8a.forEach(function(u8) {
    out.set(u8, off);
    off += u8.length;
  });
  return out;
}
function popcnt(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  return (x + (x >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(buf, offset) {
  var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
  var mantissa = buf[offset + 14] & 1;
  for (var j = offset + 13; j >= offset; --j)
    mantissa = mantissa * 256 + buf[j];
  return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
}
function writeDecimal128LE(buf, offset, value) {
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
  var mantissa = value / Math.pow(10, exp - 6176);
  buf[offset + 15] |= exp >> 7;
  buf[offset + 14] |= (exp & 127) << 1;
  for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
    buf[offset + i] = mantissa & 255;
  buf[offset + 15] |= value >= 0 ? 0 : 128;
}
function parse_varint49(buf, ptr) {
  var l = ptr ? ptr[0] : 0;
  var usz = buf[l] & 127;
  varint:
    if (buf[l++] >= 128) {
      usz |= (buf[l] & 127) << 7;
      if (buf[l++] < 128)
        break varint;
      usz |= (buf[l] & 127) << 14;
      if (buf[l++] < 128)
        break varint;
      usz |= (buf[l] & 127) << 21;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 28);
      ++l;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 35);
      ++l;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 42);
      ++l;
      if (buf[l++] < 128)
        break varint;
    }
  if (ptr)
    ptr[0] = l;
  return usz;
}
function write_varint49(v) {
  var usz = new Uint8Array(7);
  usz[0] = v & 127;
  var L = 1;
  sz:
    if (v > 127) {
      usz[L - 1] |= 128;
      usz[L] = v >> 7 & 127;
      ++L;
      if (v <= 16383)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v >> 14 & 127;
      ++L;
      if (v <= 2097151)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v >> 21 & 127;
      ++L;
      if (v <= 268435455)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 256 >>> 21 & 127;
      ++L;
      if (v <= 34359738367)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 65536 >>> 21 & 127;
      ++L;
      if (v <= 4398046511103)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 16777216 >>> 21 & 127;
      ++L;
    }
  return usz.slice(0, L);
}
function varint_to_i32(buf) {
  var l = 0, i32 = buf[l] & 127;
  varint:
    if (buf[l++] >= 128) {
      i32 |= (buf[l] & 127) << 7;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 14;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 21;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 28;
    }
  return i32;
}
function parse_shallow(buf) {
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var off = ptr[0];
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = Math.floor(num / 8);
    var len = 0;
    var res;
    if (num == 0)
      break;
    switch (type) {
      case 0:
        {
          var l = ptr[0];
          while (buf[ptr[0]++] >= 128)
            ;
          res = buf.slice(l, ptr[0]);
        }
        break;
      case 5:
        len = 4;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 1:
        len = 8;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 2:
        len = parse_varint49(buf, ptr);
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v = { data: res, type };
    if (out[num] == null)
      out[num] = [v];
    else
      out[num].push(v);
  }
  return out;
}
function write_shallow(proto) {
  var out = [];
  proto.forEach(function(field, idx) {
    field.forEach(function(item) {
      if (!item.data)
        return;
      out.push(write_varint49(idx * 8 + item.type));
      if (item.type == 2)
        out.push(write_varint49(item.data.length));
      out.push(item.data);
    });
  });
  return u8concat(out);
}
function mappa(data, cb) {
  return (data == null ? void 0 : data.map(function(d) {
    return cb(d.data);
  })) || [];
}
function parse_iwa_file(buf) {
  var _a;
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
    ptr[0] += len;
    var res = {
      id: varint_to_i32(ai[1][0].data),
      messages: []
    };
    ai[2].forEach(function(b) {
      var mi = parse_shallow(b.data);
      var fl = varint_to_i32(mi[3][0].data);
      res.messages.push({
        meta: mi,
        data: buf.slice(ptr[0], ptr[0] + fl)
      });
      ptr[0] += fl;
    });
    if ((_a = ai[3]) == null ? void 0 : _a[0])
      res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
function write_iwa_file(ias) {
  var bufs = [];
  ias.forEach(function(ia) {
    var ai = [];
    ai[1] = [{ data: write_varint49(ia.id), type: 0 }];
    ai[2] = [];
    if (ia.merge != null)
      ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
    var midata = [];
    ia.messages.forEach(function(mi) {
      midata.push(mi.data);
      mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
      ai[2].push({ data: write_shallow(mi.meta), type: 2 });
    });
    var aipayload = write_shallow(ai);
    bufs.push(write_varint49(aipayload.length));
    bufs.push(aipayload);
    midata.forEach(function(mid) {
      return bufs.push(mid);
    });
  });
  return u8concat(bufs);
}
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = [0];
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  while (ptr[0] < buf.length) {
    var tag = buf[ptr[0]] & 3;
    if (tag == 0) {
      var len = buf[ptr[0]++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c = len - 59;
        len = buf[ptr[0]];
        if (c > 1)
          len |= buf[ptr[0] + 1] << 8;
        if (c > 2)
          len |= buf[ptr[0] + 2] << 16;
        if (c > 3)
          len |= buf[ptr[0] + 3] << 24;
        len >>>= 0;
        len++;
        ptr[0] += c;
      }
      chunks.push(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      continue;
    } else {
      var offset = 0, length = 0;
      if (tag == 1) {
        length = (buf[ptr[0]] >> 2 & 7) + 4;
        offset = (buf[ptr[0]++] & 224) << 3;
        offset |= buf[ptr[0]++];
      } else {
        length = (buf[ptr[0]++] >> 2) + 1;
        if (tag == 2) {
          offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
          ptr[0] += 2;
        } else {
          offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
          ptr[0] += 4;
        }
      }
      chunks = [u8concat(chunks)];
      if (offset == 0)
        throw new Error("Invalid offset 0");
      if (offset > chunks[0].length)
        throw new Error("Invalid offset beyond length");
      if (length >= offset) {
        chunks.push(chunks[0].slice(-offset));
        length -= offset;
        while (length >= chunks[chunks.length - 1].length) {
          chunks.push(chunks[chunks.length - 1]);
          length -= chunks[chunks.length - 1].length;
        }
      }
      chunks.push(chunks[0].slice(-offset, -offset + length));
    }
  }
  var o = u8concat(chunks);
  if (o.length != usz)
    throw new Error("Unexpected length: ".concat(o.length, " != ").concat(usz));
  return o;
}
function decompress_iwa_file(buf) {
  var out = [];
  var l = 0;
  while (l < buf.length) {
    var t2 = buf[l++];
    var len = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
    l += 3;
    out.push(parse_snappy_chunk(t2, buf.slice(l, l + len)));
    l += len;
  }
  if (l !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return u8concat(out);
}
function compress_iwa_file(buf) {
  var out = [];
  var l = 0;
  while (l < buf.length) {
    var c = Math.min(buf.length - l, 268435455);
    var frame = new Uint8Array(4);
    out.push(frame);
    var usz = write_varint49(c);
    var L = usz.length;
    out.push(usz);
    if (c <= 60) {
      L++;
      out.push(new Uint8Array([c - 1 << 2]));
    } else if (c <= 256) {
      L += 2;
      out.push(new Uint8Array([240, c - 1 & 255]));
    } else if (c <= 65536) {
      L += 3;
      out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
    } else if (c <= 16777216) {
      L += 4;
      out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
    } else if (c <= 4294967296) {
      L += 5;
      out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
    }
    out.push(buf.slice(l, l + c));
    L += c;
    frame[0] = 0;
    frame[1] = L & 255;
    frame[2] = L >> 8 & 255;
    frame[3] = L >> 16 & 255;
    l += c;
  }
  return u8concat(out);
}
function parse_old_storage(buf, sst, rsst, v) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(4, true);
  var data_offset = (v > 1 ? 12 : 8) + popcnt(flags & (v > 1 ? 3470 : 398)) * 4;
  var ridx = -1, sidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);
  if (flags & 512) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  data_offset += popcnt(flags & (v > 1 ? 12288 : 4096)) * 4;
  if (flags & 16) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 32) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 64) {
    dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  var ret;
  switch (buf[2]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: ieee };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else if (sidx > -1)
          ret = { t: "s", v: sst[sidx] };
        else if (!isNaN(ieee))
          ret = { t: "n", v: ieee };
        else
          throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
      }
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
  }
  return ret;
}
function parse_new_storage(buf, sst, rsst) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(8, true);
  var data_offset = 12;
  var ridx = -1, sidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);
  if (flags & 1) {
    d128 = readDecimal128LE(buf, data_offset);
    data_offset += 16;
  }
  if (flags & 2) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 4) {
    dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  if (flags & 8) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 16) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  var ret;
  switch (buf[1]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: d128 };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else
          throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
      }
      break;
    case 10:
      ret = { t: "n", v: d128 };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
  }
  return ret;
}
function write_new_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
  out[0] = 5;
  switch (cell.t) {
    case "n":
      out[1] = 2;
      writeDecimal128LE(out, l, cell.v);
      flags |= 1;
      l += 16;
      break;
    case "b":
      out[1] = 6;
      dv.setFloat64(l, cell.v ? 1 : 0, true);
      flags |= 2;
      l += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[1] = 3;
      dv.setUint32(l, sst.indexOf(cell.v), true);
      flags |= 8;
      l += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(8, flags, true);
  return out.slice(0, l);
}
function write_old_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
  out[0] = 3;
  switch (cell.t) {
    case "n":
      out[2] = 2;
      dv.setFloat64(l, cell.v, true);
      flags |= 32;
      l += 8;
      break;
    case "b":
      out[2] = 6;
      dv.setFloat64(l, cell.v ? 1 : 0, true);
      flags |= 32;
      l += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[2] = 3;
      dv.setUint32(l, sst.indexOf(cell.v), true);
      flags |= 16;
      l += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(4, flags, true);
  return out.slice(0, l);
}
function parse_cell_storage(buf, sst, rsst) {
  switch (buf[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
      return parse_old_storage(buf, sst, rsst, buf[0]);
    case 5:
      return parse_new_storage(buf, sst, rsst);
    default:
      throw new Error("Unsupported payload version ".concat(buf[0]));
  }
}
function parse_TSP_Reference(buf) {
  var pb = parse_shallow(buf);
  return parse_varint49(pb[1][0].data);
}
function parse_TST_TableDataList(M, root) {
  var pb = parse_shallow(root.data);
  var type = varint_to_i32(pb[1][0].data);
  var entries = pb[3];
  var data = [];
  (entries || []).forEach(function(entry) {
    var le = parse_shallow(entry.data);
    var key = varint_to_i32(le[1][0].data) >>> 0;
    switch (type) {
      case 1:
        data[key] = u8str(le[3][0].data);
        break;
      case 8:
        {
          var rt = M[parse_TSP_Reference(le[9][0].data)][0];
          var rtp = parse_shallow(rt.data);
          var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];
          var mtype = varint_to_i32(rtpref.meta[1][0].data);
          if (mtype != 2001)
            throw new Error("2000 unexpected reference to ".concat(mtype));
          var tswpsa = parse_shallow(rtpref.data);
          data[key] = tswpsa[3].map(function(x) {
            return u8str(x.data);
          }).join("");
        }
        break;
    }
  });
  return data;
}
function parse_TST_TileRowInfo(u8, type) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  var pb = parse_shallow(u8);
  var R = varint_to_i32(pb[1][0].data) >>> 0;
  var cnt = varint_to_i32(pb[2][0].data) >>> 0;
  var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) && varint_to_i32(pb[8][0].data) > 0 || false;
  var used_storage_u8, used_storage;
  if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type != 0) {
    used_storage_u8 = (_f = (_e = pb[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
  } else
    throw "NUMBERS Tile missing ".concat(type, " cell storage");
  var width2 = wide_offsets ? 4 : 1;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);
  var offsets = [];
  for (var C = 0; C < used_storage_u8.length / 2; ++C) {
    var off = used_storage_offsets.getUint16(C * 2, true);
    if (off < 65535)
      offsets.push([C, off]);
  }
  if (offsets.length != cnt)
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
  var cells = [];
  for (C = 0; C < offsets.length - 1; ++C)
    cells[offsets[C][0]] = used_storage.subarray(offsets[C][1] * width2, offsets[C + 1][1] * width2);
  if (offsets.length >= 1)
    cells[offsets[offsets.length - 1][0]] = used_storage.subarray(offsets[offsets.length - 1][1] * width2);
  return { R, cells };
}
function parse_TST_Tile(M, root) {
  var _a;
  var pb = parse_shallow(root.data);
  var storage = ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) ? varint_to_i32(pb[7][0].data) >>> 0 > 0 ? 1 : 0 : -1;
  var ri = mappa(pb[5], function(u8) {
    return parse_TST_TileRowInfo(u8, storage);
  });
  return {
    nrows: varint_to_i32(pb[4][0].data) >>> 0,
    data: ri.reduce(function(acc, x) {
      if (!acc[x.R])
        acc[x.R] = [];
      x.cells.forEach(function(cell, C) {
        if (acc[x.R][C])
          throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));
        acc[x.R][C] = cell;
      });
      return acc;
    }, [])
  };
}
function parse_TST_TableModelArchive(M, root, ws) {
  var _a;
  var pb = parse_shallow(root.data);
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  range.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
  if (range.e.r < 0)
    throw new Error("Invalid row varint ".concat(pb[6][0].data));
  range.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
  if (range.e.c < 0)
    throw new Error("Invalid col varint ".concat(pb[7][0].data));
  ws["!ref"] = encode_range(range);
  var store = parse_shallow(pb[4][0].data);
  var sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);
  var rsst = ((_a = store[17]) == null ? void 0 : _a[0]) ? parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]) : [];
  var tile = parse_shallow(store[3][0].data);
  var _R = 0;
  tile[1].forEach(function(t2) {
    var tl = parse_shallow(t2.data);
    var ref2 = M[parse_TSP_Reference(tl[2][0].data)][0];
    var mtype = varint_to_i32(ref2.meta[1][0].data);
    if (mtype != 6002)
      throw new Error("6001 unexpected reference to ".concat(mtype));
    var _tile = parse_TST_Tile(M, ref2);
    _tile.data.forEach(function(row, R) {
      row.forEach(function(buf, C) {
        var addr = encode_cell({ r: _R + R, c: C });
        var res = parse_cell_storage(buf, sst, rsst);
        if (res)
          ws[addr] = res;
      });
    });
    _R += _tile.nrows;
  });
}
function parse_TST_TableInfoArchive(M, root) {
  var pb = parse_shallow(root.data);
  var out = { "!ref": "A1" };
  var tableref = M[parse_TSP_Reference(pb[2][0].data)];
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);
  if (mtype != 6001)
    throw new Error("6000 unexpected reference to ".concat(mtype));
  parse_TST_TableModelArchive(M, tableref[0], out);
  return out;
}
function parse_TN_SheetArchive(M, root) {
  var _a;
  var pb = parse_shallow(root.data);
  var out = {
    name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",
    sheets: []
  };
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);
  shapeoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 6e3)
        out.sheets.push(parse_TST_TableInfoArchive(M, m));
    });
  });
  return out;
}
function parse_TN_DocumentArchive(M, root) {
  var out = book_new();
  var pb = parse_shallow(root.data);
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);
  sheetoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 2) {
        var root2 = parse_TN_SheetArchive(M, m);
        root2.sheets.forEach(function(sheet, idx) {
          book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);
        });
      }
    });
  });
  if (out.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return out;
}
function parse_numbers_iwa(cfb) {
  var _a, _b, _c, _d;
  var M = {}, indices = [];
  cfb.FullPaths.forEach(function(p) {
    if (p.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  });
  cfb.FileIndex.forEach(function(s) {
    if (!s.name.match(/\.iwa$/))
      return;
    var o;
    try {
      o = decompress_iwa_file(s.content);
    } catch (e) {
      return console.log("?? " + s.content.length + " " + (e.message || e));
    }
    var packets;
    try {
      packets = parse_iwa_file(o);
    } catch (e) {
      return console.log("## " + (e.message || e));
    }
    packets.forEach(function(packet) {
      M[packet.id] = packet.messages;
      indices.push(packet.id);
    });
  });
  if (!indices.length)
    throw new Error("File has no messages");
  var docroot = ((_d = (_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.meta) == null ? void 0 : _c[1]) == null ? void 0 : _d[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1 && M[1][0];
  if (!docroot)
    indices.forEach(function(idx) {
      M[idx].forEach(function(iwam) {
        var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
        if (mtype == 1) {
          if (!docroot)
            docroot = iwam;
          else
            throw new Error("Document has multiple roots");
        }
      });
    });
  if (!docroot)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(M, docroot);
}
function write_tile_row(tri, data, SST) {
  var _a, _b, _c, _d;
  if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
    throw "Mutation only works on post-BNC storages!";
  var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
  if (wide_offsets)
    throw "Math only works with normal offsets";
  var cnt = 0;
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
  for (var C = 0; C < data.length; ++C) {
    if (data[C] == null) {
      dv.setUint16(C * 2, 65535, true);
      _dv.setUint16(C * 2, 65535);
      continue;
    }
    dv.setUint16(C * 2, last_offset, true);
    _dv.setUint16(C * 2, _last_offset, true);
    var celload, _celload;
    switch (typeof data[C]) {
      case "string":
        celload = write_new_storage({ t: "s", v: data[C] }, SST);
        _celload = write_old_storage({ t: "s", v: data[C] }, SST);
        break;
      case "number":
        celload = write_new_storage({ t: "n", v: data[C] }, SST);
        _celload = write_old_storage({ t: "n", v: data[C] }, SST);
        break;
      case "boolean":
        celload = write_new_storage({ t: "b", v: data[C] }, SST);
        _celload = write_old_storage({ t: "b", v: data[C] }, SST);
        break;
      default:
        throw new Error("Unsupported value " + data[C]);
    }
    cell_storage.push(celload);
    last_offset += celload.length;
    _cell_storage.push(_celload);
    _last_offset += _celload.length;
    ++cnt;
  }
  tri[2][0].data = write_varint49(cnt);
  for (; C < tri[7][0].data.length / 2; ++C) {
    dv.setUint16(C * 2, 65535, true);
    _dv.setUint16(C * 2, 65535, true);
  }
  tri[6][0].data = u8concat(cell_storage);
  tri[3][0].data = u8concat(_cell_storage);
  return cnt;
}
function write_numbers_iwa(wb, opts) {
  if (!opts || !opts.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var ws = wb.Sheets[wb.SheetNames[0]];
  if (wb.SheetNames.length > 1)
    console.error("The Numbers writer currently writes only the first table");
  var range = decode_range(ws["!ref"]);
  range.s.r = range.s.c = 0;
  var trunc = false;
  if (range.e.c > 9) {
    trunc = true;
    range.e.c = 9;
  }
  if (range.e.r > 49) {
    trunc = true;
    range.e.r = 49;
  }
  if (trunc)
    console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
  var data = sheet_to_json(ws, { range, header: 1 });
  var SST = ["~Sh33tJ5~"];
  data.forEach(function(row) {
    return row.forEach(function(cell) {
      if (typeof cell == "string")
        SST.push(cell);
    });
  });
  var dependents = {};
  var indices = [];
  var cfb = CFB.read(opts.numbers, { type: "base64" });
  cfb.FileIndex.map(function(fi, idx) {
    return [fi, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi = row[0], fp = row[1];
    if (fi.type != 2)
      return;
    if (!fi.name.match(/\.iwa/))
      return;
    var old_content = fi.content;
    var raw1 = decompress_iwa_file(old_content);
    var x2 = parse_iwa_file(raw1);
    x2.forEach(function(packet2) {
      indices.push(packet2.id);
      dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
    });
  });
  indices.sort(function(x2, y2) {
    return x2 - y2;
  });
  var indices_varint = indices.filter(function(x2) {
    return x2 > 1;
  }).map(function(x2) {
    return [x2, write_varint49(x2)];
  });
  cfb.FileIndex.map(function(fi, idx) {
    return [fi, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi = row[0];
    row[1];
    if (!fi.name.match(/\.iwa/))
      return;
    var x2 = parse_iwa_file(decompress_iwa_file(fi.content));
    x2.forEach(function(ia) {
      ia.messages.forEach(function(m) {
        indices_varint.forEach(function(ivi) {
          if (ia.messages.some(function(mess) {
            return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
          })) {
            dependents[ivi[0]].deps.push(ia.id);
          }
        });
      });
    });
  });
  var entry = CFB.find(cfb, dependents[1].location);
  var x = parse_iwa_file(decompress_iwa_file(entry.content));
  var docroot;
  for (var xi = 0; xi < x.length; ++xi) {
    var packet = x[xi];
    if (packet.id == 1)
      docroot = packet;
  }
  var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x.length; ++xi) {
    packet = x[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x.length; ++xi) {
    packet = x[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x.length; ++xi) {
    packet = x[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  var pb = parse_shallow(docroot.messages[0].data);
  {
    pb[6][0].data = write_varint49(range.e.r + 1);
    pb[7][0].data = write_varint49(range.e.c + 1);
    var cruidsref = parse_TSP_Reference(pb[46][0].data);
    var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
    var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
    {
      for (var j = 0; j < _x.length; ++j) {
        if (_x[j].id == cruidsref)
          break;
      }
      if (_x[j].id != cruidsref)
        throw "Bad ColumnRowUIDMapArchive";
      var cruids = parse_shallow(_x[j].messages[0].data);
      cruids[1] = [];
      cruids[2] = [], cruids[3] = [];
      for (var C = 0; C <= range.e.c; ++C) {
        var uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C + 420690) }];
        cruids[1].push({ type: 2, data: write_shallow(uuid) });
        cruids[2].push({ type: 0, data: write_varint49(C) });
        cruids[3].push({ type: 0, data: write_varint49(C) });
      }
      cruids[4] = [];
      cruids[5] = [], cruids[6] = [];
      for (var R = 0; R <= range.e.r; ++R) {
        uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R + 726270) }];
        cruids[4].push({ type: 2, data: write_shallow(uuid) });
        cruids[5].push({ type: 0, data: write_varint49(R) });
        cruids[6].push({ type: 0, data: write_varint49(R) });
      }
      _x[j].messages[0].data = write_shallow(cruids);
    }
    oldbucket.content = compress_iwa_file(write_iwa_file(_x));
    oldbucket.size = oldbucket.content.length;
    delete pb[46];
    var store = parse_shallow(pb[4][0].data);
    {
      store[7][0].data = write_varint49(range.e.r + 1);
      var row_headers = parse_shallow(store[1][0].data);
      var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
      oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != row_header_ref)
          throw "Bad HeaderStorageBucket";
        var base_bucket = parse_shallow(_x[0].messages[0].data);
        for (R = 0; R < data.length; ++R) {
          var _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(R);
          _bucket[4][0].data = write_varint49(data[R].length);
          base_bucket[2][R] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var col_header_ref = parse_TSP_Reference(store[2][0].data);
      oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != col_header_ref)
          throw "Bad HeaderStorageBucket";
        base_bucket = parse_shallow(_x[0].messages[0].data);
        for (C = 0; C <= range.e.c; ++C) {
          _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(C);
          _bucket[4][0].data = write_varint49(range.e.r + 1);
          base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var sstref = parse_TSP_Reference(store[4][0].data);
      (function() {
        var sentry = CFB.find(cfb, dependents[sstref].location);
        var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
        var sstroot;
        for (var sxi = 0; sxi < sx.length; ++sxi) {
          var packet2 = sx[sxi];
          if (packet2.id == sstref)
            sstroot = packet2;
        }
        var sstdata = parse_shallow(sstroot.messages[0].data);
        {
          sstdata[3] = [];
          var newsst = [];
          SST.forEach(function(str, i) {
            newsst[1] = [{ type: 0, data: write_varint49(i) }];
            newsst[2] = [{ type: 0, data: write_varint49(1) }];
            newsst[3] = [{ type: 2, data: stru8(str) }];
            sstdata[3].push({ type: 2, data: write_shallow(newsst) });
          });
        }
        sstroot.messages[0].data = write_shallow(sstdata);
        var sy = write_iwa_file(sx);
        var raw32 = compress_iwa_file(sy);
        sentry.content = raw32;
        sentry.size = sentry.content.length;
      })();
      var tile = parse_shallow(store[3][0].data);
      {
        var t2 = tile[1][0];
        delete tile[2];
        var tl = parse_shallow(t2.data);
        {
          var tileref = parse_TSP_Reference(tl[2][0].data);
          (function() {
            var tentry = CFB.find(cfb, dependents[tileref].location);
            var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
            var tileroot;
            for (var sxi = 0; sxi < tx.length; ++sxi) {
              var packet2 = tx[sxi];
              if (packet2.id == tileref)
                tileroot = packet2;
            }
            var tiledata = parse_shallow(tileroot.messages[0].data);
            {
              delete tiledata[6];
              delete tile[7];
              var rowload = new Uint8Array(tiledata[5][0].data);
              tiledata[5] = [];
              var cnt = 0;
              for (var R2 = 0; R2 <= range.e.r; ++R2) {
                var tilerow = parse_shallow(rowload);
                cnt += write_tile_row(tilerow, data[R2], SST);
                tilerow[1][0].data = write_varint49(R2);
                tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
              }
              tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
              tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
              tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
              tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
            }
            tileroot.messages[0].data = write_shallow(tiledata);
            var ty = write_iwa_file(tx);
            var raw32 = compress_iwa_file(ty);
            tentry.content = raw32;
            tentry.size = tentry.content.length;
          })();
        }
        t2.data = write_shallow(tl);
      }
      store[3][0].data = write_shallow(tile);
    }
    pb[4][0].data = write_shallow(store);
  }
  docroot.messages[0].data = write_shallow(pb);
  var y = write_iwa_file(x);
  var raw3 = compress_iwa_file(y);
  entry.content = raw3;
  entry.size = entry.content.length;
  return cfb;
}
function fix_opts_func(defaults) {
  return function fix_opts(opts) {
    for (var i = 0; i != defaults.length; ++i) {
      var d = defaults[i];
      if (opts[d[0]] === void 0)
        opts[d[0]] = d[1];
      if (d[2] === "n")
        opts[d[0]] = Number(opts[d[0]]);
    }
  };
}
function fix_read_opts(opts) {
  fix_opts_func([
    ["cellNF", false],
    /* emit cell number format string as .z */
    ["cellHTML", true],
    /* emit html string as .h */
    ["cellFormula", true],
    /* emit formulae as .f */
    ["cellStyles", false],
    /* emits style/theme as .s */
    ["cellText", true],
    /* emit formatted text as .w */
    ["cellDates", false],
    /* emit date cells with type `d` */
    ["sheetStubs", false],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", false],
    /* parse calculation chains */
    ["bookSheets", false],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", false],
    /* only try to get properties (no Sheets) */
    ["bookFiles", false],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", false],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function fix_write_opts(opts) {
  fix_opts_func([
    ["cellDates", false],
    /* write date cells with type `d` */
    ["bookSST", false],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", false],
    /* Use file compression */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function get_sheet_type(n) {
  if (RELS.WS.indexOf(n) > -1)
    return "sheet";
  if (n == RELS.CS)
    return "chart";
  if (n == RELS.DS)
    return "dialog";
  if (n == RELS.MS)
    return "macro";
  return n && n.length ? n : "sheet";
}
function safe_parse_wbrels(wbrels, sheets) {
  if (!wbrels)
    return 0;
  try {
    wbrels = sheets.map(function pwbr(w) {
      if (!w.id)
        w.id = w.strRelID;
      return [w.name, wbrels["!id"][w.id].Target, get_sheet_type(wbrels["!id"][w.id].Type)];
    });
  } catch (e) {
    return null;
  }
  return !wbrels || wbrels.length === 0 ? null : wbrels;
}
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {
  try {
    sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
    var data = getzipdata(zip, path);
    var _ws;
    switch (stype) {
      case "sheet":
        _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "chart":
        _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        if (!_ws || !_ws["!drawel"])
          break;
        var dfile = resolve_path(_ws["!drawel"].Target, path);
        var drelsp = get_rels_path(dfile);
        var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
        var chartp = resolve_path(draw, dfile);
        var crelsp = get_rels_path(chartp);
        _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
        break;
      case "macro":
        _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "dialog":
        _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      default:
        throw new Error("Unrecognized sheet type " + stype);
    }
    sheets[sheet] = _ws;
    var tcomments = [];
    if (sheetRels && sheetRels[sheet])
      keys(sheetRels[sheet]).forEach(function(n) {
        var dfile2 = "";
        if (sheetRels[sheet][n].Type == RELS.CMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          var comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
          if (!comments || !comments.length)
            return;
          sheet_insert_comments(_ws, comments, false);
        }
        if (sheetRels[sheet][n].Type == RELS.TCMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
        }
      });
    if (tcomments && tcomments.length)
      sheet_insert_comments(_ws, tcomments, true, opts.people || []);
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
}
function strip_front_slash(x) {
  return x.charAt(0) == "/" ? x.slice(1) : x;
}
function parse_zip(zip, opts) {
  make_ssf();
  opts = opts || {};
  fix_read_opts(opts);
  if (safegetzipfile(zip, "META-INF/manifest.xml"))
    return parse_ods(zip, opts);
  if (safegetzipfile(zip, "objectdata.xml"))
    return parse_ods(zip, opts);
  if (safegetzipfile(zip, "Index/Document.iwa")) {
    if (typeof Uint8Array == "undefined")
      throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa != "undefined") {
      if (zip.FileIndex)
        return parse_numbers_iwa(zip);
      var _zip = CFB.utils.cfb_new();
      zipentries(zip).forEach(function(e) {
        zip_add_file(_zip, e, getzipbin(zip, e));
      });
      return parse_numbers_iwa(_zip);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(zip, "[Content_Types].xml")) {
    if (safegetzipfile(zip, "index.xml.gz"))
      throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(zip, "index.xml"))
      throw new Error("Unsupported NUMBERS 09 file");
    throw new Error("Unsupported ZIP file");
  }
  var entries = zipentries(zip);
  var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
  var xlsb = false;
  var sheets, binname;
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.xml";
    if (getzipdata(zip, binname, true))
      dir.workbooks.push(binname);
  }
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.bin";
    if (!getzipdata(zip, binname, true))
      throw new Error("Could not find workbook");
    dir.workbooks.push(binname);
    xlsb = true;
  }
  if (dir.workbooks[0].slice(-3) == "bin")
    xlsb = true;
  var themes = {};
  var styles = {};
  if (!opts.bookSheets && !opts.bookProps) {
    strs = [];
    if (dir.sst)
      try {
        strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
      } catch (e) {
        if (opts.WTF)
          throw e;
      }
    if (opts.cellStyles && dir.themes.length)
      themes = parse_theme(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", dir.themes[0], opts);
    if (dir.style)
      styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
  }
  dir.links.map(function(link) {
    try {
      var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
      return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
    } catch (e) {
    }
  });
  var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
  var props = {}, propdata = "";
  if (dir.coreprops.length) {
    propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
    if (propdata)
      props = parse_core_props(propdata);
    if (dir.extprops.length !== 0) {
      propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
      if (propdata)
        parse_ext_props(propdata, props, opts);
    }
  }
  var custprops = {};
  if (!opts.bookSheets || opts.bookProps) {
    if (dir.custprops.length !== 0) {
      propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
      if (propdata)
        custprops = parse_cust_props(propdata, opts);
    }
  }
  var out = {};
  if (opts.bookSheets || opts.bookProps) {
    if (wb.Sheets)
      sheets = wb.Sheets.map(function pluck(x) {
        return x.name;
      });
    else if (props.Worksheets && props.SheetNames.length > 0)
      sheets = props.SheetNames;
    if (opts.bookProps) {
      out.Props = props;
      out.Custprops = custprops;
    }
    if (opts.bookSheets && typeof sheets !== "undefined")
      out.SheetNames = sheets;
    if (opts.bookSheets ? out.SheetNames : opts.bookProps)
      return out;
  }
  sheets = {};
  var deps = {};
  if (opts.bookDeps && dir.calcchain)
    deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
  var i = 0;
  var sheetRels = {};
  var path, relsPath;
  {
    var wbsheets = wb.Sheets;
    props.Worksheets = wbsheets.length;
    props.SheetNames = [];
    for (var j = 0; j != wbsheets.length; ++j) {
      props.SheetNames[j] = wbsheets[j].name;
    }
  }
  var wbext = xlsb ? "bin" : "xml";
  var wbrelsi = dir.workbooks[0].lastIndexOf("/");
  var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
  if (!safegetzipfile(zip, wbrelsfile))
    wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
  var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
  if ((dir.metadata || []).length >= 1) {
    opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
  }
  if ((dir.people || []).length >= 1) {
    opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
  }
  if (wbrels)
    wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
  var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
  wsloop:
    for (i = 0; i != props.Worksheets; ++i) {
      var stype = "sheet";
      if (wbrels && wbrels[i]) {
        path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
        if (!safegetzipfile(zip, path))
          path = wbrels[i][1];
        if (!safegetzipfile(zip, path))
          path = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i][1];
        stype = wbrels[i][2];
      } else {
        path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
        path = path.replace(/sheet0\./, "sheet.");
      }
      relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
      if (opts && opts.sheets != null)
        switch (typeof opts.sheets) {
          case "number":
            if (i != opts.sheets)
              continue wsloop;
            break;
          case "string":
            if (props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase())
              continue wsloop;
            break;
          default:
            if (Array.isArray && Array.isArray(opts.sheets)) {
              var snjseen = false;
              for (var snj = 0; snj != opts.sheets.length; ++snj) {
                if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i)
                  snjseen = 1;
                if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase())
                  snjseen = 1;
              }
              if (!snjseen)
                continue wsloop;
            }
        }
      safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);
    }
  out = {
    Directory: dir,
    Workbook: wb,
    Props: props,
    Custprops: custprops,
    Deps: deps,
    Sheets: sheets,
    SheetNames: props.SheetNames,
    Strings: strs,
    Styles: styles,
    Themes: themes,
    SSF: dup(table_fmt)
  };
  if (opts && opts.bookFiles) {
    if (zip.files) {
      out.keys = entries;
      out.files = zip.files;
    } else {
      out.keys = [];
      out.files = {};
      zip.FullPaths.forEach(function(p, idx) {
        p = p.replace(/^Root Entry[\/]/, "");
        out.keys.push(p);
        out.files[p] = zip.FileIndex[idx];
      });
    }
  }
  if (opts && opts.bookVBA) {
    if (dir.vba.length > 0)
      out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
    else if (dir.defaults && dir.defaults.bin === CT_VBA)
      out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
  }
  return out;
}
function parse_xlsxcfb(cfb, _opts) {
  var opts = _opts || {};
  var f = "Workbook", data = CFB.find(cfb, f);
  try {
    f = "/!DataSpaces/Version";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_DataSpaceVersionInfo(data.content);
    f = "/!DataSpaces/DataSpaceMap";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    var dsm = parse_DataSpaceMap(data.content);
    if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    var seds = parse_DataSpaceDefinition(data.content);
    if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_Primary(data.content);
  } catch (e) {
  }
  f = "/EncryptionInfo";
  data = CFB.find(cfb, f);
  if (!data || !data.content)
    throw new Error("ECMA-376 Encrypted file missing " + f);
  var einfo = parse_EncryptionInfo(data.content);
  f = "/EncryptedPackage";
  data = CFB.find(cfb, f);
  if (!data || !data.content)
    throw new Error("ECMA-376 Encrypted file missing " + f);
  if (einfo[0] == 4 && typeof decrypt_agile !== "undefined")
    return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
  if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined")
    return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
  throw new Error("File is password-protected");
}
function write_zip(wb, opts) {
  if (opts.bookType == "ods")
    return write_ods(wb, opts);
  if (opts.bookType == "numbers")
    return write_numbers_iwa(wb, opts);
  if (opts.bookType == "xlsb")
    return write_zip_xlsxb(wb, opts);
  return write_zip_xlsx(wb, opts);
}
function write_zip_xlsxb(wb, opts) {
  _shapeid = 1024;
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f = "docProps/core.xml";
  zip_add_file(zip, f, write_core_props(wb.Props, opts));
  ct.coreprops.push(f);
  add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
  f = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f, write_ext_props(wb.Props));
  ct.extprops.push(f);
  add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f = "docProps/custom.xml";
    zip_add_file(zip, f, write_cust_props(wb.Custprops));
    ct.custprops.push(f);
    add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  }
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f, write_ws(rId - 1, f, opts, wb, wsrels));
        ct.sheets.push(f);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_cmnt(comments, cf));
        ct.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f, write_sst(opts.Strings, f, opts));
    ct.strs.push(f);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f = "xl/workbook." + wbext;
  zip_add_file(zip, f, write_wb(wb, f));
  ct.workbooks.push(f);
  add_rels(opts.rels, 1, f, RELS.WB);
  f = "xl/theme/theme1.xml";
  zip_add_file(zip, f, write_theme(wb.Themes, opts));
  ct.themes.push(f);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f = "xl/styles." + wbext;
  zip_add_file(zip, f, write_sty(wb, f, opts));
  ct.styles.push(f);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f = "xl/vbaProject.bin";
    zip_add_file(zip, f, wb.vbaraw);
    ct.vba.push(f);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f = "xl/metadata." + wbext;
  zip_add_file(zip, f, write_xlmeta(f));
  ct.metadata.push(f);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function write_zip_xlsx(wb, opts) {
  _shapeid = 1024;
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f = "docProps/core.xml";
  zip_add_file(zip, f, write_core_props(wb.Props, opts));
  ct.coreprops.push(f);
  add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
  f = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f, write_ext_props(wb.Props));
  ct.extprops.push(f);
  add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f = "docProps/custom.xml";
    zip_add_file(zip, f, write_cust_props(wb.Custprops));
    ct.custprops.push(f);
    add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  }
  var people = ["SheetJ5"];
  opts.tcid = 0;
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f, write_ws_xml(rId - 1, opts, wb, wsrels));
        ct.sheets.push(f);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        var needtc = false;
        comments.forEach(function(carr) {
          carr[1].forEach(function(c) {
            if (c.T == true)
              needtc = true;
          });
        });
        if (needtc) {
          cf = "xl/threadedComments/threadedComment" + rId + "." + wbext;
          zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
          ct.threadedcomments.push(cf);
          add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
        }
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_comments_xml(comments));
        ct.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
    ct.strs.push(f);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f = "xl/workbook." + wbext;
  zip_add_file(zip, f, write_wb_xml(wb));
  ct.workbooks.push(f);
  add_rels(opts.rels, 1, f, RELS.WB);
  f = "xl/theme/theme1.xml";
  zip_add_file(zip, f, write_theme(wb.Themes, opts));
  ct.themes.push(f);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f = "xl/styles." + wbext;
  zip_add_file(zip, f, write_sty_xml(wb, opts));
  ct.styles.push(f);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f = "xl/vbaProject.bin";
    zip_add_file(zip, f, wb.vbaraw);
    ct.vba.push(f);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f = "xl/metadata." + wbext;
  zip_add_file(zip, f, write_xlmeta_xml());
  ct.metadata.push(f);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  if (people.length > 1) {
    f = "xl/persons/person.xml";
    zip_add_file(zip, f, write_people_xml(people));
    ct.people.push(f);
    add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
  }
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function firstbyte(f, o) {
  var x = "";
  switch ((o || {}).type || "base64") {
    case "buffer":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    case "base64":
      x = Base64_decode(f.slice(0, 12));
      break;
    case "binary":
      x = f;
      break;
    case "array":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    default:
      throw new Error("Unrecognized type " + (o && o.type || "undefined"));
  }
  return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
}
function read_cfb(cfb, opts) {
  if (CFB.find(cfb, "EncryptedPackage"))
    return parse_xlsxcfb(cfb, opts);
  return parse_xlscfb(cfb, opts);
}
function read_zip(data, opts) {
  var zip, d = data;
  var o = opts || {};
  if (!o.type)
    o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  zip = zip_read(d, o);
  return parse_zip(zip, o);
}
function read_plaintext(data, o) {
  var i = 0;
  main:
    while (i < data.length)
      switch (data.charCodeAt(i)) {
        case 10:
        case 13:
        case 32:
          ++i;
          break;
        case 60:
          return parse_xlml(data.slice(i), o);
        default:
          break main;
      }
  return PRN.to_workbook(data, o);
}
function read_plaintext_raw(data, o) {
  var str = "", bytes = firstbyte(data, o);
  switch (o.type) {
    case "base64":
      str = Base64_decode(data);
      break;
    case "binary":
      str = data;
      break;
    case "buffer":
      str = data.toString("binary");
      break;
    case "array":
      str = cc2str(data);
      break;
    default:
      throw new Error("Unrecognized type " + o.type);
  }
  if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
    str = utf8read(str);
  o.type = "binary";
  return read_plaintext(str, o);
}
function read_utf16(data, o) {
  var d = data;
  if (o.type == "base64")
    d = Base64_decode(d);
  d = $cptable.utils.decode(1200, d.slice(2), "str");
  o.type = "binary";
  return read_plaintext(d, o);
}
function bstrify(data) {
  return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
}
function read_prn(data, d, o, str) {
  if (str) {
    o.type = "string";
    return PRN.to_workbook(data, o);
  }
  return PRN.to_workbook(d, o);
}
function readSync(data, opts) {
  reset_cp();
  var o = opts || {};
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer)
    return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));
  if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o.type)
    o.type = typeof Deno !== "undefined" ? "buffer" : "array";
  var d = data, n = [0, 0, 0, 0], str = false;
  if (o.cellStyles) {
    o.cellNF = true;
    o.sheetStubs = true;
  }
  _ssfopts = {};
  if (o.dateNF)
    _ssfopts.dateNF = o.dateNF;
  if (!o.type)
    o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  if (o.type == "file") {
    o.type = has_buf ? "buffer" : "binary";
    d = read_binary(data);
    if (typeof Uint8Array !== "undefined" && !has_buf)
      o.type = "array";
  }
  if (o.type == "string") {
    str = true;
    o.type = "binary";
    o.codepage = 65001;
    d = bstrify(data);
  }
  if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
    var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
    vu.foo = "bar";
    if (!vu.foo) {
      o = dup(o);
      o.type = "array";
      return readSync(ab2a(d), o);
    }
  }
  switch ((n = firstbyte(d, o))[0]) {
    case 208:
      if (n[1] === 207 && n[2] === 17 && n[3] === 224 && n[4] === 161 && n[5] === 177 && n[6] === 26 && n[7] === 225)
        return read_cfb(CFB.read(d, o), o);
      break;
    case 9:
      if (n[1] <= 8)
        return parse_xlscfb(d, o);
      break;
    case 60:
      return parse_xlml(d, o);
    case 73:
      if (n[1] === 73 && n[2] === 42 && n[3] === 0)
        throw new Error("TIFF Image File is not a spreadsheet");
      if (n[1] === 68)
        return read_wb_ID(d, o);
      break;
    case 84:
      if (n[1] === 65 && n[2] === 66 && n[3] === 76)
        return DIF.to_workbook(d, o);
      break;
    case 80:
      return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);
    case 239:
      return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);
    case 255:
      if (n[1] === 254) {
        return read_utf16(d, o);
      } else if (n[1] === 0 && n[2] === 2 && n[3] === 0)
        return WK_.to_workbook(d, o);
      break;
    case 0:
      if (n[1] === 0) {
        if (n[2] >= 2 && n[3] === 0)
          return WK_.to_workbook(d, o);
        if (n[2] === 0 && (n[3] === 8 || n[3] === 9))
          return WK_.to_workbook(d, o);
      }
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(d, o);
    case 123:
      if (n[1] === 92 && n[2] === 114 && n[3] === 116)
        return RTF.to_workbook(d, o);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(d, o);
    case 137:
      if (n[1] === 80 && n[2] === 78 && n[3] === 71)
        throw new Error("PNG Image File is not a spreadsheet");
      break;
  }
  if (DBF_SUPPORTED_VERSIONS.indexOf(n[0]) > -1 && n[2] <= 12 && n[3] <= 31)
    return DBF.to_workbook(d, o);
  return read_prn(data, d, o, str);
}
function write_cfb_ctr(cfb, o) {
  switch (o.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      o.type = "";
      break;
    case "file":
      return write_dl(o.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + o.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + o.type);
  }
  return CFB.write(cfb, o);
}
function write_zip_type(wb, opts) {
  var o = dup(opts || {});
  var z = write_zip(wb, o);
  return write_zip_denouement(z, o);
}
function write_zip_denouement(z, o) {
  var oopts = {};
  var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
  if (o.compression)
    oopts.compression = "DEFLATE";
  if (o.password)
    oopts.type = ftype;
  else
    switch (o.type) {
      case "base64":
        oopts.type = "base64";
        break;
      case "binary":
        oopts.type = "string";
        break;
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      case "buffer":
      case "file":
        oopts.type = ftype;
        break;
      default:
        throw new Error("Unrecognized type " + o.type);
    }
  var out = z.FullPaths ? CFB.write(z, { fileType: "zip", type: (
    /*::(*/
    { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
  ), compression: !!o.compression }) : z.generate(oopts);
  if (typeof Deno !== "undefined") {
    if (typeof out == "string") {
      if (o.type == "binary" || o.type == "base64")
        return out;
      out = new Uint8Array(s2ab(out));
    }
  }
  if (o.password && typeof encrypt_agile !== "undefined")
    return write_cfb_ctr(encrypt_agile(out, o.password), o);
  if (o.type === "file")
    return write_dl(o.file, out);
  return o.type == "string" ? utf8read(
    /*::(*/
    out
    /*:: :any)*/
  ) : out;
}
function write_cfb_type(wb, opts) {
  var o = opts || {};
  var cfb = write_xlscfb(wb, o);
  return write_cfb_ctr(cfb, o);
}
function write_string_type(out, opts, bom) {
  if (!bom)
    bom = "";
  var o = bom + out;
  switch (opts.type) {
    case "base64":
      return Base64_encode(utf8write(o));
    case "binary":
      return utf8write(o);
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, o, "utf8");
    case "buffer": {
      if (has_buf)
        return Buffer_from(o, "utf8");
      else if (typeof TextEncoder !== "undefined")
        return new TextEncoder().encode(o);
      else
        return write_string_type(o, { type: "binary" }).split("").map(function(c) {
          return c.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_stxt_type(out, opts) {
  switch (opts.type) {
    case "base64":
      return Base64_encode(out);
    case "binary":
      return out;
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, out, "binary");
    case "buffer": {
      if (has_buf)
        return Buffer_from(out, "binary");
      else
        return out.split("").map(function(c) {
          return c.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_binary_type(out, opts) {
  switch (opts.type) {
    case "string":
    case "base64":
    case "binary":
      var bstr = "";
      for (var i = 0; i < out.length; ++i)
        bstr += String.fromCharCode(out[i]);
      return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
    case "file":
      return write_dl(opts.file, out);
    case "buffer":
      return out;
    default:
      throw new Error("Unrecognized type " + opts.type);
  }
}
function writeSync(wb, opts) {
  reset_cp();
  check_wb(wb);
  var o = dup(opts || {});
  if (o.cellStyles) {
    o.cellNF = true;
    o.sheetStubs = true;
  }
  if (o.type == "array") {
    o.type = "binary";
    var out = writeSync(wb, o);
    o.type = "array";
    return s2ab(out);
  }
  var idx = 0;
  if (o.sheet) {
    if (typeof o.sheet == "number")
      idx = o.sheet;
    else
      idx = wb.SheetNames.indexOf(o.sheet);
    if (!wb.SheetNames[idx])
      throw new Error("Sheet not found: " + o.sheet + " : " + typeof o.sheet);
  }
  switch (o.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(wb, o), o);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "txt":
      return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "csv":
      return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "dbf":
      return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "prn":
      return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "rtf":
      return write_string_type(RTF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "eth":
      return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "fods":
      return write_string_type(write_ods(wb, o), o);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(wb, o), o);
    case "biff2":
      if (!o.biff)
        o.biff = 2;
    case "biff3":
      if (!o.biff)
        o.biff = 3;
    case "biff4":
      if (!o.biff)
        o.biff = 4;
      return write_binary_type(write_biff_buf(wb, o), o);
    case "biff5":
      if (!o.biff)
        o.biff = 5;
    case "biff8":
    case "xla":
    case "xls":
      if (!o.biff)
        o.biff = 8;
      return write_cfb_type(wb, o);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(wb, o);
    default:
      throw new Error("Unrecognized bookType |" + o.bookType + "|");
  }
}
function make_json_row(sheet, r, R, cols, header, hdr, dense, o) {
  var rr = encode_row(R);
  var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
  var isempty = true;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty)
      try {
        Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
      } catch (e) {
        row.__rowNum__ = R;
      }
    else
      row.__rowNum__ = R;
  }
  if (!dense || sheet[R])
    for (var C = r.s.c; C <= r.e.c; ++C) {
      var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
      if (val === void 0 || val.t === void 0) {
        if (defval === void 0)
          continue;
        if (hdr[C] != null) {
          row[hdr[C]] = defval;
        }
        continue;
      }
      var v = val.v;
      switch (val.t) {
        case "z":
          if (v == null)
            break;
          continue;
        case "e":
          v = v == 0 ? null : void 0;
          break;
        case "s":
        case "d":
        case "b":
        case "n":
          break;
        default:
          throw new Error("unrecognized type " + val.t);
      }
      if (hdr[C] != null) {
        if (v == null) {
          if (val.t == "e" && v === null)
            row[hdr[C]] = null;
          else if (defval !== void 0)
            row[hdr[C]] = defval;
          else if (raw && v === null)
            row[hdr[C]] = null;
          else
            continue;
        } else {
          row[hdr[C]] = raw && (val.t !== "n" || val.t === "n" && o.rawNumbers !== false) ? v : format_cell(val, v, o);
        }
        if (v != null)
          isempty = false;
      }
    }
  return { row, isempty };
}
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null)
    return [];
  var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
  var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o = opts || {};
  var range = o.range != null ? o.range : sheet["!ref"];
  if (o.header === 1)
    header = 1;
  else if (o.header === "A")
    header = 2;
  else if (Array.isArray(o.header))
    header = 3;
  else if (o.header == null)
    header = 0;
  switch (typeof range) {
    case "string":
      r = safe_decode_range(range);
      break;
    case "number":
      r = safe_decode_range(sheet["!ref"]);
      r.s.r = range;
      break;
    default:
      r = range;
  }
  if (header > 0)
    offset = 0;
  var rr = encode_row(r.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = Array.isArray(sheet);
  var R = r.s.r, C = 0;
  var header_cnt = {};
  if (dense && !sheet[R])
    sheet[R] = [];
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (C = r.s.c; C <= r.e.c; ++C) {
    if ((colinfo[C] || {}).hidden)
      continue;
    cols[C] = encode_col(C);
    val = dense ? sheet[R][C] : sheet[cols[C] + rr];
    switch (header) {
      case 1:
        hdr[C] = C - r.s.c;
        break;
      case 2:
        hdr[C] = cols[C];
        break;
      case 3:
        hdr[C] = o.header[C - r.s.c];
        break;
      default:
        if (val == null)
          val = { w: "__EMPTY", t: "s" };
        vv = v = format_cell(val, null, o);
        counter = header_cnt[v] || 0;
        if (!counter)
          header_cnt[v] = 1;
        else {
          do {
            vv = v + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C] = vv;
    }
  }
  for (R = r.s.r + offset; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden)
      continue;
    var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
    if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows))
      out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
var qreg = /"/g;
function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
  var isempty = true;
  var row = [], txt = "", rr = encode_row(R);
  for (var C = r.s.c; C <= r.e.c; ++C) {
    if (!cols[C])
      continue;
    var val = o.dense ? (sheet[R] || [])[C] : sheet[cols[C] + rr];
    if (val == null)
      txt = "";
    else if (val.v != null) {
      isempty = false;
      txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
      for (var i = 0, cc = 0; i !== txt.length; ++i)
        if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
          txt = '"' + txt.replace(qreg, '""') + '"';
          break;
        }
      if (txt == "ID")
        txt = '"ID"';
    } else if (val.f != null && !val.F) {
      isempty = false;
      txt = "=" + val.f;
      if (txt.indexOf(",") >= 0)
        txt = '"' + txt.replace(qreg, '""') + '"';
    } else
      txt = "";
    row.push(txt);
  }
  if (o.blankrows === false && isempty)
    return null;
  return row.join(FS);
}
function sheet_to_csv(sheet, opts) {
  var out = [];
  var o = opts == null ? {} : opts;
  if (sheet == null || sheet["!ref"] == null)
    return "";
  var r = safe_decode_range(sheet["!ref"]);
  var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
  var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
  var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
  var row = "", cols = [];
  o.dense = Array.isArray(sheet);
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (var C = r.s.c; C <= r.e.c; ++C)
    if (!(colinfo[C] || {}).hidden)
      cols[C] = encode_col(C);
  var w = 0;
  for (var R = r.s.r; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden)
      continue;
    row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
    if (row == null) {
      continue;
    }
    if (o.strip)
      row = row.replace(endregex, "");
    if (row || o.blankrows !== false)
      out.push((w++ ? RS : "") + row);
  }
  delete o.dense;
  return out.join("");
}
function sheet_to_txt(sheet, opts) {
  if (!opts)
    opts = {};
  opts.FS = "	";
  opts.RS = "\n";
  var s = sheet_to_csv(sheet, opts);
  return s;
}
function book_new() {
  return { SheetNames: [], Sheets: {} };
}
function book_append_sheet(wb, ws, name, roll) {
  var i = 1;
  if (!name) {
    for (; i <= 65535; ++i, name = void 0)
      if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1)
        break;
  }
  if (!name || wb.SheetNames.length >= 65535)
    throw new Error("Too many worksheets");
  if (roll && wb.SheetNames.indexOf(name) >= 0) {
    var m = name.match(/(^.*?)(\d+)$/);
    i = m && +m[2] || 0;
    var root = m && m[1] || name;
    for (++i; i <= 65535; ++i)
      if (wb.SheetNames.indexOf(name = root + i) == -1)
        break;
  }
  check_ws_name(name);
  if (wb.SheetNames.indexOf(name) >= 0)
    throw new Error("Worksheet with name |" + name + "| already exists!");
  wb.SheetNames.push(name);
  wb.Sheets[name] = ws;
  return name;
}
function ownKeys$1(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
var themeColor = ["#FFFFFF", "#000000", "#BFBFBF", "#323232", "#4472C4", "#ED7D31", "#A5A5A5", "#FFC000", "#5B9BD5", "#71AD47"];
var indexedColor = ["#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF", "#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF", "#800000", "#008000", "#000080", "#808000", "#800080", "#008080", "#C0C0C0", "#808080", "#9999FF", "#993366", "#FFFFCC", "#CCFFFF", "#660066", "#FF8080", "#0066CC", "#CCCCFF", "#000080", "#FF00FF", "#FFFF00", "#00FFFF", "#800080", "#800000", "#008080", "#0000FF", "#00CCFF", "#CCFFFF", "#CCFFCC", "#FFFF99", "#99CCFF", "#FF99CC", "#CC99FF", "#FFCC99", "#3366FF", "#33CCCC", "#99CC00", "#FFCC00", "#FF9900", "#FF6600", "#666699", "#969696", "#003366", "#339966", "#003300", "#333300", "#993300", "#993366", "#333399", "#333333", "#000000"];
var defaultColWidth$1 = 80;
var defaultRowHeight$1 = 24;
function getData(src) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return requestExcel(getUrl(src), options);
}
function requestExcel(src, options) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open(options.method || "GET", src, true);
    xhr.responseType = options.responseType || "arraybuffer";
    xhr.onload = function() {
      if (xhr.status === 200) {
        resolve(xhr.response);
      } else {
        reject(xhr.status);
      }
    };
    xhr.onerror = function() {
      reject(xhr.status);
    };
    xhr.withCredentials = options.withCredentials || false;
    if (options.headers) {
      Object.keys(options.headers).forEach(function(key) {
        xhr.setRequestHeader(key, options.headers[key]);
      });
    }
    xhr.send(options.body);
  });
}
function readExcelData(buffer, xls) {
  try {
    if (xls) {
      var workbook = readSync(buffer, {
        type: "array"
      });
      buffer = writeSync(workbook, {
        bookType: "xlsx",
        type: "array"
      });
    }
    var wb = new exceljsExports.Workbook();
    return wb.xlsx.load(buffer);
  } catch (e) {
    console.warn(e);
    return Promise.reject(e);
  }
}
function transferColumns(excelSheet, spreadSheet, options) {
  for (var i = 0; i < (excelSheet.columns || []).length; i++) {
    spreadSheet.cols[i.toString()] = {};
    if (excelSheet.columns[i].width) {
      spreadSheet.cols[i.toString()].width = excelSheet.columns[i].width * 6 + (options.widthOffset || 0);
    } else {
      spreadSheet.cols[i.toString()].width = defaultColWidth$1 + (options.widthOffset || 0);
    }
  }
  spreadSheet.cols.len = Math.max(Object.keys(spreadSheet.cols).length, options.minColLength || 0);
}
function getCellText(cell) {
  var numFmt = cell.numFmt, value = cell.value, type = cell.type;
  switch (type) {
    case 2:
      try {
        if (cell.style.numFmt) {
          if (cell.style.numFmt.endsWith("%")) {
            var precision = cell.style.numFmt.match(/\.(\d+)%/);
            if (precision) {
              return (value * 100).toFixed(precision[1].length) + "%";
            } else {
              return value * 100 + "%";
            }
          } else if (/0(\.0+)?/.test(cell.style.numFmt)) {
            var prefix = "";
            if (cell.style.numFmt.startsWith("$")) {
              prefix = "$";
            } else if (cell.style.numFmt.startsWith('"')) {
              prefix = "";
            }
            if (value === 0 && cell.style.numFmt.startsWith("_")) {
              return "-";
            }
            var _precision = cell.style.numFmt.match(/0\.(0+)(_|;|$)/);
            if (_precision) {
              _precision = _precision[1].length;
            } else {
              _precision = 0;
            }
            var result = value.toFixed(_precision) + "";
            if (cell.style.numFmt.includes("#,##")) {
              result = result.split(".");
              var number = result[0].split("").reverse();
              var newNumber = [];
              for (var i = 0; i < number.length; i++) {
                newNumber.push(number[i]);
                if ((i + 1) % 3 === 0 && i < number.length - 1 && number[i + 1] !== "-") {
                  newNumber.push(",");
                }
              }
              result[0] = newNumber.reverse().join("");
              result = result.join(".");
            }
            return prefix + result;
          }
        }
        return value + "";
      } catch (e) {
        return value;
      }
    case 3:
      return value;
    case 4:
      switch (numFmt) {
        case "yyyy-mm-dd;@":
          return dayjs(value).format("YYYY-MM-DD");
        case "mm-dd-yy":
          return dayjs(value).format("YYYY/MM/DD");
        case "[$-F800]dddd, mmmm dd, yyyy":
          return dayjs(value).format("YYYYMD ddd");
        case 'm""d"";@':
          return dayjs(value).format("MD");
        case "yyyy/m/d h:mm;@":
        case 'm/d/yy "h":mm':
          return dayjs(value).subtract(8, "hour").format("YYYY/M/DD HH:mm");
        case "h:mm;@":
          return dayjs(value).format("HH:mm");
        default:
          return dayjs(value).format("YYYY-MM-DD");
      }
    case 5:
      return value.text;
    case 6:
      return lodashExports.get(value, "result.error") || value.result;
    case 8:
      return cell.text;
    case 9:
      return cell.text.toUpperCase();
    default:
      return value;
  }
}
function transferArgbColor(originColor) {
  if (typeof originColor === "object") {
    return "#000000";
  }
  if (/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.test(originColor)) {
    return originColor.startsWith("#") ? originColor : "#" + originColor;
  }
  originColor = originColor.trim().toLowerCase();
  var color = {};
  try {
    var argb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(originColor);
    color.r = parseInt(argb[2], 16);
    color.g = parseInt(argb[3], 16);
    color.b = parseInt(argb[4], 16);
    color.a = parseInt(argb[1], 16) / 255;
    return tinycolor("rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ").concat(color.a, ")")).toHexString();
  } catch (e) {
    console.warn(e);
  }
}
function transferThemeColor(themeIndex, tint) {
  if (themeIndex > 9) {
    return "#C7C9CC";
  }
  if (typeof tint === "undefined") {
    return themeColor[themeIndex];
  } else if (tint > 0) {
    return getLightColor(themeColor[themeIndex], tint);
  } else {
    return getDarkColor(themeColor[themeIndex], Math.abs(tint));
  }
}
function getStyle(cell) {
  cell.style = lodashExports.cloneDeep(cell.style);
  var backGroundColor = null;
  if (cell.style.fill && cell.style.fill.fgColor) {
    if (cell.style.fill.fgColor.argb) {
      backGroundColor = transferArgbColor(cell.style.fill.fgColor.argb);
    } else if (cell.style.fill.fgColor.hasOwnProperty("theme")) {
      backGroundColor = transferThemeColor(cell.style.fill.fgColor.theme, cell.style.fill.fgColor.tint);
    } else if (cell.style.fill.fgColor.indexed) {
      backGroundColor = indexedColor[cell.style.fill.fgColor.indexed] || "#C7C9CC";
    } else {
      backGroundColor = "#C7C9CC";
    }
  }
  if (backGroundColor) {
    cell.style.bgcolor = backGroundColor;
  }
  var fontColor = null;
  if (cell.style.font && cell.style.font.color) {
    if (cell.style.font.color.argb) {
      fontColor = transferArgbColor(cell.style.font.color.argb);
    } else if (cell.style.font.color.hasOwnProperty("theme")) {
      fontColor = transferThemeColor(cell.style.font.color.theme, cell.style.font.color.tint);
    } else if (cell.style.font.color.indexed) {
      fontColor = indexedColor[cell.style.font.color.indexed] || "#000000";
    } else {
      fontColor = "#000000";
    }
  }
  if (fontColor) {
    cell.style.color = fontColor;
  }
  if (cell.style.alignment) {
    if (cell.style.alignment.horizontal) {
      cell.style.align = cell.style.alignment.horizontal;
    }
    if (cell.style.alignment.vertical) {
      cell.style.valign = cell.style.alignment.vertical;
    }
  }
  if (cell.style.alignment && cell.style.alignment.wrapText) {
    cell.style.textwrap = true;
  }
  if (cell.style.border) {
    var styleBorder = {};
    Object.keys(cell.style.border).forEach(function(position) {
      var originBorder = cell.style.border[position];
      var bordColor = "#000000";
      if (typeof originBorder.color === "string") {
        bordColor = originBorder.color;
      } else if (originBorder.color) {
        if (originBorder.color.argb) {
          bordColor = transferArgbColor(originBorder.color.argb);
        } else if (originBorder.color.hasOwnProperty("theme")) {
          bordColor = transferThemeColor(originBorder.color.theme, originBorder.color.tint);
        } else if (originBorder.color.indexed) {
          bordColor = indexedColor[originBorder.color.indexed];
        }
      }
      styleBorder[position] = [originBorder.style || "thin", bordColor];
    });
    cell.style.border2 = _objectSpread$1({}, cell.style.border);
    cell.style.border = styleBorder;
  }
  if (cell.style.font && cell.style.font.size && typeof cell.style.font.size === "number") {
    cell.style.font.size = Math.round(cell.style.font.size / 1.333333);
  }
  return cell.style;
}
function transferExcelToSpreadSheet(workbook, options) {
  var workbookData = [];
  var sheets = [];
  workbook.eachSheet(function(sheet) {
    sheets.push(sheet);
    var sheetData = {
      name: sheet.name,
      styles: [],
      rows: {},
      cols: {},
      merges: [],
      media: []
    };
    var mergeAddressData = [];
    for (var mergeRange in sheet._merges) {
      sheetData.merges.push(sheet._merges[mergeRange].shortRange);
      var mergeAddress = {};
      mergeAddress.startAddress = sheet._merges[mergeRange].tl;
      mergeAddress.endAddress = sheet._merges[mergeRange].br;
      mergeAddress.YRange = sheet._merges[mergeRange].model.bottom - sheet._merges[mergeRange].model.top;
      mergeAddress.XRange = sheet._merges[mergeRange].model.right - sheet._merges[mergeRange].model.left;
      mergeAddressData.push(mergeAddress);
    }
    var effectiveMaxColLen = 0;
    (sheet._rows || []).forEach(function(row, spreadSheetRowIndex) {
      sheetData.rows[spreadSheetRowIndex] = {
        cells: {}
      };
      if (row.height) {
        sheetData.rows[spreadSheetRowIndex].height = row.height + (options.heightOffset || 0);
      } else {
        sheetData.rows[spreadSheetRowIndex].height = defaultRowHeight$1 + (options.heightOffset || 0);
      }
      (row._cells || []).forEach(function(cell, spreadSheetColIndex) {
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex] = {};
        effectiveMaxColLen = Math.max(effectiveMaxColLen, spreadSheetColIndex);
        var mergeAddress2 = lodashExports.find(mergeAddressData, function(o) {
          return o.startAddress == cell._address;
        });
        if (mergeAddress2 && cell.master.address != mergeAddress2.startAddress) {
          return;
        }
        if (mergeAddress2) {
          sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].merge = [mergeAddress2.YRange, mergeAddress2.XRange];
        }
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].text = getCellText(cell);
        sheetData.styles.push(getStyle(cell));
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].style = sheetData.styles.length - 1;
      });
    });
    if (sheetData._media) {
      sheetData.media = sheetData._media;
    }
    var tempRowsKeys = Object.keys(sheetData.rows);
    sheetData.rows.len = Math.max(+tempRowsKeys[tempRowsKeys.length - 1] + 1, options.hasOwnProperty("minRowLength") ? options.minRowLength : 100);
    if (sheet._columns && sheet._columns.length > effectiveMaxColLen + 1) {
      sheet._columns = sheet._columns.slice(0, effectiveMaxColLen + 1);
    }
    transferColumns(sheet, sheetData, options);
    workbookData.push(sheetData);
  });
  workbook._worksheets = sheets;
  return {
    workbookData,
    workbookSource: workbook,
    medias: workbook.media || []
  };
}
var cache = [];
function renderImage(ctx, medias, sheet, offset) {
  var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  if (sheet && sheet._media.length) {
    sheet._media.forEach(function(media) {
      var imageId = media.imageId, range = media.range, type = media.type;
      if (type === "image") {
        var position = calcPosition(sheet, range, offset, options);
        drawImage(ctx, imageId, medias[imageId], position);
      }
    });
  }
}
var clipWidth = 60;
var clipHeight = 25;
var defaultColWidth = 80;
var defaultRowHeight = 24;
var devicePixelRatio = window.devicePixelRatio;
function calcPosition(sheet, range, offset, options) {
  var _offset$scroll, _offset$scroll2;
  var widthOffset = options.widthOffset, heightOffset = options.heightOffset;
  var tl = range.tl, br = range.br, ext = range.ext;
  var _ref = tl || {}, _ref$nativeCol = _ref.nativeCol, nativeCol = _ref$nativeCol === void 0 ? 0 : _ref$nativeCol, _ref$nativeColOff = _ref.nativeColOff, nativeColOff = _ref$nativeColOff === void 0 ? 0 : _ref$nativeColOff, _ref$nativeRow = _ref.nativeRow, nativeRow = _ref$nativeRow === void 0 ? 0 : _ref$nativeRow, _ref$nativeRowOff = _ref.nativeRowOff, nativeRowOff = _ref$nativeRowOff === void 0 ? 0 : _ref$nativeRowOff;
  var basicX = clipWidth;
  var basicY = clipHeight;
  for (var i = 0; i < nativeCol; i++) {
    var _sheet$_columns;
    basicX += (sheet === null || sheet === void 0 || (_sheet$_columns = sheet._columns) === null || _sheet$_columns === void 0 || (_sheet$_columns = _sheet$_columns[i]) === null || _sheet$_columns === void 0 ? void 0 : _sheet$_columns.width) * 6 || defaultColWidth;
    basicX += widthOffset || 0;
  }
  for (var _i = 0; _i < nativeRow; _i++) {
    var _sheet$_rows;
    basicY += (sheet === null || sheet === void 0 || (_sheet$_rows = sheet._rows) === null || _sheet$_rows === void 0 || (_sheet$_rows = _sheet$_rows[_i]) === null || _sheet$_rows === void 0 ? void 0 : _sheet$_rows.height) || defaultRowHeight;
    basicY += heightOffset || 0;
  }
  var x = basicX + nativeColOff / 12700;
  var y = basicY + nativeRowOff / 12700;
  var _ref2 = br || {}, _ref2$nativeCol = _ref2.nativeCol, nativeColEnd = _ref2$nativeCol === void 0 ? 0 : _ref2$nativeCol, _ref2$nativeColOff = _ref2.nativeColOff, nativeColOffEnd = _ref2$nativeColOff === void 0 ? 0 : _ref2$nativeColOff, _ref2$nativeRow = _ref2.nativeRow, nativeRowEnd = _ref2$nativeRow === void 0 ? 0 : _ref2$nativeRow, _ref2$nativeRowOff = _ref2.nativeRowOff, nativeRowOffEnd = _ref2$nativeRowOff === void 0 ? 0 : _ref2$nativeRowOff;
  var width2 = 0;
  if (nativeCol === nativeColEnd) {
    width2 = (nativeColOffEnd - nativeColOff) / 12700;
  } else if (br) {
    var _sheet$_columns2;
    width2 = ((sheet === null || sheet === void 0 || (_sheet$_columns2 = sheet._columns) === null || _sheet$_columns2 === void 0 || (_sheet$_columns2 = _sheet$_columns2[nativeCol]) === null || _sheet$_columns2 === void 0 ? void 0 : _sheet$_columns2.width) * 6 || defaultColWidth) - nativeColOff / 12700;
    for (var _i2 = nativeCol + 1; _i2 < nativeColEnd; _i2++) {
      var _sheet$_columns3;
      width2 += (sheet === null || sheet === void 0 || (_sheet$_columns3 = sheet._columns) === null || _sheet$_columns3 === void 0 || (_sheet$_columns3 = _sheet$_columns3[_i2]) === null || _sheet$_columns3 === void 0 ? void 0 : _sheet$_columns3.width) * 6 || defaultColWidth;
    }
    width2 += nativeColOffEnd / 12700;
  } else if (ext !== null && ext !== void 0 && ext.width) {
    width2 = ext.width / 1.333333;
  }
  var height2;
  if (nativeRow === nativeRowEnd) {
    height2 = (nativeRowOffEnd - nativeRowOff) / 12700;
  } else if (br) {
    var _sheet$_rows2;
    height2 = ((sheet === null || sheet === void 0 || (_sheet$_rows2 = sheet._rows) === null || _sheet$_rows2 === void 0 || (_sheet$_rows2 = _sheet$_rows2[nativeRow]) === null || _sheet$_rows2 === void 0 ? void 0 : _sheet$_rows2.height) || defaultRowHeight) - nativeRowOff / 12700;
    for (var _i3 = nativeRow + 1; _i3 < nativeRowEnd; _i3++) {
      var _sheet$_rows3;
      height2 += (sheet === null || sheet === void 0 || (_sheet$_rows3 = sheet._rows) === null || _sheet$_rows3 === void 0 || (_sheet$_rows3 = _sheet$_rows3[_i3]) === null || _sheet$_rows3 === void 0 ? void 0 : _sheet$_rows3.height) || defaultRowHeight;
    }
    height2 += nativeRowOffEnd / 12700;
  } else if (ext !== null && ext !== void 0 && ext.height) {
    height2 = ext.height / 1.333333;
  }
  return {
    x: (x - ((offset === null || offset === void 0 || (_offset$scroll = offset.scroll) === null || _offset$scroll === void 0 ? void 0 : _offset$scroll.x) || 0)) * devicePixelRatio,
    y: (y - ((offset === null || offset === void 0 || (_offset$scroll2 = offset.scroll) === null || _offset$scroll2 === void 0 ? void 0 : _offset$scroll2.y) || 0)) * devicePixelRatio,
    width: width2 * devicePixelRatio,
    height: height2 * devicePixelRatio
  };
}
function clearCache() {
  cache = [];
}
function drawImage(ctx, index2, data, position) {
  getImage(index2, data).then(function(image) {
    var sx = 0;
    var sy = 0;
    var sWidth = image.width;
    var sHeight = image.height;
    var dx = position.x;
    var dy = position.y;
    var dWidth = position.width;
    var dHeight = position.height;
    var scaleX = dWidth / sWidth;
    var scaleY = dHeight / sHeight;
    if (dx < clipWidth * devicePixelRatio) {
      var diff = clipWidth * devicePixelRatio - dx;
      dx = clipWidth * devicePixelRatio;
      dWidth -= diff;
      sWidth -= diff / scaleX;
      sx += diff / scaleX;
    }
    if (dy < clipHeight * devicePixelRatio) {
      var _diff = clipHeight * devicePixelRatio - dy;
      dy = clipHeight * devicePixelRatio;
      dHeight -= _diff;
      sHeight -= _diff / scaleY;
      sy += _diff / scaleY;
    }
    ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
  }).catch(function(e) {
    console.error(e);
  });
}
function getImage(index2, data) {
  return new Promise(function(resolve, reject) {
    if (cache[index2]) {
      return resolve(cache[index2]);
    }
    var buffer = data.buffer.buffer;
    var blob = new Blob([buffer], {
      type: "image/" + data.extension
    });
    var url = URL.createObjectURL(blob);
    var image = new Image();
    image.src = url;
    image.onload = function() {
      resolve(image);
      cache[index2] = image;
    };
    image.onerror = function(e) {
      reject(e);
    };
  });
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function readOnlyInput(root) {
  if (root) {
    var nodes = root.querySelectorAll("input");
    var _iterator = _createForOfIteratorHelper(nodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var node = _step.value;
        node && !node.readOnly && (node.readOnly = true);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    document.activeElement && document.activeElement.blur();
  }
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
var defaultOptions = {
  xls: false,
  minColLength: 20
};
var _sfc_main = defineComponent({
  name: "VueOfficeExcel",
  props: {
    src: [String, ArrayBuffer, Blob],
    requestOptions: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    options: {
      type: Object,
      default: function _default2() {
        return _objectSpread({}, defaultOptions);
      }
    }
  },
  emits: ["rendered", "error", "switchSheet", "cellSelected", "cellsSelected"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var wrapperRef = ref(null);
    var rootRef = ref(null);
    var workbookDataSource = {
      _worksheets: []
    };
    var mediasSource = [];
    var sheetIndex = 0;
    var ctx = null;
    var xs = null;
    var offset = null;
    var fileData = null;
    function renderExcel(buffer) {
      fileData = buffer;
      readExcelData(buffer, props.options.xls).then(function(workbook) {
        if (!workbook._worksheets || workbook._worksheets.length === 0) {
          throw new Error("");
        }
        if (props.options.beforeTransformData && typeof props.options.beforeTransformData === "function") {
          workbook = props.options.beforeTransformData(workbook);
        }
        var _transferExcelToSprea = transferExcelToSpreadSheet(workbook, _objectSpread(_objectSpread({}, defaultOptions), props.options)), workbookData = _transferExcelToSprea.workbookData, medias = _transferExcelToSprea.medias, workbookSource = _transferExcelToSprea.workbookSource;
        if (props.options.transformData && typeof props.options.transformData === "function") {
          workbookData = props.options.transformData(workbookData);
        }
        mediasSource = medias;
        workbookDataSource = workbookSource;
        offset = null;
        sheetIndex = 0;
        clearCache();
        xs.loadData(workbookData);
        renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset, props.options);
        emit("rendered");
        emit("switchSheet", 0);
      }).catch(function(e) {
        console.warn(e);
        mediasSource = [];
        workbookDataSource = {
          _worksheets: []
        };
        clearCache();
        xs && xs.loadData({});
        emit("error", e);
        emit("switchSheet", 0);
      });
    }
    var observerCallback = lodashExports.debounce(readOnlyInput, 200).bind(this, rootRef.value);
    var observer = new MutationObserver(observerCallback);
    var observerConfig = {
      attributes: true,
      childList: true,
      subtree: true
    };
    onMounted(function() {
      nextTick(function() {
        observer.observe(rootRef.value, observerConfig);
        observerCallback(rootRef);
        xs = new Spreadsheet(rootRef.value, {
          mode: "read",
          showToolbar: false,
          showContextmenu: props.options.showContextmenu || false,
          view: {
            height: function height2() {
              return wrapperRef.value && wrapperRef.value.clientHeight || 300;
            },
            width: function width2() {
              return wrapperRef.value && wrapperRef.value.clientWidth || 1200;
            }
          },
          row: {
            height: 24,
            len: 100
          },
          col: {
            len: 26,
            width: 80,
            indexWidth: 60,
            minWidth: 60
          },
          autoFocus: false
        }).loadData({});
        xs.on("cell-selected", function(cell, ri, ci) {
          emit("cellSelected", {
            cell,
            rowIndex: ri,
            columnIndex: ci
          });
        });
        xs.on("cells-selected", function(cell, _ref2) {
          var sri = _ref2.sri, sci = _ref2.sci, eri = _ref2.eri, eci = _ref2.eci;
          emit("cellsSelected", {
            cell,
            startRowIndex: sri,
            startColumnIndex: sci,
            endRowIndex: eri,
            endColumnIndex: eci
          });
        });
        var swapFunc = xs.bottombar.swapFunc;
        xs.bottombar.swapFunc = function(index2) {
          swapFunc.call(xs.bottombar, index2);
          sheetIndex = index2;
          setTimeout(function() {
            xs.reRender();
            renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset, props.options);
            emit("switchSheet", index2);
          });
        };
        var clear = xs.sheet.editor.clear;
        xs.sheet.editor.clear = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          clear.apply(xs.sheet.editor, args);
          setTimeout(function() {
            renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset, props.options);
          });
        };
        var setOffset = xs.sheet.editor.setOffset;
        xs.sheet.editor.setOffset = function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          setOffset.apply(xs.sheet.editor, args);
          offset = args[0];
          renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset, props.options);
        };
        var canvas = rootRef.value.querySelector("canvas");
        ctx = canvas.getContext("2d");
        if (props.src) {
          getData(props.src, props.requestOptions).then(renderExcel).catch(function(e) {
            mediasSource = [];
            workbookDataSource = {
              _worksheets: []
            };
            xs.loadData({});
            emit("error", e);
          });
        }
      });
    });
    onBeforeUnmount(function() {
      observer.disconnect();
      xs = null;
    });
    watch(function() {
      return props.src;
    }, function() {
      if (props.src) {
        getData(props.src, props.requestOptions).then(renderExcel).catch(function(e) {
          mediasSource = [];
          workbookDataSource = {
            _worksheets: []
          };
          xs.loadData({});
          emit("error", e);
        });
      } else {
        mediasSource = [];
        workbookDataSource = {
          _worksheets: []
        };
        xs.loadData({});
        emit("error", new Error("src"));
      }
    });
    function save(fileName) {
      download(fileName || "vue-office-excel-".concat((/* @__PURE__ */ new Date()).getTime(), ".xlsx"), fileData);
    }
    return {
      wrapperRef,
      rootRef,
      save
    };
  }
});
var _hoisted_1 = {
  class: "vue-office-excel",
  ref: "wrapperRef"
};
var _hoisted_2 = {
  class: "vue-office-excel-main",
  ref: "rootRef"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [createElementVNode("div", _hoisted_2, null, 512)], 512);
}
const VueOfficeExcel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
VueOfficeExcel.install = function(Vue) {
  Vue.component(VueOfficeExcel.name, VueOfficeExcel);
};
export {
  VueOfficeExcel as default
};
